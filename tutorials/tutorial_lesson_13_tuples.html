<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>
 Tuples
</title>
<link rel="stylesheet" type="text/css" href="../assets/css/highlight.css">
<style>

a:visited {
color: #000000;
}

a:link {
color: #000000;
}

a:hover {
color: #aa0000;
}

</style>
</head>
<body class="hl" style="background-color: #444444; font-family: Helvetica, Arial, sans-serif;">
<script>
function toggle(id) {
    e = document.getElementById(id);
    show = document.getElementById(id + '-show');
    if (e.style.display != 'none') {
        e.style.display = 'none';
        show.innerHTML = "// Click to show output ...";
    } else {
        e.style.display = 'block';
        show.innerHTML = "// Click to hide output ...";
    }
    return false;
}
</script>
<div>
<style scoped>
@import "../assets/css/bootstrap.css";
</style>
<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="/index.html">Halide</a>
      <div class="nav-collapse">
        <ul class="nav">
          <li><a href="/index.html#gettingstarted">Getting Started</a></li>
          <li><a href="/tutorials/tutorial_introduction.html">Tutorials</a></li>
          <li><a href="/index.html#publications">Publications</a></li>
          <li><a href="/index.html#resources">Resources</a></li>
          <li class="divider-vertical"></li>
          <li><a href="/docs">Docs</a></li>
          <li><a href="http://github.com/halide/Halide/issues">Bugs</a></li>
          <li><a href="http://github.com/halide/Halide/wiki">Wiki</a></li>
          <li class="divider-vertical"></li>
          <li><a href="http://stackoverflow.com/questions/tagged/halide"><i class="fa fa-stack-overflow"></i>/#halide</a></li>
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>
</div>

<div style='position:relative; width:900pt; top:60px;'>
<div style="width:200px; float:left; ">
<a href="tutorial_introduction.html" style="text-decoration:none;" ><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px;
background-color: #dddddd; 
text-align: left; ">
<b>
00
&nbsp</b>
Introduction
</div>
</span>
</a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_01_basics.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
01
&nbsp</b>
 Getting started with Funcs, Vars, and Exprs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_02_input_image.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
02
&nbsp</b>
 Processing images
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_03_debugging_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
03
&nbsp</b>
 Inspecting the generated code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_04_debugging_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
04
&nbsp</b>
 Debugging with tracing, print, and print_when
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_05_scheduling_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
05
&nbsp</b>
 Vectorize, parallelize, unroll and tile your code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_06_realizing_over_shifted_domains.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
06
&nbsp</b>
 Realizing Funcs over arbitrary domains
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_07_multi_stage_pipelines.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
07
&nbsp</b>
 Multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_08_scheduling_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
08
&nbsp</b>
 Scheduling multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_09_update_definitions.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
09
&nbsp</b>
 Multi-pass Funcs, update definitions, and reductions
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_11_cross_compilation.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
11
&nbsp</b>
 Cross-compilation
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_12_using_the_gpu.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
12
&nbsp</b>
 Using the GPU
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_13_tuples.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; padding-right:40px; background-color: #ffffff; color: #000000; text-align: left; ">
<b>
13
&nbsp</b>
 Tuples
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_14_types.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
14
&nbsp</b>
 The Halide type system
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_15_generators.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
15
&nbsp</b>
 Generators part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_15_generators_usage.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
15
&nbsp</b>
 Generators part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_16_rgb_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
16
&nbsp</b>
 RGB images and memory layouts part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_16_rgb_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
16
&nbsp</b>
 RGB images and memory layouts part 2
</div></span></a>
</div>
<div style="position:relative; margin-left:260px; padding:20px; background-color: #ffffff;">
<pre class="hl">
<span class="hl slc">// Halide tutorial lesson 13: Tuples</span>

<span class="hl slc">// This lesson describes how to write Funcs that evaluate to multiple</span>
<span class="hl slc">// values.</span>

<span class="hl slc">// On linux, you can compile and run it like so:</span>
<span class="hl slc">// g++ lesson_13*.cpp -g -I ../include -L ../bin -lHalide -lpthread -ldl -o lesson_13 -std=c++11</span>
<span class="hl slc">// LD_LIBRARY_PATH=../bin ./lesson_13</span>

<span class="hl slc">// On os x:</span>
<span class="hl slc">// g++ lesson_13*.cpp -g -I ../include -L ../bin -lHalide -o lesson_13 -std=c++11</span>
<span class="hl slc">// DYLD_LIBRARY_PATH=../bin ./lesson_13</span>

<span class="hl slc">// If you have the entire Halide source tree, you can also build it by</span>
<span class="hl slc">// running:</span>
<span class="hl slc">//    make tutorial_lesson_13_tuples</span>
<span class="hl slc">// in a shell with the current directory at the top of the halide</span>
<span class="hl slc">// source tree.</span>

<span class="hl ppc">#include</span> <span class="hl pps">&quot;Halide.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;stdio.h&gt;</span>
<span class="hl ppc">#include &lt;algorithm&gt;</span>
<span class="hl kwa">using namespace</span> Halide<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span> <span class="hl opt">**</span>argv<span class="hl opt">) {</span>

    <span class="hl slc">// So far Funcs (such as the one below) have evaluated to a single</span>
    <span class="hl slc">// scalar value for each point in their domain.</span>
    Func single_valued<span class="hl opt">;</span>
    Var x<span class="hl opt">,</span> y<span class="hl opt">;</span>
    <span class="hl kwd">single_valued</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> x <span class="hl opt">+</span> y<span class="hl opt">;</span>

    <span class="hl slc">// One way to write a Func that returns a collection of values is</span>
    <span class="hl slc">// to add an additional dimension that indexes that</span>
    <span class="hl slc">// collection. This is how we typically deal with color. For</span>
    <span class="hl slc">// example, the Func below represents a collection of three values</span>
    <span class="hl slc">// for every x, y coordinate indexed by c.</span>
    Func color_image<span class="hl opt">;</span>
    Var c<span class="hl opt">;</span>
    <span class="hl kwd">color_image</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) =</span> <span class="hl kwd">select</span><span class="hl opt">(</span>c <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">245</span><span class="hl opt">,</span> <span class="hl slc">// Red value</span>
                                  c <span class="hl opt">==</span> <span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">42</span><span class="hl opt">,</span>  <span class="hl slc">// Green value</span>
                                  <span class="hl num">132</span><span class="hl opt">);</span>        <span class="hl slc">// Blue value</span>

    <span class="hl slc">// This method is often convenient because it makes it easy to</span>
    <span class="hl slc">// operate on this Func in a way that treats each item in the</span>
    <span class="hl slc">// collection equally:</span>
    Func brighter<span class="hl opt">;</span>
    <span class="hl kwd">brighter</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) =</span> <span class="hl kwd">color_image</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) +</span> <span class="hl num">10</span><span class="hl opt">;</span>

    <span class="hl slc">// However this method is also inconvenient for three reasons.</span>
    <span class="hl slc">//</span>
    <span class="hl slc">// 1) Funcs are defined over an infinite domain, so users of this</span>
    <span class="hl slc">// Func can for example access color_image(x, y, -17), which is</span>
    <span class="hl slc">// not a meaningful value and is probably indicative of a bug.</span>
    <span class="hl slc">//</span>
    <span class="hl slc">// 2) It requires a select, which can impact performance if not</span>
    <span class="hl slc">// bounded and unrolled:</span>
    <span class="hl slc">// brighter.bound(c, 0, 3).unroll(c);</span>
    <span class="hl slc">//</span>
    <span class="hl slc">// 3) With this method, all values in the collection must have the</span>
    <span class="hl slc">// same type. While the above two issues are merely inconvenient,</span>
    <span class="hl slc">// this one is a hard limitation that makes it impossible to</span>
    <span class="hl slc">// express certain things in this way.</span>

    <span class="hl slc">// It is also possible to represent a collection of values as a</span>
    <span class="hl slc">// collection of Funcs:</span>
    Func func_array<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">];</span>
    func_array<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">](</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> x <span class="hl opt">+</span> y<span class="hl opt">;</span>
    func_array<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">](</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> <span class="hl kwd">sin</span><span class="hl opt">(</span>x<span class="hl opt">);</span>
    func_array<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">](</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> <span class="hl kwd">cos</span><span class="hl opt">(</span>y<span class="hl opt">);</span>

    <span class="hl slc">// This method avoids the three problems above, but introduces a</span>
    <span class="hl slc">// new annoyance. Because these are separate Funcs, it is</span>
    <span class="hl slc">// difficult to schedule them so that they are all computed</span>
    <span class="hl slc">// together inside a single loop over x, y.</span>

    <span class="hl slc">// A third alternative is to define a Func as evaluating to a</span>
    <span class="hl slc">// Tuple instead of an Expr. A Tuple is a fixed-size collection of</span>
    <span class="hl slc">// Exprs. Each Expr in a Tuple may have a different type. The</span>
    <span class="hl slc">// following function evaluates to an integer value (x+y), and a</span>
    <span class="hl slc">// floating point value (sin(x*y)).</span>
    Func multi_valued<span class="hl opt">;</span>
    <span class="hl kwd">multi_valued</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> <span class="hl kwd">Tuple</span><span class="hl opt">(</span>x <span class="hl opt">+</span> y<span class="hl opt">,</span> <span class="hl kwd">sin</span><span class="hl opt">(</span>x <span class="hl opt">*</span> y<span class="hl opt">));</span>

    <span class="hl slc">// Realizing a tuple-valued Func returns a collection of</span>
    <span class="hl slc">// Buffers. We call this a Realization. It's equivalent to a</span>
    <span class="hl slc">// std::vector of Buffer/Image objects:</span>
    <span class="hl opt">{</span>
        Realization r <span class="hl opt">=</span> multi_valued<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">80</span><span class="hl opt">,</span> <span class="hl num">60</span><span class="hl opt">);</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>r<span class="hl opt">.</span><span class="hl kwd">size</span><span class="hl opt">() ==</span> <span class="hl num">2</span><span class="hl opt">);</span>
        Image<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> im0 <span class="hl opt">=</span> r<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
        Image<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;</span> im1 <span class="hl opt">=</span> r<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">im0</span><span class="hl opt">(</span><span class="hl num">30</span><span class="hl opt">,</span> <span class="hl num">40</span><span class="hl opt">) ==</span> <span class="hl num">30</span> <span class="hl opt">+</span> <span class="hl num">40</span><span class="hl opt">);</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">im1</span><span class="hl opt">(</span><span class="hl num">30</span><span class="hl opt">,</span> <span class="hl num">40</span><span class="hl opt">) ==</span> <span class="hl kwd">sinf</span><span class="hl opt">(</span><span class="hl num">30</span> <span class="hl opt">*</span> <span class="hl num">40</span><span class="hl opt">));</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// All Tuple elements are evaluated together over the same domain</span>
    <span class="hl slc">// in the same loop nest, but stored in distinct allocations. The</span>
    <span class="hl slc">// equivalent C++ code to the above is:</span>
    <span class="hl opt">{</span>
        <span class="hl kwb">int</span> multi_valued_0<span class="hl opt">[</span><span class="hl num">80</span><span class="hl opt">*</span><span class="hl num">60</span><span class="hl opt">];</span>
        <span class="hl kwb">float</span> multi_valued_1<span class="hl opt">[</span><span class="hl num">80</span><span class="hl opt">*</span><span class="hl num">60</span><span class="hl opt">];</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> <span class="hl num">80</span><span class="hl opt">;</span> y<span class="hl opt">++) {</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">60</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                multi_valued_0<span class="hl opt">[</span>x <span class="hl opt">+</span> <span class="hl num">60</span><span class="hl opt">*</span>y<span class="hl opt">] =</span> x <span class="hl opt">+</span> y<span class="hl opt">;</span>
                multi_valued_1<span class="hl opt">[</span>x <span class="hl opt">+</span> <span class="hl num">60</span><span class="hl opt">*</span>y<span class="hl opt">] =</span> <span class="hl kwd">sinf</span><span class="hl opt">(</span>x<span class="hl opt">*</span>y<span class="hl opt">);</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// When compiling ahead-of-time, a Tuple-valued Func evaluates</span>
    <span class="hl slc">// into multiple distinct output buffer_t structs. These appear in</span>
    <span class="hl slc">// order at the end of the function signature:</span>
    <span class="hl slc">// int multi_valued(...input buffers and params...,</span>
    <span class="hl slc">//                  buffer_t *output_1, buffer_t *output_2);</span>

    <span class="hl slc">// You can construct a Tuple by passing multiple Exprs to the</span>
    <span class="hl slc">// Tuple constructor as we did above. Perhaps more elegantly, you</span>
    <span class="hl slc">// can also take advantage of C++11 initializer lists and just</span>
    <span class="hl slc">// enclose your Exprs in braces:</span>
    Func multi_valued_2<span class="hl opt">;</span>
    <span class="hl kwd">multi_valued_2</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) = {</span>x <span class="hl opt">+</span> y<span class="hl opt">,</span> <span class="hl kwd">sin</span><span class="hl opt">(</span>x<span class="hl opt">*</span>y<span class="hl opt">)};</span>

    <span class="hl slc">// Calls to a multi-valued Func cannot be treated as Exprs. The</span>
    <span class="hl slc">// following is a syntax error:</span>
    <span class="hl slc">// Func consumer;</span>
    <span class="hl slc">// consumer(x, y) = multi_valued_2(x, y) + 10;</span>

    <span class="hl slc">// Instead you must index a Tuple with square brackets to retrieve</span>
    <span class="hl slc">// the individual Exprs:</span>
    Expr integer_part <span class="hl opt">=</span> <span class="hl kwd">multi_valued_2</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">)[</span><span class="hl num">0</span><span class="hl opt">];</span>
    Expr floating_part <span class="hl opt">=</span> <span class="hl kwd">multi_valued_2</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">)[</span><span class="hl num">1</span><span class="hl opt">];</span>
    Func consumer<span class="hl opt">;</span>
    <span class="hl kwd">consumer</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) = {</span>integer_part <span class="hl opt">+</span> <span class="hl num">10</span><span class="hl opt">,</span> floating_part <span class="hl opt">+</span> <span class="hl num">10.0</span>f<span class="hl opt">};</span>

    <span class="hl slc">// Tuple reductions.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// Tuples are particularly useful in reductions, as they allow</span>
        <span class="hl slc">// the reduction to maintain complex state as it walks along</span>
        <span class="hl slc">// its domain. The simplest example is an argmax.</span>

        <span class="hl slc">// First we create an Image to take the argmax over.</span>
        Func input_func<span class="hl opt">;</span>
        <span class="hl kwd">input_func</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> <span class="hl kwd">sin</span><span class="hl opt">(</span>x<span class="hl opt">);</span>
        Image<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;</span> input <span class="hl opt">=</span> input_func<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">);</span>

        <span class="hl slc">// Then we define a 2-valued Tuple which tracks the index of</span>
        <span class="hl slc">// the maximum value and the value itself.</span>
        Func arg_max<span class="hl opt">;</span>

        <span class="hl slc">// Pure definition.</span>
        <span class="hl kwd">arg_max</span><span class="hl opt">() = {</span><span class="hl num">0</span><span class="hl opt">,</span> <span class="hl kwd">input</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">)};</span>

        <span class="hl slc">// Update definition.</span>
        RDom <span class="hl kwd">r</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">99</span><span class="hl opt">);</span>
        Expr old_index <span class="hl opt">=</span> <span class="hl kwd">arg_max</span><span class="hl opt">()[</span><span class="hl num">0</span><span class="hl opt">];</span>
        Expr old_max   <span class="hl opt">=</span> <span class="hl kwd">arg_max</span><span class="hl opt">()[</span><span class="hl num">1</span><span class="hl opt">];</span>
        Expr new_index <span class="hl opt">=</span> <span class="hl kwd">select</span><span class="hl opt">(</span>old_max <span class="hl opt">&gt;</span> <span class="hl kwd">input</span><span class="hl opt">(</span>r<span class="hl opt">),</span> r<span class="hl opt">,</span> old_index<span class="hl opt">);</span>
        Expr new_max   <span class="hl opt">=</span> <span class="hl kwd">max</span><span class="hl opt">(</span><span class="hl kwd">input</span><span class="hl opt">(</span>r<span class="hl opt">),</span> old_max<span class="hl opt">);</span>
        <span class="hl kwd">arg_max</span><span class="hl opt">() = {</span>new_index<span class="hl opt">,</span> new_max<span class="hl opt">};</span>

        <span class="hl slc">// The equivalent C++ is:</span>
        <span class="hl kwb">int</span> arg_max_0 <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span>
        <span class="hl kwb">float</span> arg_max_1 <span class="hl opt">=</span> <span class="hl kwd">input</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">);</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> r <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span> r <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> r<span class="hl opt">++) {</span>
            <span class="hl kwb">int</span> old_index <span class="hl opt">=</span> arg_max_0<span class="hl opt">;</span>
            <span class="hl kwb">float</span> old_max <span class="hl opt">=</span> arg_max_1<span class="hl opt">;</span>
            <span class="hl kwb">int</span> new_index <span class="hl opt">=</span> old_max <span class="hl opt">&gt;</span> <span class="hl kwd">input</span><span class="hl opt">(</span>r<span class="hl opt">)</span> ? r <span class="hl opt">:</span> old_index<span class="hl opt">;</span>
            <span class="hl kwb">float</span> new_max <span class="hl opt">=</span> std<span class="hl opt">::</span><span class="hl kwd">max</span><span class="hl opt">(</span><span class="hl kwd">input</span><span class="hl opt">(</span>r<span class="hl opt">),</span> old_max<span class="hl opt">);</span>
            <span class="hl slc">// In a tuple update definition, all loads and computation</span>
            <span class="hl slc">// are done before any stores, so that all Tuple elements</span>
            <span class="hl slc">// are updated atomically with respect to recursive calls</span>
            <span class="hl slc">// to the same Func.</span>
            arg_max_0 <span class="hl opt">=</span> new_index<span class="hl opt">;</span>
            arg_max_1 <span class="hl opt">=</span> new_max<span class="hl opt">;</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// Let's verify that the Halide and C++ found the same maximum</span>
        <span class="hl slc">// value and index.</span>
        <span class="hl opt">{</span>
            Realization r <span class="hl opt">=</span> arg_max<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">();</span>
            Image<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> r0 <span class="hl opt">=</span> r<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
            Image<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;</span> r1 <span class="hl opt">=</span> r<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
            <span class="hl kwa">assert</span><span class="hl opt">(</span>arg_max_0 <span class="hl opt">==</span> <span class="hl kwd">r0</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span>
            <span class="hl kwa">assert</span><span class="hl opt">(</span>arg_max_1 <span class="hl opt">==</span> <span class="hl kwd">r1</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">));</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// Halide provides argmax and argmin as built-in reductions</span>
        <span class="hl slc">// similar to sum, product, maximum, and minimum. They return</span>
        <span class="hl slc">// a Tuple consisting of the point in the reduction domain</span>
        <span class="hl slc">// corresponding to that value, and the value itself. In the</span>
        <span class="hl slc">// case of ties they return the first value found. We'll use</span>
        <span class="hl slc">// one of these in the following section.</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// Tuples for user-defined types.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// Tuples can also be a convenient way to represent compound</span>
        <span class="hl slc">// objects such as complex numbers. Defining an object that</span>
        <span class="hl slc">// can be converted to and from a Tuple is one way to extend</span>
        <span class="hl slc">// Halide's type system with user-defined types.</span>
        <span class="hl kwb">struct</span> Complex <span class="hl opt">{</span>
            Expr real<span class="hl opt">,</span> imag<span class="hl opt">;</span>

            <span class="hl slc">// Construct from a Tuple</span>
            <span class="hl kwd">Complex</span><span class="hl opt">(</span>Tuple t<span class="hl opt">) :</span> <span class="hl kwd">real</span><span class="hl opt">(</span>t<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]),</span> <span class="hl kwd">imag</span><span class="hl opt">(</span>t<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]) {}</span>

            <span class="hl slc">// Construct from a pair of Exprs</span>
            <span class="hl kwd">Complex</span><span class="hl opt">(</span>Expr r<span class="hl opt">,</span> Expr i<span class="hl opt">) :</span> <span class="hl kwd">real</span><span class="hl opt">(</span>r<span class="hl opt">),</span> <span class="hl kwd">imag</span><span class="hl opt">(</span>i<span class="hl opt">) {}</span>

            <span class="hl slc">// Construct from a call to a Func by treating it as a Tuple</span>
            <span class="hl kwd">Complex</span><span class="hl opt">(</span>FuncRef t<span class="hl opt">) :</span> <span class="hl kwd">Complex</span><span class="hl opt">(</span><span class="hl kwd">Tuple</span><span class="hl opt">(</span>t<span class="hl opt">)) {}</span>

            <span class="hl slc">// Convert to a Tuple</span>
            <span class="hl kwc">operator</span> <span class="hl kwd">Tuple</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
                <span class="hl kwa">return</span> <span class="hl opt">{</span>real<span class="hl opt">,</span> imag<span class="hl opt">};</span>
            <span class="hl opt">}</span>

            <span class="hl slc">// Complex addition</span>
            Complex <span class="hl kwc">operator</span><span class="hl opt">+(</span><span class="hl kwb">const</span> Complex <span class="hl opt">&amp;</span>other<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
                <span class="hl kwa">return</span> <span class="hl opt">{</span>real <span class="hl opt">+</span> other<span class="hl opt">.</span>real<span class="hl opt">,</span> imag <span class="hl opt">+</span> other<span class="hl opt">.</span>imag<span class="hl opt">};</span>
            <span class="hl opt">}</span>

            <span class="hl slc">// Complex multiplication</span>
            Complex <span class="hl kwc">operator</span><span class="hl opt">*(</span><span class="hl kwb">const</span> Complex <span class="hl opt">&amp;</span>other<span class="hl opt">)</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
                <span class="hl kwa">return</span> <span class="hl opt">{</span>real <span class="hl opt">*</span> other<span class="hl opt">.</span>real <span class="hl opt">-</span> imag <span class="hl opt">*</span> other<span class="hl opt">.</span>imag<span class="hl opt">,</span>
                        real <span class="hl opt">*</span> other<span class="hl opt">.</span>imag <span class="hl opt">+</span> imag <span class="hl opt">*</span> other<span class="hl opt">.</span>real<span class="hl opt">};</span>
            <span class="hl opt">}</span>

            <span class="hl slc">// Complex magnitude</span>
            Expr <span class="hl kwd">magnitude</span><span class="hl opt">()</span> <span class="hl kwb">const</span> <span class="hl opt">{</span>
                <span class="hl kwa">return</span> real <span class="hl opt">*</span> real <span class="hl opt">+</span> imag <span class="hl opt">*</span> imag<span class="hl opt">;</span>
            <span class="hl opt">}</span>

            <span class="hl slc">// Other complex operators would go here. The above are</span>
            <span class="hl slc">// sufficient for this example.</span>
        <span class="hl opt">};</span>

        <span class="hl slc">// Let's use the Complex struct to compute a Mandelbrot set.</span>
        Func mandelbrot<span class="hl opt">;</span>

        <span class="hl slc">// The initial complex value corresponding to an x, y coordinate</span>
        <span class="hl slc">// in our Func.</span>
        Complex <span class="hl kwd">initial</span><span class="hl opt">(</span>x<span class="hl opt">/</span><span class="hl num">15.0</span>f <span class="hl opt">-</span> <span class="hl num">2.5</span>f<span class="hl opt">,</span> y<span class="hl opt">/</span><span class="hl num">6.0</span>f <span class="hl opt">-</span> <span class="hl num">2.0</span>f<span class="hl opt">);</span>

        <span class="hl slc">// Pure definition.</span>
        Var t<span class="hl opt">;</span>
        <span class="hl kwd">mandelbrot</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> t<span class="hl opt">) =</span> <span class="hl kwd">Complex</span><span class="hl opt">(</span><span class="hl num">0.0</span>f<span class="hl opt">,</span> <span class="hl num">0.0</span>f<span class="hl opt">);</span>

        <span class="hl slc">// We'll use an update definition to take 12 steps.</span>
        RDom <span class="hl kwd">r</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">12</span><span class="hl opt">);</span>
        Complex current <span class="hl opt">=</span> <span class="hl kwd">mandelbrot</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> r<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">);</span>

        <span class="hl slc">// The following line uses the complex multiplication and</span>
        <span class="hl slc">// addition we defined above.</span>
        <span class="hl kwd">mandelbrot</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> r<span class="hl opt">) =</span> current<span class="hl opt">*</span>current <span class="hl opt">+</span> initial<span class="hl opt">;</span>

        <span class="hl slc">// We'll use another tuple reduction to compute the iteration</span>
        <span class="hl slc">// number where the value first escapes a circle of radius 4.</span>
        <span class="hl slc">// This can be expressed as an argmin of a boolean - we want</span>
        <span class="hl slc">// the index of the first time the given boolean expression is</span>
        <span class="hl slc">// false (we consider false to be less than true).  The argmax</span>
        <span class="hl slc">// would return the index of the first time the expression is</span>
        <span class="hl slc">// true.</span>

        Expr escape_condition <span class="hl opt">=</span> <span class="hl kwd">Complex</span><span class="hl opt">(</span><span class="hl kwd">mandelbrot</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> r<span class="hl opt">)).</span><span class="hl kwd">magnitude</span><span class="hl opt">() &lt;</span> <span class="hl num">16.0</span>f<span class="hl opt">;</span>
        Tuple first_escape <span class="hl opt">=</span> <span class="hl kwd">argmin</span><span class="hl opt">(</span>escape_condition<span class="hl opt">);</span>

        <span class="hl slc">// We only want the index, not the value, but argmin returns</span>
        <span class="hl slc">// both, so we'll index the argmin Tuple expression using</span>
        <span class="hl slc">// square brackets to get the Expr representing the index.</span>
        Func escape<span class="hl opt">;</span>
        <span class="hl kwd">escape</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> first_escape<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>

        <span class="hl slc">// Realize the pipeline and print the result as ascii art.</span>
        Image<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> result <span class="hl opt">=</span> escape<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">61</span><span class="hl opt">,</span> <span class="hl num">25</span><span class="hl opt">);</span>
        <span class="hl kwb">const char</span> <span class="hl opt">*</span>code <span class="hl opt">=</span> <span class="hl str">&quot; .:-~*={}&amp;%#&#64;&quot;</span><span class="hl opt">;</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> result<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">();</span> y<span class="hl opt">++) {</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> result<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">();</span> x<span class="hl opt">++) {</span>
                <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;%c&quot;</span><span class="hl opt">,</span> code<span class="hl opt">[</span><span class="hl kwd">result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">)]);</span>
            <span class="hl opt">}</span>
            <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">);</span>
        <span class="hl opt">}</span>
    <span class="hl opt">}</span>


    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Success!</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">);</span>

    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre>
</div></body></html>
