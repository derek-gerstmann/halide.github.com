<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>
 AOT compilation part 2
</title>
<link rel="stylesheet" type="text/css" href="../assets/css/highlight.css">
<style>

a:visited {
color: #000000;
}

a:link {
color: #000000;
}

a:hover {
color: #aa0000;
}

</style>
</head>
<body class="hl" style="background-color: #444444; font-family: Helvetica, Arial, sans-serif;">
<script>
function toggle(id) {
    e = document.getElementById(id);
    show = document.getElementById(id + '-show');
    if (e.style.display != 'none') {
        e.style.display = 'none';
        show.innerHTML = "// Click to show output ...";
    } else {
        e.style.display = 'block';
        show.innerHTML = "// Click to hide output ...";
    }
    return false;
}
</script>
<div>
<style scoped>
@import "../assets/css/bootstrap.css";
</style>
<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="/index.html">Halide</a>
      <div class="nav-collapse">
        <ul class="nav">
          <li><a href="/index.html#gettingstarted">Getting Started</a></li>
          <li><a href="/tutorials/tutorial_introduction.html">Tutorials</a></li>
          <li><a href="/index.html#publications">Publications</a></li>
          <li><a href="/index.html#resources">Resources</a></li>
          <li class="divider-vertical"></li>
          <li><a href="/docs">Docs</a></li>
          <li><a href="http://github.com/halide/Halide/issues">Bugs</a></li>
          <li><a href="http://github.com/halide/Halide/wiki">Wiki</a></li>
          <li class="divider-vertical"></li>
          <li><a href="http://stackoverflow.com/questions/tagged/halide"><i class="fa fa-stack-overflow"></i>/#halide</a></li>
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>
</div>

<div style='position:relative; width:900pt; top:60px;'>
<div style="width:200px; float:left; ">
<a href="tutorial_introduction.html" style="text-decoration:none;" ><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px;
background-color: #dddddd; 
text-align: left; ">
<b>
00
&nbsp</b>
Introduction
</div>
</span>
</a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_01_basics.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
01
&nbsp</b>
 Getting started with Funcs, Vars, and Exprs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_02_input_image.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
02
&nbsp</b>
 Processing images
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_03_debugging_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
03
&nbsp</b>
 Inspecting the generated code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_04_debugging_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
04
&nbsp</b>
 Debugging with tracing, print, and print_when
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_05_scheduling_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
05
&nbsp</b>
 Vectorize, parallelize, unroll and tile your code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_06_realizing_over_shifted_domains.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
06
&nbsp</b>
 Realizing Funcs over arbitrary domains
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_07_multi_stage_pipelines.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
07
&nbsp</b>
 Multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_08_scheduling_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
08
&nbsp</b>
 Scheduling multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_09_update_definitions.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
09
&nbsp</b>
 Multi-pass Funcs, update definitions, and reductions
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; padding-right:40px; background-color: #ffffff; color: #000000; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_11_cross_compilation.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
11
&nbsp</b>
 Cross-compilation
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_12_using_the_gpu.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
12
&nbsp</b>
 Using the GPU
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_13_tuples.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
13
&nbsp</b>
 Tuples
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_14_types.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
14
&nbsp</b>
 The Halide type system
</div></span></a>
</div>
<div style="position:relative; margin-left:260px; padding:20px; background-color: #ffffff;">
<pre class="hl">
<span class="hl slc">// Halide tutorial lesson 10: AOT compilation part 2</span>

<span class="hl slc">// Before reading this file, see lesson_10_aot_compilation_generate.cpp</span>

<span class="hl slc">// This is the code that actually uses the Halide pipeline we've</span>
<span class="hl slc">// compiled. It does not depend on libHalide, so we won't be including</span>
<span class="hl slc">// Halide.h.</span>
<span class="hl slc">//</span>
<span class="hl slc">// Instead, it depends on the header file that lesson_10_generate</span>
<span class="hl slc">// produced when we ran it:</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;lesson_10_halide.h&quot;</span><span class="hl ppc"></span>

<span class="hl ppc">#include &lt;stdio.h&gt;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span> <span class="hl opt">**</span>argv<span class="hl opt">) {</span>
    <span class="hl slc">// Have a look in the header file above (it won't exist until you've run</span>
    <span class="hl slc">// lesson_10_generate).</span>

    <span class="hl slc">// It starts with a definition of a buffer_t:</span>
    <span class="hl slc">//</span>
    <span class="hl slc">// typedef struct buffer_t {</span>
    <span class="hl slc">//     uint64_t dev;</span>
    <span class="hl slc">//     uint8_t* host;</span>
    <span class="hl slc">//     int32_t extent[4];</span>
    <span class="hl slc">//     int32_t stride[4];</span>
    <span class="hl slc">//     int32_t min[4];</span>
    <span class="hl slc">//     int32_t elem_size;</span>
    <span class="hl slc">//     bool host_dirty;</span>
    <span class="hl slc">//     bool dev_dirty;</span>
    <span class="hl slc">// } buffer_t;</span>
    <span class="hl slc">//</span>
    <span class="hl slc">// This is how Halide represents input and output images in</span>
    <span class="hl slc">// pre-compiled pipelines. There's a 'host' pointer that points to the</span>
    <span class="hl slc">// start of the image data, some fields that describe how to access</span>
    <span class="hl slc">// pixels, and some fields related to using the GPU that we'll ignore</span>
    <span class="hl slc">// for now (dev, host_dirty, dev_dirty).</span>

    <span class="hl slc">// Let's make some input data to test with:</span>
    <span class="hl kwb">uint8_t</span> input<span class="hl opt">[</span><span class="hl num">640</span> <span class="hl opt">*</span> <span class="hl num">480</span><span class="hl opt">];</span>
    <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> <span class="hl num">480</span><span class="hl opt">;</span> y<span class="hl opt">++) {</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">640</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
            input<span class="hl opt">[</span>y <span class="hl opt">*</span> <span class="hl num">640</span> <span class="hl opt">+</span> x<span class="hl opt">] =</span> x <span class="hl opt">^ (</span>y <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">);</span>
        <span class="hl opt">}</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// And the memory where we want to write our output:</span>
    <span class="hl kwb">uint8_t</span> output<span class="hl opt">[</span><span class="hl num">640</span> <span class="hl opt">*</span> <span class="hl num">480</span><span class="hl opt">];</span>

    <span class="hl slc">// In AOT-compiled mode, Halide doesn't manage this memory for</span>
    <span class="hl slc">// you. You should use whatever image data type makes sense for</span>
    <span class="hl slc">// your application. Halide just needs pointers to it.</span>

    <span class="hl slc">// Now we make a buffer_t to represent our input and output. It's</span>
    <span class="hl slc">// important to zero-initialize them so you don't end up with</span>
    <span class="hl slc">// garbage fields that confuse Halide.</span>
    buffer_t input_buf <span class="hl opt">= {</span><span class="hl num">0</span><span class="hl opt">},</span> output_buf <span class="hl opt">= {</span><span class="hl num">0</span><span class="hl opt">};</span>

    <span class="hl slc">// The host pointers point to the start of the image data:</span>
    input_buf<span class="hl opt">.</span>host  <span class="hl opt">= &amp;</span>input<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
    output_buf<span class="hl opt">.</span>host <span class="hl opt">= &amp;</span>output<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>

    <span class="hl slc">// To access pixel (x, y) in a two-dimensional buffer_t, Halide</span>
    <span class="hl slc">// looks at memory address:</span>

    <span class="hl slc">// host + elem_size * ((x - min[0])*stride[0] + (y - min[1])*stride[1])</span>

    <span class="hl slc">// The stride in a dimension represents the number of elements in</span>
    <span class="hl slc">// memory between adjacent entries in that dimension. We have a</span>
    <span class="hl slc">// grayscale image stored in scanline order, so stride[0] is 1,</span>
    <span class="hl slc">// because pixels that are adjacent in x are next to each other in</span>
    <span class="hl slc">// memory.</span>
    input_buf<span class="hl opt">.</span>stride<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> output_buf<span class="hl opt">.</span>stride<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> <span class="hl num">1</span><span class="hl opt">;</span>

    <span class="hl slc">// stride[1] is the width of the image, because pixels that are</span>
    <span class="hl slc">// adjacent in y are separated by a scanline's worth of pixels in</span>
    <span class="hl slc">// memory.</span>
    input_buf<span class="hl opt">.</span>stride<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] =</span> output_buf<span class="hl opt">.</span>stride<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] =</span> <span class="hl num">640</span><span class="hl opt">;</span>

    <span class="hl slc">// The extent tells us how large the image is in each dimension.</span>
    input_buf<span class="hl opt">.</span>extent<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> output_buf<span class="hl opt">.</span>extent<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> <span class="hl num">640</span><span class="hl opt">;</span>
    input_buf<span class="hl opt">.</span>extent<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] =</span> output_buf<span class="hl opt">.</span>extent<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] =</span> <span class="hl num">480</span><span class="hl opt">;</span>

    <span class="hl slc">// We'll leave the mins as zero. This is what they typically</span>
    <span class="hl slc">// are. The host pointer points to the memory location of the min</span>
    <span class="hl slc">// coordinate (not the origin!).  See lesson 6 for more detail</span>
    <span class="hl slc">// about the mins.</span>

    <span class="hl slc">// The elem_size field tells us how many bytes each element</span>
    <span class="hl slc">// uses. For the 8-bit image we use in this test it's one.</span>
    input_buf<span class="hl opt">.</span>elem_size <span class="hl opt">=</span> output_buf<span class="hl opt">.</span>elem_size <span class="hl opt">=</span> <span class="hl num">1</span><span class="hl opt">;</span>

    <span class="hl slc">// To avoid repeating all the boilerplate above, We recommend you</span>
    <span class="hl slc">// make a helper function that populates a buffer_t given whatever</span>
    <span class="hl slc">// image type you're using.</span>

    <span class="hl slc">// Now that we've setup our input and output buffers, we can call</span>
    <span class="hl slc">// our function. Looking in the header file, it's signature is:</span>

    <span class="hl slc">// int lesson_10_halide(buffer_t *_input, const int32_t _offset, buffer_t *_brighter);</span>

    <span class="hl slc">// The return value is an error code. It's zero on success.</span>

    <span class="hl kwb">int</span> offset <span class="hl opt">=</span> <span class="hl num">5</span><span class="hl opt">;</span>
    <span class="hl kwb">int</span> error <span class="hl opt">=</span> <span class="hl kwd">lesson_10_halide</span><span class="hl opt">(&amp;</span>input_buf<span class="hl opt">,</span> offset<span class="hl opt">, &amp;</span>output_buf<span class="hl opt">);</span>

    <span class="hl kwa">if</span> <span class="hl opt">(</span>error<span class="hl opt">) {</span>
        <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Halide returned an error: %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span> error<span class="hl opt">);</span>
        <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// Now let's check the filter performed as advertised. It was</span>
    <span class="hl slc">// supposed to add the offset to every input pixel.</span>
    <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> <span class="hl num">480</span><span class="hl opt">;</span> y<span class="hl opt">++) {</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">640</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
            <span class="hl kwb">uint8_t</span> input_val <span class="hl opt">=</span> input<span class="hl opt">[</span>y <span class="hl opt">*</span> <span class="hl num">640</span> <span class="hl opt">+</span> <span class="hl num">480</span><span class="hl opt">];</span>
            <span class="hl kwb">uint8_t</span> output_val <span class="hl opt">=</span> output<span class="hl opt">[</span>y <span class="hl opt">*</span> <span class="hl num">640</span> <span class="hl opt">+</span> <span class="hl num">480</span><span class="hl opt">];</span>
            <span class="hl kwb">uint8_t</span> correct_val <span class="hl opt">=</span> input_val <span class="hl opt">+</span> offset<span class="hl opt">;</span>
            <span class="hl kwa">if</span> <span class="hl opt">(</span>output_val <span class="hl opt">!=</span> correct_val<span class="hl opt">) {</span>
                <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;output(%d, %d) was %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                       x<span class="hl opt">,</span> y<span class="hl opt">,</span> output_val<span class="hl opt">,</span> correct_val<span class="hl opt">);</span>
                <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// Everything worked!</span>
    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Success!</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre>
</div></body></html>
