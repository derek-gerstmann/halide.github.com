<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Internal::Function Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_halide_1_1_internal_1_1_function.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_halide_1_1_internal_1_1_function-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Halide::Internal::Function Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A reference-counted handle to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s internal representation of a function.  
 <a href="class_halide_1_1_internal_1_1_function.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_function_8h_source.html">Function.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_function_1_1_compare.html">Compare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This lets you use a <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> as a key in a map of the form map&lt;Function, Foo, Function::Compare&gt;  <a href="struct_halide_1_1_internal_1_1_function_1_1_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a554e59f1182c49834e0f6e1da0291c0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a554e59f1182c49834e0f6e1da0291c0d">Function</a> ()=default</td></tr>
<tr class="memdesc:a554e59f1182c49834e0f6e1da0291c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new function with no definitions and no name.  <a href="class_halide_1_1_internal_1_1_function.html#a554e59f1182c49834e0f6e1da0291c0d">More...</a><br /></td></tr>
<tr class="separator:a554e59f1182c49834e0f6e1da0291c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8109a2b3f78087f68cadb33765af88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a0f8109a2b3f78087f68cadb33765af88">Function</a> (const std::string &amp;n)</td></tr>
<tr class="memdesc:a0f8109a2b3f78087f68cadb33765af88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new function with the given name.  <a href="class_halide_1_1_internal_1_1_function.html#a0f8109a2b3f78087f68cadb33765af88">More...</a><br /></td></tr>
<tr class="separator:a0f8109a2b3f78087f68cadb33765af88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb22fbfccb4336a5a60e6d56414bf6ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#afb22fbfccb4336a5a60e6d56414bf6ff">Function</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;<a class="el" href="class_halide_1_1_internal_1_1_function.html#a327bfb2b7949e501a7e236bdf441d09b">required_types</a>, int required_dims, const std::string &amp;n)</td></tr>
<tr class="memdesc:afb22fbfccb4336a5a60e6d56414bf6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new function with the given name, with a requirement that it can only represent Expr(s) of the given type(s), and must have exactly the give nnumber of dimensions.  <a href="class_halide_1_1_internal_1_1_function.html#afb22fbfccb4336a5a60e6d56414bf6ff">More...</a><br /></td></tr>
<tr class="separator:afb22fbfccb4336a5a60e6d56414bf6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13f728a73fcf2f407d45ecee30be83e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#ae13f728a73fcf2f407d45ecee30be83e">Function</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &amp;)</td></tr>
<tr class="memdesc:ae13f728a73fcf2f407d45ecee30be83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> from an existing FunctionContents pointer.  <a href="class_halide_1_1_internal_1_1_function.html#ae13f728a73fcf2f407d45ecee30be83e">More...</a><br /></td></tr>
<tr class="separator:ae13f728a73fcf2f407d45ecee30be83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ab7f6aaa47fc731c029c6d2c419b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a028ab7f6aaa47fc731c029c6d2c419b4">get_contents</a> () const</td></tr>
<tr class="memdesc:a028ab7f6aaa47fc731c029c6d2c419b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle on the halide function contents that this <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> represents.  <a href="class_halide_1_1_internal_1_1_function.html#a028ab7f6aaa47fc731c029c6d2c419b4">More...</a><br /></td></tr>
<tr class="separator:a028ab7f6aaa47fc731c029c6d2c419b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f9dbfe93cb6b12d965a6a7ffa4495a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a09f9dbfe93cb6b12d965a6a7ffa4495a">deep_copy</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &amp;copy, std::map&lt; <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a>, <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &gt; &amp;copied_map) const</td></tr>
<tr class="memdesc:a09f9dbfe93cb6b12d965a6a7ffa4495a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy this <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> into 'copy'.  <a href="class_halide_1_1_internal_1_1_function.html#a09f9dbfe93cb6b12d965a6a7ffa4495a">More...</a><br /></td></tr>
<tr class="separator:a09f9dbfe93cb6b12d965a6a7ffa4495a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4a8ca9c55b84e62b732c0369db5d29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a9b4a8ca9c55b84e62b732c0369db5d29">deep_copy</a> (std::string <a class="el" href="class_halide_1_1_internal_1_1_function.html#af59b4d4d91843aa513a4a84afa968d73">name</a>, const <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &amp;copy, std::map&lt; <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a>, <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &gt; &amp;copied_map) const</td></tr>
<tr class="separator:a9b4a8ca9c55b84e62b732c0369db5d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e0aade5c77940b25d883eeaab82393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a03e0aade5c77940b25d883eeaab82393">define</a> (const std::vector&lt; std::string &gt; &amp;<a class="el" href="class_halide_1_1_internal_1_1_function.html#a8f0c8fde693029b5b623f724daff5610">args</a>, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; <a class="el" href="class_halide_1_1_internal_1_1_function.html#ace97de68fb5c37775320085af9a6b92e">values</a>)</td></tr>
<tr class="memdesc:a03e0aade5c77940b25d883eeaab82393"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> a pure definition to this function.  <a href="class_halide_1_1_internal_1_1_function.html#a03e0aade5c77940b25d883eeaab82393">More...</a><br /></td></tr>
<tr class="separator:a03e0aade5c77940b25d883eeaab82393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ec4114945020dffc766ffe103c5364"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#aa9ec4114945020dffc766ffe103c5364">define_update</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;<a class="el" href="class_halide_1_1_internal_1_1_function.html#a8f0c8fde693029b5b623f724daff5610">args</a>, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; <a class="el" href="class_halide_1_1_internal_1_1_function.html#ace97de68fb5c37775320085af9a6b92e">values</a>)</td></tr>
<tr class="memdesc:aa9ec4114945020dffc766ffe103c5364"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> an update definition to this function.  <a href="class_halide_1_1_internal_1_1_function.html#aa9ec4114945020dffc766ffe103c5364">More...</a><br /></td></tr>
<tr class="separator:aa9ec4114945020dffc766ffe103c5364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc0efa26555486171f091d4f0c24450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#aafc0efa26555486171f091d4f0c24450">accept</a> (<a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a> *visitor) const</td></tr>
<tr class="memdesc:aafc0efa26555486171f091d4f0c24450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a visitor to visit all of the definitions and arguments of this function.  <a href="class_halide_1_1_internal_1_1_function.html#aafc0efa26555486171f091d4f0c24450">More...</a><br /></td></tr>
<tr class="separator:aafc0efa26555486171f091d4f0c24450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fef227fa92ce427b9cb2451b2373e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a8fef227fa92ce427b9cb2451b2373e9d">mutate</a> (<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> *mutator)</td></tr>
<tr class="memdesc:a8fef227fa92ce427b9cb2451b2373e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a mutator to mutator all of the definitions and arguments of this function.  <a href="class_halide_1_1_internal_1_1_function.html#a8fef227fa92ce427b9cb2451b2373e9d">More...</a><br /></td></tr>
<tr class="separator:a8fef227fa92ce427b9cb2451b2373e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59b4d4d91843aa513a4a84afa968d73"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#af59b4d4d91843aa513a4a84afa968d73">name</a> () const</td></tr>
<tr class="memdesc:af59b4d4d91843aa513a4a84afa968d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the function.  <a href="class_halide_1_1_internal_1_1_function.html#af59b4d4d91843aa513a4a84afa968d73">More...</a><br /></td></tr>
<tr class="separator:af59b4d4d91843aa513a4a84afa968d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fa54bf31b9c38057a1184f4a705a01"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#ae1fa54bf31b9c38057a1184f4a705a01">origin_name</a> () const</td></tr>
<tr class="memdesc:ae1fa54bf31b9c38057a1184f4a705a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this is a wrapper of another func, created by a chain of in or clone_in calls, returns the name of the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="class_halide_1_1_internal_1_1_function.html#ae1fa54bf31b9c38057a1184f4a705a01">More...</a><br /></td></tr>
<tr class="separator:ae1fa54bf31b9c38057a1184f4a705a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a250edfab369e796a0e87aeffabf5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a80a250edfab369e796a0e87aeffabf5f">definition</a> ()</td></tr>
<tr class="memdesc:a80a250edfab369e796a0e87aeffabf5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable handle to the init definition.  <a href="class_halide_1_1_internal_1_1_function.html#a80a250edfab369e796a0e87aeffabf5f">More...</a><br /></td></tr>
<tr class="separator:a80a250edfab369e796a0e87aeffabf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5331befda767968ab152782a98273f2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a5331befda767968ab152782a98273f2f">definition</a> () const</td></tr>
<tr class="memdesc:a5331befda767968ab152782a98273f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the init definition.  <a href="class_halide_1_1_internal_1_1_function.html#a5331befda767968ab152782a98273f2f">More...</a><br /></td></tr>
<tr class="separator:a5331befda767968ab152782a98273f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0c8fde693029b5b623f724daff5610"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a8f0c8fde693029b5b623f724daff5610">args</a> () const</td></tr>
<tr class="memdesc:a8f0c8fde693029b5b623f724daff5610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pure arguments.  <a href="class_halide_1_1_internal_1_1_function.html#a8f0c8fde693029b5b623f724daff5610">More...</a><br /></td></tr>
<tr class="separator:a8f0c8fde693029b5b623f724daff5610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c660ef274262af138c60fa0ff32c50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a17c660ef274262af138c60fa0ff32c50">dimensions</a> () const</td></tr>
<tr class="memdesc:a17c660ef274262af138c60fa0ff32c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimensionality.  <a href="class_halide_1_1_internal_1_1_function.html#a17c660ef274262af138c60fa0ff32c50">More...</a><br /></td></tr>
<tr class="separator:a17c660ef274262af138c60fa0ff32c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f71c4b6e6fc369b0142e4f835cd913"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a20f71c4b6e6fc369b0142e4f835cd913">outputs</a> () const</td></tr>
<tr class="memdesc:a20f71c4b6e6fc369b0142e4f835cd913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of outputs.  <a href="class_halide_1_1_internal_1_1_function.html#a20f71c4b6e6fc369b0142e4f835cd913">More...</a><br /></td></tr>
<tr class="separator:a20f71c4b6e6fc369b0142e4f835cd913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97ed0656108f735c7d917b0b0666430"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#ab97ed0656108f735c7d917b0b0666430">output_types</a> () const</td></tr>
<tr class="memdesc:ab97ed0656108f735c7d917b0b0666430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the types of the outputs.  <a href="class_halide_1_1_internal_1_1_function.html#ab97ed0656108f735c7d917b0b0666430">More...</a><br /></td></tr>
<tr class="separator:ab97ed0656108f735c7d917b0b0666430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327bfb2b7949e501a7e236bdf441d09b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a327bfb2b7949e501a7e236bdf441d09b">required_types</a> () const</td></tr>
<tr class="memdesc:a327bfb2b7949e501a7e236bdf441d09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type constaints on the outputs (if any).  <a href="class_halide_1_1_internal_1_1_function.html#a327bfb2b7949e501a7e236bdf441d09b">More...</a><br /></td></tr>
<tr class="separator:a327bfb2b7949e501a7e236bdf441d09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22332bc0102a32a38a012a1a4ed4e8d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a22332bc0102a32a38a012a1a4ed4e8d5">required_dimensions</a> () const</td></tr>
<tr class="memdesc:a22332bc0102a32a38a012a1a4ed4e8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimensionality constaints on the outputs (if any).  <a href="class_halide_1_1_internal_1_1_function.html#a22332bc0102a32a38a012a1a4ed4e8d5">More...</a><br /></td></tr>
<tr class="separator:a22332bc0102a32a38a012a1a4ed4e8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace97de68fb5c37775320085af9a6b92e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#ace97de68fb5c37775320085af9a6b92e">values</a> () const</td></tr>
<tr class="memdesc:ace97de68fb5c37775320085af9a6b92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the right-hand-side of the pure definition.  <a href="class_halide_1_1_internal_1_1_function.html#ace97de68fb5c37775320085af9a6b92e">More...</a><br /></td></tr>
<tr class="separator:ace97de68fb5c37775320085af9a6b92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d94dd5d95a1a4c9825af47d334f15f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a49d94dd5d95a1a4c9825af47d334f15f">has_pure_definition</a> () const</td></tr>
<tr class="memdesc:a49d94dd5d95a1a4c9825af47d334f15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this function have a pure definition?  <a href="class_halide_1_1_internal_1_1_function.html#a49d94dd5d95a1a4c9825af47d334f15f">More...</a><br /></td></tr>
<tr class="separator:a49d94dd5d95a1a4c9825af47d334f15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5736144d42049821f7d7058884fa8753"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a5736144d42049821f7d7058884fa8753">is_pure</a> () const</td></tr>
<tr class="memdesc:a5736144d42049821f7d7058884fa8753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this function <em>only</em> have a pure definition?  <a href="class_halide_1_1_internal_1_1_function.html#a5736144d42049821f7d7058884fa8753">More...</a><br /></td></tr>
<tr class="separator:a5736144d42049821f7d7058884fa8753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dea3ec3600a1f0dd492f149d7eeffc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a39dea3ec3600a1f0dd492f149d7eeffc">can_be_inlined</a> () const</td></tr>
<tr class="memdesc:a39dea3ec3600a1f0dd492f149d7eeffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it legal to inline this function?  <a href="class_halide_1_1_internal_1_1_function.html#a39dea3ec3600a1f0dd492f149d7eeffc">More...</a><br /></td></tr>
<tr class="separator:a39dea3ec3600a1f0dd492f149d7eeffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fcc029247c8904b3c176cb5f0173bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_func_schedule.html">FuncSchedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a50fcc029247c8904b3c176cb5f0173bd">schedule</a> ()</td></tr>
<tr class="memdesc:a50fcc029247c8904b3c176cb5f0173bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the function-specific schedule for the purpose of modifying it.  <a href="class_halide_1_1_internal_1_1_function.html#a50fcc029247c8904b3c176cb5f0173bd">More...</a><br /></td></tr>
<tr class="separator:a50fcc029247c8904b3c176cb5f0173bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f025a198da7307968d68a2b313f3e0c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_halide_1_1_internal_1_1_func_schedule.html">FuncSchedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a6f025a198da7307968d68a2b313f3e0c">schedule</a> () const</td></tr>
<tr class="memdesc:a6f025a198da7307968d68a2b313f3e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const handle to the function-specific schedule for inspecting it.  <a href="class_halide_1_1_internal_1_1_function.html#a6f025a198da7307968d68a2b313f3e0c">More...</a><br /></td></tr>
<tr class="separator:a6f025a198da7307968d68a2b313f3e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527c78325a8bc6fbde12ed965a4db08b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Parameter</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a527c78325a8bc6fbde12ed965a4db08b">output_buffers</a> () const</td></tr>
<tr class="memdesc:a527c78325a8bc6fbde12ed965a4db08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle on the output buffer used for setting constraints on it.  <a href="class_halide_1_1_internal_1_1_function.html#a527c78325a8bc6fbde12ed965a4db08b">More...</a><br /></td></tr>
<tr class="separator:a527c78325a8bc6fbde12ed965a4db08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee6716396f280c0bfdcd7be8231a254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a3ee6716396f280c0bfdcd7be8231a254">update_schedule</a> (int idx=0)</td></tr>
<tr class="memdesc:a3ee6716396f280c0bfdcd7be8231a254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable handle to the stage-specfic schedule for the update stage.  <a href="class_halide_1_1_internal_1_1_function.html#a3ee6716396f280c0bfdcd7be8231a254">More...</a><br /></td></tr>
<tr class="separator:a3ee6716396f280c0bfdcd7be8231a254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09cf0450690dbeeb5a951c799ffcd49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#aa09cf0450690dbeeb5a951c799ffcd49">update</a> (int idx=0)</td></tr>
<tr class="memdesc:aa09cf0450690dbeeb5a951c799ffcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable handle to this function's update definition at index 'idx'.  <a href="class_halide_1_1_internal_1_1_function.html#aa09cf0450690dbeeb5a951c799ffcd49">More...</a><br /></td></tr>
<tr class="separator:aa09cf0450690dbeeb5a951c799ffcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff7cf28b3b2ee65b2e2adad5f5e73da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a2ff7cf28b3b2ee65b2e2adad5f5e73da">update</a> (int idx=0) const</td></tr>
<tr class="memdesc:a2ff7cf28b3b2ee65b2e2adad5f5e73da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to this function's update definition at index 'idx'.  <a href="class_halide_1_1_internal_1_1_function.html#a2ff7cf28b3b2ee65b2e2adad5f5e73da">More...</a><br /></td></tr>
<tr class="separator:a2ff7cf28b3b2ee65b2e2adad5f5e73da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3bfbd240f79886e1d5547ff7b80f81"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a7f3bfbd240f79886e1d5547ff7b80f81">updates</a> () const</td></tr>
<tr class="memdesc:a7f3bfbd240f79886e1d5547ff7b80f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to this function's update definitions.  <a href="class_halide_1_1_internal_1_1_function.html#a7f3bfbd240f79886e1d5547ff7b80f81">More...</a><br /></td></tr>
<tr class="separator:a7f3bfbd240f79886e1d5547ff7b80f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bb57b1ea8e1eecca754786eb539f33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a59bb57b1ea8e1eecca754786eb539f33">has_update_definition</a> () const</td></tr>
<tr class="memdesc:a59bb57b1ea8e1eecca754786eb539f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this function have an update definition?  <a href="class_halide_1_1_internal_1_1_function.html#a59bb57b1ea8e1eecca754786eb539f33">More...</a><br /></td></tr>
<tr class="separator:a59bb57b1ea8e1eecca754786eb539f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2001e658ff01c80e7bfbc30eb559d58c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a2001e658ff01c80e7bfbc30eb559d58c">has_extern_definition</a> () const</td></tr>
<tr class="memdesc:a2001e658ff01c80e7bfbc30eb559d58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the function has an extern definition.  <a href="class_halide_1_1_internal_1_1_function.html#a2001e658ff01c80e7bfbc30eb559d58c">More...</a><br /></td></tr>
<tr class="separator:a2001e658ff01c80e7bfbc30eb559d58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a5756127da1f85205b7885f8348bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#aa8a5756127da1f85205b7885f8348bf9">extern_definition_name_mangling</a> () const</td></tr>
<tr class="memdesc:aa8a5756127da1f85205b7885f8348bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name mangling specified for the extern definition.  <a href="class_halide_1_1_internal_1_1_function.html#aa8a5756127da1f85205b7885f8348bf9">More...</a><br /></td></tr>
<tr class="separator:aa8a5756127da1f85205b7885f8348bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cd7283bbe8e53e43dd4436ab99588e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#ae0cd7283bbe8e53e43dd4436ab99588e">make_call_to_extern_definition</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;<a class="el" href="class_halide_1_1_internal_1_1_function.html#a8f0c8fde693029b5b623f724daff5610">args</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t) const</td></tr>
<tr class="memdesc:ae0cd7283bbe8e53e43dd4436ab99588e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a call node to the extern definition.  <a href="class_halide_1_1_internal_1_1_function.html#ae0cd7283bbe8e53e43dd4436ab99588e">More...</a><br /></td></tr>
<tr class="separator:ae0cd7283bbe8e53e43dd4436ab99588e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf79a6c2735d6e56a6b98a77f5337db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#afaf79a6c2735d6e56a6b98a77f5337db">extern_definition_proxy_expr</a> () const</td></tr>
<tr class="memdesc:afaf79a6c2735d6e56a6b98a77f5337db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the proxy <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> for the extern stage.  <a href="class_halide_1_1_internal_1_1_function.html#afaf79a6c2735d6e56a6b98a77f5337db">More...</a><br /></td></tr>
<tr class="separator:afaf79a6c2735d6e56a6b98a77f5337db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa939aaf0d42b2116d45cafaa88109a8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#aa939aaf0d42b2116d45cafaa88109a8d">extern_definition_proxy_expr</a> ()</td></tr>
<tr class="separator:aa939aaf0d42b2116d45cafaa88109a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91254492cb27dd19086d2b6f6551b068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a91254492cb27dd19086d2b6f6551b068">define_extern</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;<a class="el" href="class_halide_1_1_internal_1_1_function.html#a8f0c8fde693029b5b623f724daff5610">args</a>, const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;types, const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;dims, <a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> mangling, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api)</td></tr>
<tr class="memdesc:a91254492cb27dd19086d2b6f6551b068"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> an external definition of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="class_halide_1_1_internal_1_1_function.html#a91254492cb27dd19086d2b6f6551b068">More...</a><br /></td></tr>
<tr class="separator:a91254492cb27dd19086d2b6f6551b068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0186fc821f50efe3d7ab321f030ffd44"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a0186fc821f50efe3d7ab321f030ffd44">extern_arguments</a> () const</td></tr>
<tr class="memdesc:a0186fc821f50efe3d7ab321f030ffd44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrive the arguments of the extern definition.  <a href="class_halide_1_1_internal_1_1_function.html#a0186fc821f50efe3d7ab321f030ffd44">More...</a><br /></td></tr>
<tr class="separator:a0186fc821f50efe3d7ab321f030ffd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0a73ceb91018d0ebbc9c16df6fc4bb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a6c0a73ceb91018d0ebbc9c16df6fc4bb">extern_arguments</a> ()</td></tr>
<tr class="separator:a6c0a73ceb91018d0ebbc9c16df6fc4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021320b074e8f6a06f22334cee12b43e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a021320b074e8f6a06f22334cee12b43e">extern_function_name</a> () const</td></tr>
<tr class="memdesc:a021320b074e8f6a06f22334cee12b43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the extern function called for an extern definition.  <a href="class_halide_1_1_internal_1_1_function.html#a021320b074e8f6a06f22334cee12b43e">More...</a><br /></td></tr>
<tr class="separator:a021320b074e8f6a06f22334cee12b43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb237dee85d25132500b4e3244b551e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a0eb237dee85d25132500b4e3244b551e">extern_function_device_api</a> () const</td></tr>
<tr class="memdesc:a0eb237dee85d25132500b4e3244b551e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the DeviceAPI declared for an extern function.  <a href="class_halide_1_1_internal_1_1_function.html#a0eb237dee85d25132500b4e3244b551e">More...</a><br /></td></tr>
<tr class="separator:a0eb237dee85d25132500b4e3244b551e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28b99893e8625121a99583cb07c147f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#ab28b99893e8625121a99583cb07c147f">same_as</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;other) const</td></tr>
<tr class="memdesc:ab28b99893e8625121a99583cb07c147f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> for equality of identity.  <a href="class_halide_1_1_internal_1_1_function.html#ab28b99893e8625121a99583cb07c147f">More...</a><br /></td></tr>
<tr class="separator:ab28b99893e8625121a99583cb07c147f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3916aadd8befe2fca67a97cddd7b398"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#ad3916aadd8befe2fca67a97cddd7b398">debug_file</a> () const</td></tr>
<tr class="memdesc:ad3916aadd8befe2fca67a97cddd7b398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const handle to the debug filename.  <a href="class_halide_1_1_internal_1_1_function.html#ad3916aadd8befe2fca67a97cddd7b398">More...</a><br /></td></tr>
<tr class="separator:ad3916aadd8befe2fca67a97cddd7b398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487f074305ee42cc69ead8ccbd6a85ad"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a487f074305ee42cc69ead8ccbd6a85ad">debug_file</a> ()</td></tr>
<tr class="memdesc:a487f074305ee42cc69ead8ccbd6a85ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the debug filename.  <a href="class_halide_1_1_internal_1_1_function.html#a487f074305ee42cc69ead8ccbd6a85ad">More...</a><br /></td></tr>
<tr class="separator:a487f074305ee42cc69ead8ccbd6a85ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b2a2792f134df9dd79c64b03da9afd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#af3b2a2792f134df9dd79c64b03da9afd">operator ExternFuncArgument</a> () const</td></tr>
<tr class="memdesc:af3b2a2792f134df9dd79c64b03da9afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use an an extern argument to another function.  <a href="class_halide_1_1_internal_1_1_function.html#af3b2a2792f134df9dd79c64b03da9afd">More...</a><br /></td></tr>
<tr class="separator:af3b2a2792f134df9dd79c64b03da9afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaf4fbf5b97d7542b3d1c68c1e27dd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a5eaf4fbf5b97d7542b3d1c68c1e27dd2">trace_loads</a> ()</td></tr>
<tr class="memdesc:a5eaf4fbf5b97d7542b3d1c68c1e27dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracing calls and accessors, passed down from the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> equivalents.  <a href="class_halide_1_1_internal_1_1_function.html#a5eaf4fbf5b97d7542b3d1c68c1e27dd2">More...</a><br /></td></tr>
<tr class="separator:a5eaf4fbf5b97d7542b3d1c68c1e27dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fe90d4e0035742b999c5f6031f7dc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#ac1fe90d4e0035742b999c5f6031f7dc3">trace_stores</a> ()</td></tr>
<tr class="separator:ac1fe90d4e0035742b999c5f6031f7dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95082a21d62cc296e6877b43e3ea3aec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a95082a21d62cc296e6877b43e3ea3aec">trace_realizations</a> ()</td></tr>
<tr class="separator:a95082a21d62cc296e6877b43e3ea3aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e4bf90672b4c1ff9072377838a1726"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#af5e4bf90672b4c1ff9072377838a1726">add_trace_tag</a> (const std::string &amp;trace_tag)</td></tr>
<tr class="separator:af5e4bf90672b4c1ff9072377838a1726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307ae672d7e2fd16d2cda815618be8bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a307ae672d7e2fd16d2cda815618be8bf">is_tracing_loads</a> () const</td></tr>
<tr class="separator:a307ae672d7e2fd16d2cda815618be8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426ef8ca8868d747d141a8de6c3d0304"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a426ef8ca8868d747d141a8de6c3d0304">is_tracing_stores</a> () const</td></tr>
<tr class="separator:a426ef8ca8868d747d141a8de6c3d0304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184bd790777eaf7f5ddde8f30ca6e039"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a184bd790777eaf7f5ddde8f30ca6e039">is_tracing_realizations</a> () const</td></tr>
<tr class="separator:a184bd790777eaf7f5ddde8f30ca6e039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe31938a5e2710aad8bd6d3b68332656"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#abe31938a5e2710aad8bd6d3b68332656">get_trace_tags</a> () const</td></tr>
<tr class="separator:abe31938a5e2710aad8bd6d3b68332656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fb19bf63b0d52a02820500df448621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a34fb19bf63b0d52a02820500df448621">lock_loop_levels</a> ()</td></tr>
<tr class="memdesc:a34fb19bf63b0d52a02820500df448621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace this <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a>'s LoopLevels with locked copies that cannot be mutated further.  <a href="class_halide_1_1_internal_1_1_function.html#a34fb19bf63b0d52a02820500df448621">More...</a><br /></td></tr>
<tr class="separator:a34fb19bf63b0d52a02820500df448621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88ed26e82c3c53cc1a937a78510b605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#ac88ed26e82c3c53cc1a937a78510b605">freeze</a> ()</td></tr>
<tr class="memdesc:ac88ed26e82c3c53cc1a937a78510b605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark function as frozen, which means it cannot accept new definitions.  <a href="class_halide_1_1_internal_1_1_function.html#ac88ed26e82c3c53cc1a937a78510b605">More...</a><br /></td></tr>
<tr class="separator:ac88ed26e82c3c53cc1a937a78510b605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2c4658a74a9dc5a71e50290f4130d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a0d2c4658a74a9dc5a71e50290f4130d8">frozen</a> () const</td></tr>
<tr class="memdesc:a0d2c4658a74a9dc5a71e50290f4130d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a function has been frozen.  <a href="class_halide_1_1_internal_1_1_function.html#a0d2c4658a74a9dc5a71e50290f4130d8">More...</a><br /></td></tr>
<tr class="separator:a0d2c4658a74a9dc5a71e50290f4130d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e508934cf01fb297f25494a90901a9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a7e508934cf01fb297f25494a90901a9c">new_function_in_same_group</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a7e508934cf01fb297f25494a90901a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> with the same lifetime as this one, and return a strong reference to it.  <a href="class_halide_1_1_internal_1_1_function.html#a7e508934cf01fb297f25494a90901a9c">More...</a><br /></td></tr>
<tr class="separator:a7e508934cf01fb297f25494a90901a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cb19bf847e2900fc7c6157f62933a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#ad9cb19bf847e2900fc7c6157f62933a4">add_wrapper</a> (const std::string &amp;f, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;wrapper)</td></tr>
<tr class="memdesc:ad9cb19bf847e2900fc7c6157f62933a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark calls of this function by 'f' to be replaced with its wrapper during the lowering stage.  <a href="class_halide_1_1_internal_1_1_function.html#ad9cb19bf847e2900fc7c6157f62933a4">More...</a><br /></td></tr>
<tr class="separator:ad9cb19bf847e2900fc7c6157f62933a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6760aa739eab608779acf878a77545"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a2c6760aa739eab608779acf878a77545">wrappers</a> () const</td></tr>
<tr class="separator:a2c6760aa739eab608779acf878a77545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d0688e15931b714d92349570cb2ddc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a48d0688e15931b714d92349570cb2ddc">is_wrapper</a> () const</td></tr>
<tr class="memdesc:a48d0688e15931b714d92349570cb2ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> is a trivial wrapper around another <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a>, <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a>, or <a class="el" href="class_halide_1_1_internal_1_1_parameter.html" title="A reference-counted handle to a parameter to a halide pipeline.">Parameter</a>.  <a href="class_halide_1_1_internal_1_1_function.html#a48d0688e15931b714d92349570cb2ddc">More...</a><br /></td></tr>
<tr class="separator:a48d0688e15931b714d92349570cb2ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292b23ab8ef0f2a542c9bdee656cbdc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a292b23ab8ef0f2a542c9bdee656cbdc3">substitute_calls</a> (const std::map&lt; <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a>, <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &gt; &amp;substitutions)</td></tr>
<tr class="memdesc:a292b23ab8ef0f2a542c9bdee656cbdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace every call to Functions in 'substitutions' keys by all Exprs referenced in this <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> to call to their substitute Functions (i.e.  <a href="class_halide_1_1_internal_1_1_function.html#a292b23ab8ef0f2a542c9bdee656cbdc3">More...</a><br /></td></tr>
<tr class="separator:a292b23ab8ef0f2a542c9bdee656cbdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ea151b49bf6240e52613f6f8c1d567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#ad1ea151b49bf6240e52613f6f8c1d567">substitute_calls</a> (const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;orig, const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;<a class="el" href="namespace_halide_1_1_internal.html#ab77fafc3670bd07362c388820dd10c11">substitute</a>)</td></tr>
<tr class="separator:ad1ea151b49bf6240e52613f6f8c1d567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc581eb5326ca6ad00e39252b8167425"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#abc581eb5326ca6ad00e39252b8167425">is_pure_arg</a> (const std::string &amp;<a class="el" href="class_halide_1_1_internal_1_1_function.html#af59b4d4d91843aa513a4a84afa968d73">name</a>) const</td></tr>
<tr class="memdesc:abc581eb5326ca6ad00e39252b8167425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the name matches one of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a>'s pure args.  <a href="class_halide_1_1_internal_1_1_function.html#abc581eb5326ca6ad00e39252b8167425">More...</a><br /></td></tr>
<tr class="separator:abc581eb5326ca6ad00e39252b8167425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e8bfc2390d4d745d1e3ca7de30f5b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a99e8bfc2390d4d745d1e3ca7de30f5b5">check_types</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;e) const</td></tr>
<tr class="memdesc:a99e8bfc2390d4d745d1e3ca7de30f5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> has type requirements, check that the given argument is compatible with them.  <a href="class_halide_1_1_internal_1_1_function.html#a99e8bfc2390d4d745d1e3ca7de30f5b5">More...</a><br /></td></tr>
<tr class="separator:a99e8bfc2390d4d745d1e3ca7de30f5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e9947994c28f3528980cf1d082480e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#ac0e9947994c28f3528980cf1d082480e">check_types</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;t) const</td></tr>
<tr class="separator:ac0e9947994c28f3528980cf1d082480e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1828ab7689a2de2a9fae63137b013eb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a1828ab7689a2de2a9fae63137b013eb2">check_types</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t) const</td></tr>
<tr class="separator:a1828ab7689a2de2a9fae63137b013eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84024504b7308194b4d194c9d3c60579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a84024504b7308194b4d194c9d3c60579">check_types</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;exprs) const</td></tr>
<tr class="separator:a84024504b7308194b4d194c9d3c60579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfba9766837c36d181dcd2e6c3887947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#adfba9766837c36d181dcd2e6c3887947">check_types</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;types) const</td></tr>
<tr class="separator:adfba9766837c36d181dcd2e6c3887947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54af8c744f95a7af1a80343e2b87083d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a54af8c744f95a7af1a80343e2b87083d">check_dims</a> (int dims) const</td></tr>
<tr class="memdesc:a54af8c744f95a7af1a80343e2b87083d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> has dimension requirements, check that the given argument is compatible with them.  <a href="class_halide_1_1_internal_1_1_function.html#a54af8c744f95a7af1a80343e2b87083d">More...</a><br /></td></tr>
<tr class="separator:a54af8c744f95a7af1a80343e2b87083d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d22cbb4bf7abe5ed3f988236b4c119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html#a85d22cbb4bf7abe5ed3f988236b4c119">create_output_buffers</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;types, int dims) const</td></tr>
<tr class="memdesc:a85d22cbb4bf7abe5ed3f988236b4c119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the output buffers.  <a href="class_halide_1_1_internal_1_1_function.html#a85d22cbb4bf7abe5ed3f988236b4c119">More...</a><br /></td></tr>
<tr class="separator:a85d22cbb4bf7abe5ed3f988236b4c119"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A reference-counted handle to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline,...">Halide</a>'s internal representation of a function. </p>
<p >Similar to a front-end <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> object, but with no syntactic sugar to help with definitions. </p>

<p class="definition">Definition at line <a class="el" href="_function_8h_source.html#l00039">39</a> of file <a class="el" href="_function_8h_source.html">Function.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a554e59f1182c49834e0f6e1da0291c0d" name="a554e59f1182c49834e0f6e1da0291c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554e59f1182c49834e0f6e1da0291c0d">&#9670;&nbsp;</a></span>Function() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::Function::Function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new function with no definitions and no name. </p>
<p >This constructor only exists so that you can make vectors of functions, etc. </p>

</div>
</div>
<a id="a0f8109a2b3f78087f68cadb33765af88" name="a0f8109a2b3f78087f68cadb33765af88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8109a2b3f78087f68cadb33765af88">&#9670;&nbsp;</a></span>Function() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::Function::Function </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new function with the given name. </p>

</div>
</div>
<a id="afb22fbfccb4336a5a60e6d56414bf6ff" name="afb22fbfccb4336a5a60e6d56414bf6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb22fbfccb4336a5a60e6d56414bf6ff">&#9670;&nbsp;</a></span>Function() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::Function::Function </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>required_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>required_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new function with the given name, with a requirement that it can only represent Expr(s) of the given type(s), and must have exactly the give nnumber of dimensions. </p>
<p >required_types.empty() means there are no constraints on the type(s). required_dims == AnyDims means there are no constraints on the dimensions. </p>

</div>
</div>
<a id="ae13f728a73fcf2f407d45ecee30be83e" name="ae13f728a73fcf2f407d45ecee30be83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13f728a73fcf2f407d45ecee30be83e">&#9670;&nbsp;</a></span>Function() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::Function::Function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> from an existing FunctionContents pointer. </p>
<p >Must be non-null </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a028ab7f6aaa47fc731c029c6d2c419b4" name="a028ab7f6aaa47fc731c029c6d2c419b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028ab7f6aaa47fc731c029c6d2c419b4">&#9670;&nbsp;</a></span>get_contents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> Halide::Internal::Function::get_contents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a handle on the halide function contents that this <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> represents. </p>

<p class="definition">Definition at line <a class="el" href="_function_8h_source.html#l00073">73</a> of file <a class="el" href="_function_8h_source.html">Function.h</a>.</p>

</div>
</div>
<a id="a09f9dbfe93cb6b12d965a6a7ffa4495a" name="a09f9dbfe93cb6b12d965a6a7ffa4495a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f9dbfe93cb6b12d965a6a7ffa4495a">&#9670;&nbsp;</a></span>deep_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::deep_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a>, <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>copied_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep copy this <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> into 'copy'. </p>
<p >It recursively deep copies all called functions, schedules, update definitions, extern func arguments, specializations, and reduction domains. This method does not deep-copy the <a class="el" href="class_halide_1_1_internal_1_1_parameter.html" title="A reference-counted handle to a parameter to a halide pipeline.">Parameter</a> objects. This method also takes a map of &lt;old <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a>, deep-copied version&gt; as input and would use the deep-copied <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> from the map if exists instead of creating a new deep-copy to avoid creating deep-copies of the same <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> multiple times. If 'name' is specified, copy's name will be set to that. </p>

</div>
</div>
<a id="a9b4a8ca9c55b84e62b732c0369db5d29" name="a9b4a8ca9c55b84e62b732c0369db5d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4a8ca9c55b84e62b732c0369db5d29">&#9670;&nbsp;</a></span>deep_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::deep_copy </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a>, <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>copied_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03e0aade5c77940b25d883eeaab82393" name="a03e0aade5c77940b25d883eeaab82393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e0aade5c77940b25d883eeaab82393">&#9670;&nbsp;</a></span>define()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::define </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> a pure definition to this function. </p>
<p >It may not already have a definition. All the free variables in 'value' must appear in the args list. 'value' must not depend on any reduction domain </p>

</div>
</div>
<a id="aa9ec4114945020dffc766ffe103c5364" name="aa9ec4114945020dffc766ffe103c5364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ec4114945020dffc766ffe103c5364">&#9670;&nbsp;</a></span>define_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::define_update </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> an update definition to this function. </p>
<p >It must already have a pure definition but not an update definition, and the length of args must match the length of args used in the pure definition. 'value' must depend on some reduction domain, and may contain variables from that domain as well as pure variables. Any pure variables must also appear as Variables in the args array, and they must have the same name as the pure definition's argument in the same index. </p>

</div>
</div>
<a id="aafc0efa26555486171f091d4f0c24450" name="aafc0efa26555486171f091d4f0c24450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc0efa26555486171f091d4f0c24450">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a visitor to visit all of the definitions and arguments of this function. </p>

</div>
</div>
<a id="a8fef227fa92ce427b9cb2451b2373e9d" name="a8fef227fa92ce427b9cb2451b2373e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fef227fa92ce427b9cb2451b2373e9d">&#9670;&nbsp;</a></span>mutate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::mutate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> *&#160;</td>
          <td class="paramname"><em>mutator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a mutator to mutator all of the definitions and arguments of this function. </p>

</div>
</div>
<a id="af59b4d4d91843aa513a4a84afa968d73" name="af59b4d4d91843aa513a4a84afa968d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59b4d4d91843aa513a4a84afa968d73">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Halide::Internal::Function::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the function. </p>

</div>
</div>
<a id="ae1fa54bf31b9c38057a1184f4a705a01" name="ae1fa54bf31b9c38057a1184f4a705a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fa54bf31b9c38057a1184f4a705a01">&#9670;&nbsp;</a></span>origin_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Halide::Internal::Function::origin_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this is a wrapper of another func, created by a chain of in or clone_in calls, returns the name of the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p >Otherwise returns the name. </p>

</div>
</div>
<a id="a80a250edfab369e796a0e87aeffabf5f" name="a80a250edfab369e796a0e87aeffabf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a250edfab369e796a0e87aeffabf5f">&#9670;&nbsp;</a></span>definition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp; Halide::Internal::Function::definition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a mutable handle to the init definition. </p>

</div>
</div>
<a id="a5331befda767968ab152782a98273f2f" name="a5331befda767968ab152782a98273f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5331befda767968ab152782a98273f2f">&#9670;&nbsp;</a></span>definition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp; Halide::Internal::Function::definition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the init definition. </p>

</div>
</div>
<a id="a8f0c8fde693029b5b623f724daff5610" name="a8f0c8fde693029b5b623f724daff5610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0c8fde693029b5b623f724daff5610">&#9670;&nbsp;</a></span>args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; Halide::Internal::Function::args </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pure arguments. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l00094">Halide::Stage::Stage()</a>.</p>

</div>
</div>
<a id="a17c660ef274262af138c60fa0ff32c50" name="a17c660ef274262af138c60fa0ff32c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c660ef274262af138c60fa0ff32c50">&#9670;&nbsp;</a></span>dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::Function::dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimensionality. </p>

</div>
</div>
<a id="a20f71c4b6e6fc369b0142e4f835cd913" name="a20f71c4b6e6fc369b0142e4f835cd913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f71c4b6e6fc369b0142e4f835cd913">&#9670;&nbsp;</a></span>outputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::Function::outputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of outputs. </p>

</div>
</div>
<a id="ab97ed0656108f735c7d917b0b0666430" name="ab97ed0656108f735c7d917b0b0666430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97ed0656108f735c7d917b0b0666430">&#9670;&nbsp;</a></span>output_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp; Halide::Internal::Function::output_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the types of the outputs. </p>

</div>
</div>
<a id="a327bfb2b7949e501a7e236bdf441d09b" name="a327bfb2b7949e501a7e236bdf441d09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327bfb2b7949e501a7e236bdf441d09b">&#9670;&nbsp;</a></span>required_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp; Halide::Internal::Function::required_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type constaints on the outputs (if any). </p>

</div>
</div>
<a id="a22332bc0102a32a38a012a1a4ed4e8d5" name="a22332bc0102a32a38a012a1a4ed4e8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22332bc0102a32a38a012a1a4ed4e8d5">&#9670;&nbsp;</a></span>required_dimensions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::Function::required_dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dimensionality constaints on the outputs (if any). </p>

</div>
</div>
<a id="ace97de68fb5c37775320085af9a6b92e" name="ace97de68fb5c37775320085af9a6b92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace97de68fb5c37775320085af9a6b92e">&#9670;&nbsp;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp; Halide::Internal::Function::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the right-hand-side of the pure definition. </p>
<p >Returns an empty vector if there is no pure definition. </p>

</div>
</div>
<a id="a49d94dd5d95a1a4c9825af47d334f15f" name="a49d94dd5d95a1a4c9825af47d334f15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d94dd5d95a1a4c9825af47d334f15f">&#9670;&nbsp;</a></span>has_pure_definition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Function::has_pure_definition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this function have a pure definition? </p>

<p class="reference">Referenced by <a class="el" href="_function_8h_source.html#l00155">is_pure()</a>.</p>

</div>
</div>
<a id="a5736144d42049821f7d7058884fa8753" name="a5736144d42049821f7d7058884fa8753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5736144d42049821f7d7058884fa8753">&#9670;&nbsp;</a></span>is_pure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Function::is_pure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this function <em>only</em> have a pure definition? </p>

<p class="definition">Definition at line <a class="el" href="_function_8h_source.html#l00155">155</a> of file <a class="el" href="_function_8h_source.html">Function.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_internal_1_1_function.html#a2001e658ff01c80e7bfbc30eb559d58c">has_extern_definition()</a>, <a class="el" href="class_halide_1_1_internal_1_1_function.html#a49d94dd5d95a1a4c9825af47d334f15f">has_pure_definition()</a>, and <a class="el" href="class_halide_1_1_internal_1_1_function.html#a59bb57b1ea8e1eecca754786eb539f33">has_update_definition()</a>.</p>

</div>
</div>
<a id="a39dea3ec3600a1f0dd492f149d7eeffc" name="a39dea3ec3600a1f0dd492f149d7eeffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39dea3ec3600a1f0dd492f149d7eeffc">&#9670;&nbsp;</a></span>can_be_inlined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Function::can_be_inlined </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is it legal to inline this function? </p>

</div>
</div>
<a id="a50fcc029247c8904b3c176cb5f0173bd" name="a50fcc029247c8904b3c176cb5f0173bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fcc029247c8904b3c176cb5f0173bd">&#9670;&nbsp;</a></span>schedule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_func_schedule.html">FuncSchedule</a> &amp; Halide::Internal::Function::schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to the function-specific schedule for the purpose of modifying it. </p>

</div>
</div>
<a id="a6f025a198da7307968d68a2b313f3e0c" name="a6f025a198da7307968d68a2b313f3e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f025a198da7307968d68a2b313f3e0c">&#9670;&nbsp;</a></span>schedule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_halide_1_1_internal_1_1_func_schedule.html">FuncSchedule</a> &amp; Halide::Internal::Function::schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const handle to the function-specific schedule for inspecting it. </p>

</div>
</div>
<a id="a527c78325a8bc6fbde12ed965a4db08b" name="a527c78325a8bc6fbde12ed965a4db08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527c78325a8bc6fbde12ed965a4db08b">&#9670;&nbsp;</a></span>output_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Parameter</a> &gt; &amp; Halide::Internal::Function::output_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle on the output buffer used for setting constraints on it. </p>

</div>
</div>
<a id="a3ee6716396f280c0bfdcd7be8231a254" name="a3ee6716396f280c0bfdcd7be8231a254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee6716396f280c0bfdcd7be8231a254">&#9670;&nbsp;</a></span>update_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a> &amp; Halide::Internal::Function::update_schedule </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a mutable handle to the stage-specfic schedule for the update stage. </p>

</div>
</div>
<a id="aa09cf0450690dbeeb5a951c799ffcd49" name="aa09cf0450690dbeeb5a951c799ffcd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09cf0450690dbeeb5a951c799ffcd49">&#9670;&nbsp;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp; Halide::Internal::Function::update </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a mutable handle to this function's update definition at index 'idx'. </p>

</div>
</div>
<a id="a2ff7cf28b3b2ee65b2e2adad5f5e73da" name="a2ff7cf28b3b2ee65b2e2adad5f5e73da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff7cf28b3b2ee65b2e2adad5f5e73da">&#9670;&nbsp;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp; Halide::Internal::Function::update </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const reference to this function's update definition at index 'idx'. </p>

</div>
</div>
<a id="a7f3bfbd240f79886e1d5547ff7b80f81" name="a7f3bfbd240f79886e1d5547ff7b80f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3bfbd240f79886e1d5547ff7b80f81">&#9670;&nbsp;</a></span>updates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &gt; &amp; Halide::Internal::Function::updates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const reference to this function's update definitions. </p>

</div>
</div>
<a id="a59bb57b1ea8e1eecca754786eb539f33" name="a59bb57b1ea8e1eecca754786eb539f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bb57b1ea8e1eecca754786eb539f33">&#9670;&nbsp;</a></span>has_update_definition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Function::has_update_definition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this function have an update definition? </p>

<p class="reference">Referenced by <a class="el" href="simd__op__check_8h_source.html#l00167">Halide::SimdOpCheckTest::check_one()</a>, and <a class="el" href="_function_8h_source.html#l00155">is_pure()</a>.</p>

</div>
</div>
<a id="a2001e658ff01c80e7bfbc30eb559d58c" name="a2001e658ff01c80e7bfbc30eb559d58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2001e658ff01c80e7bfbc30eb559d58c">&#9670;&nbsp;</a></span>has_extern_definition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Function::has_extern_definition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the function has an extern definition. </p>

<p class="reference">Referenced by <a class="el" href="_function_8h_source.html#l00155">is_pure()</a>.</p>

</div>
</div>
<a id="aa8a5756127da1f85205b7885f8348bf9" name="aa8a5756127da1f85205b7885f8348bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a5756127da1f85205b7885f8348bf9">&#9670;&nbsp;</a></span>extern_definition_name_mangling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a> Halide::Internal::Function::extern_definition_name_mangling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name mangling specified for the extern definition. </p>

</div>
</div>
<a id="ae0cd7283bbe8e53e43dd4436ab99588e" name="ae0cd7283bbe8e53e43dd4436ab99588e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cd7283bbe8e53e43dd4436ab99588e">&#9670;&nbsp;</a></span>make_call_to_extern_definition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::Function::make_call_to_extern_definition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a call node to the extern definition. </p>
<p >An error if the function has no extern definition. </p>

</div>
</div>
<a id="afaf79a6c2735d6e56a6b98a77f5337db" name="afaf79a6c2735d6e56a6b98a77f5337db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf79a6c2735d6e56a6b98a77f5337db">&#9670;&nbsp;</a></span>extern_definition_proxy_expr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::Function::extern_definition_proxy_expr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the proxy <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> for the extern stage. </p>
<p >This is an expression known to have the same data access pattern as the extern stage. It must touch at least all of the memory that the extern stage does, though it is permissible for it to be conservative and touch a superset. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> most Functions, including those with extern definitions, this will be an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>. </p>

</div>
</div>
<a id="aa939aaf0d42b2116d45cafaa88109a8d" name="aa939aaf0d42b2116d45cafaa88109a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa939aaf0d42b2116d45cafaa88109a8d">&#9670;&nbsp;</a></span>extern_definition_proxy_expr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp; Halide::Internal::Function::extern_definition_proxy_expr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91254492cb27dd19086d2b6f6551b068" name="a91254492cb27dd19086d2b6f6551b068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91254492cb27dd19086d2b6f6551b068">&#9670;&nbsp;</a></span>define_extern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::define_extern </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a9a0a73a2b8a7322d8ac330adfce8d134">NameMangling</a>&#160;</td>
          <td class="paramname"><em>mangling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions.">Add</a> an external definition of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>

</div>
</div>
<a id="a0186fc821f50efe3d7ab321f030ffd44" name="a0186fc821f50efe3d7ab321f030ffd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0186fc821f50efe3d7ab321f030ffd44">&#9670;&nbsp;</a></span>extern_arguments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp; Halide::Internal::Function::extern_arguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrive the arguments of the extern definition. </p>

</div>
</div>
<a id="a6c0a73ceb91018d0ebbc9c16df6fc4bb" name="a6c0a73ceb91018d0ebbc9c16df6fc4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0a73ceb91018d0ebbc9c16df6fc4bb">&#9670;&nbsp;</a></span>extern_arguments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp; Halide::Internal::Function::extern_arguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a021320b074e8f6a06f22334cee12b43e" name="a021320b074e8f6a06f22334cee12b43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021320b074e8f6a06f22334cee12b43e">&#9670;&nbsp;</a></span>extern_function_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Halide::Internal::Function::extern_function_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the extern function called for an extern definition. </p>

</div>
</div>
<a id="a0eb237dee85d25132500b4e3244b551e" name="a0eb237dee85d25132500b4e3244b551e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb237dee85d25132500b4e3244b551e">&#9670;&nbsp;</a></span>extern_function_device_api()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> Halide::Internal::Function::extern_function_device_api </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the DeviceAPI declared for an extern function. </p>

</div>
</div>
<a id="ab28b99893e8625121a99583cb07c147f" name="ab28b99893e8625121a99583cb07c147f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28b99893e8625121a99583cb07c147f">&#9670;&nbsp;</a></span>same_as()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Function::same_as </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal_1_1_test.html">Test</a> for equality of identity. </p>

<p class="definition">Definition at line <a class="el" href="_function_8h_source.html#l00236">236</a> of file <a class="el" href="_function_8h_source.html">Function.h</a>.</p>

<p class="reference">References <a class="el" href="_function_ptr_8h_source.html#l00079">Halide::Internal::FunctionPtr::same_as()</a>.</p>

</div>
</div>
<a id="ad3916aadd8befe2fca67a97cddd7b398" name="ad3916aadd8befe2fca67a97cddd7b398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3916aadd8befe2fca67a97cddd7b398">&#9670;&nbsp;</a></span>debug_file() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Halide::Internal::Function::debug_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const handle to the debug filename. </p>

</div>
</div>
<a id="a487f074305ee42cc69ead8ccbd6a85ad" name="a487f074305ee42cc69ead8ccbd6a85ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487f074305ee42cc69ead8ccbd6a85ad">&#9670;&nbsp;</a></span>debug_file() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; Halide::Internal::Function::debug_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to the debug filename. </p>

</div>
</div>
<a id="af3b2a2792f134df9dd79c64b03da9afd" name="af3b2a2792f134df9dd79c64b03da9afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b2a2792f134df9dd79c64b03da9afd">&#9670;&nbsp;</a></span>operator ExternFuncArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Internal::Function::operator <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use an an extern argument to another function. </p>

</div>
</div>
<a id="a5eaf4fbf5b97d7542b3d1c68c1e27dd2" name="a5eaf4fbf5b97d7542b3d1c68c1e27dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eaf4fbf5b97d7542b3d1c68c1e27dd2">&#9670;&nbsp;</a></span>trace_loads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::trace_loads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracing calls and accessors, passed down from the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> equivalents. </p>

</div>
</div>
<a id="ac1fe90d4e0035742b999c5f6031f7dc3" name="ac1fe90d4e0035742b999c5f6031f7dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fe90d4e0035742b999c5f6031f7dc3">&#9670;&nbsp;</a></span>trace_stores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::trace_stores </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95082a21d62cc296e6877b43e3ea3aec" name="a95082a21d62cc296e6877b43e3ea3aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95082a21d62cc296e6877b43e3ea3aec">&#9670;&nbsp;</a></span>trace_realizations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::trace_realizations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5e4bf90672b4c1ff9072377838a1726" name="af5e4bf90672b4c1ff9072377838a1726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e4bf90672b4c1ff9072377838a1726">&#9670;&nbsp;</a></span>add_trace_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::add_trace_tag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>trace_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a307ae672d7e2fd16d2cda815618be8bf" name="a307ae672d7e2fd16d2cda815618be8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307ae672d7e2fd16d2cda815618be8bf">&#9670;&nbsp;</a></span>is_tracing_loads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Function::is_tracing_loads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a426ef8ca8868d747d141a8de6c3d0304" name="a426ef8ca8868d747d141a8de6c3d0304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426ef8ca8868d747d141a8de6c3d0304">&#9670;&nbsp;</a></span>is_tracing_stores()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Function::is_tracing_stores </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a184bd790777eaf7f5ddde8f30ca6e039" name="a184bd790777eaf7f5ddde8f30ca6e039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184bd790777eaf7f5ddde8f30ca6e039">&#9670;&nbsp;</a></span>is_tracing_realizations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Function::is_tracing_realizations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe31938a5e2710aad8bd6d3b68332656" name="abe31938a5e2710aad8bd6d3b68332656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe31938a5e2710aad8bd6d3b68332656">&#9670;&nbsp;</a></span>get_trace_tags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; Halide::Internal::Function::get_trace_tags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34fb19bf63b0d52a02820500df448621" name="a34fb19bf63b0d52a02820500df448621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fb19bf63b0d52a02820500df448621">&#9670;&nbsp;</a></span>lock_loop_levels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::lock_loop_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace this <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a>'s LoopLevels with locked copies that cannot be mutated further. </p>

</div>
</div>
<a id="ac88ed26e82c3c53cc1a937a78510b605" name="ac88ed26e82c3c53cc1a937a78510b605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88ed26e82c3c53cc1a937a78510b605">&#9670;&nbsp;</a></span>freeze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::freeze </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark function as frozen, which means it cannot accept new definitions. </p>

</div>
</div>
<a id="a0d2c4658a74a9dc5a71e50290f4130d8" name="a0d2c4658a74a9dc5a71e50290f4130d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2c4658a74a9dc5a71e50290f4130d8">&#9670;&nbsp;</a></span>frozen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Function::frozen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a function has been frozen. </p>
<p >If so, it is an error to add new definitions. </p>

</div>
</div>
<a id="a7e508934cf01fb297f25494a90901a9c" name="a7e508934cf01fb297f25494a90901a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e508934cf01fb297f25494a90901a9c">&#9670;&nbsp;</a></span>new_function_in_same_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> Halide::Internal::Function::new_function_in_same_group </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a new <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> with the same lifetime as this one, and return a strong reference to it. </p>
<p >Useful to create Functions which have circular references to this one - e.g. the wrappers produced by <a class="el" href="class_halide_1_1_func.html#af0957a1f444256a88279d5d922bf1c52" title="Creates and returns a new identity Func that wraps this Func.">Func::in</a>. </p>

</div>
</div>
<a id="ad9cb19bf847e2900fc7c6157f62933a4" name="ad9cb19bf847e2900fc7c6157f62933a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cb19bf847e2900fc7c6157f62933a4">&#9670;&nbsp;</a></span>add_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::add_wrapper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>wrapper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark calls of this function by 'f' to be replaced with its wrapper during the lowering stage. </p>
<p >If the string 'f' is empty, it means replace all calls to this function by all other functions (excluding itself) in the pipeline with the wrapper. This will also freeze 'wrapper' to prevent user from updating the values of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> it wraps via the wrapper. See <a class="el" href="class_halide_1_1_func.html#af0957a1f444256a88279d5d922bf1c52">Func::in</a> for more details. </p>

</div>
</div>
<a id="a2c6760aa739eab608779acf878a77545" name="a2c6760aa739eab608779acf878a77545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6760aa739eab608779acf878a77545">&#9670;&nbsp;</a></span>wrappers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &gt; &amp; Halide::Internal::Function::wrappers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48d0688e15931b714d92349570cb2ddc" name="a48d0688e15931b714d92349570cb2ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d0688e15931b714d92349570cb2ddc">&#9670;&nbsp;</a></span>is_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a> * Halide::Internal::Function::is_wrapper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> is a trivial wrapper around another <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a>, <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer.">Buffer</a>, or <a class="el" href="class_halide_1_1_internal_1_1_parameter.html" title="A reference-counted handle to a parameter to a halide pipeline.">Parameter</a>. </p>
<p >Returns the <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> node if it is. Otherwise returns null. </p>

</div>
</div>
<a id="a292b23ab8ef0f2a542c9bdee656cbdc3" name="a292b23ab8ef0f2a542c9bdee656cbdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292b23ab8ef0f2a542c9bdee656cbdc3">&#9670;&nbsp;</a></span>substitute_calls() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp; Halide::Internal::Function::substitute_calls </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a>, <a class="el" href="struct_halide_1_1_internal_1_1_function_ptr.html">FunctionPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>substitutions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace every call to Functions in 'substitutions' keys by all Exprs referenced in this <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> to call to their substitute Functions (i.e. </p>
<p >the corresponding values in 'substitutions' map). </p>

</div>
</div>
<a id="ad1ea151b49bf6240e52613f6f8c1d567" name="ad1ea151b49bf6240e52613f6f8c1d567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ea151b49bf6240e52613f6f8c1d567">&#9670;&nbsp;</a></span>substitute_calls() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp; Halide::Internal::Function::substitute_calls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>substitute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc581eb5326ca6ad00e39252b8167425" name="abc581eb5326ca6ad00e39252b8167425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc581eb5326ca6ad00e39252b8167425">&#9670;&nbsp;</a></span>is_pure_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Function::is_pure_arg </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true iff the name matches one of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a>'s pure args. </p>

</div>
</div>
<a id="a99e8bfc2390d4d745d1e3ca7de30f5b5" name="a99e8bfc2390d4d745d1e3ca7de30f5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e8bfc2390d4d745d1e3ca7de30f5b5">&#9670;&nbsp;</a></span>check_types() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::check_types </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> has type requirements, check that the given argument is compatible with them. </p>
<p >If not, assert-fail. (If there are no type requirements, do nothing.) </p>

</div>
</div>
<a id="ac0e9947994c28f3528980cf1d082480e" name="ac0e9947994c28f3528980cf1d082480e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e9947994c28f3528980cf1d082480e">&#9670;&nbsp;</a></span>check_types() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::check_types </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1828ab7689a2de2a9fae63137b013eb2" name="a1828ab7689a2de2a9fae63137b013eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1828ab7689a2de2a9fae63137b013eb2">&#9670;&nbsp;</a></span>check_types() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::check_types </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84024504b7308194b4d194c9d3c60579" name="a84024504b7308194b4d194c9d3c60579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84024504b7308194b4d194c9d3c60579">&#9670;&nbsp;</a></span>check_types() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::check_types </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exprs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfba9766837c36d181dcd2e6c3887947" name="adfba9766837c36d181dcd2e6c3887947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfba9766837c36d181dcd2e6c3887947">&#9670;&nbsp;</a></span>check_types() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::check_types </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54af8c744f95a7af1a80343e2b87083d" name="a54af8c744f95a7af1a80343e2b87083d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54af8c744f95a7af1a80343e2b87083d">&#9670;&nbsp;</a></span>check_dims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::check_dims </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> has dimension requirements, check that the given argument is compatible with them. </p>
<p >If not, assert-fail. (If there are no dimension requirements, do nothing.) </p>

</div>
</div>
<a id="a85d22cbb4bf7abe5ed3f988236b4c119" name="a85d22cbb4bf7abe5ed3f988236b4c119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d22cbb4bf7abe5ed3f988236b4c119">&#9670;&nbsp;</a></span>create_output_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Function::create_output_buffers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the output buffers. </p>
<p >If the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> has types specified, this can be called at any time. If not, it can only be called for a <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> with a pure definition. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_function_8h_source.html">Function.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li><li class="navelem"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
