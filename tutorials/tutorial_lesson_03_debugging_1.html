<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>
 Inspecting the generated code
</title>
<link rel="stylesheet" type="text/css" href="../assets/css/highlight.css">
<style>

a:visited {
color: #000000;
}

a:link {
color: #000000;
}

a:hover {
color: #aa0000;
}

</style>
</head>
<body class="hl" style="background-color: #444444; font-family: Helvetica, Arial, sans-serif;">
<script>
function toggle(id) {
    e = document.getElementById(id);
    show = document.getElementById(id + '-show');
    if (e.style.display != 'none') {
        e.style.display = 'none';
        show.innerHTML = "// Click to show output ...";
    } else {
        e.style.display = 'block';
        show.innerHTML = "// Click to hide output ...";
    }
    return false;
}
</script>
<div>
<style scoped>
@import "../assets/css/bootstrap.css";
</style>
<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="/index.html">Halide</a>
      <div class="nav-collapse">
        <ul class="nav">
          <li><a href="/index.html#gettingstarted">Getting Started</a></li>
          <li><a href="/tutorials/tutorial_introduction.html">Tutorials</a></li>
          <li><a href="/index.html#publications">Publications</a></li>
          <li><a href="/index.html#resources">Resources</a></li>
          <li class="divider-vertical"></li>
          <li><a href="/docs">Docs</a></li>
          <li><a href="http://github.com/halide/Halide/issues">Bugs</a></li>
          <li><a href="http://github.com/halide/Halide/wiki">Wiki</a></li>
          <li class="divider-vertical"></li>
          <li><a href="http://stackoverflow.com/questions/tagged/halide"><i class="fa fa-stack-overflow"></i>/#halide</a></li>
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>
</div>

<div style='position:relative; width:900pt; top:60px;'>
<div style="width:200px; float:left; ">
<a href="tutorial_introduction.html" style="text-decoration:none;" ><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px;
background-color: #dddddd; 
text-align: left; ">
<b>
00
&nbsp</b>
Introduction
</div>
</span>
</a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_01_basics.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
01
&nbsp</b>
 Getting started with Funcs, Vars, and Exprs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_02_input_image.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
02
&nbsp</b>
 Processing images
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_03_debugging_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; padding-right:40px; background-color: #ffffff; color: #000000; text-align: left; ">
<b>
03
&nbsp</b>
 Inspecting the generated code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_04_debugging_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
04
&nbsp</b>
 Debugging with tracing, print, and print_when
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_05_scheduling_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
05
&nbsp</b>
 Vectorize, parallelize, unroll and tile your code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_06_realizing_over_shifted_domains.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
06
&nbsp</b>
 Realizing Funcs over arbitrary domains
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_07_multi_stage_pipelines.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
07
&nbsp</b>
 Multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_08_scheduling_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
08
&nbsp</b>
 Scheduling multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_09_update_definitions.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
09
&nbsp</b>
 Multi-pass Funcs, update definitions, and reductions
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_11_cross_compilation.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
11
&nbsp</b>
 Cross-compilation
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_12_using_the_gpu.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
12
&nbsp</b>
 Using the GPU
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_13_tuples.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
13
&nbsp</b>
 Tuples
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_14_types.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
14
&nbsp</b>
 The Halide type system
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_15_generators.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
15
&nbsp</b>
 Generators part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_15_generators_usage.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
15
&nbsp</b>
 Generators part 2
</div></span></a>
</div>
<div style="position:relative; margin-left:260px; padding:20px; background-color: #ffffff;">
<pre class="hl">
<span class="hl slc">// Halide tutorial lesson 3: Inspecting the generated code</span>

<span class="hl slc">// This lesson demonstrates how to inspect what the Halide compiler is producing.</span>

<span class="hl slc">// On linux, you can compile and run it like so:</span>
<span class="hl slc">// g++ lesson_03*.cpp -g -I ../include -L ../bin -lHalide -lpthread -ldl -o lesson_03 -std=c++11</span>
<span class="hl slc">// LD_LIBRARY_PATH=../bin ./lesson_03</span>

<span class="hl slc">// On os x:</span>
<span class="hl slc">// g++ lesson_03*.cpp -g -I ../include -L ../bin -lHalide -o lesson_03 -std=c++11</span>
<span class="hl slc">// DYLD_LIBRARY_PATH=../bin ./lesson_03</span>

<span class="hl slc">// If you have the entire Halide source tree, you can also build it by</span>
<span class="hl slc">// running:</span>
<span class="hl slc">//    make tutorial_lesson_03_debugging_1</span>
<span class="hl slc">// in a shell with the current directory at the top of the halide</span>
<span class="hl slc">// source tree.</span>

<span class="hl ppc">#include</span> <span class="hl pps">&quot;Halide.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;stdio.h&gt;</span>

<span class="hl slc">// This time we'll just import the entire Halide namespace</span>
<span class="hl kwa">using namespace</span> Halide<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span> <span class="hl opt">**</span>argv<span class="hl opt">) {</span>

    <span class="hl slc">// We'll start by defining the simple single-stage imaging</span>
    <span class="hl slc">// pipeline from lesson 1.</span>

    <span class="hl slc">// This lesson will be about debugging, but unfortunately in C++,</span>
    <span class="hl slc">// objects don't know their own names, which makes it hard for us</span>
    <span class="hl slc">// to understand the generated code. To get around this, you can</span>
    <span class="hl slc">// pass a string to the Func and Var constructors to give them a</span>
    <span class="hl slc">// name for debugging purposes.</span>
    Func <span class="hl kwd">gradient</span><span class="hl opt">(</span><span class="hl str">&quot;gradient&quot;</span><span class="hl opt">);</span>
    Var <span class="hl kwd">x</span><span class="hl opt">(</span><span class="hl str">&quot;x&quot;</span><span class="hl opt">),</span> <span class="hl kwd">y</span><span class="hl opt">(</span><span class="hl str">&quot;y&quot;</span><span class="hl opt">);</span>
    <span class="hl kwd">gradient</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> x <span class="hl opt">+</span> y<span class="hl opt">;</span>

    <span class="hl slc">// Realize the function to produce an output image. We'll keep it</span>
    <span class="hl slc">// very small for this lesson.</span>
    Image<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> output <span class="hl opt">=</span> gradient<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">,</span> <span class="hl num">8</span><span class="hl opt">);</span>

    <span class="hl slc">// That line compiled and ran the pipeline. Try running this</span>
    
    <span class="hl slc">// 1. It will print out the various stages of compilation, and a</span>
    <span class="hl slc">// pseudocode representation of the final pipeline.</span>
    <a onclick='return toggle("_44");'><b id=_44-show>// Click to show output ...</b></a><div id=_44 style= "display:none; background:#333333; color:#ffffff"><b>
 > Inferred argument: handle64 __user_context
 > Creating initial loop nests...
 > Injecting realization of gradient
 > Skipping injecting memoization...
 > Injecting tracing...
 > Adding checks for parameters
 > Computing bounds of each function's value
 > Adding checks for images
 > Performing computation bounds inference...
 > Performing sliding window optimization...
 > Performing allocation bounds inference...
 > Removing code that depends on undef values...
 > Uniquifying variable names...
 > Performing storage folding optimization...
 > Injecting debug_to_file calls...
 > Simplifying...
 > Dynamically skipping stages...
 > Performing storage flattening...
 > Skipping rewriting memoized allocations...
 > Simplifying...
 > Unrolling...
 > Vectorizing...
 > Detecting vector interleavings...
 > Partitioning loops to simplify boundary conditions...
 > Injecting early frees...
 > Simplifying...
 > Lowering after final simplification:
 > if (gradient.host_and_dev_are_null) {
 >   rewrite_buffer(gradient.buffer, 4, gradient.min.0, gradient.extent.0, 1, gradient.min.1, gradient.extent.1, gradient.extent.0)
 > }
 > if (!gradient.host_and_dev_are_null) {
 >   assert((gradient.elem_size == 4), halide_error_bad_elem_size("Output buffer gradient", "int32", gradient.elem_size, 4))
 >   assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
 >   let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
 >   assert((int64(gradient.extent.0) <= int64(2147483647)), halide_error_buffer_allocation_too_large("gradient", int64(gradient.extent.0), int64(2147483647)))
 >   assert(((int64(gradient.extent.1)*int64(gradient.stride.1)) <= int64(2147483647)), halide_error_buffer_allocation_too_large("gradient", (int64(gradient.extent.1)*int64(gradient.stride.1)), int64(2147483647)))
 >   assert((gradient.total_extent.1 <= int64(2147483647)), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, int64(2147483647)))
 >   produce gradient {
 >     for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
 >       for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
 >         gradient[((gradient.s0.x + (gradient.s0.y*gradient.stride.1)) - (gradient.min.0 + (gradient.min.1*gradient.stride.1)))] = (gradient.s0.x + gradient.s0.y)
 >       }
 >     }
 >   }
 >   0
 > }
 > Inferred argument: handle64 __user_context
 > Target triple of initial module: x86_64--linux-gnu
 > Generating llvm bitcode...
 > Generating llvm bitcode for function __gradient...
 > Generating llvm bitcode for function gradient...
 > JIT compiling shared runtime
 > JIT compiling halide_module_gradient
 > JIT input scalar argument __user_context @ 0x1ccd4b0
 > JIT output buffer b0 @ 0x1c90da0
 > Creating initial loop nests...
 > Injecting realization of gradient
 > Skipping injecting memoization...
 > Injecting tracing...
 > Adding checks for parameters
 > Computing bounds of each function's value
 > Adding checks for images
 > Performing computation bounds inference...
 > Performing sliding window optimization...
 > Performing allocation bounds inference...
 > Removing code that depends on undef values...
 > Uniquifying variable names...
 > Performing storage folding optimization...
 > Injecting debug_to_file calls...
 > Simplifying...
 > Dynamically skipping stages...
 > Performing storage flattening...
 > Skipping rewriting memoized allocations...
 > Simplifying...
 > Unrolling...
 > Vectorizing...
 > Detecting vector interleavings...
 > Partitioning loops to simplify boundary conditions...
 > Injecting early frees...
 > Simplifying...
 > Lowering after final simplification:
 > if (gradient.host_and_dev_are_null) {
 >   rewrite_buffer(gradient.buffer, 4, gradient.min.0, gradient.extent.0, 1, gradient.min.1, gradient.extent.1, gradient.extent.0)
 > }
 > if (!gradient.host_and_dev_are_null) {
 >   assert((gradient.elem_size == 4), halide_error_bad_elem_size("Output buffer gradient", "int32", gradient.elem_size, 4))
 >   assert((gradient.stride.0 == 1), halide_error_constraint_violated("gradient.stride.0", gradient.stride.0, "1", 1))
 >   let gradient.total_extent.1 = (int64(gradient.extent.1)*int64(gradient.extent.0))
 >   assert((int64(gradient.extent.0) <= int64(2147483647)), halide_error_buffer_allocation_too_large("gradient", int64(gradient.extent.0), int64(2147483647)))
 >   assert(((int64(gradient.extent.1)*int64(gradient.stride.1)) <= int64(2147483647)), halide_error_buffer_allocation_too_large("gradient", (int64(gradient.extent.1)*int64(gradient.stride.1)), int64(2147483647)))
 >   assert((gradient.total_extent.1 <= int64(2147483647)), halide_error_buffer_extents_too_large("gradient", gradient.total_extent.1, int64(2147483647)))
 >   produce gradient {
 >     for (gradient.s0.y, gradient.min.1, gradient.extent.1) {
 >       for (gradient.s0.x, gradient.min.0, gradient.extent.0) {
 >         gradient[((gradient.s0.x + (gradient.s0.y*gradient.stride.1)) - (gradient.min.0 + (gradient.min.1*gradient.stride.1)))] = (gradient.s0.x + gradient.s0.y)
 >       }
 >     }
 >   }
 >   0
 > }
 > Inferred argument: handle64 __user_context

</b></div>

    <span class="hl slc">// If you set HL_DEBUG_CODEGEN to a higher number, you can see</span>
    <span class="hl slc">// more and more details of how Halide compiles your pipeline.</span>
    <span class="hl slc">// Setting HL_DEBUG_CODEGEN=2 shows the Halide code at each stage</span>
    <span class="hl slc">// of compilation, and also the llvm bitcode we generate at the</span>
    <span class="hl slc">// end.</span>

    
    <span class="hl slc">// code that implements the Halide pipeline. It can't compile</span>
    <span class="hl slc">// as-is without you also implementing some support functions, but</span>
    <span class="hl slc">// it can be helpful for understanding what the Halide pipeline is</span>
    <span class="hl slc">// doing. You pass it the name of the file, a list of arguments</span>
    <span class="hl slc">// the generated function should take (none in this case), and the</span>
    <span class="hl slc">// name of the generated function. Have a look inside gradient.cpp</span>
    <span class="hl slc">// after compiling and running this lesson.</span>
    gradient<span class="hl opt">.</span><span class="hl kwd">compile_to_c</span><span class="hl opt">(</span><span class="hl str">&quot;gradient.cpp&quot;</span><span class="hl opt">,</span> std<span class="hl opt">::</span>vector<span class="hl opt">&lt;</span>Argument<span class="hl opt">&gt;(),</span> <span class="hl str">&quot;gradient&quot;</span><span class="hl opt">);</span>
    <a onclick='return toggle("_54");'><b id=_54-show>// Click to show output ...</b></a><div id=_54 style= "display:none; background:#333333; color:#ffffff"><b>
 > #include <iostream>
 > #include <math.h>
 > #include <float.h>
 > #include <assert.h>
 > #include <string.h>
 > #include <stdio.h>
 > #include <stdint.h>
 > #ifndef HALIDE_ATTRIBUTE_ALIGN
 >   #ifdef _MSC_VER
 >     #define HALIDE_ATTRIBUTE_ALIGN(x) __declspec(align(x))
 >   #else
 >     #define HALIDE_ATTRIBUTE_ALIGN(x) __attribute__((aligned(x)))
 >   #endif
 > #endif
 > #ifndef BUFFER_T_DEFINED
 > #define BUFFER_T_DEFINED
 > #include <stdint.h>
 > typedef struct buffer_t {
 >     uint64_t dev;
 >     uint8_t* host;
 >     int32_t extent[4];
 >     int32_t stride[4];
 >     int32_t min[4];
 >     int32_t elem_size;
 >     HALIDE_ATTRIBUTE_ALIGN(1) bool host_dirty;
 >     HALIDE_ATTRIBUTE_ALIGN(1) bool dev_dirty;
 >     HALIDE_ATTRIBUTE_ALIGN(1) uint8_t _padding[10 - sizeof(void *)];
 > } buffer_t;
 > #endif
 > struct halide_filter_metadata_t;
 > extern "C" {
 > void *halide_malloc(void *ctx, size_t);
 > void halide_free(void *ctx, void *ptr);
 > void *halide_print(void *ctx, const void *str);
 > void *halide_error(void *ctx, const void *str);
 > int halide_debug_to_file(void *ctx, const char *filename, void *data, int, int, int, int, int, int);
 > int halide_start_clock(void *ctx);
 > int64_t halide_current_time_ns(void *ctx);
 > void halide_profiler_pipeline_end(void *, void *);
 > }
 > #ifdef _WIN32
 > float roundf(float);
 > double round(double);
 > #else
 > inline float asinh_f32(float x) {return asinhf(x);}
 > inline float acosh_f32(float x) {return acoshf(x);}
 > inline float atanh_f32(float x) {return atanhf(x);}
 > inline double asinh_f64(double x) {return asinh(x);}
 > inline double acosh_f64(double x) {return acosh(x);}
 > inline double atanh_f64(double x) {return atanh(x);}
 > #endif
 > inline float sqrt_f32(float x) {return sqrtf(x);}
 > inline float sin_f32(float x) {return sinf(x);}
 > inline float asin_f32(float x) {return asinf(x);}
 > inline float cos_f32(float x) {return cosf(x);}
 > inline float acos_f32(float x) {return acosf(x);}
 > inline float tan_f32(float x) {return tanf(x);}
 > inline float atan_f32(float x) {return atanf(x);}
 > inline float sinh_f32(float x) {return sinhf(x);}
 > inline float cosh_f32(float x) {return coshf(x);}
 > inline float tanh_f32(float x) {return tanhf(x);}
 > inline float hypot_f32(float x, float y) {return hypotf(x, y);}
 > inline float exp_f32(float x) {return expf(x);}
 > inline float log_f32(float x) {return logf(x);}
 > inline float pow_f32(float x, float y) {return powf(x, y);}
 > inline float floor_f32(float x) {return floorf(x);}
 > inline float ceil_f32(float x) {return ceilf(x);}
 > inline float round_f32(float x) {return roundf(x);}
 > inline double sqrt_f64(double x) {return sqrt(x);}
 > inline double sin_f64(double x) {return sin(x);}
 > inline double asin_f64(double x) {return asin(x);}
 > inline double cos_f64(double x) {return cos(x);}
 > inline double acos_f64(double x) {return acos(x);}
 > inline double tan_f64(double x) {return tan(x);}
 > inline double atan_f64(double x) {return atan(x);}
 > inline double sinh_f64(double x) {return sinh(x);}
 > inline double cosh_f64(double x) {return cosh(x);}
 > inline double tanh_f64(double x) {return tanh(x);}
 > inline double hypot_f64(double x, double y) {return hypot(x, y);}
 > inline double exp_f64(double x) {return exp(x);}
 > inline double log_f64(double x) {return log(x);}
 > inline double pow_f64(double x, double y) {return pow(x, y);}
 > inline double floor_f64(double x) {return floor(x);}
 > inline double ceil_f64(double x) {return ceil(x);}
 > inline double round_f64(double x) {return round(x);}
 > inline float maxval_f32() {return FLT_MAX;}
 > inline float minval_f32() {return -FLT_MAX;}
 > inline double maxval_f64() {return DBL_MAX;}
 > inline double minval_f64() {return -DBL_MAX;}
 > inline uint8_t maxval_u8() {return 0xff;}
 > inline uint8_t minval_u8() {return 0;}
 > inline uint16_t maxval_u16() {return 0xffff;}
 > inline uint16_t minval_u16() {return 0;}
 > inline uint32_t maxval_u32() {return 0xffffffff;}
 > inline uint32_t minval_u32() {return 0;}
 > inline uint64_t maxval_u64() {return 0xffffffffffffffff;}
 > inline uint64_t minval_u64() {return 0;}
 > inline int8_t maxval_s8() {return 0x7f;}
 > inline int8_t minval_s8() {return 0x80;}
 > inline int16_t maxval_s16() {return 0x7fff;}
 > inline int16_t minval_s16() {return 0x8000;}
 > inline int32_t maxval_s32() {return 0x7fffffff;}
 > inline int32_t minval_s32() {return 0x80000000;}
 > inline int64_t maxval_s64() {return 0x7fffffffffffffff;}
 > inline int64_t minval_s64() {return 0x8000000000000000;}
 > inline int8_t abs_i8(int8_t a) {return a >= 0 ? a : -a;}
 > inline int16_t abs_i16(int16_t a) {return a >= 0 ? a : -a;}
 > inline int32_t abs_i32(int32_t a) {return a >= 0 ? a : -a;}
 > inline int64_t abs_i64(int64_t a) {return a >= 0 ? a : -a;}
 > inline float abs_f32(float a) {return fabsf(a);}
 > inline double abs_f64(double a) {return fabs(a);}
 > inline float nan_f32() {return NAN;}
 > inline float neg_inf_f32() {return -INFINITY;}
 > inline float inf_f32() {return INFINITY;}
 > inline bool is_nan_f32(float x) {return x != x;}
 > inline bool is_nan_f64(double x) {return x != x;}
 > inline float float_from_bits(uint32_t bits) {
 >  union {
 >   uint32_t as_uint;
 >   float as_float;
 >  } u;
 >  u.as_uint = bits;
 >  return u.as_float;
 > }
 > inline int64_t make_int64(int32_t hi, int32_t lo) {
 >     return (((int64_t)hi) << 32) | (uint32_t)lo;
 > }
 > inline double make_float64(int32_t i0, int32_t i1) {
 >     union {
 >         int32_t as_int32[2];
 >         double as_double;
 >     } u;
 >     u.as_int32[0] = i0;
 >     u.as_int32[1] = i1;
 >     return u.as_double;
 > }
 > template<typename T> T max(T a, T b) {if (a > b) return a; return b;}
 > template<typename T> T min(T a, T b) {if (a < b) return a; return b;}
 > template<typename T> T smod(T a, T b) {T result = a % b; if (result < 0) result += b < 0 ? -b : b; return result;}
 > template<typename T> T sdiv(T a, T b) {T q = a / b; T r = a - q*b; int bs = b >> (8*sizeof(T) - 1); int rs = r >> (8*sizeof(T) - 1); return q - (rs & bs) + (rs & ~bs);}
 > template<typename A, typename B> A reinterpret(B b) {A a; memcpy(&a, &b, sizeof(a)); return a;}
 > static bool halide_rewrite_buffer(buffer_t *b, int32_t elem_size,
 >                            int32_t min0, int32_t extent0, int32_t stride0,
 >                            int32_t min1, int32_t extent1, int32_t stride1,
 >                            int32_t min2, int32_t extent2, int32_t stride2,
 >                            int32_t min3, int32_t extent3, int32_t stride3) {
 >  b->min[0] = min0;
 >  b->min[1] = min1;
 >  b->min[2] = min2;
 >  b->min[3] = min3;
 >  b->extent[0] = extent0;
 >  b->extent[1] = extent1;
 >  b->extent[2] = extent2;
 >  b->extent[3] = extent3;
 >  b->stride[0] = stride0;
 >  b->stride[1] = stride1;
 >  b->stride[2] = stride2;
 >  b->stride[3] = stride3;
 >  return true;
 > }
 > #ifndef HALIDE_FUNCTION_ATTRS
 > #define HALIDE_FUNCTION_ATTRS
 > #endif
 > #ifdef __cplusplus
 > extern "C" {
 > #endif
 > int32_t halide_error_bad_elem_size(void *, const char *, const char *, int32_t, int32_t);
 > int32_t halide_error_constraint_violated(void *, const char *, int32_t, const char *, int32_t);
 > int32_t halide_error_buffer_allocation_too_large(void *, const char *, int64_t, int64_t);
 > int32_t halide_error_buffer_extents_too_large(void *, const char *, int64_t, int64_t);
 > static int __gradient(buffer_t *_gradient_buffer) HALIDE_FUNCTION_ATTRS {
 >  int32_t *_gradient = (int32_t *)(_gradient_buffer->host);
 >  (void)_gradient;
 >  const bool _gradient_host_and_dev_are_null = (_gradient_buffer->host == NULL) && (_gradient_buffer->dev == 0);
 >  (void)_gradient_host_and_dev_are_null;
 >  const int32_t _gradient_min_0 = _gradient_buffer->min[0];
 >  (void)_gradient_min_0;
 >  const int32_t _gradient_min_1 = _gradient_buffer->min[1];
 >  (void)_gradient_min_1;
 >  const int32_t _gradient_min_2 = _gradient_buffer->min[2];
 >  (void)_gradient_min_2;
 >  const int32_t _gradient_min_3 = _gradient_buffer->min[3];
 >  (void)_gradient_min_3;
 >  const int32_t _gradient_extent_0 = _gradient_buffer->extent[0];
 >  (void)_gradient_extent_0;
 >  const int32_t _gradient_extent_1 = _gradient_buffer->extent[1];
 >  (void)_gradient_extent_1;
 >  const int32_t _gradient_extent_2 = _gradient_buffer->extent[2];
 >  (void)_gradient_extent_2;
 >  const int32_t _gradient_extent_3 = _gradient_buffer->extent[3];
 >  (void)_gradient_extent_3;
 >  const int32_t _gradient_stride_0 = _gradient_buffer->stride[0];
 >  (void)_gradient_stride_0;
 >  const int32_t _gradient_stride_1 = _gradient_buffer->stride[1];
 >  (void)_gradient_stride_1;
 >  const int32_t _gradient_stride_2 = _gradient_buffer->stride[2];
 >  (void)_gradient_stride_2;
 >  const int32_t _gradient_stride_3 = _gradient_buffer->stride[3];
 >  (void)_gradient_stride_3;
 >  const int32_t _gradient_elem_size = _gradient_buffer->elem_size;
 >  (void)_gradient_elem_size;
 >  if (_gradient_host_and_dev_are_null)
 >  {
 >   bool _0 = halide_rewrite_buffer(_gradient_buffer, 4, _gradient_min_0, _gradient_extent_0, 1, _gradient_min_1, _gradient_extent_1, _gradient_extent_0, 0, 0, 0, 0, 0, 0);
 >   (void)_0;
 >  } // if _gradient_host_and_dev_are_null
 >  bool _1 = !(_gradient_host_and_dev_are_null);
 >  if (_1)
 >  {
 >   bool _2 = _gradient_elem_size == 4;
 >   if (!_2)   {
 >    int32_t _3 = halide_error_bad_elem_size(NULL, "Output buffer gradient", "int32", _gradient_elem_size, 4);
 >    return _3;
 >   }
 >   bool _4 = _gradient_stride_0 == 1;
 >   if (!_4)   {
 >    int32_t _5 = halide_error_constraint_violated(NULL, "gradient.stride.0", _gradient_stride_0, "1", 1);
 >    return _5;
 >   }
 >   int64_t _6 = (int64_t)(_gradient_extent_1);
 >   int64_t _7 = (int64_t)(_gradient_extent_0);
 >   int64_t _8 = _6 * _7;
 >   int64_t _9 = (int64_t)(2147483647);
 >   bool _10 = _7 <= _9;
 >   if (!_10)   {
 >    int64_t _11 = (int64_t)(_gradient_extent_0);
 >    int64_t _12 = (int64_t)(2147483647);
 >    int32_t _13 = halide_error_buffer_allocation_too_large(NULL, "gradient", _11, _12);
 >    return _13;
 >   }
 >   int64_t _14 = (int64_t)(_gradient_extent_1);
 >   int64_t _15 = (int64_t)(_gradient_stride_1);
 >   int64_t _16 = _14 * _15;
 >   int64_t _17 = (int64_t)(2147483647);
 >   bool _18 = _16 <= _17;
 >   if (!_18)   {
 >    int64_t _19 = (int64_t)(_gradient_extent_1);
 >    int64_t _20 = (int64_t)(_gradient_stride_1);
 >    int64_t _21 = _19 * _20;
 >    int64_t _22 = (int64_t)(2147483647);
 >    int32_t _23 = halide_error_buffer_allocation_too_large(NULL, "gradient", _21, _22);
 >    return _23;
 >   }
 >   int64_t _24 = (int64_t)(2147483647);
 >   bool _25 = _8 <= _24;
 >   if (!_25)   {
 >    int64_t _26 = (int64_t)(2147483647);
 >    int32_t _27 = halide_error_buffer_extents_too_large(NULL, "gradient", _8, _26);
 >    return _27;
 >   }
 >   // produce gradient
 >   for (int _gradient_s0_y = _gradient_min_1; _gradient_s0_y < _gradient_min_1 + _gradient_extent_1; _gradient_s0_y++)
 >   {
 >    for (int _gradient_s0_x = _gradient_min_0; _gradient_s0_x < _gradient_min_0 + _gradient_extent_0; _gradient_s0_x++)
 >    {
 >     int32_t _28 = _gradient_s0_y * _gradient_stride_1;
 >     int32_t _29 = _gradient_s0_x + _28;
 >     int32_t _30 = _gradient_min_1 * _gradient_stride_1;
 >     int32_t _31 = _gradient_min_0 + _30;
 >     int32_t _32 = _29 - _31;
 >     int32_t _33 = _gradient_s0_x + _gradient_s0_y;
 >     _gradient[_32] = _33;
 >    } // for _gradient_s0_x
 >   } // for _gradient_s0_y
 >   // consume gradient
 >  } // if _1
 >  return 0;
 > }
 > int gradient(buffer_t *_gradient_buffer) HALIDE_FUNCTION_ATTRS {
 >  int32_t *_gradient = (int32_t *)(_gradient_buffer->host);
 >  (void)_gradient;
 >  const bool _gradient_host_and_dev_are_null = (_gradient_buffer->host == NULL) && (_gradient_buffer->dev == 0);
 >  (void)_gradient_host_and_dev_are_null;
 >  const int32_t _gradient_min_0 = _gradient_buffer->min[0];
 >  (void)_gradient_min_0;
 >  const int32_t _gradient_min_1 = _gradient_buffer->min[1];
 >  (void)_gradient_min_1;
 >  const int32_t _gradient_min_2 = _gradient_buffer->min[2];
 >  (void)_gradient_min_2;
 >  const int32_t _gradient_min_3 = _gradient_buffer->min[3];
 >  (void)_gradient_min_3;
 >  const int32_t _gradient_extent_0 = _gradient_buffer->extent[0];
 >  (void)_gradient_extent_0;
 >  const int32_t _gradient_extent_1 = _gradient_buffer->extent[1];
 >  (void)_gradient_extent_1;
 >  const int32_t _gradient_extent_2 = _gradient_buffer->extent[2];
 >  (void)_gradient_extent_2;
 >  const int32_t _gradient_extent_3 = _gradient_buffer->extent[3];
 >  (void)_gradient_extent_3;
 >  const int32_t _gradient_stride_0 = _gradient_buffer->stride[0];
 >  (void)_gradient_stride_0;
 >  const int32_t _gradient_stride_1 = _gradient_buffer->stride[1];
 >  (void)_gradient_stride_1;
 >  const int32_t _gradient_stride_2 = _gradient_buffer->stride[2];
 >  (void)_gradient_stride_2;
 >  const int32_t _gradient_stride_3 = _gradient_buffer->stride[3];
 >  (void)_gradient_stride_3;
 >  const int32_t _gradient_elem_size = _gradient_buffer->elem_size;
 >  (void)_gradient_elem_size;
 >  int32_t _34 = __gradient(_gradient_buffer);
 >  bool _35 = _34 == 0;
 >  if (!_35)  {
 >   return _34;
 >  }
 >  return 0;
 > }
 > #ifdef __cplusplus
 > }  // extern "C"
 > #endif

</b></div>

    <span class="hl slc">// Using these two tricks -- setting HL_DEBUG_CODEGEN and calling</span>
    <span class="hl slc">// compile_to_c -- you can usually figure out what code Halide is</span>
    <span class="hl slc">// generating. In the next lesson we'll see how to snoop on Halide</span>
    <span class="hl slc">// at runtime.</span>

    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Success!</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre>
</div></body></html>
