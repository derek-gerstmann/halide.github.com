<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>
 Multi-pass Funcs, update definitions, and reductions
</title>
<link rel="stylesheet" type="text/css" href="../assets/css/highlight.css">
<style>

a:visited {
color: #000000;
}

a:link {
color: #000000;
}

a:hover {
color: #aa0000;
}

</style>
</head>
<body class="hl" style="background-color: #444444; font-family: Helvetica, Arial, sans-serif;">
<script>
function toggle(id) {
    e = document.getElementById(id);
    show = document.getElementById(id + '-show');
    if (e.style.display != 'none') {
        e.style.display = 'none';
        show.innerHTML = "// Click to show output ...";
    } else {
        e.style.display = 'block';
        show.innerHTML = "// Click to hide output ...";
    }
    return false;
}
</script>
<div>
<style scoped>
@import "../assets/css/bootstrap.css";
</style>
<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="/index.html">Halide</a>
      <div class="nav-collapse">
        <ul class="nav">
          <li><a href="/index.html#gettingstarted">Getting Started</a></li>
          <li><a href="/tutorials/tutorial_introduction.html">Tutorials</a></li>
          <li><a href="/index.html#publications">Publications</a></li>
          <li><a href="/index.html#resources">Resources</a></li>
          <li class="divider-vertical"></li>
          <li><a href="/docs">Docs</a></li>
          <li><a href="http://github.com/halide/Halide/issues">Bugs</a></li>
          <li><a href="http://github.com/halide/Halide/wiki">Wiki</a></li>
          <li class="divider-vertical"></li>
          <li><a href="http://stackoverflow.com/questions/tagged/halide"><i class="fa fa-stack-overflow"></i>/#halide</a></li>
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>
</div>

<div style='position:relative; width:900pt; top:60px;'>
<div style="width:200px; float:left; ">
<a href="tutorial_introduction.html" style="text-decoration:none;" ><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px;
background-color: #dddddd; 
text-align: left; ">
<b>
00
&nbsp</b>
Introduction
</div>
</span>
</a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_01_basics.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
01
&nbsp</b>
 Getting started with Funcs, Vars, and Exprs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_02_input_image.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
02
&nbsp</b>
 Processing images
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_03_debugging_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
03
&nbsp</b>
 Inspecting the generated code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_04_debugging_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
04
&nbsp</b>
 Debugging with tracing, print, and print_when
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_05_scheduling_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
05
&nbsp</b>
 Vectorize, parallelize, unroll and tile your code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_06_realizing_over_shifted_domains.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
06
&nbsp</b>
 Realizing Funcs over arbitrary domains
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_07_multi_stage_pipelines.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
07
&nbsp</b>
 Multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_08_scheduling_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
08
&nbsp</b>
 Scheduling multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_09_update_definitions.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; padding-right:40px; background-color: #ffffff; color: #000000; text-align: left; ">
<b>
09
&nbsp</b>
 Multi-pass Funcs, update definitions, and reductions
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_11_cross_compilation.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
11
&nbsp</b>
 Cross-compilation
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_12_using_the_gpu.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
12
&nbsp</b>
 Using the GPU
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_13_tuples.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
13
&nbsp</b>
 Tuples
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_14_types.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
14
&nbsp</b>
 The Halide type system
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_15_generators.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
15
&nbsp</b>
 Generators part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_16_rgb_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
16
&nbsp</b>
 RGB images and memory layouts part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_16_rgb_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
16
&nbsp</b>
 RGB images and memory layouts part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_17_predicated_rdom.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
17
&nbsp</b>
 Reductions over non-rectangular domains
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_18_parallel_associative_reductions.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
18
&nbsp</b>
 Factoring an associative reduction using rfactor
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_19_wrapper_funcs.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
19
&nbsp</b>
 Wrapper Funcs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_20_cloning_funcs.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
20
&nbsp</b>
 Cloning Funcs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_21_auto_scheduler_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
21
&nbsp</b>
 Auto-Scheduler
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_21_auto_scheduler_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
21
&nbsp</b>
 Auto-Scheduler
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_15_generators_usage.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
15
&nbsp</b>
 Generators part 2
</div></span></a>
</div>
<div style="position:relative; margin-left:260px; padding:20px; background-color: #ffffff;">
<pre class="hl">
<span class="hl slc">// Halide tutorial lesson 9: Multi-pass Funcs, update definitions, and reductions</span>

<span class="hl slc">// On linux, you can compile and run it like so:</span>
<span class="hl slc">// g++ lesson_09*.cpp -g -std=c++11 -I ../include -I ../tools -L ../bin -lHalide `libpng-config --cflags --ldflags` -ljpeg -lpthread -ldl -fopenmp -o lesson_09</span>
<span class="hl slc">// LD_LIBRARY_PATH=../bin ./lesson_09</span>

<span class="hl slc">// On os x (will only work if you actually have g++, not Apple's pretend g++ which is actually clang):</span>
<span class="hl slc">// g++ lesson_09*.cpp -g -std=c++11 -I ../include -I ../tools -L ../bin -lHalide `libpng-config --cflags --ldflags` -ljpeg -fopenmp -o lesson_09</span>
<span class="hl slc">// DYLD_LIBRARY_PATH=../bin ./lesson_09</span>

<span class="hl slc">// If you have the entire Halide source tree, you can also build it by</span>
<span class="hl slc">// running:</span>
<span class="hl slc">//    make tutorial_lesson_09_update_definitions</span>
<span class="hl slc">// in a shell with the current directory at the top of the halide</span>
<span class="hl slc">// source tree.</span>

<span class="hl ppc">#include</span> <span class="hl pps">&quot;Halide.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;stdio.h&gt;</span>

<span class="hl slc">// We're going to be using x86 SSE intrinsics later on in this lesson.</span>
<span class="hl ppc">#ifdef __SSE2__</span>
<span class="hl ppc">#include &lt;emmintrin.h&gt;</span>
<span class="hl ppc">#endif</span>

<span class="hl slc">// We'll also need a clock to do performance testing at the end.</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;clock.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwa">using namespace</span> Halide<span class="hl opt">;</span>

<span class="hl slc">// Support code for loading pngs.</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;halide_image_io.h&quot;</span><span class="hl ppc"></span>
<span class="hl kwa">using namespace</span> Halide<span class="hl opt">::</span>Tools<span class="hl opt">;</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span> <span class="hl opt">**</span>argv<span class="hl opt">) {</span>
    <span class="hl slc">// Declare some Vars to use below.</span>
    Var <span class="hl kwd">x</span><span class="hl opt">(</span><span class="hl str">&quot;x&quot;</span><span class="hl opt">),</span> <span class="hl kwd">y</span><span class="hl opt">(</span><span class="hl str">&quot;y&quot;</span><span class="hl opt">);</span>

    <span class="hl slc">// Load a grayscale image to use as an input.</span>
    Buffer<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;</span> input <span class="hl opt">=</span> <span class="hl kwd">load_image</span><span class="hl opt">(</span><span class="hl str">&quot;images/gray.png&quot;</span><span class="hl opt">);</span>

    <span class="hl slc">// You can define a Func in multiple passes. Let's see a toy</span>
    <span class="hl slc">// example first.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// The first definition must be one like we have seen already</span>
        <span class="hl slc">// - a mapping from Vars to an Expr:</span>
        Func f<span class="hl opt">;</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> x <span class="hl opt">+</span> y<span class="hl opt">;</span>
        <span class="hl slc">// We call this first definition the &quot;pure&quot; definition.</span>

        <span class="hl slc">// But the later definitions can include computed expressions on</span>
        <span class="hl slc">// both sides. The simplest example is modifying a single point:</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">,</span> <span class="hl num">7</span><span class="hl opt">) =</span> <span class="hl num">42</span><span class="hl opt">;</span>

        <span class="hl slc">// We call these extra definitions &quot;update&quot; definitions, or</span>
        <span class="hl slc">// &quot;reduction&quot; definitions. A reduction definition is an</span>
        <span class="hl slc">// update definition that recursively refers back to the</span>
        <span class="hl slc">// function's current value at the same site:</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) +</span> <span class="hl num">17</span><span class="hl opt">;</span>

        <span class="hl slc">// If we confine our update to a single row, we can</span>
        <span class="hl slc">// recursively refer to values in the same column:</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">) =</span> <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">) *</span> <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">10</span><span class="hl opt">);</span>

        <span class="hl slc">// Similarly, if we confine our update to a single column, we</span>
        <span class="hl slc">// can recursively refer to other values in the same row.</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> y<span class="hl opt">) =</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> y<span class="hl opt">) /</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">,</span> y<span class="hl opt">);</span>

        <span class="hl slc">// The general rule is: Each Var used in an update definition</span>
        <span class="hl slc">// must appear unadorned in the same position as in the pure</span>
        <span class="hl slc">// definition in all references to the function on the left-</span>
        <span class="hl slc">// and right-hand sides. So the following definitions are</span>
        <span class="hl slc">// legal updates:</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">17</span><span class="hl opt">) =</span> x <span class="hl opt">+</span> <span class="hl num">8</span><span class="hl opt">;</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> y<span class="hl opt">) =</span> y <span class="hl opt">*</span> <span class="hl num">8</span><span class="hl opt">;</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> x <span class="hl opt">+</span> <span class="hl num">1</span><span class="hl opt">) =</span> x <span class="hl opt">+</span> <span class="hl num">8</span><span class="hl opt">;</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span>y<span class="hl opt">/</span><span class="hl num">2</span><span class="hl opt">,</span> y<span class="hl opt">) =</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> y<span class="hl opt">) *</span> <span class="hl num">17</span><span class="hl opt">;</span>

        <span class="hl slc">// But these ones would cause an error:</span>

        <span class="hl slc">// f(x, 0) = f(x + 1, 0);</span>
        <span class="hl slc">// First argument to f on the right-hand-side must be 'x', not 'x + 1'.</span>

        <span class="hl slc">// f(y, y + 1) = y + 8;</span>
        <span class="hl slc">// Second argument to f on the left-hand-side must be 'y', not 'y + 1'.</span>

        <span class="hl slc">// f(y, x) = y - x;</span>
        <span class="hl slc">// Arguments to f on the left-hand-side are in the wrong places.</span>

        <span class="hl slc">// f(3, 4) = x + y;</span>
        <span class="hl slc">// Free variables appear on the right-hand-side but not the left-hand-side.</span>

        <span class="hl slc">// We'll realize this one just to make sure it compiles. The</span>
        <span class="hl slc">// second-to-last definition forces us to realize over a</span>
        <span class="hl slc">// domain that is taller than it is wide.</span>
        f<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">,</span> <span class="hl num">101</span><span class="hl opt">);</span>

        <span class="hl slc">// For each realization of f, each step runs in its entirety</span>
        <span class="hl slc">// before the next one begins. Let's trace the loads and</span>
        <span class="hl slc">// stores for a simpler example:</span>
        Func <span class="hl kwd">g</span><span class="hl opt">(</span><span class="hl str">&quot;g&quot;</span><span class="hl opt">);</span>
        <span class="hl kwd">g</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> x <span class="hl opt">+</span> y<span class="hl opt">;</span>   <span class="hl slc">// Pure definition</span>
        <span class="hl kwd">g</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">) =</span> <span class="hl num">42</span><span class="hl opt">;</span>      <span class="hl slc">// First update definition</span>
        <span class="hl kwd">g</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">) =</span> <span class="hl kwd">g</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// Second update definition</span>

        g<span class="hl opt">.</span><span class="hl kwd">trace_loads</span><span class="hl opt">();</span>
        g<span class="hl opt">.</span><span class="hl kwd">trace_stores</span><span class="hl opt">();</span>

        g<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">4</span><span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">);</span>
        <a onclick='return toggle("_108");'><b id=_108-show>// Click to show output ...</b></a><div id=_108 style= "display:none; background:#333333; color:#ffffff"><b>
 > Begin pipeline g.0()
 > Store g.0(0, 0) = 0
 > Store g.0(1, 0) = 1
 > Store g.0(2, 0) = 2
 > Store g.0(3, 0) = 3
 > Store g.0(0, 1) = 1
 > Store g.0(1, 1) = 2
 > Store g.0(2, 1) = 3
 > Store g.0(3, 1) = 4
 > Store g.0(0, 2) = 2
 > Store g.0(1, 2) = 3
 > Store g.0(2, 2) = 4
 > Store g.0(3, 2) = 5
 > Store g.0(0, 3) = 3
 > Store g.0(1, 3) = 4
 > Store g.0(2, 3) = 5
 > Store g.0(3, 3) = 6
 > Store g.0(2, 1) = 42
 > Load g.0(0, 1) = 1
 > Store g.0(0, 0) = 1
 > Load g.0(1, 1) = 2
 > Store g.0(1, 0) = 2
 > Load g.0(2, 1) = 42
 > Store g.0(2, 0) = 42
 > Load g.0(3, 1) = 4
 > Store g.0(3, 0) = 4
 > End pipeline g.0()

</b></div>

        <span class="hl slc">// See below for a visualization.</span>

         <span><img src= figures/lesson_09_update.gif ></span>

        <span class="hl slc">// Reading the log, we see that each pass is applied in</span>
        <span class="hl slc">// turn. The equivalent C is:</span>
        <span class="hl kwb">int</span> result<span class="hl opt">[</span><span class="hl num">4</span><span class="hl opt">][</span><span class="hl num">4</span><span class="hl opt">];</span>
        <span class="hl slc">// Pure definition</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> <span class="hl num">4</span><span class="hl opt">;</span> y<span class="hl opt">++) {</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">4</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">] =</span> x <span class="hl opt">+</span> y<span class="hl opt">;</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>
        <span class="hl slc">// First update definition</span>
        result<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">][</span><span class="hl num">2</span><span class="hl opt">] =</span> <span class="hl num">42</span><span class="hl opt">;</span>
        <span class="hl slc">// Second update definition</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">4</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
            result<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">][</span>x<span class="hl opt">] =</span> result<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">][</span>x<span class="hl opt">];</span>
        <span class="hl opt">}</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// Putting update passes inside loops.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// Starting with this pure definition:</span>
        Func f<span class="hl opt">;</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) = (</span>x <span class="hl opt">+</span> y<span class="hl opt">)/</span><span class="hl num">100.0</span>f<span class="hl opt">;</span>

        <span class="hl slc">// Say we want an update that squares the first fifty rows. We</span>
        <span class="hl slc">// could do this by adding 50 update definitions:</span>

        <span class="hl slc">// f(x, 0) = f(x, 0) * f(x, 0);</span>
        <span class="hl slc">// f(x, 1) = f(x, 1) * f(x, 1);</span>
        <span class="hl slc">// f(x, 2) = f(x, 2) * f(x, 2);</span>
        <span class="hl slc">// ...</span>
        <span class="hl slc">// f(x, 49) = f(x, 49) * f(x, 49);</span>

        <span class="hl slc">// Or equivalently using a compile-time loop in our C++:</span>
        <span class="hl slc">// for (int i = 0; i &lt; 50; i++) {</span>
        <span class="hl slc">//   f(x, i) = f(x, i) * f(x, i);</span>
        <span class="hl slc">// }</span>

        <span class="hl slc">// But it's more manageable and more flexible to put the loop</span>
        <span class="hl slc">// in the generated code. We do this by defining a &quot;reduction</span>
        <span class="hl slc">// domain&quot; and using it inside an update definition:</span>
        RDom <span class="hl kwd">r</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">50</span><span class="hl opt">);</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> r<span class="hl opt">) =</span> <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> r<span class="hl opt">) *</span> <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> r<span class="hl opt">);</span>
        Buffer<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;</span> halide_result <span class="hl opt">=</span> f<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">100</span><span class="hl opt">,</span> <span class="hl num">100</span><span class="hl opt">);</span>

        <span class="hl slc">// See below for a visualization.</span>

         <span><video autoplay loop><source src= figures/lesson_09_update_rdom.mp4  />Your browser does not support the video tag :(</video></span>

        <span class="hl slc">// The equivalent C is:</span>
        <span class="hl kwb">float</span> c_result<span class="hl opt">[</span><span class="hl num">100</span><span class="hl opt">][</span><span class="hl num">100</span><span class="hl opt">];</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> y<span class="hl opt">++) {</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                c_result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">] = (</span>x <span class="hl opt">+</span> y<span class="hl opt">)/</span><span class="hl num">100.0</span>f<span class="hl opt">;</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> r <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> r <span class="hl opt">&lt;</span> <span class="hl num">50</span><span class="hl opt">;</span> r<span class="hl opt">++) {</span>
                <span class="hl slc">// The loop over the reduction domain occurs inside of</span>
                <span class="hl slc">// the loop over any pure variables used in the update</span>
                <span class="hl slc">// step:</span>
                c_result<span class="hl opt">[</span>r<span class="hl opt">][</span>x<span class="hl opt">] =</span> c_result<span class="hl opt">[</span>r<span class="hl opt">][</span>x<span class="hl opt">] *</span> c_result<span class="hl opt">[</span>r<span class="hl opt">][</span>x<span class="hl opt">];</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// Check the results match:</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> y<span class="hl opt">++) {</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                <span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">fabs</span><span class="hl opt">(</span><span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) -</span> c_result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">]) &gt;</span> <span class="hl num">0.01</span>f<span class="hl opt">) {</span>
                    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result(%d, %d) = %f instead of %f</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                           x<span class="hl opt">,</span> y<span class="hl opt">,</span> <span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">),</span> c_result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">]);</span>
                    <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
                <span class="hl opt">}</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// Now we'll examine a real-world use for an update definition:</span>
    <span class="hl slc">// computing a histogram.</span>
    <span class="hl opt">{</span>

        <span class="hl slc">// Some operations on images can't be cleanly expressed as a pure</span>
        <span class="hl slc">// function from the output coordinates to the value stored</span>
        <span class="hl slc">// there. The classic example is computing a histogram. The</span>
        <span class="hl slc">// natural way to do it is to iterate over the input image,</span>
        <span class="hl slc">// updating histogram buckets. Here's how you do that in Halide:</span>
        Func <span class="hl kwd">histogram</span><span class="hl opt">(</span><span class="hl str">&quot;histogram&quot;</span><span class="hl opt">);</span>

        <span class="hl slc">// Histogram buckets start as zero.</span>
        <span class="hl kwd">histogram</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> <span class="hl num">0</span><span class="hl opt">;</span>

        <span class="hl slc">// Define a multi-dimensional reduction domain over the input image:</span>
        RDom <span class="hl kwd">r</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(),</span> <span class="hl num">0</span><span class="hl opt">,</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">());</span>

        <span class="hl slc">// For every point in the reduction domain, increment the</span>
        <span class="hl slc">// histogram bucket corresponding to the intensity of the</span>
        <span class="hl slc">// input image at that point.</span>
        <span class="hl kwd">histogram</span><span class="hl opt">(</span><span class="hl kwd">input</span><span class="hl opt">(</span>r<span class="hl opt">.</span>x<span class="hl opt">,</span> r<span class="hl opt">.</span>y<span class="hl opt">)) +=</span> <span class="hl num">1</span><span class="hl opt">;</span>

        Buffer<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> halide_result <span class="hl opt">=</span> histogram<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">256</span><span class="hl opt">);</span>

        <span class="hl slc">// The equivalent C is:</span>
        <span class="hl kwb">int</span> c_result<span class="hl opt">[</span><span class="hl num">256</span><span class="hl opt">];</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">256</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
            c_result<span class="hl opt">[</span>x<span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
        <span class="hl opt">}</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> r_y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> r_y <span class="hl opt">&lt;</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">();</span> r_y<span class="hl opt">++) {</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> r_x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> r_x <span class="hl opt">&lt;</span> input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">();</span> r_x<span class="hl opt">++) {</span>
                c_result<span class="hl opt">[</span><span class="hl kwd">input</span><span class="hl opt">(</span>r_x<span class="hl opt">,</span> r_y<span class="hl opt">)] +=</span> <span class="hl num">1</span><span class="hl opt">;</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// Check the answers agree:</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">256</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
            <span class="hl kwa">if</span> <span class="hl opt">(</span>c_result<span class="hl opt">[</span>x<span class="hl opt">] !=</span> <span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">)) {</span>
                <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result(%d) = %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                       x<span class="hl opt">,</span> <span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">),</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]);</span>
                <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// Scheduling update steps</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// The pure variables in an update step and can be</span>
        <span class="hl slc">// parallelized, vectorized, split, etc as usual.</span>

        <span class="hl slc">// Vectorizing, splitting, or parallelize the variables that</span>
        <span class="hl slc">// are part of the reduction domain is trickier. We'll cover</span>
        <span class="hl slc">// that in a later lesson.</span>

        <span class="hl slc">// Consider the definition:</span>
        Func f<span class="hl opt">;</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> x<span class="hl opt">*</span>y<span class="hl opt">;</span>
        <span class="hl slc">// Set row zero to each row 8</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">) =</span> <span class="hl kwd">f</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">8</span><span class="hl opt">);</span>
        <span class="hl slc">// Set column 1 equal to column 8 plus 2</span>
        <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> y<span class="hl opt">) =</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">,</span> y<span class="hl opt">) +</span> <span class="hl num">2</span><span class="hl opt">;</span>

        <span class="hl slc">// The pure variables in each stage can be scheduled</span>
        <span class="hl slc">// independently. To control the pure definition, we schedule</span>
        <span class="hl slc">// as we have done in the past. The following code vectorizes</span>
        <span class="hl slc">// and parallelizes the pure definition only.</span>
        f<span class="hl opt">.</span><span class="hl kwd">vectorize</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">).</span><span class="hl kwd">parallel</span><span class="hl opt">(</span>y<span class="hl opt">);</span>

        <span class="hl slc">// We use Func::update(int) to get a handle to an update step</span>
        <span class="hl slc">// for the purposes of scheduling. The following line</span>
        <span class="hl slc">// vectorizes the first update step across x. We can't do</span>
        <span class="hl slc">// anything with y for this update step, because it doesn't</span>
        <span class="hl slc">// use y.</span>
        f<span class="hl opt">.</span><span class="hl kwd">update</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">).</span><span class="hl kwd">vectorize</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">);</span>

        <span class="hl slc">// Now we parallelize the second update step in chunks of size</span>
        <span class="hl slc">// 4.</span>
        Var yo<span class="hl opt">,</span> yi<span class="hl opt">;</span>
        f<span class="hl opt">.</span><span class="hl kwd">update</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">).</span><span class="hl kwd">split</span><span class="hl opt">(</span>y<span class="hl opt">,</span> yo<span class="hl opt">,</span> yi<span class="hl opt">,</span> <span class="hl num">4</span><span class="hl opt">).</span><span class="hl kwd">parallel</span><span class="hl opt">(</span>yo<span class="hl opt">);</span>

        Buffer<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> halide_result <span class="hl opt">=</span> f<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">16</span><span class="hl opt">,</span> <span class="hl num">16</span><span class="hl opt">);</span>

        <span class="hl slc">// See below for a visualization.</span>

         <span><video autoplay loop><source src= figures/lesson_09_update_schedule.mp4  />Your browser does not support the video tag :(</video></span>

        <span class="hl slc">// Here's the equivalent (serial) C:</span>
        <span class="hl kwb">int</span> c_result<span class="hl opt">[</span><span class="hl num">16</span><span class="hl opt">][</span><span class="hl num">16</span><span class="hl opt">];</span>

        <span class="hl slc">// Pure step. Vectorized in x and parallelized in y.</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> <span class="hl num">16</span><span class="hl opt">;</span> y<span class="hl opt">++) {</span> <span class="hl slc">// Should be a parallel for loop</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x_vec <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x_vec <span class="hl opt">&lt;</span> <span class="hl num">4</span><span class="hl opt">;</span> x_vec<span class="hl opt">++) {</span>
                <span class="hl kwb">int</span> x<span class="hl opt">[] = {</span>x_vec<span class="hl opt">*</span><span class="hl num">4</span><span class="hl opt">,</span> x_vec<span class="hl opt">*</span><span class="hl num">4</span><span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">,</span> x_vec<span class="hl opt">*</span><span class="hl num">4</span><span class="hl opt">+</span><span class="hl num">2</span><span class="hl opt">,</span> x_vec<span class="hl opt">*</span><span class="hl num">4</span><span class="hl opt">+</span><span class="hl num">3</span><span class="hl opt">};</span>
                c_result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]] =</span> x<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] *</span> y<span class="hl opt">;</span>
                c_result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]] =</span> x<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">] *</span> y<span class="hl opt">;</span>
                c_result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">]] =</span> x<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">] *</span> y<span class="hl opt">;</span>
                c_result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">]] =</span> x<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">] *</span> y<span class="hl opt">;</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// First update. Vectorized in x.</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x_vec <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x_vec <span class="hl opt">&lt;</span> <span class="hl num">4</span><span class="hl opt">;</span> x_vec<span class="hl opt">++) {</span>
            <span class="hl kwb">int</span> x<span class="hl opt">[] = {</span>x_vec<span class="hl opt">*</span><span class="hl num">4</span><span class="hl opt">,</span> x_vec<span class="hl opt">*</span><span class="hl num">4</span><span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">,</span> x_vec<span class="hl opt">*</span><span class="hl num">4</span><span class="hl opt">+</span><span class="hl num">2</span><span class="hl opt">,</span> x_vec<span class="hl opt">*</span><span class="hl num">4</span><span class="hl opt">+</span><span class="hl num">3</span><span class="hl opt">};</span>
            c_result<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">][</span>x<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]] =</span> c_result<span class="hl opt">[</span><span class="hl num">8</span><span class="hl opt">][</span>x<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]];</span>
            c_result<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">][</span>x<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]] =</span> c_result<span class="hl opt">[</span><span class="hl num">8</span><span class="hl opt">][</span>x<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">]];</span>
            c_result<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">][</span>x<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">]] =</span> c_result<span class="hl opt">[</span><span class="hl num">8</span><span class="hl opt">][</span>x<span class="hl opt">[</span><span class="hl num">2</span><span class="hl opt">]];</span>
            c_result<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">][</span>x<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">]] =</span> c_result<span class="hl opt">[</span><span class="hl num">8</span><span class="hl opt">][</span>x<span class="hl opt">[</span><span class="hl num">3</span><span class="hl opt">]];</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// Second update. Parallelized in chunks of size 4 in y.</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> yo <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> yo <span class="hl opt">&lt;</span> <span class="hl num">4</span><span class="hl opt">;</span> yo<span class="hl opt">++) {</span> <span class="hl slc">// Should be a parallel for loop</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> yi <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> yi <span class="hl opt">&lt;</span> <span class="hl num">4</span><span class="hl opt">;</span> yi<span class="hl opt">++) {</span>
                <span class="hl kwb">int</span> y <span class="hl opt">=</span> yo<span class="hl opt">*</span><span class="hl num">4</span> <span class="hl opt">+</span> yi<span class="hl opt">;</span>
                c_result<span class="hl opt">[</span>y<span class="hl opt">][</span><span class="hl num">0</span><span class="hl opt">] =</span> c_result<span class="hl opt">[</span>y<span class="hl opt">][</span><span class="hl num">8</span><span class="hl opt">] +</span> <span class="hl num">2</span><span class="hl opt">;</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// Check the C and Halide results match:</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> <span class="hl num">16</span><span class="hl opt">;</span> y<span class="hl opt">++) {</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">16</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                <span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) !=</span> c_result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">]) {</span>
                    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result(%d, %d) = %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                           x<span class="hl opt">,</span> y<span class="hl opt">,</span> <span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">),</span> c_result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">]);</span>
                    <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
                <span class="hl opt">}</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// That covers how to schedule the variables within a Func that</span>
    <span class="hl slc">// uses update steps, but what about producer-consumer</span>
    <span class="hl slc">// relationships that involve compute_at and store_at? Let's</span>
    <span class="hl slc">// examine a reduction as a producer, in a producer-consumer pair.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// Because an update does multiple passes over a stored array,</span>
        <span class="hl slc">// it's not meaningful to inline them. So the default schedule</span>
        <span class="hl slc">// for them does the closest thing possible. It computes them</span>
        <span class="hl slc">// in the innermost loop of their consumer. Consider this</span>
        <span class="hl slc">// trivial example:</span>
        Func producer<span class="hl opt">,</span> consumer<span class="hl opt">;</span>
        <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> x<span class="hl opt">*</span><span class="hl num">2</span><span class="hl opt">;</span>
        <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">) +=</span> <span class="hl num">10</span><span class="hl opt">;</span>
        <span class="hl kwd">consumer</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> <span class="hl num">2</span> <span class="hl opt">*</span> <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">);</span>
        Buffer<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> halide_result <span class="hl opt">=</span> consumer<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>

        <span class="hl slc">// See below for a visualization.</span>

         <span><img src= figures/lesson_09_inline_reduction.gif ></span>

        <span class="hl slc">// The equivalent C is:</span>
        <span class="hl kwb">int</span> c_result<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++)  {</span>
            <span class="hl kwb">int</span> producer_storage<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
            <span class="hl slc">// Pure step for producer</span>
            producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> x <span class="hl opt">*</span> <span class="hl num">2</span><span class="hl opt">;</span>
            <span class="hl slc">// Update step for producer</span>
            producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] +</span> <span class="hl num">10</span><span class="hl opt">;</span>
            <span class="hl slc">// Pure step for consumer</span>
            c_result<span class="hl opt">[</span>x<span class="hl opt">] =</span> <span class="hl num">2</span> <span class="hl opt">*</span> producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// Check the results match</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
            <span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">) !=</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]) {</span>
                <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result(%d) = %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                       x<span class="hl opt">,</span> <span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">),</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]);</span>
                <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// For all other compute_at/store_at options, the reduction</span>
        <span class="hl slc">// gets placed where you would expect, somewhere in the loop</span>
        <span class="hl slc">// nest of the consumer.</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// Now let's consider a reduction as a consumer in a</span>
    <span class="hl slc">// producer-consumer pair. This is a little more involved.</span>
    <span class="hl opt">{</span>
        <span class="hl opt">{</span>
            <span class="hl slc">// Case 1: The consumer references the producer in the pure step only.</span>
            Func producer<span class="hl opt">,</span> consumer<span class="hl opt">;</span>
            <span class="hl slc">// The producer is pure.</span>
            <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> x<span class="hl opt">*</span><span class="hl num">17</span><span class="hl opt">;</span>
            <span class="hl kwd">consumer</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> <span class="hl num">2</span> <span class="hl opt">*</span> <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">);</span>
            <span class="hl kwd">consumer</span><span class="hl opt">(</span>x<span class="hl opt">) +=</span> <span class="hl num">50</span><span class="hl opt">;</span>

            <span class="hl slc">// The valid schedules for the producer in this case are</span>
            <span class="hl slc">// the default schedule - inlined, and also:</span>
            <span class="hl slc">//</span>
            <span class="hl slc">// 1) producer.compute_at(x), which places the computation of</span>
            <span class="hl slc">// the producer inside the loop over x in the pure step of the</span>
            <span class="hl slc">// consumer.</span>
            <span class="hl slc">//</span>
            <span class="hl slc">// 2) producer.compute_root(), which computes all of the</span>
            <span class="hl slc">// producer ahead of time.</span>
            <span class="hl slc">//</span>
            <span class="hl slc">// 3) producer.store_root().compute_at(x), which allocates</span>
            <span class="hl slc">// space for the consumer outside the loop over x, but fills</span>
            <span class="hl slc">// it in as needed inside the loop.</span>
            <span class="hl slc">//</span>
            <span class="hl slc">// Let's use option 1.</span>

            producer<span class="hl opt">.</span><span class="hl kwd">compute_at</span><span class="hl opt">(</span>consumer<span class="hl opt">,</span> x<span class="hl opt">);</span>

            Buffer<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> halide_result <span class="hl opt">=</span> consumer<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>

            <span class="hl slc">// See below for a visualization.</span>

             <span><img src= figures/lesson_09_compute_at_pure.gif ></span>

            <span class="hl slc">// The equivalent C is:</span>
            <span class="hl kwb">int</span> c_result<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
            <span class="hl slc">// Pure step for the consumer</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++)  {</span>
                <span class="hl slc">// Pure step for producer</span>
                <span class="hl kwb">int</span> producer_storage<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
                producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> x <span class="hl opt">*</span> <span class="hl num">17</span><span class="hl opt">;</span>
                c_result<span class="hl opt">[</span>x<span class="hl opt">] =</span> <span class="hl num">2</span> <span class="hl opt">*</span> producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
            <span class="hl opt">}</span>
            <span class="hl slc">// Update step for the consumer</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                c_result<span class="hl opt">[</span>x<span class="hl opt">] +=</span> <span class="hl num">50</span><span class="hl opt">;</span>
            <span class="hl opt">}</span>

            <span class="hl slc">// All of the pure step is evaluated before any of the</span>
            <span class="hl slc">// update step, so there are two separate loops over x.</span>

            <span class="hl slc">// Check the results match</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                <span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">) !=</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]) {</span>
                    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result(%d) = %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                           x<span class="hl opt">,</span> <span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">),</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]);</span>
                    <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
                <span class="hl opt">}</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>

        <span class="hl opt">{</span>
            <span class="hl slc">// Case 2: The consumer references the producer in the update step only</span>
            Func producer<span class="hl opt">,</span> consumer<span class="hl opt">;</span>
            <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> x <span class="hl opt">*</span> <span class="hl num">17</span><span class="hl opt">;</span>
            <span class="hl kwd">consumer</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> <span class="hl num">100</span> <span class="hl opt">-</span> x <span class="hl opt">*</span> <span class="hl num">10</span><span class="hl opt">;</span>
            <span class="hl kwd">consumer</span><span class="hl opt">(</span>x<span class="hl opt">) +=</span> <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">);</span>

            <span class="hl slc">// Again we compute the producer per x coordinate of the</span>
            <span class="hl slc">// consumer. This places producer code inside the update</span>
            <span class="hl slc">// step of the consumer, because that's the only step that</span>
            <span class="hl slc">// uses the producer.</span>
            producer<span class="hl opt">.</span><span class="hl kwd">compute_at</span><span class="hl opt">(</span>consumer<span class="hl opt">,</span> x<span class="hl opt">);</span>

            <span class="hl slc">// Note however, that we didn't say:</span>
            <span class="hl slc">//</span>
            <span class="hl slc">// producer.compute_at(consumer.update(0), x).</span>
            <span class="hl slc">//</span>
            <span class="hl slc">// Scheduling is done with respect to Vars of a Func, and</span>
            <span class="hl slc">// the Vars of a Func are shared across the pure and</span>
            <span class="hl slc">// update steps.</span>

            Buffer<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> halide_result <span class="hl opt">=</span> consumer<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>

            <span class="hl slc">// See below for a visualization.</span>

             <span><img src= figures/lesson_09_compute_at_update.gif ></span>

            <span class="hl slc">// The equivalent C is:</span>
            <span class="hl kwb">int</span> c_result<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
            <span class="hl slc">// Pure step for the consumer</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++)  {</span>
                c_result<span class="hl opt">[</span>x<span class="hl opt">] =</span> <span class="hl num">100</span> <span class="hl opt">-</span> x <span class="hl opt">*</span> <span class="hl num">10</span><span class="hl opt">;</span>
            <span class="hl opt">}</span>
            <span class="hl slc">// Update step for the consumer</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                <span class="hl slc">// Pure step for producer</span>
                <span class="hl kwb">int</span> producer_storage<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
                producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> x <span class="hl opt">*</span> <span class="hl num">17</span><span class="hl opt">;</span>
                c_result<span class="hl opt">[</span>x<span class="hl opt">] +=</span> producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
            <span class="hl opt">}</span>


            <span class="hl slc">// Check the results match</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                <span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">) !=</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]) {</span>
                    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result(%d) = %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                           x<span class="hl opt">,</span> <span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">),</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]);</span>
                    <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
                <span class="hl opt">}</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>

        <span class="hl opt">{</span>
            <span class="hl slc">// Case 3: The consumer references the producer in</span>
            <span class="hl slc">// multiple steps that share common variables</span>
            Func producer<span class="hl opt">,</span> consumer<span class="hl opt">;</span>
            <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> x <span class="hl opt">*</span> <span class="hl num">17</span><span class="hl opt">;</span>
            <span class="hl kwd">consumer</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> <span class="hl num">170</span> <span class="hl opt">-</span> <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">);</span>
            <span class="hl kwd">consumer</span><span class="hl opt">(</span>x<span class="hl opt">) +=</span> <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">)/</span><span class="hl num">2</span><span class="hl opt">;</span>

            <span class="hl slc">// Again we compute the producer per x coordinate of the</span>
            <span class="hl slc">// consumer. This places producer code inside both the</span>
            <span class="hl slc">// pure and the update step of the consumer. So there end</span>
            <span class="hl slc">// up being two separate realizations of the producer, and</span>
            <span class="hl slc">// redundant work occurs.</span>
            producer<span class="hl opt">.</span><span class="hl kwd">compute_at</span><span class="hl opt">(</span>consumer<span class="hl opt">,</span> x<span class="hl opt">);</span>

            Buffer<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> halide_result <span class="hl opt">=</span> consumer<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>

            <span class="hl slc">// See below for a visualization.</span>

             <span><img src= figures/lesson_09_compute_at_pure_and_update.gif ></span>

            <span class="hl slc">// The equivalent C is:</span>
            <span class="hl kwb">int</span> c_result<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
            <span class="hl slc">// Pure step for the consumer</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++)  {</span>
                <span class="hl slc">// Pure step for producer</span>
                <span class="hl kwb">int</span> producer_storage<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
                producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> x <span class="hl opt">*</span> <span class="hl num">17</span><span class="hl opt">;</span>
                c_result<span class="hl opt">[</span>x<span class="hl opt">] =</span> <span class="hl num">170</span> <span class="hl opt">-</span> producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
            <span class="hl opt">}</span>
            <span class="hl slc">// Update step for the consumer</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                <span class="hl slc">// Another copy of the pure step for producer</span>
                <span class="hl kwb">int</span> producer_storage<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
                producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> x <span class="hl opt">*</span> <span class="hl num">17</span><span class="hl opt">;</span>
                c_result<span class="hl opt">[</span>x<span class="hl opt">] +=</span> producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">]/</span><span class="hl num">2</span><span class="hl opt">;</span>
            <span class="hl opt">}</span>

            <span class="hl slc">// Check the results match</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                <span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">) !=</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]) {</span>
                    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result(%d) = %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                           x<span class="hl opt">,</span> <span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">),</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]);</span>
                    <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
                <span class="hl opt">}</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>

        <span class="hl opt">{</span>
            <span class="hl slc">// Case 4: The consumer references the producer in</span>
            <span class="hl slc">// multiple steps that do not share common variables</span>
            Func producer<span class="hl opt">,</span> consumer<span class="hl opt">;</span>
            <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) = (</span>x <span class="hl opt">*</span> y<span class="hl opt">) /</span> <span class="hl num">10</span> <span class="hl opt">+</span> <span class="hl num">8</span><span class="hl opt">;</span>
            <span class="hl kwd">consumer</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> x <span class="hl opt">+</span> y<span class="hl opt">;</span>
            <span class="hl kwd">consumer</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">) =</span> <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">,</span> x<span class="hl opt">);</span>
            <span class="hl kwd">consumer</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> y<span class="hl opt">) =</span> <span class="hl kwd">producer</span><span class="hl opt">(</span>y<span class="hl opt">,</span> <span class="hl num">9</span><span class="hl opt">-</span>y<span class="hl opt">);</span>

            <span class="hl slc">// In this case neither producer.compute_at(consumer, x)</span>
            <span class="hl slc">// nor producer.compute_at(consumer, y) will work, because</span>
            <span class="hl slc">// either one fails to cover one of the uses of the</span>
            <span class="hl slc">// producer. So we'd have to inline producer, or use</span>
            <span class="hl slc">// producer.compute_root().</span>

            <span class="hl slc">// Let's say we really really want producer to be</span>
            <span class="hl slc">// compute_at the inner loops of both consumer update</span>
            <span class="hl slc">// steps. Halide doesn't allow multiple different</span>
            <span class="hl slc">// schedules for a single Func, but we can work around it</span>
            <span class="hl slc">// by making two wrappers around producer, and scheduling</span>
            <span class="hl slc">// those instead:</span>

            <span class="hl slc">// Attempt 2:</span>
            Func producer_1<span class="hl opt">,</span> producer_2<span class="hl opt">,</span> consumer_2<span class="hl opt">;</span>
            <span class="hl kwd">producer_1</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">);</span>
            <span class="hl kwd">producer_2</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">);</span>

            <span class="hl kwd">consumer_2</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> x <span class="hl opt">+</span> y<span class="hl opt">;</span>
            <span class="hl kwd">consumer_2</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">) +=</span> <span class="hl kwd">producer_1</span><span class="hl opt">(</span>x<span class="hl opt">,</span> x<span class="hl opt">);</span>
            <span class="hl kwd">consumer_2</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> y<span class="hl opt">) +=</span> <span class="hl kwd">producer_2</span><span class="hl opt">(</span>y<span class="hl opt">,</span> <span class="hl num">9</span><span class="hl opt">-</span>y<span class="hl opt">);</span>

            <span class="hl slc">// The wrapper functions give us two separate handles on</span>
            <span class="hl slc">// the producer, so we can schedule them differently.</span>
            producer_1<span class="hl opt">.</span><span class="hl kwd">compute_at</span><span class="hl opt">(</span>consumer_2<span class="hl opt">,</span> x<span class="hl opt">);</span>
            producer_2<span class="hl opt">.</span><span class="hl kwd">compute_at</span><span class="hl opt">(</span>consumer_2<span class="hl opt">,</span> y<span class="hl opt">);</span>

            Buffer<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> halide_result <span class="hl opt">=</span> consumer_2<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">,</span> <span class="hl num">10</span><span class="hl opt">);</span>

            <span class="hl slc">// See below for a visualization.</span>

             <span><video autoplay loop><source src= figures/lesson_09_compute_at_multiple_updates.mp4  />Your browser does not support the video tag :(</video></span>

            <span class="hl slc">// The equivalent C is:</span>
            <span class="hl kwb">int</span> c_result<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">][</span><span class="hl num">10</span><span class="hl opt">];</span>
            <span class="hl slc">// Pure step for the consumer</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> y<span class="hl opt">++) {</span>
                <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                    c_result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">] =</span> x <span class="hl opt">+</span> y<span class="hl opt">;</span>
                <span class="hl opt">}</span>
            <span class="hl opt">}</span>
            <span class="hl slc">// First update step for consumer</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                <span class="hl kwb">int</span> producer_1_storage<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
                producer_1_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] = (</span>x <span class="hl opt">*</span> x<span class="hl opt">) /</span> <span class="hl num">10</span> <span class="hl opt">+</span> <span class="hl num">8</span><span class="hl opt">;</span>
                c_result<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">][</span>x<span class="hl opt">] +=</span> producer_1_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
            <span class="hl opt">}</span>
            <span class="hl slc">// Second update step for consumer</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> y<span class="hl opt">++) {</span>
                <span class="hl kwb">int</span> producer_2_storage<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
                producer_2_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] = (</span>y <span class="hl opt">* (</span><span class="hl num">9</span><span class="hl opt">-</span>y<span class="hl opt">)) /</span> <span class="hl num">10</span> <span class="hl opt">+</span> <span class="hl num">8</span><span class="hl opt">;</span>
                c_result<span class="hl opt">[</span>y<span class="hl opt">][</span><span class="hl num">0</span><span class="hl opt">] +=</span> producer_2_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
            <span class="hl opt">}</span>

            <span class="hl slc">// Check the results match</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> y<span class="hl opt">++) {</span>
                <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                    <span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) !=</span> c_result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">]) {</span>
                        <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result(%d, %d) = %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                               x<span class="hl opt">,</span> y<span class="hl opt">,</span> <span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">),</span> c_result<span class="hl opt">[</span>y<span class="hl opt">][</span>x<span class="hl opt">]);</span>
                        <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
                    <span class="hl opt">}</span>
                <span class="hl opt">}</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>

        <span class="hl opt">{</span>
            <span class="hl slc">// Case 5: Scheduling a producer under a reduction domain</span>
            <span class="hl slc">// variable of the consumer.</span>

            <span class="hl slc">// We are not just restricted to scheduling producers at</span>
            <span class="hl slc">// the loops over the pure variables of the consumer. If a</span>
            <span class="hl slc">// producer is only used within a loop over a reduction</span>
            <span class="hl slc">// domain (RDom) variable, we can also schedule the</span>
            <span class="hl slc">// producer there.</span>

            Func producer<span class="hl opt">,</span> consumer<span class="hl opt">;</span>

            RDom <span class="hl kwd">r</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
            <span class="hl kwd">producer</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> x <span class="hl opt">%</span> <span class="hl num">8</span><span class="hl opt">;</span>
            <span class="hl kwd">consumer</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> x <span class="hl opt">+</span> <span class="hl num">10</span><span class="hl opt">;</span>
            <span class="hl kwd">consumer</span><span class="hl opt">(</span>x<span class="hl opt">) +=</span> r <span class="hl opt">+</span> <span class="hl kwd">producer</span><span class="hl opt">(</span>x <span class="hl opt">+</span> r<span class="hl opt">);</span>

            producer<span class="hl opt">.</span><span class="hl kwd">compute_at</span><span class="hl opt">(</span>consumer<span class="hl opt">,</span> r<span class="hl opt">);</span>

            Buffer<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> halide_result <span class="hl opt">=</span> consumer<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>

            <span class="hl slc">// See below for a visualization.</span>

             <span><img src= figures/lesson_09_compute_at_rvar.gif ></span>

            <span class="hl slc">// The equivalent C is:</span>
            <span class="hl kwb">int</span> c_result<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
            <span class="hl slc">// Pure step for the consumer.</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++)  {</span>
                c_result<span class="hl opt">[</span>x<span class="hl opt">] =</span> x <span class="hl opt">+</span> <span class="hl num">10</span><span class="hl opt">;</span>
            <span class="hl opt">}</span>
            <span class="hl slc">// Update step for the consumer.</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                <span class="hl slc">// The loop over the reduction domain is always the inner loop.</span>
                <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> r <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> r <span class="hl opt">&lt;</span> <span class="hl num">5</span><span class="hl opt">;</span> r<span class="hl opt">++) {</span>
                    <span class="hl slc">// We've schedule the storage and computation of</span>
                    <span class="hl slc">// the producer here. We just need a single value.</span>
                    <span class="hl kwb">int</span> producer_storage<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
                    <span class="hl slc">// Pure step of the producer.</span>
                    producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] = (</span>x <span class="hl opt">+</span> r<span class="hl opt">) %</span> <span class="hl num">8</span><span class="hl opt">;</span>

                    <span class="hl slc">// Now use it in the update step of the consumer.</span>
                    c_result<span class="hl opt">[</span>x<span class="hl opt">] +=</span> r <span class="hl opt">+</span> producer_storage<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">];</span>
                <span class="hl opt">}</span>
            <span class="hl opt">}</span>

            <span class="hl slc">// Check the results match</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                <span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">) !=</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]) {</span>
                    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result(%d) = %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                           x<span class="hl opt">,</span> <span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">),</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]);</span>
                    <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
                <span class="hl opt">}</span>
            <span class="hl opt">}</span>


        <span class="hl opt">}</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// A real-world example of a reduction inside a producer-consumer chain.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// The default schedule for a reduction is a good one for</span>
        <span class="hl slc">// convolution-like operations. For example, the following</span>
        <span class="hl slc">// computes a 5x5 box-blur of our grayscale test image with a</span>
        <span class="hl slc">// clamp-to-edge boundary condition:</span>

        <span class="hl slc">// First add the boundary condition.</span>
        Func clamped <span class="hl opt">=</span> BoundaryConditions<span class="hl opt">::</span><span class="hl kwd">repeat_edge</span><span class="hl opt">(</span>input<span class="hl opt">);</span>

        <span class="hl slc">// Define a 5x5 box that starts at (-2, -2)</span>
        RDom <span class="hl kwd">r</span><span class="hl opt">(-</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">, -</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>

        <span class="hl slc">// Compute the 5x5 sum around each pixel.</span>
        Func local_sum<span class="hl opt">;</span>
        <span class="hl kwd">local_sum</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> <span class="hl num">0</span><span class="hl opt">;</span> <span class="hl slc">// Compute the sum as a 32-bit integer</span>
        <span class="hl kwd">local_sum</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) +=</span> <span class="hl kwd">clamped</span><span class="hl opt">(</span>x <span class="hl opt">+</span> r<span class="hl opt">.</span>x<span class="hl opt">,</span> y <span class="hl opt">+</span> r<span class="hl opt">.</span>y<span class="hl opt">);</span>

        <span class="hl slc">// Divide the sum by 25 to make it an average</span>
        Func blurry<span class="hl opt">;</span>
        <span class="hl kwd">blurry</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;(</span><span class="hl kwd">local_sum</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) /</span> <span class="hl num">25</span><span class="hl opt">);</span>

        Buffer<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;</span> halide_result <span class="hl opt">=</span> blurry<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span>input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(),</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">());</span>

        <span class="hl slc">// The default schedule will inline 'clamped' into the update</span>
        <span class="hl slc">// step of 'local_sum', because clamped only has a pure</span>
        <span class="hl slc">// definition, and so its default schedule is fully-inlined.</span>
        <span class="hl slc">// We will then compute local_sum per x coordinate of blurry,</span>
        <span class="hl slc">// because the default schedule for reductions is</span>
        <span class="hl slc">// compute-innermost. Here's the equivalent C:</span>

        Buffer<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;</span> <span class="hl kwd">c_result</span><span class="hl opt">(</span>input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(),</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">());</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">();</span> y<span class="hl opt">++) {</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">();</span> x<span class="hl opt">++) {</span>
                <span class="hl kwb">int</span> local_sum<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
                <span class="hl slc">// Pure step of local_sum</span>
                local_sum<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
                <span class="hl slc">// Update step of local_sum</span>
                <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> r_y <span class="hl opt">= -</span><span class="hl num">2</span><span class="hl opt">;</span> r_y <span class="hl opt">&lt;=</span> <span class="hl num">2</span><span class="hl opt">;</span> r_y<span class="hl opt">++) {</span>
                    <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> r_x <span class="hl opt">= -</span><span class="hl num">2</span><span class="hl opt">;</span> r_x <span class="hl opt">&lt;=</span> <span class="hl num">2</span><span class="hl opt">;</span> r_x<span class="hl opt">++) {</span>
                        <span class="hl slc">// The clamping has been inlined into the update step.</span>
                        <span class="hl kwb">int</span> clamped_x <span class="hl opt">=</span> std<span class="hl opt">::</span><span class="hl kwd">min</span><span class="hl opt">(</span>std<span class="hl opt">::</span><span class="hl kwd">max</span><span class="hl opt">(</span>x <span class="hl opt">+</span> r_x<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">),</span> input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">()-</span><span class="hl num">1</span><span class="hl opt">);</span>
                        <span class="hl kwb">int</span> clamped_y <span class="hl opt">=</span> std<span class="hl opt">::</span><span class="hl kwd">min</span><span class="hl opt">(</span>std<span class="hl opt">::</span><span class="hl kwd">max</span><span class="hl opt">(</span>y <span class="hl opt">+</span> r_y<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">),</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">()-</span><span class="hl num">1</span><span class="hl opt">);</span>
                        local_sum<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] +=</span> <span class="hl kwd">input</span><span class="hl opt">(</span>clamped_x<span class="hl opt">,</span> clamped_y<span class="hl opt">);</span>
                    <span class="hl opt">}</span>
                <span class="hl opt">}</span>
                <span class="hl slc">// Pure step of blurry</span>
                <span class="hl kwd">c_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) = (</span><span class="hl kwb">uint8_t</span><span class="hl opt">)(</span>local_sum<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] /</span> <span class="hl num">25</span><span class="hl opt">);</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// Check the results match</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">();</span> y<span class="hl opt">++) {</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">();</span> x<span class="hl opt">++) {</span>
                <span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) !=</span> <span class="hl kwd">c_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">)) {</span>
                    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result(%d, %d) = %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                           x<span class="hl opt">,</span> y<span class="hl opt">,</span> <span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">),</span> <span class="hl kwd">c_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">));</span>
                    <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
                <span class="hl opt">}</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// Reduction helpers.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// There are several reduction helper functions provided in</span>
        <span class="hl slc">// Halide.h, which compute small reductions and schedule them</span>
        <span class="hl slc">// innermost into their consumer. The most useful one is</span>
        <span class="hl slc">// &quot;sum&quot;.</span>
        Func f1<span class="hl opt">;</span>
        RDom <span class="hl kwd">r</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">100</span><span class="hl opt">);</span>
        <span class="hl kwd">f1</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> <span class="hl kwd">sum</span><span class="hl opt">(</span>r <span class="hl opt">+</span> x<span class="hl opt">) *</span> <span class="hl num">7</span><span class="hl opt">;</span>

        <span class="hl slc">// Sum creates a small anonymous Func to do the reduction. It's equivalent to:</span>
        Func f2<span class="hl opt">;</span>
        Func anon<span class="hl opt">;</span>
        <span class="hl kwd">anon</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> <span class="hl num">0</span><span class="hl opt">;</span>
        <span class="hl kwd">anon</span><span class="hl opt">(</span>x<span class="hl opt">) +=</span> r <span class="hl opt">+</span> x<span class="hl opt">;</span>
        <span class="hl kwd">f2</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> <span class="hl kwd">anon</span><span class="hl opt">(</span>x<span class="hl opt">) *</span> <span class="hl num">7</span><span class="hl opt">;</span>

        <span class="hl slc">// So even though f1 references a reduction domain, it is a</span>
        <span class="hl slc">// pure function. The reduction domain has been swallowed to</span>
        <span class="hl slc">// define the inner anonymous reduction.</span>

        Buffer<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> halide_result_1 <span class="hl opt">=</span> f1<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>
        Buffer<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;</span> halide_result_2 <span class="hl opt">=</span> f2<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span><span class="hl num">10</span><span class="hl opt">);</span>

        <span class="hl slc">// The equivalent C is:</span>
        <span class="hl kwb">int</span> c_result<span class="hl opt">[</span><span class="hl num">10</span><span class="hl opt">];</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
            <span class="hl kwb">int</span> anon<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
            anon<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] =</span> <span class="hl num">0</span><span class="hl opt">;</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> r <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> r <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> r<span class="hl opt">++) {</span>
                anon<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] +=</span> r <span class="hl opt">+</span> x<span class="hl opt">;</span>
            <span class="hl opt">}</span>
            c_result<span class="hl opt">[</span>x<span class="hl opt">] =</span> anon<span class="hl opt">[</span><span class="hl num">0</span><span class="hl opt">] *</span> <span class="hl num">7</span><span class="hl opt">;</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// Check they all match.</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> <span class="hl num">10</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
            <span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">halide_result_1</span><span class="hl opt">(</span>x<span class="hl opt">) !=</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]) {</span>
                <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result_1(%d) = %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                       x<span class="hl opt">,</span> <span class="hl kwd">halide_result_1</span><span class="hl opt">(</span>x<span class="hl opt">),</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]);</span>
                <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
            <span class="hl opt">}</span>
            <span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">halide_result_2</span><span class="hl opt">(</span>x<span class="hl opt">) !=</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]) {</span>
                <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result_2(%d) = %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                       x<span class="hl opt">,</span> <span class="hl kwd">halide_result_2</span><span class="hl opt">(</span>x<span class="hl opt">),</span> c_result<span class="hl opt">[</span>x<span class="hl opt">]);</span>
                <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// A complex example that uses reduction helpers.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// Other reduction helpers include &quot;product&quot;, &quot;minimum&quot;,</span>
        <span class="hl slc">// &quot;maximum&quot;, &quot;argmin&quot;, and &quot;argmax&quot;. Using argmin and argmax</span>
        <span class="hl slc">// requires understanding tuples, which come in a later</span>
        <span class="hl slc">// lesson. Let's use minimum and maximum to compute the local</span>
        <span class="hl slc">// spread of our grayscale image.</span>

        <span class="hl slc">// First, add a boundary condition to the input.</span>
        Func clamped<span class="hl opt">;</span>
        Expr x_clamped <span class="hl opt">=</span> <span class="hl kwd">clamp</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">()-</span><span class="hl num">1</span><span class="hl opt">);</span>
        Expr y_clamped <span class="hl opt">=</span> <span class="hl kwd">clamp</span><span class="hl opt">(</span>y<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">()-</span><span class="hl num">1</span><span class="hl opt">);</span>
        <span class="hl kwd">clamped</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) =</span> <span class="hl kwd">input</span><span class="hl opt">(</span>x_clamped<span class="hl opt">,</span> y_clamped<span class="hl opt">);</span>

        RDom <span class="hl kwd">box</span><span class="hl opt">(-</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">, -</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">5</span><span class="hl opt">);</span>
        <span class="hl slc">// Compute the local maximum minus the local minimum:</span>
        Func spread<span class="hl opt">;</span>
        <span class="hl kwd">spread</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) = (</span><span class="hl kwd">maximum</span><span class="hl opt">(</span><span class="hl kwd">clamped</span><span class="hl opt">(</span>x <span class="hl opt">+</span> box<span class="hl opt">.</span>x<span class="hl opt">,</span> y <span class="hl opt">+</span> box<span class="hl opt">.</span>y<span class="hl opt">)) -</span>
                        <span class="hl kwd">minimum</span><span class="hl opt">(</span><span class="hl kwd">clamped</span><span class="hl opt">(</span>x <span class="hl opt">+</span> box<span class="hl opt">.</span>x<span class="hl opt">,</span> y <span class="hl opt">+</span> box<span class="hl opt">.</span>y<span class="hl opt">)));</span>

        <span class="hl slc">// Compute the result in strips of 32 scanlines</span>
        Var yo<span class="hl opt">,</span> yi<span class="hl opt">;</span>
        spread<span class="hl opt">.</span><span class="hl kwd">split</span><span class="hl opt">(</span>y<span class="hl opt">,</span> yo<span class="hl opt">,</span> yi<span class="hl opt">,</span> <span class="hl num">32</span><span class="hl opt">).</span><span class="hl kwd">parallel</span><span class="hl opt">(</span>yo<span class="hl opt">);</span>

        <span class="hl slc">// Vectorize across x within the strips. This implicitly</span>
        <span class="hl slc">// vectorizes stuff that is computed within the loop over x in</span>
        <span class="hl slc">// spread, which includes our minimum and maximum helpers, so</span>
        <span class="hl slc">// they get vectorized too.</span>
        spread<span class="hl opt">.</span><span class="hl kwd">vectorize</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">16</span><span class="hl opt">);</span>

        <span class="hl slc">// We'll apply the boundary condition by padding each scanline</span>
        <span class="hl slc">// as we need it in a circular buffer (see lesson 08).</span>
        clamped<span class="hl opt">.</span><span class="hl kwd">store_at</span><span class="hl opt">(</span>spread<span class="hl opt">,</span> yo<span class="hl opt">).</span><span class="hl kwd">compute_at</span><span class="hl opt">(</span>spread<span class="hl opt">,</span> yi<span class="hl opt">);</span>

        Buffer<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;</span> halide_result <span class="hl opt">=</span> spread<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span>input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(),</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">());</span>

        <span class="hl slc">// The C equivalent is almost too horrible to contemplate (and</span>
        <span class="hl slc">// took me a long time to debug). This time I want to time</span>
        <span class="hl slc">// both the Halide version and the C version, so I'll use sse</span>
        <span class="hl slc">// intrinsics for the vectorization, and openmp to do the</span>
        <span class="hl slc">// parallel for loop (you'll need to compile with -fopenmp or</span>
        <span class="hl slc">// similar to get correct timing).</span>
        <span class="hl ppc">#ifdef __SSE2__</span>

        <span class="hl slc">// Don't include the time required to allocate the output buffer.</span>
        Buffer<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;</span> <span class="hl kwd">c_result</span><span class="hl opt">(</span>input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(),</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">());</span>

        <span class="hl ppc">#ifdef _OPENMP</span>
        <span class="hl kwb">double</span> t1 <span class="hl opt">=</span> <span class="hl kwd">current_time</span><span class="hl opt">();</span>
        <span class="hl ppc">#endif</span>

        <span class="hl slc">// Run this one hundred times so we can average the timing results.</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> iters <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> iters <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> iters<span class="hl opt">++) {</span>

            <span class="hl ppc">#pragma omp parallel for</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> yo <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> yo <span class="hl opt">&lt; (</span>input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">() +</span> <span class="hl num">31</span><span class="hl opt">)/</span><span class="hl num">32</span><span class="hl opt">;</span> yo<span class="hl opt">++) {</span>
                <span class="hl kwb">int</span> y_base <span class="hl opt">=</span> std<span class="hl opt">::</span><span class="hl kwd">min</span><span class="hl opt">(</span>yo <span class="hl opt">*</span> <span class="hl num">32</span><span class="hl opt">,</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">() -</span> <span class="hl num">32</span><span class="hl opt">);</span>

                <span class="hl slc">// Compute clamped in a circular buffer of size 8</span>
                <span class="hl slc">// (smallest power of two greater than 5). Each thread</span>
                <span class="hl slc">// needs its own allocation, so it must occur here.</span>

                <span class="hl kwb">int</span> clamped_width <span class="hl opt">=</span> input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">() +</span> <span class="hl num">4</span><span class="hl opt">;</span>
                <span class="hl kwb">uint8_t</span> <span class="hl opt">*</span>clamped_storage <span class="hl opt">= (</span><span class="hl kwb">uint8_t</span> <span class="hl opt">*)</span><span class="hl kwd">malloc</span><span class="hl opt">(</span>clamped_width <span class="hl opt">*</span> <span class="hl num">8</span><span class="hl opt">);</span>

                <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> yi <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> yi <span class="hl opt">&lt;</span> <span class="hl num">32</span><span class="hl opt">;</span> yi<span class="hl opt">++) {</span>
                    <span class="hl kwb">int</span> y <span class="hl opt">=</span> y_base <span class="hl opt">+</span> yi<span class="hl opt">;</span>

                    <span class="hl kwb">uint8_t</span> <span class="hl opt">*</span>output_row <span class="hl opt">= &amp;</span><span class="hl kwd">c_result</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> y<span class="hl opt">);</span>

                    <span class="hl slc">// Compute clamped for this scanline, skipping rows</span>
                    <span class="hl slc">// already computed within this slice.</span>
                    <span class="hl kwb">int</span> min_y_clamped <span class="hl opt">= (</span>yi <span class="hl opt">==</span> <span class="hl num">0</span><span class="hl opt">)</span> ? <span class="hl opt">(</span>y <span class="hl opt">-</span> <span class="hl num">2</span><span class="hl opt">) : (</span>y <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">);</span>
                    <span class="hl kwb">int</span> max_y_clamped <span class="hl opt">= (</span>y <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">);</span>
                    <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> cy <span class="hl opt">=</span> min_y_clamped<span class="hl opt">;</span> cy <span class="hl opt">&lt;=</span> max_y_clamped<span class="hl opt">;</span> cy<span class="hl opt">++) {</span>
                        <span class="hl slc">// Figure out which row of the circular buffer</span>
                        <span class="hl slc">// we're filling in using bitmasking:</span>
                        <span class="hl kwb">uint8_t</span> <span class="hl opt">*</span>clamped_row <span class="hl opt">=</span>
                            clamped_storage <span class="hl opt">+ (</span>cy <span class="hl opt">&amp;</span> <span class="hl num">7</span><span class="hl opt">) *</span> clamped_width<span class="hl opt">;</span>

                        <span class="hl slc">// Figure out which row of the input we're reading</span>
                        <span class="hl slc">// from by clamping the y coordinate:</span>
                        <span class="hl kwb">int</span> clamped_y <span class="hl opt">=</span> std<span class="hl opt">::</span><span class="hl kwd">min</span><span class="hl opt">(</span>std<span class="hl opt">::</span><span class="hl kwd">max</span><span class="hl opt">(</span>cy<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">),</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">()-</span><span class="hl num">1</span><span class="hl opt">);</span>
                        <span class="hl kwb">uint8_t</span> <span class="hl opt">*</span>input_row <span class="hl opt">= &amp;</span><span class="hl kwd">input</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> clamped_y<span class="hl opt">);</span>

                        <span class="hl slc">// Fill it in with the padding.</span>
                        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">= -</span><span class="hl num">2</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">() +</span> <span class="hl num">2</span><span class="hl opt">;</span> x<span class="hl opt">++) {</span>
                            <span class="hl kwb">int</span> clamped_x <span class="hl opt">=</span> std<span class="hl opt">::</span><span class="hl kwd">min</span><span class="hl opt">(</span>std<span class="hl opt">::</span><span class="hl kwd">max</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">),</span> input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">()-</span><span class="hl num">1</span><span class="hl opt">);</span>
                            <span class="hl opt">*</span>clamped_row<span class="hl opt">++ =</span> input_row<span class="hl opt">[</span>clamped_x<span class="hl opt">];</span>
                        <span class="hl opt">}</span>
                    <span class="hl opt">}</span>

                    <span class="hl slc">// Now iterate over vectors of x for the pure step of the output.</span>
                    <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x_vec <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x_vec <span class="hl opt">&lt; (</span>input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">() +</span> <span class="hl num">15</span><span class="hl opt">)/</span><span class="hl num">16</span><span class="hl opt">;</span> x_vec<span class="hl opt">++) {</span>
                        <span class="hl kwb">int</span> x_base <span class="hl opt">=</span> std<span class="hl opt">::</span><span class="hl kwd">min</span><span class="hl opt">(</span>x_vec <span class="hl opt">*</span> <span class="hl num">16</span><span class="hl opt">,</span> input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">() -</span> <span class="hl num">16</span><span class="hl opt">);</span>

                        <span class="hl slc">// Allocate storage for the minimum and maximum</span>
                        <span class="hl slc">// helpers. One vector is enough.</span>
                        __m128i minimum_storage<span class="hl opt">,</span> maximum_storage<span class="hl opt">;</span>

                        <span class="hl slc">// The pure step for the maximum is a vector of zeros</span>
                        maximum_storage <span class="hl opt">=</span> <span class="hl kwd">_mm_setzero_si128</span><span class="hl opt">();</span>

                        <span class="hl slc">// The update step for maximum</span>
                        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> max_y <span class="hl opt">=</span> y <span class="hl opt">-</span> <span class="hl num">2</span><span class="hl opt">;</span> max_y <span class="hl opt">&lt;=</span> y <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">;</span> max_y<span class="hl opt">++) {</span>
                            <span class="hl kwb">uint8_t</span> <span class="hl opt">*</span>clamped_row <span class="hl opt">=</span>
                                clamped_storage <span class="hl opt">+ (</span>max_y <span class="hl opt">&amp;</span> <span class="hl num">7</span><span class="hl opt">) *</span> clamped_width<span class="hl opt">;</span>
                            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> max_x <span class="hl opt">=</span> x_base <span class="hl opt">-</span> <span class="hl num">2</span><span class="hl opt">;</span> max_x <span class="hl opt">&lt;=</span> x_base <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">;</span> max_x<span class="hl opt">++) {</span>
                                __m128i v <span class="hl opt">=</span> <span class="hl kwd">_mm_loadu_si128</span><span class="hl opt">(</span>
                                    <span class="hl opt">(</span>__m128i <span class="hl kwb">const</span> <span class="hl opt">*)(</span>clamped_row <span class="hl opt">+</span> max_x <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">));</span>
                                maximum_storage <span class="hl opt">=</span> <span class="hl kwd">_mm_max_epu8</span><span class="hl opt">(</span>maximum_storage<span class="hl opt">,</span> v<span class="hl opt">);</span>
                            <span class="hl opt">}</span>
                        <span class="hl opt">}</span>

                        <span class="hl slc">// The pure step for the minimum is a vector of</span>
                        <span class="hl slc">// ones. Create it by comparing something to</span>
                        <span class="hl slc">// itself.</span>
                        minimum_storage <span class="hl opt">=</span> <span class="hl kwd">_mm_cmpeq_epi32</span><span class="hl opt">(</span><span class="hl kwd">_mm_setzero_si128</span><span class="hl opt">(),</span>
                                                          <span class="hl kwd">_mm_setzero_si128</span><span class="hl opt">());</span>

                        <span class="hl slc">// The update step for minimum.</span>
                        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> min_y <span class="hl opt">=</span> y <span class="hl opt">-</span> <span class="hl num">2</span><span class="hl opt">;</span> min_y <span class="hl opt">&lt;=</span> y <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">;</span> min_y<span class="hl opt">++) {</span>
                            <span class="hl kwb">uint8_t</span> <span class="hl opt">*</span>clamped_row <span class="hl opt">=</span>
                                clamped_storage <span class="hl opt">+ (</span>min_y <span class="hl opt">&amp;</span> <span class="hl num">7</span><span class="hl opt">) *</span> clamped_width<span class="hl opt">;</span>
                            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> min_x <span class="hl opt">=</span> x_base <span class="hl opt">-</span> <span class="hl num">2</span><span class="hl opt">;</span> min_x <span class="hl opt">&lt;=</span> x_base <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">;</span> min_x<span class="hl opt">++) {</span>
                                __m128i v <span class="hl opt">=</span> <span class="hl kwd">_mm_loadu_si128</span><span class="hl opt">(</span>
                                    <span class="hl opt">(</span>__m128i <span class="hl kwb">const</span> <span class="hl opt">*)(</span>clamped_row <span class="hl opt">+</span> min_x <span class="hl opt">+</span> <span class="hl num">2</span><span class="hl opt">));</span>
                                minimum_storage <span class="hl opt">=</span> <span class="hl kwd">_mm_min_epu8</span><span class="hl opt">(</span>minimum_storage<span class="hl opt">,</span> v<span class="hl opt">);</span>
                            <span class="hl opt">}</span>
                        <span class="hl opt">}</span>

                        <span class="hl slc">// Now compute the spread.</span>
                        __m128i spread <span class="hl opt">=</span> <span class="hl kwd">_mm_sub_epi8</span><span class="hl opt">(</span>maximum_storage<span class="hl opt">,</span> minimum_storage<span class="hl opt">);</span>

                        <span class="hl slc">// Store it.</span>
                        <span class="hl kwd">_mm_storeu_si128</span><span class="hl opt">((</span>__m128i <span class="hl opt">*)(</span>output_row <span class="hl opt">+</span> x_base<span class="hl opt">),</span> spread<span class="hl opt">);</span>

                    <span class="hl opt">}</span>
                <span class="hl opt">}</span>

                <span class="hl kwd">free</span><span class="hl opt">(</span>clamped_storage<span class="hl opt">);</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// Skip the timing comparison if we don't have openmp</span>
        <span class="hl slc">// enabled. Otherwise it's unfair to C.</span>
        <span class="hl ppc">#ifdef _OPENMP</span>
        <span class="hl kwb">double</span> t2 <span class="hl opt">=</span> <span class="hl kwd">current_time</span><span class="hl opt">();</span>

        <span class="hl slc">// Now run the Halide version again without the</span>
        <span class="hl slc">// jit-compilation overhead. Also run it one hundred times.</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> iters <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> iters <span class="hl opt">&lt;</span> <span class="hl num">100</span><span class="hl opt">;</span> iters<span class="hl opt">++) {</span>
            spread<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span>halide_result<span class="hl opt">);</span>
        <span class="hl opt">}</span>

        <span class="hl kwb">double</span> t3 <span class="hl opt">=</span> <span class="hl kwd">current_time</span><span class="hl opt">();</span>

        <span class="hl slc">// Report the timings. On my machine they both take about 3ms</span>
        <span class="hl slc">// for the 4-megapixel input (fast!), which makes sense,</span>
        <span class="hl slc">// because they're using the same vectorization and</span>
        <span class="hl slc">// parallelization strategy. However I find the Halide easier</span>
        <span class="hl slc">// to read, write, debug, modify, and port.</span>
        <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Halide spread took %f ms. C equivalent took %f ms</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
               <span class="hl opt">(</span>t3 <span class="hl opt">-</span> t2<span class="hl opt">)/</span><span class="hl num">100</span><span class="hl opt">, (</span>t2 <span class="hl opt">-</span> t1<span class="hl opt">)/</span><span class="hl num">100</span><span class="hl opt">);</span>

        <span class="hl ppc">#endif</span> <span class="hl slc">// _OPENMP</span>
<span class="hl ppc"></span>
        <span class="hl slc">// Check the results match:</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> y <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> y <span class="hl opt">&lt;</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">();</span> y<span class="hl opt">++) {</span>
            <span class="hl kwa">for</span> <span class="hl opt">(</span><span class="hl kwb">int</span> x <span class="hl opt">=</span> <span class="hl num">0</span><span class="hl opt">;</span> x <span class="hl opt">&lt;</span> input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">();</span> x<span class="hl opt">++) {</span>
                <span class="hl kwa">if</span> <span class="hl opt">(</span><span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">) !=</span> <span class="hl kwd">c_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">)) {</span>
                    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;halide_result(%d, %d) = %d instead of %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">,</span>
                           x<span class="hl opt">,</span> y<span class="hl opt">,</span> <span class="hl kwd">halide_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">),</span> <span class="hl kwd">c_result</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">));</span>
                    <span class="hl kwa">return</span> <span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">;</span>
                <span class="hl opt">}</span>
            <span class="hl opt">}</span>
        <span class="hl opt">}</span>

        <span class="hl ppc">#endif</span> <span class="hl slc">// __SSE2__</span>
<span class="hl ppc"></span>
    <span class="hl opt">}</span>

    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Success!</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre>
</div></body></html>
