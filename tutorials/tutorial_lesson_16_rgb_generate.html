<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>
 RGB images and memory layouts part 1
</title>
<link rel="stylesheet" type="text/css" href="../assets/css/highlight.css">
<style>

a:visited {
color: #000000;
}

a:link {
color: #000000;
}

a:hover {
color: #aa0000;
}

</style>
</head>
<body class="hl" style="background-color: #444444; font-family: Helvetica, Arial, sans-serif;">
<script>
function toggle(id) {
    e = document.getElementById(id);
    show = document.getElementById(id + '-show');
    if (e.style.display != 'none') {
        e.style.display = 'none';
        show.innerHTML = "// Click to show output ...";
    } else {
        e.style.display = 'block';
        show.innerHTML = "// Click to hide output ...";
    }
    return false;
}
</script>
<div>
<style scoped>
@import "../assets/css/bootstrap.css";
</style>
<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="/index.html">Halide</a>
      <div class="nav-collapse">
        <ul class="nav">
          <li><a href="/index.html#gettingstarted">Getting Started</a></li>
          <li><a href="/tutorials/tutorial_introduction.html">Tutorials</a></li>
          <li><a href="/index.html#publications">Publications</a></li>
          <li><a href="/index.html#resources">Resources</a></li>
          <li class="divider-vertical"></li>
          <li><a href="/docs">Docs</a></li>
          <li><a href="http://github.com/halide/Halide/issues">Bugs</a></li>
          <li><a href="http://github.com/halide/Halide/wiki">Wiki</a></li>
          <li class="divider-vertical"></li>
          <li><a href="http://stackoverflow.com/questions/tagged/halide"><i class="fa fa-stack-overflow"></i>/#halide</a></li>
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>
</div>

<div style='position:relative; width:900pt; top:60px;'>
<div style="width:200px; float:left; ">
<a href="tutorial_introduction.html" style="text-decoration:none;" ><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px;
background-color: #dddddd; 
text-align: left; ">
<b>
00
&nbsp</b>
Introduction
</div>
</span>
</a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_01_basics.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
01
&nbsp</b>
 Getting started with Funcs, Vars, and Exprs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_02_input_image.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
02
&nbsp</b>
 Processing images
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_03_debugging_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
03
&nbsp</b>
 Inspecting the generated code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_04_debugging_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
04
&nbsp</b>
 Debugging with tracing, print, and print_when
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_05_scheduling_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
05
&nbsp</b>
 Vectorize, parallelize, unroll and tile your code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_06_realizing_over_shifted_domains.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
06
&nbsp</b>
 Realizing Funcs over arbitrary domains
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_07_multi_stage_pipelines.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
07
&nbsp</b>
 Multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_08_scheduling_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
08
&nbsp</b>
 Scheduling multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_09_update_definitions.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
09
&nbsp</b>
 Multi-pass Funcs, update definitions, and reductions
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_11_cross_compilation.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
11
&nbsp</b>
 Cross-compilation
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_12_using_the_gpu.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
12
&nbsp</b>
 Using the GPU
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_13_tuples.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
13
&nbsp</b>
 Tuples
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_14_types.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
14
&nbsp</b>
 The Halide type system
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_15_generators.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
15
&nbsp</b>
 Generators part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_15_generators_usage.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
15
&nbsp</b>
 Generators part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_16_rgb_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; padding-right:40px; background-color: #ffffff; color: #000000; text-align: left; ">
<b>
16
&nbsp</b>
 RGB images and memory layouts part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_16_rgb_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
16
&nbsp</b>
 RGB images and memory layouts part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_17_predicated_rdom.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
17
&nbsp</b>
 Reductions over non-rectangular domains
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_18_parallel_associative_reductions.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
18
&nbsp</b>
 Factoring an associative reduction using rfactor
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_19_wrapper_funcs.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
19
&nbsp</b>
 Wrapper Funcs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_20_cloning_funcs.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
20
&nbsp</b>
 Cloning Funcs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_21_auto_scheduler_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
21
&nbsp</b>
 Auto-Scheduler
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_21_auto_scheduler_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
21
&nbsp</b>
 Auto-Scheduler
</div></span></a>
</div>
<div style="position:relative; margin-left:260px; padding:20px; background-color: #ffffff;">
<pre class="hl">
<span class="hl slc">// Halide tutorial lesson 16: RGB images and memory layouts part 1</span>

<span class="hl slc">// This lesson demonstrates how to feed Halide RGB images in</span>
<span class="hl slc">// interleaved or planar format, and how to write code optimized for</span>
<span class="hl slc">// each case.</span>

<span class="hl slc">// On linux or os x, you can compile and run it like so:</span>

<span class="hl slc">// g++ lesson_16_rgb_generate.cpp ../tools/GenGen.cpp -g -std=c++11 -fno-rtti -I ../include -L ../bin -lHalide -lpthread -ldl -o lesson_16_generate</span>
<span class="hl slc">// export LD_LIBRARY_PATH=../bin   # For linux</span>
<span class="hl slc">// export DYLD_LIBRARY_PATH=../bin # For OS X</span>
<span class="hl slc">// ./lesson_16_generate -o . -f brighten_planar      target=host layout=planar</span>
<span class="hl slc">// ./lesson_16_generate -o . -f brighten_interleaved target=host layout=interleaved</span>
<span class="hl slc">// ./lesson_16_generate -o . -f brighten_either      target=host layout=either</span>
<span class="hl slc">// ./lesson_16_generate -o . -f brighten_specialized target=host layout=specialized</span>
<span class="hl slc">// g++ lesson_16_rgb_run.cpp brighten_*.o -ldl -lpthread -o lesson_16_run</span>
<span class="hl slc">// ./lesson_16_run</span>

<span class="hl slc">// If you have the entire Halide source tree, you can also build it by</span>
<span class="hl slc">// running:</span>
<span class="hl slc">//    make tutorial_lesson_16_rgb_run</span>
<span class="hl slc">// in a shell with the current directory at the top of the halide</span>
<span class="hl slc">// source tree.</span>

<span class="hl ppc">#include</span> <span class="hl pps">&quot;Halide.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;stdio.h&gt;</span>

<span class="hl kwa">using namespace</span> Halide<span class="hl opt">;</span>

<span class="hl slc">// We will define a generator that brightens an RGB image.</span>
<span class="hl kwc">class</span> Brighten <span class="hl opt">:</span> <span class="hl kwc">public Halide</span><span class="hl opt">::</span>Generator<span class="hl opt">&lt;</span>Brighten<span class="hl opt">&gt; {</span>
<span class="hl kwc">public</span><span class="hl opt">:</span>
    <span class="hl slc">// We declare a three-dimensional input image. The first two</span>
    <span class="hl slc">// dimensions will be x, and y, and the third dimension will be</span>
    <span class="hl slc">// the color channel.</span>
    Input<span class="hl opt">&lt;</span>Buffer<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;&gt;</span> input<span class="hl opt">{</span><span class="hl str">&quot;input&quot;</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">};</span>

    <span class="hl slc">// We will compile this generator in several ways to accept</span>
    <span class="hl slc">// several different memory layouts for the input and output. This</span>
    <span class="hl slc">// is a good use of a GeneratorParam (see lesson 15).</span>
    <span class="hl kwb">enum</span> <span class="hl kwc">class</span> Layout <span class="hl opt">{</span> Planar<span class="hl opt">,</span> Interleaved<span class="hl opt">,</span> Either<span class="hl opt">,</span> Specialized <span class="hl opt">};</span>
    GeneratorParam<span class="hl opt">&lt;</span>Layout<span class="hl opt">&gt;</span> layout<span class="hl opt">{</span><span class="hl str">&quot;layout&quot;</span><span class="hl opt">,</span>
            <span class="hl slc">// default value</span>
            <span class="hl kwc">Layout</span><span class="hl opt">::</span>Planar<span class="hl opt">,</span>
            <span class="hl slc">// map from names to values</span>
                <span class="hl opt">{{</span> <span class="hl str">&quot;planar&quot;</span><span class="hl opt">,</span>        <span class="hl kwc">Layout</span><span class="hl opt">::</span>Planar <span class="hl opt">},</span>
                 <span class="hl opt">{</span> <span class="hl str">&quot;interleaved&quot;</span><span class="hl opt">,</span>   <span class="hl kwc">Layout</span><span class="hl opt">::</span>Interleaved <span class="hl opt">},</span>
                 <span class="hl opt">{</span> <span class="hl str">&quot;either&quot;</span><span class="hl opt">,</span>        <span class="hl kwc">Layout</span><span class="hl opt">::</span>Either <span class="hl opt">},</span>
                 <span class="hl opt">{</span> <span class="hl str">&quot;specialized&quot;</span><span class="hl opt">,</span>   <span class="hl kwc">Layout</span><span class="hl opt">::</span>Specialized <span class="hl opt">}}};</span>

    <span class="hl slc">// We also declare a scalar input to control the amount of</span>
    <span class="hl slc">// brightening.</span>
    Input<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;</span> offset<span class="hl opt">{</span><span class="hl str">&quot;offset&quot;</span><span class="hl opt">};</span>

    <span class="hl slc">// Declare our outputs</span>
    Output<span class="hl opt">&lt;</span>Buffer<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;&gt;</span> brighter<span class="hl opt">{</span><span class="hl str">&quot;brighter&quot;</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">};</span>

    <span class="hl slc">// Declare our Vars</span>
    Var x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">;</span>

    <span class="hl kwb">void</span> <span class="hl kwd">generate</span><span class="hl opt">() {</span>
        <span class="hl slc">// Define the Func.</span>
        <span class="hl kwd">brighter</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) =</span> <span class="hl kwd">input</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) +</span> offset<span class="hl opt">;</span>

        <span class="hl slc">// Schedule it.</span>
        brighter<span class="hl opt">.</span><span class="hl kwd">vectorize</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">16</span><span class="hl opt">);</span>

        <span class="hl slc">// We will compile this pipeline to handle memory layouts in</span>
        <span class="hl slc">// several different ways, depending on the &apos;layout&apos; generator</span>
        <span class="hl slc">// param.</span>
        <span class="hl kwa">if</span> <span class="hl opt">(</span>layout <span class="hl opt">==</span> <span class="hl kwc">Layout</span><span class="hl opt">::</span>Planar<span class="hl opt">) {</span>
            <span class="hl slc">// This pipeline as written will only work with images in</span>
            <span class="hl slc">// which each scanline is densely-packed single color</span>
            <span class="hl slc">// channel. In terms of the strides described in lesson</span>
            <span class="hl slc">// 10, Halide assumes and asserts that the stride in x is</span>
            <span class="hl slc">// one.</span>

            <span class="hl slc">// This constraint permits planar images, where the red,</span>
            <span class="hl slc">// green, and blue channels are laid out in memory like</span>
            <span class="hl slc">// this:</span>

            <span class="hl slc">// RRRRRRRR</span>
            <span class="hl slc">// RRRRRRRR</span>
            <span class="hl slc">// RRRRRRRR</span>
            <span class="hl slc">// RRRRRRRR</span>
            <span class="hl slc">// GGGGGGGG</span>
            <span class="hl slc">// GGGGGGGG</span>
            <span class="hl slc">// GGGGGGGG</span>
            <span class="hl slc">// GGGGGGGG</span>
            <span class="hl slc">// BBBBBBBB</span>
            <span class="hl slc">// BBBBBBBB</span>
            <span class="hl slc">// BBBBBBBB</span>
            <span class="hl slc">// BBBBBBBB</span>

            <span class="hl slc">// It also works with the less-commonly used line-by-line</span>
            <span class="hl slc">// layout, in which scanlines of red, green, and blue</span>
            <span class="hl slc">// alternate.</span>

            <span class="hl slc">// RRRRRRRR</span>
            <span class="hl slc">// GGGGGGGG</span>
            <span class="hl slc">// BBBBBBBB</span>
            <span class="hl slc">// RRRRRRRR</span>
            <span class="hl slc">// GGGGGGGG</span>
            <span class="hl slc">// BBBBBBBB</span>
            <span class="hl slc">// RRRRRRRR</span>
            <span class="hl slc">// GGGGGGGG</span>
            <span class="hl slc">// BBBBBBBB</span>
            <span class="hl slc">// RRRRRRRR</span>
            <span class="hl slc">// GGGGGGGG</span>
            <span class="hl slc">// BBBBBBBB</span>

        <span class="hl opt">}</span> <span class="hl kwa">else if</span> <span class="hl opt">(</span>layout <span class="hl opt">==</span> <span class="hl kwc">Layout</span><span class="hl opt">::</span>Interleaved<span class="hl opt">) {</span>
            <span class="hl slc">// Another common format is &apos;interleaved&apos;, in which the</span>
            <span class="hl slc">// red, green, and blue values for each pixel occur next</span>
            <span class="hl slc">// to each other in memory:</span>

            <span class="hl slc">// RGBRGBRGBRGBRGBRGBRGBRGB</span>
            <span class="hl slc">// RGBRGBRGBRGBRGBRGBRGBRGB</span>
            <span class="hl slc">// RGBRGBRGBRGBRGBRGBRGBRGB</span>
            <span class="hl slc">// RGBRGBRGBRGBRGBRGBRGBRGB</span>

            <span class="hl slc">// In this case the stride in x is three, the stride in y</span>
            <span class="hl slc">// is three times the width of the image, and the stride</span>
            <span class="hl slc">// in c is one. We can tell Halide to assume (and assert)</span>
            <span class="hl slc">// that this is the case for the input and output like so:</span>

            input
                <span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">).</span><span class="hl kwd">set_stride</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">)</span> <span class="hl slc">// stride in dimension 0 (x) is three</span>
                <span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">).</span><span class="hl kwd">set_stride</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span> <span class="hl slc">// stride in dimension 2 (c) is one</span>

            brighter
                <span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">).</span><span class="hl kwd">set_stride</span><span class="hl opt">(</span><span class="hl num">3</span><span class="hl opt">)</span>
                <span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">).</span><span class="hl kwd">set_stride</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">);</span>

            <span class="hl slc">// For interleaved layout, you may want to use a different</span>
            <span class="hl slc">// schedule. We&apos;ll tell Halide to additionally assume and</span>
            <span class="hl slc">// assert that there are three color channels, then</span>
            <span class="hl slc">// exploit this fact to make the loop over &apos;c&apos; innermost</span>
            <span class="hl slc">// and unrolled.</span>

            input<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">).</span><span class="hl kwd">set_bounds</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">);</span> <span class="hl slc">// Dimension 2 (c) starts at 0 and has extent 3.</span>
            brighter<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">).</span><span class="hl kwd">set_bounds</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">);</span>

            <span class="hl slc">// Move the loop over color channels innermost and unroll</span>
            <span class="hl slc">// it.</span>
            brighter<span class="hl opt">.</span><span class="hl kwd">reorder</span><span class="hl opt">(</span>c<span class="hl opt">,</span> x<span class="hl opt">,</span> y<span class="hl opt">).</span><span class="hl kwd">unroll</span><span class="hl opt">(</span>c<span class="hl opt">);</span>

            <span class="hl slc">// Note that if we were dealing with an image with an</span>
            <span class="hl slc">// alpha channel (RGBA), then the stride in x and the</span>
            <span class="hl slc">// bounds of the channels dimension would both be four</span>
            <span class="hl slc">// instead of three.</span>

        <span class="hl opt">}</span> <span class="hl kwa">else if</span> <span class="hl opt">(</span>layout <span class="hl opt">==</span> <span class="hl kwc">Layout</span><span class="hl opt">::</span>Either<span class="hl opt">) {</span>
            <span class="hl slc">// We can also remove all constraints and compile a</span>
            <span class="hl slc">// pipeline that will work with any memory layout. It will</span>
            <span class="hl slc">// probably be slow, because all vector loads become</span>
            <span class="hl slc">// gathers, and all vector stores become scatters.</span>
            input<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">).</span><span class="hl kwd">set_stride</span><span class="hl opt">(</span><span class="hl kwd">Expr</span><span class="hl opt">());</span> <span class="hl slc">// Use a default-constructed</span>
                                             <span class="hl slc">// undefined Expr to mean</span>
                                             <span class="hl slc">// there is no constraint.</span>

            brighter<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">).</span><span class="hl kwd">set_stride</span><span class="hl opt">(</span><span class="hl kwd">Expr</span><span class="hl opt">());</span>

        <span class="hl opt">}</span> <span class="hl kwa">else if</span> <span class="hl opt">(</span>layout <span class="hl opt">==</span> <span class="hl kwc">Layout</span><span class="hl opt">::</span>Specialized<span class="hl opt">) {</span>
            <span class="hl slc">// We can accept any memory layout with good performance</span>
            <span class="hl slc">// by telling Halide to inspect the memory layout at</span>
            <span class="hl slc">// runtime, and branch to different code depending on the</span>
            <span class="hl slc">// strides it find. First we relax the default constraint</span>
            <span class="hl slc">// that dim(0).stride() == 1:</span>

            input<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">).</span><span class="hl kwd">set_stride</span><span class="hl opt">(</span><span class="hl kwd">Expr</span><span class="hl opt">());</span> <span class="hl slc">// Use an undefined Expr to</span>
                                             <span class="hl slc">// mean there is no</span>
                                             <span class="hl slc">// constraint.</span>

            brighter<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">).</span><span class="hl kwd">set_stride</span><span class="hl opt">(</span><span class="hl kwd">Expr</span><span class="hl opt">());</span>

            <span class="hl slc">// The we construct boolean Exprs that detect at runtime</span>
            <span class="hl slc">// whether we&apos;re planar or interleaved. The conditions</span>
            <span class="hl slc">// should check for all the facts we want to exploit in</span>
            <span class="hl slc">// each case.</span>
            Expr input_is_planar <span class="hl opt">=</span>
                <span class="hl opt">(</span>input<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">).</span><span class="hl kwd">stride</span><span class="hl opt">() ==</span> <span class="hl num">1</span><span class="hl opt">);</span>
            Expr input_is_interleaved <span class="hl opt">=</span>
                <span class="hl opt">(</span>input<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">).</span><span class="hl kwd">stride</span><span class="hl opt">() ==</span> <span class="hl num">3</span> <span class="hl opt">&amp;&amp;</span>
                 input<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">).</span><span class="hl kwd">stride</span><span class="hl opt">() ==</span> <span class="hl num">1</span> <span class="hl opt">&amp;&amp;</span>
                 input<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">).</span><span class="hl kwd">extent</span><span class="hl opt">() ==</span> <span class="hl num">3</span><span class="hl opt">);</span>

            Expr output_is_planar <span class="hl opt">=</span>
                <span class="hl opt">(</span>brighter<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">).</span><span class="hl kwd">stride</span><span class="hl opt">() ==</span> <span class="hl num">1</span><span class="hl opt">);</span>
            Expr output_is_interleaved <span class="hl opt">=</span>
                <span class="hl opt">(</span>brighter<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">).</span><span class="hl kwd">stride</span><span class="hl opt">() ==</span> <span class="hl num">3</span> <span class="hl opt">&amp;&amp;</span>
                 brighter<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">).</span><span class="hl kwd">stride</span><span class="hl opt">() ==</span> <span class="hl num">1</span> <span class="hl opt">&amp;&amp;</span>
                 brighter<span class="hl opt">.</span><span class="hl kwd">dim</span><span class="hl opt">(</span><span class="hl num">2</span><span class="hl opt">).</span><span class="hl kwd">extent</span><span class="hl opt">() ==</span> <span class="hl num">3</span><span class="hl opt">);</span>

            <span class="hl slc">// We can then use Func::specialize to write a schedule</span>
            <span class="hl slc">// that switches at runtime to specialized code based on a</span>
            <span class="hl slc">// boolean Expr. That code will exploit the fact that the</span>
            <span class="hl slc">// Expr is known to be true.</span>
            brighter<span class="hl opt">.</span><span class="hl kwd">specialize</span><span class="hl opt">(</span>input_is_planar <span class="hl opt">&amp;&amp;</span> output_is_planar<span class="hl opt">);</span>

            <span class="hl slc">// We&apos;ve already vectorized and parallelized brighter, and</span>
            <span class="hl slc">// our two specializations will inherit those scheduling</span>
            <span class="hl slc">// directives. We can also add additional scheduling</span>
            <span class="hl slc">// directives that apply to a single specialization</span>
            <span class="hl slc">// only. We&apos;ll tell Halide to make a specialized version</span>
            <span class="hl slc">// of the code for interleaved layouts, and to reorder and</span>
            <span class="hl slc">// unroll that specialized code.</span>
            brighter<span class="hl opt">.</span><span class="hl kwd">specialize</span><span class="hl opt">(</span>input_is_interleaved <span class="hl opt">&amp;&amp;</span> output_is_interleaved<span class="hl opt">)</span>
                <span class="hl opt">.</span><span class="hl kwd">reorder</span><span class="hl opt">(</span>c<span class="hl opt">,</span> x<span class="hl opt">,</span> y<span class="hl opt">).</span><span class="hl kwd">unroll</span><span class="hl opt">(</span>c<span class="hl opt">);</span>

            <span class="hl slc">// We could also add specializations for if the input is</span>
            <span class="hl slc">// interleaved and the output is planar, and vice versa,</span>
            <span class="hl slc">// but two specializations is enough to demonstrate the</span>
            <span class="hl slc">// feature. A later tutorial will explore more creative</span>
            <span class="hl slc">// uses of Func::specialize.</span>

            <span class="hl slc">// Adding specializations can improve performance</span>
            <span class="hl slc">// substantially for the cases they apply to, but it also</span>
            <span class="hl slc">// increases the amount of code to compile and ship. If</span>
            <span class="hl slc">// binary sizes are a concern and the input and output</span>
            <span class="hl slc">// memory layouts are known, you probably want to use</span>
            <span class="hl slc">// set_stride and set_extent instead.</span>
        <span class="hl opt">}</span>
    <span class="hl opt">}</span>
<span class="hl opt">};</span>

<span class="hl slc">// As in lesson 15, we register our generator and then compile this</span>
<span class="hl slc">// file along with tools/GenGen.cpp.</span>
<span class="hl kwd">HALIDE_REGISTER_GENERATOR</span><span class="hl opt">(</span>Brighten<span class="hl opt">,</span> brighten<span class="hl opt">)</span>

<span class="hl slc">// After compiling this file, see how to use it in</span>
<span class="hl slc">// lesson_16_rgb_run.cpp</span>
</pre>
</div></body></html>
