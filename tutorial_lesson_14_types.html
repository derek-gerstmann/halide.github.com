<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>
lesson 14 types
</title>
<link rel="stylesheet" type="text/css" href="highlight.css">
<link href="../assets/css/bootstrap.css" rel="stylesheet">
<style>

a:visited {
color: #000000;
}

a:link {
color: #000000;
}

a:hover {
color: #aa0000;
}

</style>
</head>
<body class="hl" style="background-color: #dddddd; font-family: Helvetica, Arial, sans-serif;">
<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="#">Halide</a>
      <div class="nav-collapse">
        <ul class="nav">
          <li class="active"><a href="#overview">Overview</a></li>
          <li><a href="#gettingstarted">Getting Started</a></li>
          <li><a href="#publications">Publications</a></li>
          <li><a href="#resources">Resources</a></li>
          <li class="divider-vertical"></li>
          <li><a href="/docs">Docs</a></li>
          <li><a href="http://github.com/halide/Halide/issues">Bugs</a></li>
          <li><a href="http://github.com/halide/Halide/wiki">Wiki</a></li>
          <li class="divider-vertical"></li>
          <li><a href="http://stackoverflow.com/questions/tagged/halide"><i class="fa fa-stack-overflow"></i>/#halide</a></li>
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>
<div style="position:relative; width: 100%">
<div style="width:200px; float:left; ">
<a href="introduction.html" style="text-decoration:none;" ><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px;
background-color: #ffffff; text-align: left; ">
<b>
00
&nbsp</b>
Introduction
</div>
</span>
</a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_01_basics.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
01
&nbsp</b>
 Getting started with Funcs, Vars, and Exprs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_02_input_image.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
02
&nbsp</b>
 Processing images
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_03_debugging_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
03
&nbsp</b>
 Inspecting the generated code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_04_debugging_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
04
&nbsp</b>
 Debugging with tracing, print, and print_when
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_05_scheduling_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
05
&nbsp</b>
 Vectorize, parallelize, unroll and tile your code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_06_realizing_over_shifted_domains.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
06
&nbsp</b>
 Realizing Funcs over arbitrary domains
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_07_multi_stage_pipelines.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
07
&nbsp</b>
 Multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_08_scheduling_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
08
&nbsp</b>
 Scheduling multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_09_update_definitions.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
09
&nbsp</b>
 Multi-pass Funcs, update definitions, and reductions
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_11_cross_compilation.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
11
&nbsp</b>
 Cross-compilation
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_12_using_the_gpu.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
12
&nbsp</b>
 Using the GPU
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_13_tuples.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #ffffff; text-align: left; ">
<b>
13
&nbsp</b>
 Tuples
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_14_types.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; padding-right:40px; background-color: #ffffff; color: #aa0000; text-align: left; ">
<b>
14
&nbsp</b>
 The Halide type system
</div></span></a>
</div>
<div style="position:relative; margin-left:260px; padding:20px; background-color: #ffffff;">
<pre class="hl">
<span class="hl slc">// Halide tutorial lesson 14: The Halide type system</span>

<span class="hl slc">// This lesson more precisely describes Halide's type system.</span>

<span class="hl slc">// On linux, you can compile and run it like so:</span>
<span class="hl slc">// g++ lesson_14*.cpp -g -I ../include -L ../bin -lHalide -lpthread -ldl -o lesson_14 -std=c++11</span>
<span class="hl slc">// LD_LIBRARY_PATH=../bin ./lesson_14</span>

<span class="hl slc">// On os x:</span>
<span class="hl slc">// g++ lesson_14*.cpp -g -I ../include -L ../bin -lHalide -o lesson_14 -std=c++11</span>
<span class="hl slc">// DYLD_LIBRARY_PATH=../bin ./lesson_14</span>

<span class="hl slc">// If you have the entire Halide source tree, you can also build it by</span>
<span class="hl slc">// running:</span>
<span class="hl slc">//    make tutorial_lesson_14_types</span>
<span class="hl slc">// in a shell with the current directory at the top of the halide</span>
<span class="hl slc">// source tree.</span>

<span class="hl ppc">#include</span> <span class="hl pps">&quot;Halide.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;stdio.h&gt;</span>
<span class="hl kwa">using namespace</span> Halide<span class="hl opt">;</span>

<span class="hl slc">// This function is used to demonstrate generic code at the end of</span>
<span class="hl slc">// this lesson.</span>
Expr <span class="hl kwd">average</span><span class="hl opt">(</span>Expr a<span class="hl opt">,</span> Expr b<span class="hl opt">);</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span> <span class="hl opt">**</span>argv<span class="hl opt">) {</span>

    <span class="hl slc">// All Exprs have a scalar type, and all Funcs evaluate to one or</span>
    <span class="hl slc">// more scalar types. The scalar types in Halide are unsigned</span>
    <span class="hl slc">// integers of various bit widths, signed integers of the same set</span>
    <span class="hl slc">// of bit widths, floating point numbers in single and double</span>
    <span class="hl slc">// precision, and opaque handles (equivalent to void *). The</span>
    <span class="hl slc">// following array contains all the legal types.</span>

    Type valid_halide_types<span class="hl opt">[] = {</span>
        <span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">),</span> <span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">16</span><span class="hl opt">),</span> <span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">),</span> <span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">64</span><span class="hl opt">),</span>
        <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">),</span> <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">16</span><span class="hl opt">),</span> <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">),</span> <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">64</span><span class="hl opt">),</span>
        <span class="hl kwd">Float</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">),</span> <span class="hl kwd">Float</span><span class="hl opt">(</span><span class="hl num">64</span><span class="hl opt">),</span> <span class="hl kwd">Handle</span><span class="hl opt">()</span>
    <span class="hl opt">};</span>

    <span class="hl slc">// Constructing and inspecting types.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// You can programmatically examine the properties of a Halide</span>
        <span class="hl slc">// type. This is useful when you write a C++ function that has</span>
        <span class="hl slc">// Expr arguments and you wish to check their types:</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">).</span>bits <span class="hl opt">==</span> <span class="hl num">8</span><span class="hl opt">);</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">).</span><span class="hl kwd">is_int</span><span class="hl opt">());</span>

        <span class="hl slc">// You can also programmatically construct Types as a function of other Types.</span>
        Type t <span class="hl opt">=</span> <span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">);</span>
        t<span class="hl opt">.</span>bits <span class="hl opt">*=</span> <span class="hl num">2</span><span class="hl opt">;</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>t <span class="hl opt">==</span> <span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">16</span><span class="hl opt">));</span>

        <span class="hl slc">// Or construct a Type from a C++ scalar type</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>type_of<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;() ==</span> <span class="hl kwd">Float</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>

        <span class="hl slc">// The Type struct is also capable of representing vector types,</span>
        <span class="hl slc">// but this is reserved for Halide's internal use. You should</span>
        <span class="hl slc">// vectorize code by using Func::vectorize, not by attempting to</span>
        <span class="hl slc">// construct vector expressions directly. You may encounter vector</span>
        <span class="hl slc">// types if you programmatically manipulate lowered Halide code,</span>
        <span class="hl slc">// but this is an advanced topic (see Func::add_custom_lowering_pass).</span>

        <span class="hl slc">// You can query any Halide Expr for its type. An Expr</span>
        <span class="hl slc">// representing a Var has type Int(32):</span>
        Var x<span class="hl opt">;</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">Expr</span><span class="hl opt">(</span>x<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>

        <span class="hl slc">// Most transcendental functions in Halide cast their inputs to a</span>
        <span class="hl slc">// Float(32) and return a Float(32):</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">sin</span><span class="hl opt">(</span>x<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Float</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>

        <span class="hl slc">// You can cast an Expr from one Type to another using the cast operator:</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">cast</span><span class="hl opt">(</span><span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">),</span> x<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">));</span>

        <span class="hl slc">// This also comes in a template form that takes a C++ type.</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>cast<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;(</span>x<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">));</span>

        <span class="hl slc">// You can also query any defined Func for the types it produces.</span>
        Func f1<span class="hl opt">;</span>
        <span class="hl kwd">f1</span><span class="hl opt">(</span>x<span class="hl opt">) =</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;(</span>x<span class="hl opt">);</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>f1<span class="hl opt">.</span><span class="hl kwd">output_types</span><span class="hl opt">()[</span><span class="hl num">0</span><span class="hl opt">] ==</span> <span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">));</span>

        Func f2<span class="hl opt">;</span>
        <span class="hl kwd">f2</span><span class="hl opt">(</span>x<span class="hl opt">) = {</span>x<span class="hl opt">,</span> <span class="hl kwd">sin</span><span class="hl opt">(</span>x<span class="hl opt">)};</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>f2<span class="hl opt">.</span><span class="hl kwd">output_types</span><span class="hl opt">()[</span><span class="hl num">0</span><span class="hl opt">] ==</span> <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">) &amp;&amp;</span>
               f2<span class="hl opt">.</span><span class="hl kwd">output_types</span><span class="hl opt">()[</span><span class="hl num">1</span><span class="hl opt">] ==</span> <span class="hl kwd">Float</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>
    <span class="hl opt">}</span>


    <span class="hl slc">// Type promotion rules.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// When you combine Exprs of different types (e.g. using '+',</span>
        <span class="hl slc">// '*', etc), Halide uses a system of type promotion</span>
        <span class="hl slc">// rules. These differ to C's rules. To demonstrate these</span>
        <span class="hl slc">// we'll make some Exprs of each type.</span>
        Var x<span class="hl opt">;</span>
        Expr u8 <span class="hl opt">=</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;(</span>x<span class="hl opt">);</span>
        Expr u16 <span class="hl opt">=</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">uint16_t</span><span class="hl opt">&gt;(</span>x<span class="hl opt">);</span>
        Expr u32 <span class="hl opt">=</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">uint32_t</span><span class="hl opt">&gt;(</span>x<span class="hl opt">);</span>
        Expr u64 <span class="hl opt">=</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">uint64_t</span><span class="hl opt">&gt;(</span>x<span class="hl opt">);</span>
        Expr s8 <span class="hl opt">=</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">int8_t</span><span class="hl opt">&gt;(</span>x<span class="hl opt">);</span>
        Expr s16 <span class="hl opt">=</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">int16_t</span><span class="hl opt">&gt;(</span>x<span class="hl opt">);</span>
        Expr s32 <span class="hl opt">=</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">int32_t</span><span class="hl opt">&gt;(</span>x<span class="hl opt">);</span>
        Expr s64 <span class="hl opt">=</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">int64_t</span><span class="hl opt">&gt;(</span>x<span class="hl opt">);</span>
        Expr f32 <span class="hl opt">=</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;(</span>x<span class="hl opt">);</span>
        Expr f64 <span class="hl opt">=</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">double</span><span class="hl opt">&gt;(</span>x<span class="hl opt">);</span>

        <span class="hl slc">// The rules are as follows, and are applied in the order they are</span>
        <span class="hl slc">// written below.</span>

        <span class="hl slc">// 1) It is an error to cast or use arithmetic operators on Exprs of type Handle().</span>

        <span class="hl slc">// 2) If the types are the same, then no type conversions occur.</span>
        <span class="hl kwa">for</span> <span class="hl opt">(</span>Type t <span class="hl opt">:</span> valid_halide_types<span class="hl opt">) {</span>
            <span class="hl slc">// Skip the handle type.</span>
            <span class="hl kwa">if</span> <span class="hl opt">(</span>t<span class="hl opt">.</span><span class="hl kwd">is_handle</span><span class="hl opt">())</span> <span class="hl kwa">continue</span><span class="hl opt">;</span>
            Expr e <span class="hl opt">=</span> <span class="hl kwd">cast</span><span class="hl opt">(</span>t<span class="hl opt">,</span> x<span class="hl opt">);</span>
            <span class="hl kwa">assert</span><span class="hl opt">((</span>e <span class="hl opt">+</span> e<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> e<span class="hl opt">.</span><span class="hl kwd">type</span><span class="hl opt">());</span>
        <span class="hl opt">}</span>

        <span class="hl slc">// 3) If one type is a float but the other is not, then the</span>
        <span class="hl slc">// non-float argument is promoted to a float (possibly causing a</span>
        <span class="hl slc">// loss of precision for large integers).</span>
        <span class="hl kwa">assert</span><span class="hl opt">((</span>u8 <span class="hl opt">+</span> f32<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Float</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>
        <span class="hl kwa">assert</span><span class="hl opt">((</span>f32 <span class="hl opt">+</span> s64<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Float</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>
        <span class="hl kwa">assert</span><span class="hl opt">((</span>u16 <span class="hl opt">+</span> f64<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Float</span><span class="hl opt">(</span><span class="hl num">64</span><span class="hl opt">));</span>
        <span class="hl kwa">assert</span><span class="hl opt">((</span>f64 <span class="hl opt">+</span> s32<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Float</span><span class="hl opt">(</span><span class="hl num">64</span><span class="hl opt">));</span>

        <span class="hl slc">// 4) If both types are float, then the narrower argument is</span>
        <span class="hl slc">// promoted to the wider bit-width.</span>
        <span class="hl kwa">assert</span><span class="hl opt">((</span>f64 <span class="hl opt">+</span> f32<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Float</span><span class="hl opt">(</span><span class="hl num">64</span><span class="hl opt">));</span>

        <span class="hl slc">// The rules above handle all the floating-point cases. The</span>
        <span class="hl slc">// following three rules handle the integer cases.</span>

        <span class="hl slc">// 5) If one of the expressions is an integer constant, then it is</span>
        <span class="hl slc">// coerced to the type of the other expression.</span>
        <span class="hl kwa">assert</span><span class="hl opt">((</span>u32 <span class="hl opt">+</span> <span class="hl num">3</span><span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>
        <span class="hl kwa">assert</span><span class="hl opt">((</span><span class="hl num">3</span> <span class="hl opt">+</span> s16<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">16</span><span class="hl opt">));</span>

        <span class="hl slc">// If this rule would cause the integer to overflow, then Halide</span>
        <span class="hl slc">// will trigger an error, e.g. uncommenting the following line</span>
        <span class="hl slc">// will cause this program to terminate with an error.</span>
        <span class="hl slc">// Expr bad = u8 + 257;</span>

        <span class="hl slc">// 6) If both types are unsigned integers, or both types are</span>
        <span class="hl slc">// signed integers, then the narrower argument is promoted to</span>
        <span class="hl slc">// wider type.</span>
        <span class="hl kwa">assert</span><span class="hl opt">((</span>u32 <span class="hl opt">+</span> u8<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>
        <span class="hl kwa">assert</span><span class="hl opt">((</span>s16 <span class="hl opt">+</span> s64<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">64</span><span class="hl opt">));</span>

        <span class="hl slc">// 7) If one type is signed and the other is unsigned, both</span>
        <span class="hl slc">// arguments are promoted to a signed integer with the greater of</span>
        <span class="hl slc">// the two bit widths.</span>
        <span class="hl kwa">assert</span><span class="hl opt">((</span>u8 <span class="hl opt">+</span> s32<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>
        <span class="hl kwa">assert</span><span class="hl opt">((</span>u32 <span class="hl opt">+</span> s8<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>

        <span class="hl slc">// Note that this may silently overflow the unsigned type in the</span>
        <span class="hl slc">// case where the bit widths are the same.</span>
        <span class="hl kwa">assert</span><span class="hl opt">((</span>u32 <span class="hl opt">+</span> s32<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>

        <span class="hl slc">// When an unsigned Expr is converted to a wider signed type in</span>
        <span class="hl slc">// this way, it is first widened to a wider unsigned type</span>
        <span class="hl slc">// (zero-extended), and then reinterpreted as a signed</span>
        <span class="hl slc">// integer. I.e. casting the UInt(8) value 255 to an Int(32)</span>
        <span class="hl slc">// produces 255, not -1.</span>
        <span class="hl kwb">int32_t</span> result32 <span class="hl opt">=</span> evaluate<span class="hl opt">&lt;</span><span class="hl kwb">int</span><span class="hl opt">&gt;(</span>cast<span class="hl opt">&lt;</span><span class="hl kwb">int32_t</span><span class="hl opt">&gt;(</span>cast<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;(</span><span class="hl num">255</span><span class="hl opt">)));</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>result32 <span class="hl opt">==</span> <span class="hl num">255</span><span class="hl opt">);</span>

        <span class="hl slc">// When a signed type is explicitly converted to a wider unsigned</span>
        <span class="hl slc">// type with the cast operator (the type promotion rules will</span>
        <span class="hl slc">// never do this automatically), it is first converted to the</span>
        <span class="hl slc">// wider signed type (sign-extended), and then reinterpreted as</span>
        <span class="hl slc">// an unsigned integer. I.e. casting the Int(8) value -1 to a</span>
        <span class="hl slc">// UInt(16) produces 65535, not 255.</span>
        <span class="hl kwb">uint16_t</span> result16 <span class="hl opt">=</span> evaluate<span class="hl opt">&lt;</span><span class="hl kwb">uint16_t</span><span class="hl opt">&gt;(</span>cast<span class="hl opt">&lt;</span><span class="hl kwb">uint16_t</span><span class="hl opt">&gt;(</span>cast<span class="hl opt">&lt;</span><span class="hl kwb">int8_t</span><span class="hl opt">&gt;(-</span><span class="hl num">1</span><span class="hl opt">)));</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>result16 <span class="hl opt">==</span> <span class="hl num">65535</span><span class="hl opt">);</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// The type Handle().</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// Handle is used to represent opaque pointers. Applying</span>
        <span class="hl slc">// type_of to any pointer type will return Handle()</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>type_of<span class="hl opt">&lt;</span><span class="hl kwb">void</span> <span class="hl opt">*&gt;() ==</span> <span class="hl kwd">Handle</span><span class="hl opt">());</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span>type_of<span class="hl opt">&lt;</span><span class="hl kwb">const char</span> <span class="hl opt">*</span> <span class="hl kwb">const</span> <span class="hl opt">**&gt;() ==</span> <span class="hl kwd">Handle</span><span class="hl opt">());</span>

        <span class="hl slc">// Handles are always stored as 64-bit, regardless of the compilation</span>
        <span class="hl slc">// target.</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">Handle</span><span class="hl opt">().</span>bits <span class="hl opt">==</span> <span class="hl num">64</span><span class="hl opt">);</span>

        <span class="hl slc">// The main use of an Expr of type Handle is to pass</span>
        <span class="hl slc">// it through Halide to other external code.</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// Generic code.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// The main explicit use of Type in Halide is to write Halide</span>
        <span class="hl slc">// code parameterized by a Type. In C++ you'd do this with</span>
        <span class="hl slc">// templates. In Halide there's no need - you can inspect and</span>
        <span class="hl slc">// modify the types dynamically at C++ runtime instead. The</span>
        <span class="hl slc">// function defined below averages two expressions of any</span>
        <span class="hl slc">// equal numeric type.</span>
        Var x<span class="hl opt">;</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">average</span><span class="hl opt">(</span>cast<span class="hl opt">&lt;</span><span class="hl kwb">float</span><span class="hl opt">&gt;(</span>x<span class="hl opt">),</span> <span class="hl num">3.0</span>f<span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Float</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">average</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">Int</span><span class="hl opt">(</span><span class="hl num">32</span><span class="hl opt">));</span>
        <span class="hl kwa">assert</span><span class="hl opt">(</span><span class="hl kwd">average</span><span class="hl opt">(</span>cast<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;(</span>x<span class="hl opt">),</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;(</span><span class="hl num">3</span><span class="hl opt">)).</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> <span class="hl kwd">UInt</span><span class="hl opt">(</span><span class="hl num">8</span><span class="hl opt">));</span>
    <span class="hl opt">}</span>

    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Success!</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">);</span>

    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>

Expr <span class="hl kwd">average</span><span class="hl opt">(</span>Expr a<span class="hl opt">,</span> Expr b<span class="hl opt">) {</span>
    <span class="hl slc">// Types must match.</span>
    <span class="hl kwa">assert</span><span class="hl opt">(</span>a<span class="hl opt">.</span><span class="hl kwd">type</span><span class="hl opt">() ==</span> b<span class="hl opt">.</span><span class="hl kwd">type</span><span class="hl opt">());</span>

    <span class="hl slc">// For floating point types:</span>
    <span class="hl kwa">if</span> <span class="hl opt">(</span>a<span class="hl opt">.</span><span class="hl kwd">type</span><span class="hl opt">().</span><span class="hl kwd">is_float</span><span class="hl opt">()) {</span>
        <span class="hl slc">// The '2' will be promoted to the floating point type due to</span>
        <span class="hl slc">// rule 3 above.</span>
        <span class="hl kwa">return</span> <span class="hl opt">(</span>a <span class="hl opt">+</span> b<span class="hl opt">)/</span><span class="hl num">2</span><span class="hl opt">;</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// For integer types, we must compute the intermediate value in a</span>
    <span class="hl slc">// wider type to avoid overflow.</span>
    Type narrow <span class="hl opt">=</span> a<span class="hl opt">.</span><span class="hl kwd">type</span><span class="hl opt">();</span>
    Type wider <span class="hl opt">=</span> narrow<span class="hl opt">;</span>
    wider<span class="hl opt">.</span>bits <span class="hl opt">*=</span> <span class="hl num">2</span><span class="hl opt">;</span>
    a <span class="hl opt">=</span> <span class="hl kwd">cast</span><span class="hl opt">(</span>wider<span class="hl opt">,</span> a<span class="hl opt">);</span>
    b <span class="hl opt">=</span> <span class="hl kwd">cast</span><span class="hl opt">(</span>wider<span class="hl opt">,</span> b<span class="hl opt">);</span>
    <span class="hl kwa">return</span> <span class="hl kwd">cast</span><span class="hl opt">(</span>narrow<span class="hl opt">, (</span>a <span class="hl opt">+</span> b<span class="hl opt">)/</span><span class="hl num">2</span><span class="hl opt">);</span>
<span class="hl opt">}</span>
</pre>
</div>
</body>
</html>
