<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: Halide Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_halide.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Halide Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines methods for solving equations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide_1_1_internal"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></td></tr>
<tr class="memdesc:namespace_halide_1_1_internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to detect if a type is a pointer. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_boundary_conditions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html">BoundaryConditions</a></td></tr>
<tr class="memdesc:namespace_halide_1_1_boundary_conditions"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace to hold functions for imposing boundary conditions on <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> Funcs. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_integer_divide_table"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_integer_divide_table.html">IntegerDivideTable</a></td></tr>
<tr class="memdesc:namespace_halide_1_1_integer_divide_table"><td class="mdescLeft">&#160;</td><td class="mdescRight">Built-in images used for fast_integer_divide below. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_runtime"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_runtime.html">Runtime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_argument.html">Argument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct representing an argument to a halide-generated function.  <a href="struct_halide_1_1_argument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal representation of an image, or other dense array data.  <a href="class_halide_1_1_buffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_error.html">Error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> errors.  <a href="struct_halide_1_1_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_runtime_error.html">RuntimeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error that occurs while running a JIT-compiled <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> pipeline.  <a href="struct_halide_1_1_runtime_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_compile_error.html">CompileError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error that occurs while compiling a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> pipeline that <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> attributes to a user error.  <a href="struct_halide_1_1_compile_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_error.html">InternalError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error that occurs while compiling a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> pipeline that <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> attributes to an internal compiler bug, or to an invalid use of <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s internals.  <a href="struct_halide_1_1_internal_error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_compile_time_error_reporter.html">CompileTimeErrorReporter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_compile_time_error_reporter.html" title="CompileTimeErrorReporter is used at compile time (not runtime) when an error or warning is generated ...">CompileTimeErrorReporter</a> is used at compile time (<em>not</em> runtime) when an error or warning is generated by <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>.  <a href="class_halide_1_1_compile_time_error_reporter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fragment of <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> syntax.  <a href="struct_halide_1_1_expr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_expr_compare.html">ExprCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This lets you use an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> as a key in a map of the form map&lt;Expr, Foo, ExprCompare&gt;  <a href="struct_halide_1_1_expr_compare.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that can represent Vars or RVars.  <a href="struct_halide_1_1_var_or_r_var.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html">Stage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>.  <a href="class_halide_1_1_stage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Exprs.  <a href="class_halide_1_1_func_ref_expr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html">Func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A halide function.  <a href="class_halide_1_1_func.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An argument to an extern-defined <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>.  <a href="struct_halide_1_1_extern_func_argument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator_param.html">GeneratorParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_generator_param.html" title="GeneratorParam is a templated class that can be used to modify the behavior of the Generator at code-...">GeneratorParam</a> is a templated class that can be used to modify the behavior of the <a class="el" href="class_halide_1_1_generator.html">Generator</a> at code-generation time.  <a href="class_halide_1_1_generator_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_names_interface.html">NamesInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_register_generator.html">RegisterGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_generator.html">Generator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_image_base.html">ImageBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for Images, which are typed accessors on Buffers.  <a href="class_halide_1_1_image_base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_image.html">Image</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle on a dense multidimensional array containing scalar values of type T.  <a href="class_halide_1_1_image.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_scalar_or_buffer_t.html">ScalarOrBufferT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_extern_signature.html">ExternSignature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_module.html">Module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A halide module.  <a href="class_halide_1_1_module.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_param.html">Param</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar parameter to a halide pipeline.  <a href="class_halide_1_1_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_output_image_param.html">OutputImageParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle on the output buffer of a pipeline.  <a href="class_halide_1_1_output_image_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_image_param.html">ImageParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image</a> parameter to a halide pipeline.  <a href="class_halide_1_1_image_param.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_custom_lowering_pass.html">CustomLoweringPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom lowering pass.  <a href="struct_halide_1_1_custom_lowering_pass.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_outputs.html">Outputs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct specifying a collection of outputs.  <a href="struct_halide_1_1_outputs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html">Pipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> pipeline.  <a href="class_halide_1_1_pipeline.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_j_i_t_extern.html">JITExtern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_r_var.html">RVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reduction variable represents a single dimension of a reduction domain (<a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a>).  <a href="class_halide_1_1_r_var.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_r_dom.html">RDom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional domain over which to iterate.  <a href="class_halide_1_1_r_dom.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html">Target</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct representing a target machine and os to generate code for.  <a href="struct_halide_1_1_target.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a small array of Exprs for defining and calling functions with multiple outputs.  <a href="class_halide_1_1_tuple.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_realization.html">Realization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funcs with <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a> values return multiple buffers when you realize them.  <a href="class_halide_1_1_realization.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types in the halide type system.  <a href="struct_halide_1_1_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_var.html">Var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> variable, to be used when defining functions.  <a href="class_halide_1_1_var.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad7b585cf844dcb14fa12386d743cbb24"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_halide_1_1_stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad7b585cf844dcb14fa12386d743cbb24">ScheduleHandle</a></td></tr>
<tr class="separator:ad7b585cf844dcb14fa12386d743cbb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa26c7f430d2b1c44ba3e1d3f6df2ba6e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> { <br/>
&#160;&#160;<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6ea30269022e9d8f51beaabb52e5d0de2b7">DeviceAPI::Parent</a>, 
<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2">DeviceAPI::Host</a>, 
<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>, 
<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaa33b7755e5f9b504d2d038eaca4ff28d">DeviceAPI::CUDA</a>, 
<br/>
&#160;&#160;<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6ea7982b09a852b37f2afb1227eaf552e47">DeviceAPI::OpenCL</a>, 
<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6ea2a2c1392bcbaececf702b611e7d7df25">DeviceAPI::GLSL</a>, 
<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eab79f9fcb64263765842486e340edd503">DeviceAPI::Renderscript</a>, 
<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6ea3adf0945d2bbb4c868f37d38e02684d5">DeviceAPI::OpenGLCompute</a>
<br/>
 }</td></tr>
<tr class="memdesc:aa26c7f430d2b1c44ba3e1d3f6df2ba6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing a type of device API.  <a href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">More...</a><br/></td></tr>
<tr class="separator:aa26c7f430d2b1c44ba3e1d3f6df2ba6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1953af304956bd6a5d0bd780b135f56"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> { <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, 
<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a0e7445a36a4c4afba58997fbc4871f3b">HTML</a>
 }</td></tr>
<tr class="memdesc:ad1953af304956bd6a5d0bd780b135f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine if the output printed to file should be as a normal string or as an HTML file which can be opened in a browerser and manipulated via JS and CSS.  <a href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">More...</a><br/></td></tr>
<tr class="separator:ad1953af304956bd6a5d0bd780b135f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9a5775a4f39e7579b10ceb1f2b611ffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> llvm::Module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a5775a4f39e7579b10ceb1f2b611ffa">codegen_llvm</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, llvm::LLVMContext &amp;context)</td></tr>
<tr class="memdesc:a9a5775a4f39e7579b10ceb1f2b611ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> module, generate an llvm::Module.  <a href="#a9a5775a4f39e7579b10ceb1f2b611ffa">More...</a><br/></td></tr>
<tr class="separator:a9a5775a4f39e7579b10ceb1f2b611ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3021087fa785031812f050398edfec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7b3021087fa785031812f050398edfec">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;)</td></tr>
<tr class="memdesc:a7b3021087fa785031812f050398edfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an expression on an output stream (such as std::cout) in a human-readable form.  <a href="#a7b3021087fa785031812f050398edfec">More...</a><br/></td></tr>
<tr class="separator:a7b3021087fa785031812f050398edfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fb1fd38f327c0271eaebaf446ec700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a81fb1fd38f327c0271eaebaf446ec700">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;)</td></tr>
<tr class="memdesc:a81fb1fd38f327c0271eaebaf446ec700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide type on an output stream (such as std::cout) in a human-readable form.  <a href="#a81fb1fd38f327c0271eaebaf446ec700">More...</a><br/></td></tr>
<tr class="separator:a81fb1fd38f327c0271eaebaf446ec700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d27a04e65a9c083f68fc8c895f3205"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac6d27a04e65a9c083f68fc8c895f3205">exceptions_enabled</a> ()</td></tr>
<tr class="memdesc:ac6d27a04e65a9c083f68fc8c895f3205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> was compiled with exceptions.  <a href="#ac6d27a04e65a9c083f68fc8c895f3205">More...</a><br/></td></tr>
<tr class="separator:ac6d27a04e65a9c083f68fc8c895f3205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c76d9a6be91f972dbeb1c46ce2f68b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af1c76d9a6be91f972dbeb1c46ce2f68b">set_custom_compile_time_error_reporter</a> (<a class="el" href="class_halide_1_1_compile_time_error_reporter.html">CompileTimeErrorReporter</a> *error_reporter)</td></tr>
<tr class="memdesc:af1c76d9a6be91f972dbeb1c46ce2f68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default error reporter logs to stderr, then throws an exception (if WITH_EXCEPTIONS) or calls abort (if not).  <a href="#af1c76d9a6be91f972dbeb1c46ce2f68b">More...</a><br/></td></tr>
<tr class="separator:af1c76d9a6be91f972dbeb1c46ce2f68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced4b4be21fc5bd6c85f354b59e301ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aced4b4be21fc5bd6c85f354b59e301ff">fast_integer_divide</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> numerator, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> denominator)</td></tr>
<tr class="memdesc:aced4b4be21fc5bd6c85f354b59e301ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer division by small values can be done exactly as multiplies and shifts.  <a href="#aced4b4be21fc5bd6c85f354b59e301ff">More...</a><br/></td></tr>
<tr class="separator:aced4b4be21fc5bd6c85f354b59e301ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bc862e5fcc7aeb2b41bc049e86754d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10bc862e5fcc7aeb2b41bc049e86754d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a10bc862e5fcc7aeb2b41bc049e86754d">evaluate</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a10bc862e5fcc7aeb2b41bc049e86754d"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-Compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> expression.  <a href="#a10bc862e5fcc7aeb2b41bc049e86754d">More...</a><br/></td></tr>
<tr class="separator:a10bc862e5fcc7aeb2b41bc049e86754d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ff5a8bb22ddc8770198df1be5c0d49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95ff5a8bb22ddc8770198df1be5c0d49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a95ff5a8bb22ddc8770198df1be5c0d49">evaluate_may_gpu</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a95ff5a8bb22ddc8770198df1be5c0d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-Compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> expression.  <a href="#a95ff5a8bb22ddc8770198df1be5c0d49">More...</a><br/></td></tr>
<tr class="separator:a95ff5a8bb22ddc8770198df1be5c0d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c6da1a731c0804063458b531e8a849"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51c6da1a731c0804063458b531e8a849"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a51c6da1a731c0804063458b531e8a849">cast</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a51c6da1a731c0804063458b531e8a849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to the halide type corresponding to the C++ type T.  <a href="#a51c6da1a731c0804063458b531e8a849">More...</a><br/></td></tr>
<tr class="separator:a51c6da1a731c0804063458b531e8a849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ce0e6da961a52ace4b8fa8444fac20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a69ce0e6da961a52ace4b8fa8444fac20">cast</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a69ce0e6da961a52ace4b8fa8444fac20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a new type.  <a href="#a69ce0e6da961a52ace4b8fa8444fac20">More...</a><br/></td></tr>
<tr class="separator:a69ce0e6da961a52ace4b8fa8444fac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db532b84ba55ff72555c4b427fc42bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2db532b84ba55ff72555c4b427fc42bc">operator+</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a2db532b84ba55ff72555c4b427fc42bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a2db532b84ba55ff72555c4b427fc42bc">More...</a><br/></td></tr>
<tr class="separator:a2db532b84ba55ff72555c4b427fc42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd77e71422999076fa3339829ac8c30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acd77e71422999076fa3339829ac8c30d">operator+=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:acd77e71422999076fa3339829ac8c30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the sum of two expressions, without changing its type.  <a href="#acd77e71422999076fa3339829ac8c30d">More...</a><br/></td></tr>
<tr class="separator:acd77e71422999076fa3339829ac8c30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f3eb27005363158ca0e934811c98ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a86f3eb27005363158ca0e934811c98ed">operator-</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a86f3eb27005363158ca0e934811c98ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a86f3eb27005363158ca0e934811c98ed">More...</a><br/></td></tr>
<tr class="separator:a86f3eb27005363158ca0e934811c98ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80881209a15ed749e168d6edbcb6f687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a80881209a15ed749e168d6edbcb6f687">operator-</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a80881209a15ed749e168d6edbcb6f687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negative of the argument.  <a href="#a80881209a15ed749e168d6edbcb6f687">More...</a><br/></td></tr>
<tr class="separator:a80881209a15ed749e168d6edbcb6f687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94db82f1af5cd7492bb503c2238ade8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a94db82f1af5cd7492bb503c2238ade8a">operator-=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a94db82f1af5cd7492bb503c2238ade8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the difference of two expressions, without changing its type.  <a href="#a94db82f1af5cd7492bb503c2238ade8a">More...</a><br/></td></tr>
<tr class="separator:a94db82f1af5cd7492bb503c2238ade8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908c6748ab34a4a66274b196b6900af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a908c6748ab34a4a66274b196b6900af5">operator*</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a908c6748ab34a4a66274b196b6900af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a908c6748ab34a4a66274b196b6900af5">More...</a><br/></td></tr>
<tr class="separator:a908c6748ab34a4a66274b196b6900af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac0c84f284a38d6018e2d4e5d075c8b5b">operator*=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the product of two expressions, without changing its type.  <a href="#ac0c84f284a38d6018e2d4e5d075c8b5b">More...</a><br/></td></tr>
<tr class="separator:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a73e12ddd6395e3a1c1286e2e3c51e675">operator/</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ratio of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a73e12ddd6395e3a1c1286e2e3c51e675">More...</a><br/></td></tr>
<tr class="separator:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0da6820c40a5911fb23d973283487f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3c0da6820c40a5911fb23d973283487f">operator/=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a3c0da6820c40a5911fb23d973283487f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the ratio of two expressions, without changing its type.  <a href="#a3c0da6820c40a5911fb23d973283487f">More...</a><br/></td></tr>
<tr class="separator:a3c0da6820c40a5911fb23d973283487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc191ed3318e2072d18f42d11f5b01d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc191ed3318e2072d18f42d11f5b01d4">operator%</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:abc191ed3318e2072d18f42d11f5b01d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument reduced modulo the second, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#abc191ed3318e2072d18f42d11f5b01d4">More...</a><br/></td></tr>
<tr class="separator:abc191ed3318e2072d18f42d11f5b01d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9105ae9f0995f450825e522170f5d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af9105ae9f0995f450825e522170f5d1e">operator&gt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:af9105ae9f0995f450825e522170f5d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#af9105ae9f0995f450825e522170f5d1e">More...</a><br/></td></tr>
<tr class="separator:af9105ae9f0995f450825e522170f5d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbad5ee20448455260670dec22c76a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abbad5ee20448455260670dec22c76a21">operator&lt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:abbad5ee20448455260670dec22c76a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#abbad5ee20448455260670dec22c76a21">More...</a><br/></td></tr>
<tr class="separator:abbad5ee20448455260670dec22c76a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad297e6fa5deb0ba4e8ad7fe344629706">operator&lt;=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#ad297e6fa5deb0ba4e8ad7fe344629706">More...</a><br/></td></tr>
<tr class="separator:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8f2e815b9cc7475802c0fb6a7e7ae6ae">operator&gt;=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a8f2e815b9cc7475802c0fb6a7e7ae6ae">More...</a><br/></td></tr>
<tr class="separator:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abfbbb2e5820938f4d8f0a8b2324776df">operator==</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:abfbbb2e5820938f4d8f0a8b2324776df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#abfbbb2e5820938f4d8f0a8b2324776df">More...</a><br/></td></tr>
<tr class="separator:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3d11c86964dbb2586103744cac1614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d3d11c86964dbb2586103744cac1614">operator!=</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a8d3d11c86964dbb2586103744cac1614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is not equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a8d3d11c86964dbb2586103744cac1614">More...</a><br/></td></tr>
<tr class="separator:a8d3d11c86964dbb2586103744cac1614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df159d6ed5236cc8e02d04bf72be4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a02df159d6ed5236cc8e02d04bf72be4f">operator&amp;&amp;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a02df159d6ed5236cc8e02d04bf72be4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical and of the two arguments.  <a href="#a02df159d6ed5236cc8e02d04bf72be4f">More...</a><br/></td></tr>
<tr class="separator:a02df159d6ed5236cc8e02d04bf72be4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3528931d7929d533103ada2badca092c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3528931d7929d533103ada2badca092c">operator||</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a3528931d7929d533103ada2badca092c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical or of the two arguments.  <a href="#a3528931d7929d533103ada2badca092c">More...</a><br/></td></tr>
<tr class="separator:a3528931d7929d533103ada2badca092c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb54256bfab344b6720775cf2e0936e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afb54256bfab344b6720775cf2e0936e0">operator!</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:afb54256bfab344b6720775cf2e0936e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical not the argument.  <a href="#afb54256bfab344b6720775cf2e0936e0">More...</a><br/></td></tr>
<tr class="separator:afb54256bfab344b6720775cf2e0936e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec">max</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a9a00cabb9f57b4cf5d101b2af338f5ec">More...</a><br/></td></tr>
<tr class="separator:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b5db24ca379dda8241433c0014c940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940">min</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a38b5db24ca379dda8241433c0014c940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a38b5db24ca379dda8241433c0014c940">More...</a><br/></td></tr>
<tr class="separator:a38b5db24ca379dda8241433c0014c940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fc11b69e1ae900cebae51c319a1caa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a41fc11b69e1ae900cebae51c319a1caa">clamp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> max_val)</td></tr>
<tr class="memdesc:a41fc11b69e1ae900cebae51c319a1caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps an expression to lie within the given bounds.  <a href="#a41fc11b69e1ae900cebae51c319a1caa">More...</a><br/></td></tr>
<tr class="separator:a41fc11b69e1ae900cebae51c319a1caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae698f4bfd37d3d15cee4bf22c4627e0d">abs</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a signed integer or floating-point expression.  <a href="#ae698f4bfd37d3d15cee4bf22c4627e0d">More...</a><br/></td></tr>
<tr class="separator:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d96f6e421c7a9a25f3d027283c7149d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d96f6e421c7a9a25f3d027283c7149d">absd</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a8d96f6e421c7a9a25f3d027283c7149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute difference between two values.  <a href="#a8d96f6e421c7a9a25f3d027283c7149d">More...</a><br/></td></tr>
<tr class="separator:a8d96f6e421c7a9a25f3d027283c7149d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6371892ae38e7eb681fd3f23945b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> true_value, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> false_value)</td></tr>
<tr class="memdesc:a9d6371892ae38e7eb681fd3f23945b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression similar to the ternary operator in C, except that it always evaluates all arguments.  <a href="#a9d6371892ae38e7eb681fd3f23945b06">More...</a><br/></td></tr>
<tr class="separator:a9d6371892ae38e7eb681fd3f23945b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1fca22f79625765096133e39caee5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">sin</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a5e1fca22f79625765096133e39caee5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of a floating-point expression.  <a href="#a5e1fca22f79625765096133e39caee5e">More...</a><br/></td></tr>
<tr class="separator:a5e1fca22f79625765096133e39caee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3bfc77a80e6b40a6c00899a8e2ad1f28">asin</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arcsine of a floating-point expression.  <a href="#a3bfc77a80e6b40a6c00899a8e2ad1f28">More...</a><br/></td></tr>
<tr class="separator:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1ef33189b99c7b8bc73b5e10121834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7e1ef33189b99c7b8bc73b5e10121834">cos</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a7e1ef33189b99c7b8bc73b5e10121834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of a floating-point expression.  <a href="#a7e1ef33189b99c7b8bc73b5e10121834">More...</a><br/></td></tr>
<tr class="separator:a7e1ef33189b99c7b8bc73b5e10121834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a64d3ef272e07177d95b624968951"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a722a64d3ef272e07177d95b624968951">acos</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a722a64d3ef272e07177d95b624968951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arccosine of a floating-point expression.  <a href="#a722a64d3ef272e07177d95b624968951">More...</a><br/></td></tr>
<tr class="separator:a722a64d3ef272e07177d95b624968951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18f43994d3cf73c20b7eb62b243076e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad18f43994d3cf73c20b7eb62b243076e">tan</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:ad18f43994d3cf73c20b7eb62b243076e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of a floating-point expression.  <a href="#ad18f43994d3cf73c20b7eb62b243076e">More...</a><br/></td></tr>
<tr class="separator:ad18f43994d3cf73c20b7eb62b243076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3b0ec19519602bc880a1ae0236f1c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe3b0ec19519602bc880a1ae0236f1c3">atan</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abe3b0ec19519602bc880a1ae0236f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arctangent of a floating-point expression.  <a href="#abe3b0ec19519602bc880a1ae0236f1c3">More...</a><br/></td></tr>
<tr class="separator:abe3b0ec19519602bc880a1ae0236f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5646de466ac31efd07ec5af1e4603cbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5646de466ac31efd07ec5af1e4603cbf">atan2</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> y, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a5646de466ac31efd07ec5af1e4603cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angle of a floating-point gradient.  <a href="#a5646de466ac31efd07ec5af1e4603cbf">More...</a><br/></td></tr>
<tr class="separator:a5646de466ac31efd07ec5af1e4603cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe05bc670b713a278f8182457a750bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe05bc670b713a278f8182457a750bd9">sinh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abe05bc670b713a278f8182457a750bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of a floating-point expression.  <a href="#abe05bc670b713a278f8182457a750bd9">More...</a><br/></td></tr>
<tr class="separator:abe05bc670b713a278f8182457a750bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">asinh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arcsinhe of a floating-point expression.  <a href="#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">More...</a><br/></td></tr>
<tr class="separator:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68aff5fc199ecbabe209ce32ec507292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a68aff5fc199ecbabe209ce32ec507292">cosh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a68aff5fc199ecbabe209ce32ec507292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of a floating-point expression.  <a href="#a68aff5fc199ecbabe209ce32ec507292">More...</a><br/></td></tr>
<tr class="separator:a68aff5fc199ecbabe209ce32ec507292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2ce048ac6f7c309d26c83fbc3132be2b">acosh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arccosine of a floating-point expression.  <a href="#a2ce048ac6f7c309d26c83fbc3132be2b">More...</a><br/></td></tr>
<tr class="separator:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb15a9760067c05d2e5a343f529188be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acb15a9760067c05d2e5a343f529188be">tanh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:acb15a9760067c05d2e5a343f529188be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of a floating-point expression.  <a href="#acb15a9760067c05d2e5a343f529188be">More...</a><br/></td></tr>
<tr class="separator:acb15a9760067c05d2e5a343f529188be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd93e33e8d82be7cf9487e881d834ec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acd93e33e8d82be7cf9487e881d834ec9">atanh</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:acd93e33e8d82be7cf9487e881d834ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arctangent of a floating-point expression.  <a href="#acd93e33e8d82be7cf9487e881d834ec9">More...</a><br/></td></tr>
<tr class="separator:acd93e33e8d82be7cf9487e881d834ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7f08f13439b86581a47162e1a2d2de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abc7f08f13439b86581a47162e1a2d2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of a floating-point expression.  <a href="#abc7f08f13439b86581a47162e1a2d2de">More...</a><br/></td></tr>
<tr class="separator:abc7f08f13439b86581a47162e1a2d2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb75ff010919c00492e4f654a4d8f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4fb75ff010919c00492e4f654a4d8f85">hypot</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a4fb75ff010919c00492e4f654a4d8f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the sum of the squares of two floating-point expressions.  <a href="#a4fb75ff010919c00492e4f654a4d8f85">More...</a><br/></td></tr>
<tr class="separator:a4fb75ff010919c00492e4f654a4d8f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c6187068d6e839e548776dfa7dde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a877c6187068d6e839e548776dfa7dde3">exp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a877c6187068d6e839e548776dfa7dde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponential of a floating-point expression.  <a href="#a877c6187068d6e839e548776dfa7dde3">More...</a><br/></td></tr>
<tr class="separator:a877c6187068d6e839e548776dfa7dde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f1c38239e6e977fea90b94217499ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a02f1c38239e6e977fea90b94217499ae">log</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a02f1c38239e6e977fea90b94217499ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logarithm of a floating-point expression.  <a href="#a02f1c38239e6e977fea90b94217499ae">More...</a><br/></td></tr>
<tr class="separator:a02f1c38239e6e977fea90b94217499ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd83996070aa3e4bc3a102a654176fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4dd83996070aa3e4bc3a102a654176fa">pow</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a4dd83996070aa3e4bc3a102a654176fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one floating point expression raised to the power of another.  <a href="#a4dd83996070aa3e4bc3a102a654176fa">More...</a><br/></td></tr>
<tr class="separator:a4dd83996070aa3e4bc3a102a654176fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a80df08887f9457c9bffc349f834ce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a80df08887f9457c9bffc349f834ce1">erf</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a9a80df08887f9457c9bffc349f834ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the error function erf.  <a href="#a9a80df08887f9457c9bffc349f834ce1">More...</a><br/></td></tr>
<tr class="separator:a9a80df08887f9457c9bffc349f834ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df3f02c28d9710c836194f5b2e9e8c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7df3f02c28d9710c836194f5b2e9e8c7">fast_log</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a7df3f02c28d9710c836194f5b2e9e8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable log for Float(32).  <a href="#a7df3f02c28d9710c836194f5b2e9e8c7">More...</a><br/></td></tr>
<tr class="separator:a7df3f02c28d9710c836194f5b2e9e8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df130f96d92c066478cd28148d8af53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5df130f96d92c066478cd28148d8af53">fast_exp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a5df130f96d92c066478cd28148d8af53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable exp for Float(32).  <a href="#a5df130f96d92c066478cd28148d8af53">More...</a><br/></td></tr>
<tr class="separator:a5df130f96d92c066478cd28148d8af53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958457cd688f84d583779e649c9e52e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a958457cd688f84d583779e649c9e52e6">fast_pow</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a958457cd688f84d583779e649c9e52e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable pow for Float(32).  <a href="#a958457cd688f84d583779e649c9e52e6">More...</a><br/></td></tr>
<tr class="separator:a958457cd688f84d583779e649c9e52e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343eac4b4aa329e52c7cbf8167902696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a343eac4b4aa329e52c7cbf8167902696">fast_inverse</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a343eac4b4aa329e52c7cbf8167902696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate inverse for Float(32).  <a href="#a343eac4b4aa329e52c7cbf8167902696">More...</a><br/></td></tr>
<tr class="separator:a343eac4b4aa329e52c7cbf8167902696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4424b070b363f53107a6c2705bbe50b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad4424b070b363f53107a6c2705bbe50b">fast_inverse_sqrt</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:ad4424b070b363f53107a6c2705bbe50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate inverse square root for Float(32).  <a href="#ad4424b070b363f53107a6c2705bbe50b">More...</a><br/></td></tr>
<tr class="separator:ad4424b070b363f53107a6c2705bbe50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed670387016322f8db2b7abdecdc0e4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed670387016322f8db2b7abdecdc0e4c">floor</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:aed670387016322f8db2b7abdecdc0e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest whole number less than or equal to a floating-point expression.  <a href="#aed670387016322f8db2b7abdecdc0e4c">More...</a><br/></td></tr>
<tr class="separator:aed670387016322f8db2b7abdecdc0e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070dde32195d1ae83082c15fd11d5d90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a070dde32195d1ae83082c15fd11d5d90">ceil</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a070dde32195d1ae83082c15fd11d5d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least whole number greater than or equal to a floating-point expression.  <a href="#a070dde32195d1ae83082c15fd11d5d90">More...</a><br/></td></tr>
<tr class="separator:a070dde32195d1ae83082c15fd11d5d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2090a77072af682d9e2daea086d2fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d2090a77072af682d9e2daea086d2fe">round</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a9d2090a77072af682d9e2daea086d2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the whole number closest to a floating-point expression.  <a href="#a9d2090a77072af682d9e2daea086d2fe">More...</a><br/></td></tr>
<tr class="separator:a9d2090a77072af682d9e2daea086d2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287f93889910a28197d2a1631486a433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a287f93889910a28197d2a1631486a433">trunc</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a287f93889910a28197d2a1631486a433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the integer part of a floating-point expression.  <a href="#a287f93889910a28197d2a1631486a433">More...</a><br/></td></tr>
<tr class="separator:a287f93889910a28197d2a1631486a433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71c5b6b09e0f679724ccfb95515b338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab71c5b6b09e0f679724ccfb95515b338">is_nan</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:ab71c5b6b09e0f679724ccfb95515b338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the argument is a Not a Number (NaN).  <a href="#ab71c5b6b09e0f679724ccfb95515b338">More...</a><br/></td></tr>
<tr class="separator:ab71c5b6b09e0f679724ccfb95515b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fd83b219755aef0e53062cffc111bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a57fd83b219755aef0e53062cffc111bc">fract</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a57fd83b219755aef0e53062cffc111bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fractional part of a floating-point expression.  <a href="#a57fd83b219755aef0e53062cffc111bc">More...</a><br/></td></tr>
<tr class="separator:a57fd83b219755aef0e53062cffc111bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0f13f0a9e97bf7673ca5a8e04b1bd9a9">reinterpret</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret the bits of one value as another type.  <a href="#a0f13f0a9e97bf7673ca5a8e04b1bd9a9">More...</a><br/></td></tr>
<tr class="separator:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2012c20f1666555e7a229c9db1b64091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2012c20f1666555e7a229c9db1b64091"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2012c20f1666555e7a229c9db1b64091">reinterpret</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="separator:a2012c20f1666555e7a229c9db1b64091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec8e49b0b42230077ee6bdca669d299"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4ec8e49b0b42230077ee6bdca669d299">operator&amp;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a4ec8e49b0b42230077ee6bdca669d299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise and of two expressions (which need not have the same type).  <a href="#a4ec8e49b0b42230077ee6bdca669d299">More...</a><br/></td></tr>
<tr class="separator:a4ec8e49b0b42230077ee6bdca669d299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8bec8d2f6194f4db7b88e554173f05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe8bec8d2f6194f4db7b88e554173f05">operator|</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:abe8bec8d2f6194f4db7b88e554173f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise or of two expressions (which need not have the same type).  <a href="#abe8bec8d2f6194f4db7b88e554173f05">More...</a><br/></td></tr>
<tr class="separator:abe8bec8d2f6194f4db7b88e554173f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdde4dd479f4eb59631e09148897ad2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afdde4dd479f4eb59631e09148897ad2a">operator^</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:afdde4dd479f4eb59631e09148897ad2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise exclusive or of two expressions (which need not have the same type).  <a href="#afdde4dd479f4eb59631e09148897ad2a">More...</a><br/></td></tr>
<tr class="separator:afdde4dd479f4eb59631e09148897ad2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c07e39289b14103ccd45ee31630a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afc9c07e39289b14103ccd45ee31630a3">operator~</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:afc9c07e39289b14103ccd45ee31630a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise not of an expression.  <a href="#afc9c07e39289b14103ccd45ee31630a3">More...</a><br/></td></tr>
<tr class="separator:afc9c07e39289b14103ccd45ee31630a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39865d2369d130f6c8e435c860cafb14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a39865d2369d130f6c8e435c860cafb14">operator&lt;&lt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a39865d2369d130f6c8e435c860cafb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value left.  <a href="#a39865d2369d130f6c8e435c860cafb14">More...</a><br/></td></tr>
<tr class="separator:a39865d2369d130f6c8e435c860cafb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0615561baf45c3d84e7d36c77204ee3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0615561baf45c3d84e7d36c77204ee3d">operator&gt;&gt;</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y)</td></tr>
<tr class="memdesc:a0615561baf45c3d84e7d36c77204ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value right.  <a href="#a0615561baf45c3d84e7d36c77204ee3d">More...</a><br/></td></tr>
<tr class="separator:a0615561baf45c3d84e7d36c77204ee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55158f5f229510194c425dfae256d530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">lerp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> zero_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> one_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> weight)</td></tr>
<tr class="memdesc:a55158f5f229510194c425dfae256d530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolate between the two values according to a weight.  <a href="#a55158f5f229510194c425dfae256d530">More...</a><br/></td></tr>
<tr class="separator:a55158f5f229510194c425dfae256d530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dd5e65a4c167c112de447c628c099a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a41dd5e65a4c167c112de447c628c099a">popcount</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a41dd5e65a4c167c112de447c628c099a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of set bits in an expression.  <a href="#a41dd5e65a4c167c112de447c628c099a">More...</a><br/></td></tr>
<tr class="separator:a41dd5e65a4c167c112de447c628c099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e39642cc99af99045ec5f424cde8709"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0e39642cc99af99045ec5f424cde8709">count_leading_zeros</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a0e39642cc99af99045ec5f424cde8709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of leading zero bits in an expression.  <a href="#a0e39642cc99af99045ec5f424cde8709">More...</a><br/></td></tr>
<tr class="separator:a0e39642cc99af99045ec5f424cde8709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0042ff9c2283a15cda1a1e72de460ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa0042ff9c2283a15cda1a1e72de460ad">count_trailing_zeros</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:aa0042ff9c2283a15cda1a1e72de460ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of trailing zero bits in an expression.  <a href="#aa0042ff9c2283a15cda1a1e72de460ad">More...</a><br/></td></tr>
<tr class="separator:aa0042ff9c2283a15cda1a1e72de460ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bd57263c72c6712b643ab6486ed026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">random_float</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> seed=<a class="el" href="struct_halide_1_1_expr.html">Expr</a>())</td></tr>
<tr class="memdesc:a59bd57263c72c6712b643ab6486ed026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed float in the half-open interval [0.0f, 1.0f).  <a href="#a59bd57263c72c6712b643ab6486ed026">More...</a><br/></td></tr>
<tr class="separator:a59bd57263c72c6712b643ab6486ed026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed5b59d6a43446e311633912427b2b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aaed5b59d6a43446e311633912427b2b3">random_int</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> seed=<a class="el" href="struct_halide_1_1_expr.html">Expr</a>())</td></tr>
<tr class="memdesc:aaed5b59d6a43446e311633912427b2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed 32-bit integer.  <a href="#aaed5b59d6a43446e311633912427b2b3">More...</a><br/></td></tr>
<tr class="separator:aaed5b59d6a43446e311633912427b2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9389bcacbed602df70eae94826312e03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9389bcacbed602df70eae94826312e03">undef</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a9389bcacbed602df70eae94826312e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an undef value of the given type.  <a href="#a9389bcacbed602df70eae94826312e03">More...</a><br/></td></tr>
<tr class="separator:a9389bcacbed602df70eae94826312e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f29c5417077b940483e88cc9c1c74b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f29c5417077b940483e88cc9c1c74b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4f29c5417077b940483e88cc9c1c74b2">undef</a> ()</td></tr>
<tr class="separator:a4f29c5417077b940483e88cc9c1c74b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764">likely</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expressions tagged with this intrinsic are considered to be part of the steady state of some loop with a nasty beginning and end (e.g.  <a href="#afbf18e1b8bab056f8f8e8f1af8cbd764">More...</a><br/></td></tr>
<tr class="separator:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc875da0916176e83384df58d3ac2a08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc875da0916176e83384df58d3ac2a08">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;)</td></tr>
<tr class="memdesc:abc875da0916176e83384df58d3ac2a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> on an output stream (such as std::cout) in a human-readable form.  <a href="#abc875da0916176e83384df58d3ac2a08">More...</a><br/></td></tr>
<tr class="separator:abc875da0916176e83384df58d3ac2a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d02e8a7a68192f0f5f9d404ef23c977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5d02e8a7a68192f0f5f9d404ef23c977">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> &amp;)</td></tr>
<tr class="memdesc:a5d02e8a7a68192f0f5f9d404ef23c977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide device api type in a human readable form.  <a href="#a5d02e8a7a68192f0f5f9d404ef23c977">More...</a><br/></td></tr>
<tr class="separator:a5d02e8a7a68192f0f5f9d404ef23c977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57190a14ea6851c5ce46eaedaa77d21a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a57190a14ea6851c5ce46eaedaa77d21a">lambda</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a57190a14ea6851c5ce46eaedaa77d21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a zero-dimensional halide function that returns the given expression.  <a href="#a57190a14ea6851c5ce46eaedaa77d21a">More...</a><br/></td></tr>
<tr class="separator:a57190a14ea6851c5ce46eaedaa77d21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7305aa7d85b97f0900d7f035578ce41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa7305aa7d85b97f0900d7f035578ce41">lambda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:aa7305aa7d85b97f0900d7f035578ce41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 1-D halide function in the first argument that returns the second argument.  <a href="#aa7305aa7d85b97f0900d7f035578ce41">More...</a><br/></td></tr>
<tr class="separator:aa7305aa7d85b97f0900d7f035578ce41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bcf8b4f9e47c294dc8eb7f3784fed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a53bcf8b4f9e47c294dc8eb7f3784fed2">lambda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a53bcf8b4f9e47c294dc8eb7f3784fed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 2-D halide function in the first two arguments that returns the last argument.  <a href="#a53bcf8b4f9e47c294dc8eb7f3784fed2">More...</a><br/></td></tr>
<tr class="separator:a53bcf8b4f9e47c294dc8eb7f3784fed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938729e358e952cd3142850e6307adf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a938729e358e952cd3142850e6307adf4">lambda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a938729e358e952cd3142850e6307adf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 3-D halide function in the first three arguments that returns the last argument.  <a href="#a938729e358e952cd3142850e6307adf4">More...</a><br/></td></tr>
<tr class="separator:a938729e358e952cd3142850e6307adf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e105f7398081a2353df028af3ca79a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae8e105f7398081a2353df028af3ca79a">lambda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:ae8e105f7398081a2353df028af3ca79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 4-D halide function in the first four arguments that returns the last argument.  <a href="#ae8e105f7398081a2353df028af3ca79a">More...</a><br/></td></tr>
<tr class="separator:ae8e105f7398081a2353df028af3ca79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafda8d7cc6c2d679bd829e6817f56a7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aafda8d7cc6c2d679bd829e6817f56a7a">lambda</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> v, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:aafda8d7cc6c2d679bd829e6817f56a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 5-D halide function in the first five arguments that returns the last argument.  <a href="#aafda8d7cc6c2d679bd829e6817f56a7a">More...</a><br/></td></tr>
<tr class="separator:aafda8d7cc6c2d679bd829e6817f56a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969024cbe87c46ebf6a613214a761599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a969024cbe87c46ebf6a613214a761599">get_target_options</a> (const llvm::Module *module, llvm::TargetOptions &amp;options, std::string &amp;mcpu, std::string &amp;mattrs)</td></tr>
<tr class="memdesc:a969024cbe87c46ebf6a613214a761599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get given an llvm <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a>, get the target options by extracting the <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> metadata.  <a href="#a969024cbe87c46ebf6a613214a761599">More...</a><br/></td></tr>
<tr class="separator:a969024cbe87c46ebf6a613214a761599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8efcd232035200a0a7c0454e48bd499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa8efcd232035200a0a7c0454e48bd499">clone_target_options</a> (const llvm::Module *from, llvm::Module *to)</td></tr>
<tr class="separator:aa8efcd232035200a0a7c0454e48bd499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7ebc81a80165f5f96e217a11191b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> llvm::Module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1a7ebc81a80165f5f96e217a11191b4a">compile_module_to_llvm_module</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, llvm::LLVMContext &amp;context)</td></tr>
<tr class="memdesc:a1a7ebc81a80165f5f96e217a11191b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an LLVM module.  <a href="#a1a7ebc81a80165f5f96e217a11191b4a">More...</a><br/></td></tr>
<tr class="separator:a1a7ebc81a80165f5f96e217a11191b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04503a9bc12b1befcfd19b0dce65d42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_module.html">Module</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa04503a9bc12b1befcfd19b0dce65d42">link_modules</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="class_halide_1_1_module.html">Module</a> &gt; &amp;modules)</td></tr>
<tr class="memdesc:aa04503a9bc12b1befcfd19b0dce65d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link a set of modules together into one module.  <a href="#aa04503a9bc12b1befcfd19b0dce65d42">More...</a><br/></td></tr>
<tr class="separator:aa04503a9bc12b1befcfd19b0dce65d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef96845759806d27c854a43343bc2dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aef96845759806d27c854a43343bc2dff">compile_module_to_html</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, std::string filename=&quot;&quot;)</td></tr>
<tr class="memdesc:aef96845759806d27c854a43343bc2dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the module to HTML.  <a href="#aef96845759806d27c854a43343bc2dff">More...</a><br/></td></tr>
<tr class="separator:aef96845759806d27c854a43343bc2dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4a0e8caaf508ece646727fecf5eb32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4a4a0e8caaf508ece646727fecf5eb32">compile_module_to_text</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, std::string filename=&quot;&quot;)</td></tr>
<tr class="memdesc:a4a4a0e8caaf508ece646727fecf5eb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the module to a text statement file.  <a href="#a4a4a0e8caaf508ece646727fecf5eb32">More...</a><br/></td></tr>
<tr class="separator:a4a4a0e8caaf508ece646727fecf5eb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572e74d280e8f818abd508f5282eb2dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a572e74d280e8f818abd508f5282eb2dd">compile_standalone_runtime</a> (std::string object_filename, <a class="el" href="struct_halide_1_1_target.html">Target</a> t)</td></tr>
<tr class="memdesc:a572e74d280e8f818abd508f5282eb2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an object file containing the <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> runtime for a given target.  <a href="#a572e74d280e8f818abd508f5282eb2dd">More...</a><br/></td></tr>
<tr class="separator:a572e74d280e8f818abd508f5282eb2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8877b8b863a6b16d6ff13e196ec457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ada8877b8b863a6b16d6ff13e196ec457">user_context_value</a> ()</td></tr>
<tr class="memdesc:ada8877b8b863a6b16d6ff13e196ec457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> corresponding to the user context passed to the function (if any).  <a href="#ada8877b8b863a6b16d6ff13e196ec457">More...</a><br/></td></tr>
<tr class="separator:ada8877b8b863a6b16d6ff13e196ec457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526ddeb0daa2a8445c23381817eea573"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a526ddeb0daa2a8445c23381817eea573">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="class_halide_1_1_r_var.html">RVar</a>)</td></tr>
<tr class="memdesc:a526ddeb0daa2a8445c23381817eea573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom). ">RVar</a> in a human-readable form.  <a href="#a526ddeb0daa2a8445c23381817eea573">More...</a><br/></td></tr>
<tr class="separator:a526ddeb0daa2a8445c23381817eea573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccef6c4dd64764e831b56cd14e410c0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4ccef6c4dd64764e831b56cd14e410c0">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>)</td></tr>
<tr class="memdesc:a4ccef6c4dd64764e831b56cd14e410c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> in a human-readable form.  <a href="#a4ccef6c4dd64764e831b56cd14e410c0">More...</a><br/></td></tr>
<tr class="separator:a4ccef6c4dd64764e831b56cd14e410c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb1734eaadb362e875519e6ab68158e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e">get_host_target</a> ()</td></tr>
<tr class="memdesc:a4fb1734eaadb362e875519e6ab68158e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the target corresponding to the host machine.  <a href="#a4fb1734eaadb362e875519e6ab68158e">More...</a><br/></td></tr>
<tr class="separator:a4fb1734eaadb362e875519e6ab68158e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d655bb0051fc525e3e5d73997f93cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a> ()</td></tr>
<tr class="memdesc:a2d655bb0051fc525e3e5d73997f93cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the target that <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> will use.  <a href="#a2d655bb0051fc525e3e5d73997f93cdd">More...</a><br/></td></tr>
<tr class="separator:a2d655bb0051fc525e3e5d73997f93cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb2fdc9b09935c4f2825d425359da37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a> ()</td></tr>
<tr class="memdesc:afdb2fdc9b09935c4f2825d425359da37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the target that <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> will use for jit-compilation.  <a href="#afdb2fdc9b09935c4f2825d425359da37">More...</a><br/></td></tr>
<tr class="separator:afdb2fdc9b09935c4f2825d425359da37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41200d3966083bac5cfc95a0b4f06c26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a41200d3966083bac5cfc95a0b4f06c26">parse_target_string</a> (const std::string &amp;target)</td></tr>
<tr class="memdesc:a41200d3966083bac5cfc95a0b4f06c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string of the form used in HL_TARGET (e.g.  <a href="#a41200d3966083bac5cfc95a0b4f06c26">More...</a><br/></td></tr>
<tr class="separator:a41200d3966083bac5cfc95a0b4f06c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf59f500385c448b26d0d245f55b23f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acf59f500385c448b26d0d245f55b23f4">Int</a> (int bits, int width=1)</td></tr>
<tr class="memdesc:acf59f500385c448b26d0d245f55b23f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructing a signed integer type.  <a href="#acf59f500385c448b26d0d245f55b23f4">More...</a><br/></td></tr>
<tr class="separator:acf59f500385c448b26d0d245f55b23f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc1a3eb6d907e515712a228e1d5cbc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#addc1a3eb6d907e515712a228e1d5cbc9">UInt</a> (int bits, int width=1)</td></tr>
<tr class="memdesc:addc1a3eb6d907e515712a228e1d5cbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructing an unsigned integer type.  <a href="#addc1a3eb6d907e515712a228e1d5cbc9">More...</a><br/></td></tr>
<tr class="separator:addc1a3eb6d907e515712a228e1d5cbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a7b9a74aa0b0598f6a37b5137bab68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a63a7b9a74aa0b0598f6a37b5137bab68">Float</a> (int bits, int width=1)</td></tr>
<tr class="memdesc:a63a7b9a74aa0b0598f6a37b5137bab68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a floating-point type.  <a href="#a63a7b9a74aa0b0598f6a37b5137bab68">More...</a><br/></td></tr>
<tr class="separator:a63a7b9a74aa0b0598f6a37b5137bab68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b918730b9d45b139cabdcef54b25773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7b918730b9d45b139cabdcef54b25773">Bool</a> (int width=1)</td></tr>
<tr class="memdesc:a7b918730b9d45b139cabdcef54b25773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean type.  <a href="#a7b918730b9d45b139cabdcef54b25773">More...</a><br/></td></tr>
<tr class="separator:a7b918730b9d45b139cabdcef54b25773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae838ee5f6db542dad3500ba3a4b3c495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae838ee5f6db542dad3500ba3a4b3c495">Handle</a> (int width=1)</td></tr>
<tr class="memdesc:ae838ee5f6db542dad3500ba3a4b3c495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a handle type.  <a href="#ae838ee5f6db542dad3500ba3a4b3c495">More...</a><br/></td></tr>
<tr class="separator:ae838ee5f6db542dad3500ba3a4b3c495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230bbc98235cdeaea250aa9ab19f3312"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a230bbc98235cdeaea250aa9ab19f3312"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312">type_of</a> ()</td></tr>
<tr class="memdesc:a230bbc98235cdeaea250aa9ab19f3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the halide equivalent of a C type.  <a href="#a230bbc98235cdeaea250aa9ab19f3312">More...</a><br/></td></tr>
<tr class="separator:a230bbc98235cdeaea250aa9ab19f3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acb1194370b946274598cf0ee1a18997d"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:acb1194370b946274598cf0ee1a18997d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acb1194370b946274598cf0ee1a18997d">evaluate</a> (<a class="el" href="class_halide_1_1_tuple.html">Tuple</a> t, A *a, B *b)</td></tr>
<tr class="memdesc:acb1194370b946274598cf0ee1a18997d"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a>.  <a href="#acb1194370b946274598cf0ee1a18997d">More...</a><br/></td></tr>
<tr class="separator:acb1194370b946274598cf0ee1a18997d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa9be2c78e0e4b0abc44f4733242e5a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C &gt; </td></tr>
<tr class="memitem:a1fa9be2c78e0e4b0abc44f4733242e5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1fa9be2c78e0e4b0abc44f4733242e5a">evaluate</a> (<a class="el" href="class_halide_1_1_tuple.html">Tuple</a> t, A *a, B *b, C *c)</td></tr>
<tr class="memdesc:a1fa9be2c78e0e4b0abc44f4733242e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a>.  <a href="#a1fa9be2c78e0e4b0abc44f4733242e5a">More...</a><br/></td></tr>
<tr class="separator:a1fa9be2c78e0e4b0abc44f4733242e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f02c03e717890f1180421d3a63cfb4"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename D &gt; </td></tr>
<tr class="memitem:a91f02c03e717890f1180421d3a63cfb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a91f02c03e717890f1180421d3a63cfb4">evaluate</a> (<a class="el" href="class_halide_1_1_tuple.html">Tuple</a> t, A *a, B *b, C *c, D *d)</td></tr>
<tr class="memdesc:a91f02c03e717890f1180421d3a63cfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a>.  <a href="#a91f02c03e717890f1180421d3a63cfb4">More...</a><br/></td></tr>
<tr class="separator:a91f02c03e717890f1180421d3a63cfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4be0745af91288408f802b3a9cc7277c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a4be0745af91288408f802b3a9cc7277c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4be0745af91288408f802b3a9cc7277c">evaluate_may_gpu</a> (<a class="el" href="class_halide_1_1_tuple.html">Tuple</a> t, A *a, B *b)</td></tr>
<tr class="memdesc:a4be0745af91288408f802b3a9cc7277c"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a>.  <a href="#a4be0745af91288408f802b3a9cc7277c">More...</a><br/></td></tr>
<tr class="separator:a4be0745af91288408f802b3a9cc7277c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56e7fb0463482dfbca7b9a7f2b524d2"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C &gt; </td></tr>
<tr class="memitem:ac56e7fb0463482dfbca7b9a7f2b524d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac56e7fb0463482dfbca7b9a7f2b524d2">evaluate_may_gpu</a> (<a class="el" href="class_halide_1_1_tuple.html">Tuple</a> t, A *a, B *b, C *c)</td></tr>
<tr class="memdesc:ac56e7fb0463482dfbca7b9a7f2b524d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a>.  <a href="#ac56e7fb0463482dfbca7b9a7f2b524d2">More...</a><br/></td></tr>
<tr class="separator:ac56e7fb0463482dfbca7b9a7f2b524d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55e8726f3fd36995b1cf186992be163"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename D &gt; </td></tr>
<tr class="memitem:af55e8726f3fd36995b1cf186992be163"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af55e8726f3fd36995b1cf186992be163">evaluate_may_gpu</a> (<a class="el" href="class_halide_1_1_tuple.html">Tuple</a> t, A *a, B *b, C *c, D *d)</td></tr>
<tr class="memdesc:af55e8726f3fd36995b1cf186992be163"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a>.  <a href="#af55e8726f3fd36995b1cf186992be163">More...</a><br/></td></tr>
<tr class="separator:af55e8726f3fd36995b1cf186992be163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1cdc5fefb67660314f83e00869bb2d07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;sum&quot;)</td></tr>
<tr class="memdesc:a1cdc5fefb67660314f83e00869bb2d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inline reduction.  <a href="#a1cdc5fefb67660314f83e00869bb2d07">More...</a><br/></td></tr>
<tr class="separator:a1cdc5fefb67660314f83e00869bb2d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e465dd41437622c34d8ca57fae46986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1e465dd41437622c34d8ca57fae46986">product</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;product&quot;)</td></tr>
<tr class="memdesc:a1e465dd41437622c34d8ca57fae46986"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inline reduction.  <a href="#a1e465dd41437622c34d8ca57fae46986">More...</a><br/></td></tr>
<tr class="separator:a1e465dd41437622c34d8ca57fae46986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea53a4bc91b3d69eb68d3e712d81c39c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aea53a4bc91b3d69eb68d3e712d81c39c">maximum</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;maximum&quot;)</td></tr>
<tr class="memdesc:aea53a4bc91b3d69eb68d3e712d81c39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inline reduction.  <a href="#aea53a4bc91b3d69eb68d3e712d81c39c">More...</a><br/></td></tr>
<tr class="separator:aea53a4bc91b3d69eb68d3e712d81c39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7999c3871839488df9d591b3f55adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d7999c3871839488df9d591b3f55adf">minimum</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;minimum&quot;)</td></tr>
<tr class="memdesc:a9d7999c3871839488df9d591b3f55adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inline reduction.  <a href="#a9d7999c3871839488df9d591b3f55adf">More...</a><br/></td></tr>
<tr class="separator:a9d7999c3871839488df9d591b3f55adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aec1e5cfe69baa638e262daa16177736f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aec1e5cfe69baa638e262daa16177736f">sum</a> (<a class="el" href="class_halide_1_1_r_dom.html">RDom</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;sum&quot;)</td></tr>
<tr class="memdesc:aec1e5cfe69baa638e262daa16177736f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the inline reduction in which the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> is stated explicitly.  <a href="#aec1e5cfe69baa638e262daa16177736f">More...</a><br/></td></tr>
<tr class="separator:aec1e5cfe69baa638e262daa16177736f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2092393018c8d8165427967451631185"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2092393018c8d8165427967451631185">product</a> (<a class="el" href="class_halide_1_1_r_dom.html">RDom</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;product&quot;)</td></tr>
<tr class="memdesc:a2092393018c8d8165427967451631185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the inline reduction in which the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> is stated explicitly.  <a href="#a2092393018c8d8165427967451631185">More...</a><br/></td></tr>
<tr class="separator:a2092393018c8d8165427967451631185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353213213553142464571f4c3514d659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a353213213553142464571f4c3514d659">maximum</a> (<a class="el" href="class_halide_1_1_r_dom.html">RDom</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;maximum&quot;)</td></tr>
<tr class="memdesc:a353213213553142464571f4c3514d659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the inline reduction in which the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> is stated explicitly.  <a href="#a353213213553142464571f4c3514d659">More...</a><br/></td></tr>
<tr class="separator:a353213213553142464571f4c3514d659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185933a66a6d413535479a3c23de9496"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a185933a66a6d413535479a3c23de9496">minimum</a> (<a class="el" href="class_halide_1_1_r_dom.html">RDom</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;minimum&quot;)</td></tr>
<tr class="memdesc:a185933a66a6d413535479a3c23de9496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the inline reduction in which the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> is stated explicitly.  <a href="#a185933a66a6d413535479a3c23de9496">More...</a><br/></td></tr>
<tr class="separator:a185933a66a6d413535479a3c23de9496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5425a1934f889823896247c98e76e7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5425a1934f889823896247c98e76e7b2">argmax</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;argmax&quot;)</td></tr>
<tr class="memdesc:a5425a1934f889823896247c98e76e7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a> representing the coordinates of the point in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> which minimizes or maximizes the expression.  <a href="#a5425a1934f889823896247c98e76e7b2">More...</a><br/></td></tr>
<tr class="separator:a5425a1934f889823896247c98e76e7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b42c8c37893bacb33261bdec53303d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6b42c8c37893bacb33261bdec53303d3">argmin</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;argmin&quot;)</td></tr>
<tr class="memdesc:a6b42c8c37893bacb33261bdec53303d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a> representing the coordinates of the point in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> which minimizes or maximizes the expression.  <a href="#a6b42c8c37893bacb33261bdec53303d3">More...</a><br/></td></tr>
<tr class="separator:a6b42c8c37893bacb33261bdec53303d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56a7432d40bcac783f5292258fd00cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af56a7432d40bcac783f5292258fd00cb">argmax</a> (<a class="el" href="class_halide_1_1_r_dom.html">RDom</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;argmax&quot;)</td></tr>
<tr class="memdesc:af56a7432d40bcac783f5292258fd00cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a> representing the coordinates of the point in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> which minimizes or maximizes the expression.  <a href="#af56a7432d40bcac783f5292258fd00cb">More...</a><br/></td></tr>
<tr class="separator:af56a7432d40bcac783f5292258fd00cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4c116dc964ccc81984ed9fba6e5ac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4f4c116dc964ccc81984ed9fba6e5ac5">argmin</a> (<a class="el" href="class_halide_1_1_r_dom.html">RDom</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, const std::string &amp;s=&quot;argmin&quot;)</td></tr>
<tr class="memdesc:a4f4c116dc964ccc81984ed9fba6e5ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a> representing the coordinates of the point in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> which minimizes or maximizes the expression.  <a href="#a4f4c116dc964ccc81984ed9fba6e5ac5">More...</a><br/></td></tr>
<tr class="separator:a4f4c116dc964ccc81984ed9fba6e5ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae1900511e3091424d6d19a0d603dadf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae1900511e3091424d6d19a0d603dadf0">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> default_val)</td></tr>
<tr class="memdesc:ae1900511e3091424d6d19a0d603dadf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#ae1900511e3091424d6d19a0d603dadf0">More...</a><br/></td></tr>
<tr class="separator:ae1900511e3091424d6d19a0d603dadf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0bf94c96070c9b106c6c6408fc6156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aad0bf94c96070c9b106c6c6408fc6156">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> default_val)</td></tr>
<tr class="memdesc:aad0bf94c96070c9b106c6c6408fc6156"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#aad0bf94c96070c9b106c6c6408fc6156">More...</a><br/></td></tr>
<tr class="separator:aad0bf94c96070c9b106c6c6408fc6156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8fa9965b4ef3bf72a2e3633b12b9e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aeb8fa9965b4ef3bf72a2e3633b12b9e3">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> default_val)</td></tr>
<tr class="memdesc:aeb8fa9965b4ef3bf72a2e3633b12b9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#aeb8fa9965b4ef3bf72a2e3633b12b9e3">More...</a><br/></td></tr>
<tr class="separator:aeb8fa9965b4ef3bf72a2e3633b12b9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a49177bcb9cb40c5f481e7087d9f72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab1a49177bcb9cb40c5f481e7087d9f72">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> default_val)</td></tr>
<tr class="memdesc:ab1a49177bcb9cb40c5f481e7087d9f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#ab1a49177bcb9cb40c5f481e7087d9f72">More...</a><br/></td></tr>
<tr class="separator:ab1a49177bcb9cb40c5f481e7087d9f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a47e5c5ecf7b044dab0f974dc24a043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5a47e5c5ecf7b044dab0f974dc24a043">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c6, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v6, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> default_val)</td></tr>
<tr class="memdesc:a5a47e5c5ecf7b044dab0f974dc24a043"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#a5a47e5c5ecf7b044dab0f974dc24a043">More...</a><br/></td></tr>
<tr class="separator:a5a47e5c5ecf7b044dab0f974dc24a043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addef8a58fdaf0c263e2e0d45458e0af9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#addef8a58fdaf0c263e2e0d45458e0af9">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c6, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v6, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c7, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v7, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> default_val)</td></tr>
<tr class="memdesc:addef8a58fdaf0c263e2e0d45458e0af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#addef8a58fdaf0c263e2e0d45458e0af9">More...</a><br/></td></tr>
<tr class="separator:addef8a58fdaf0c263e2e0d45458e0af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d20138fa0526da4dbbfc1b1b59371c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a22d20138fa0526da4dbbfc1b1b59371c">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c6, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v6, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c7, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v7, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c8, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v8, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> default_val)</td></tr>
<tr class="memdesc:a22d20138fa0526da4dbbfc1b1b59371c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#a22d20138fa0526da4dbbfc1b1b59371c">More...</a><br/></td></tr>
<tr class="separator:a22d20138fa0526da4dbbfc1b1b59371c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ca1bfac3b49e9ed6705da557f52c9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a37ca1bfac3b49e9ed6705da557f52c9d">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c6, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v6, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c7, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v7, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c8, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v8, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c9, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v9, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> default_val)</td></tr>
<tr class="memdesc:a37ca1bfac3b49e9ed6705da557f52c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#a37ca1bfac3b49e9ed6705da557f52c9d">More...</a><br/></td></tr>
<tr class="separator:a37ca1bfac3b49e9ed6705da557f52c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9746d55ef95c2dd61350c69f0e5c5792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9746d55ef95c2dd61350c69f0e5c5792">select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c6, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v6, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c7, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v7, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c8, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v8, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c9, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v9, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> c10, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v10, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> default_val)</td></tr>
<tr class="memdesc:a9746d55ef95c2dd61350c69f0e5c5792"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#a9746d55ef95c2dd61350c69f0e5c5792">More...</a><br/></td></tr>
<tr class="separator:a9746d55ef95c2dd61350c69f0e5c5792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab9255b9f7b5c046d86588a9a157a6e8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab9255b9f7b5c046d86588a9a157a6e8d">print</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:ab9255b9f7b5c046d86588a9a157a6e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints out its value whenever it is evaluated.  <a href="#ab9255b9f7b5c046d86588a9a157a6e8d">More...</a><br/></td></tr>
<tr class="separator:ab9255b9f7b5c046d86588a9a157a6e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8758515155309d9f2370ae4b2e9665"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aeb8758515155309d9f2370ae4b2e9665"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aeb8758515155309d9f2370ae4b2e9665">print</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, Args...args)</td></tr>
<tr class="memdesc:aeb8758515155309d9f2370ae4b2e9665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints out its value whenever it is evaluated.  <a href="#aeb8758515155309d9f2370ae4b2e9665">More...</a><br/></td></tr>
<tr class="separator:aeb8758515155309d9f2370ae4b2e9665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5196456d46ad1c58095aea036b2a740c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5196456d46ad1c58095aea036b2a740c">print_when</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a5196456d46ad1c58095aea036b2a740c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints whenever it is evaluated, provided that the condition is true.  <a href="#a5196456d46ad1c58095aea036b2a740c">More...</a><br/></td></tr>
<tr class="separator:a5196456d46ad1c58095aea036b2a740c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab127f9210b8a9e121eb44c921475b29a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab127f9210b8a9e121eb44c921475b29a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab127f9210b8a9e121eb44c921475b29a">print_when</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, Args...args)</td></tr>
<tr class="memdesc:ab127f9210b8a9e121eb44c921475b29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints whenever it is evaluated, provided that the condition is true.  <a href="#ab127f9210b8a9e121eb44c921475b29a">More...</a><br/></td></tr>
<tr class="separator:ab127f9210b8a9e121eb44c921475b29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a565353875dc8c5c2ba41046679d6dacc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a565353875dc8c5c2ba41046679d6dacc">memoize_tag</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> result, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;cache_key_values)</td></tr>
<tr class="memdesc:a565353875dc8c5c2ba41046679d6dacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the values used in the memoization cache key for memoize.  <a href="#a565353875dc8c5c2ba41046679d6dacc">More...</a><br/></td></tr>
<tr class="separator:a565353875dc8c5c2ba41046679d6dacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeb91fa3045dfba9643ea7deabff8c7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a5eeb91fa3045dfba9643ea7deabff8c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5eeb91fa3045dfba9643ea7deabff8c7">memoize_tag</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> result, Args...args)</td></tr>
<tr class="memdesc:a5eeb91fa3045dfba9643ea7deabff8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the values used in the memoization cache key for memoize.  <a href="#a5eeb91fa3045dfba9643ea7deabff8c7">More...</a><br/></td></tr>
<tr class="separator:a5eeb91fa3045dfba9643ea7deabff8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5563684748f3d29a87b48289e5ec7c79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5563684748f3d29a87b48289e5ec7c79">compile_llvm_module_to_object</a> (llvm::Module *module, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a5563684748f3d29a87b48289e5ec7c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile an LLVM module to native targets (objects, native assembly).  <a href="#a5563684748f3d29a87b48289e5ec7c79">More...</a><br/></td></tr>
<tr class="separator:a5563684748f3d29a87b48289e5ec7c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5945ed78882b686ae07213066e36230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab5945ed78882b686ae07213066e36230">compile_llvm_module_to_assembly</a> (llvm::Module *module, const std::string &amp;filename)</td></tr>
<tr class="memdesc:ab5945ed78882b686ae07213066e36230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile an LLVM module to native targets (objects, native assembly).  <a href="#ab5945ed78882b686ae07213066e36230">More...</a><br/></td></tr>
<tr class="separator:ab5945ed78882b686ae07213066e36230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab98f07b395e5d7a7e0d23a88e9b4d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aab98f07b395e5d7a7e0d23a88e9b4d81">compile_llvm_module_to_native</a> (llvm::Module *module, const std::string &amp;object_filename, const std::string &amp;assembly_filename)</td></tr>
<tr class="memdesc:aab98f07b395e5d7a7e0d23a88e9b4d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile an LLVM module to native targets (objects, native assembly).  <a href="#aab98f07b395e5d7a7e0d23a88e9b4d81">More...</a><br/></td></tr>
<tr class="separator:aab98f07b395e5d7a7e0d23a88e9b4d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8d15365efbf0065d77c4b9b0d6a5dedb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d15365efbf0065d77c4b9b0d6a5dedb">compile_llvm_module_to_llvm_bitcode</a> (llvm::Module *module, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a8d15365efbf0065d77c4b9b0d6a5dedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile an LLVM module to LLVM targets (bitcode, LLVM assembly).  <a href="#a8d15365efbf0065d77c4b9b0d6a5dedb">More...</a><br/></td></tr>
<tr class="separator:a8d15365efbf0065d77c4b9b0d6a5dedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9563890fe279a4bfb3ecf74c8ae6bd7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9563890fe279a4bfb3ecf74c8ae6bd7a">compile_llvm_module_to_llvm_assembly</a> (llvm::Module *module, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a9563890fe279a4bfb3ecf74c8ae6bd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile an LLVM module to LLVM targets (bitcode, LLVM assembly).  <a href="#a9563890fe279a4bfb3ecf74c8ae6bd7a">More...</a><br/></td></tr>
<tr class="separator:a9563890fe279a4bfb3ecf74c8ae6bd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a21fc8271c35f04a6f60cbe0e1591f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1a21fc8271c35f04a6f60cbe0e1591f4">compile_llvm_module_to_llvm</a> (llvm::Module *module, const std::string &amp;bitcode_filename, const std::string &amp;llvm_assembly_filename)</td></tr>
<tr class="memdesc:a1a21fc8271c35f04a6f60cbe0e1591f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile an LLVM module to LLVM targets (bitcode, LLVM assembly).  <a href="#a1a21fc8271c35f04a6f60cbe0e1591f4">More...</a><br/></td></tr>
<tr class="separator:a1a21fc8271c35f04a6f60cbe0e1591f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adac5160f4a239637bb36262056242d53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#adac5160f4a239637bb36262056242d53">compile_module_to_object</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, std::string filename=&quot;&quot;)</td></tr>
<tr class="memdesc:adac5160f4a239637bb36262056242d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to a native target (object file, native assembly).  <a href="#adac5160f4a239637bb36262056242d53">More...</a><br/></td></tr>
<tr class="separator:adac5160f4a239637bb36262056242d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654ac5098b03984a6b9d7a2cc312e089"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a654ac5098b03984a6b9d7a2cc312e089">compile_module_to_assembly</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, std::string filename=&quot;&quot;)</td></tr>
<tr class="memdesc:a654ac5098b03984a6b9d7a2cc312e089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to a native target (object file, native assembly).  <a href="#a654ac5098b03984a6b9d7a2cc312e089">More...</a><br/></td></tr>
<tr class="separator:a654ac5098b03984a6b9d7a2cc312e089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1615912d73b01b9ae4a4b5bb03e7a77b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1615912d73b01b9ae4a4b5bb03e7a77b">compile_module_to_native</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, std::string object_filename=&quot;&quot;, std::string assembly_filename=&quot;&quot;)</td></tr>
<tr class="memdesc:a1615912d73b01b9ae4a4b5bb03e7a77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to a native target (object file, native assembly).  <a href="#a1615912d73b01b9ae4a4b5bb03e7a77b">More...</a><br/></td></tr>
<tr class="separator:a1615912d73b01b9ae4a4b5bb03e7a77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa3e04d1bc61fad0068cabefd30a6bf59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa3e04d1bc61fad0068cabefd30a6bf59">compile_module_to_llvm_bitcode</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, std::string filename=&quot;&quot;)</td></tr>
<tr class="memdesc:aa3e04d1bc61fad0068cabefd30a6bf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to an LLVM target (bitcode file, llvm assembly).  <a href="#aa3e04d1bc61fad0068cabefd30a6bf59">More...</a><br/></td></tr>
<tr class="separator:aa3e04d1bc61fad0068cabefd30a6bf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8412692458a649fc1078343017767ea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8412692458a649fc1078343017767ea1">compile_module_to_llvm_assembly</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, std::string filename=&quot;&quot;)</td></tr>
<tr class="memdesc:a8412692458a649fc1078343017767ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to an LLVM target (bitcode file, llvm assembly).  <a href="#a8412692458a649fc1078343017767ea1">More...</a><br/></td></tr>
<tr class="separator:a8412692458a649fc1078343017767ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1a2025e9962d2f1e3646a7c218a9b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1b1a2025e9962d2f1e3646a7c218a9b4">compile_module_to_llvm</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, std::string bitcode_filename=&quot;&quot;, std::string llvm_assembly_filename=&quot;&quot;)</td></tr>
<tr class="memdesc:a1b1a2025e9962d2f1e3646a7c218a9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to an LLVM target (bitcode file, llvm assembly).  <a href="#a1b1a2025e9962d2f1e3646a7c218a9b4">More...</a><br/></td></tr>
<tr class="separator:a1b1a2025e9962d2f1e3646a7c218a9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a10dce0459c985f45589de29e95636084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a10dce0459c985f45589de29e95636084">compile_module_to_c_header</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, std::string filename=&quot;&quot;)</td></tr>
<tr class="memdesc:a10dce0459c985f45589de29e95636084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the module to C header/source code.  <a href="#a10dce0459c985f45589de29e95636084">More...</a><br/></td></tr>
<tr class="separator:a10dce0459c985f45589de29e95636084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f919e399c8c96c5c5002ce8ab63ff21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0f919e399c8c96c5c5002ce8ab63ff21">compile_module_to_c_source</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, std::string filename=&quot;&quot;)</td></tr>
<tr class="memdesc:a0f919e399c8c96c5c5002ce8ab63ff21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the module to C header/source code.  <a href="#a0f919e399c8c96c5c5002ce8ab63ff21">More...</a><br/></td></tr>
<tr class="separator:a0f919e399c8c96c5c5002ce8ab63ff21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62be5e3c52d9d798c1a829e9f737486e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a62be5e3c52d9d798c1a829e9f737486e">compile_module_to_c</a> (const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;module, std::string h_filename=&quot;&quot;, std::string c_filename=&quot;&quot;)</td></tr>
<tr class="memdesc:a62be5e3c52d9d798c1a829e9f737486e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the module to C header/source code.  <a href="#a62be5e3c52d9d798c1a829e9f737486e">More...</a><br/></td></tr>
<tr class="separator:a62be5e3c52d9d798c1a829e9f737486e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ace03fa2f7cc38e87cccfe28089232b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ace03fa2f7cc38e87cccfe28089232b67">tuple_select</a> (<a class="el" href="class_halide_1_1_tuple.html">Tuple</a> condition, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;true_value, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;false_value)</td></tr>
<tr class="memdesc:ace03fa2f7cc38e87cccfe28089232b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalents of some standard operators for tuples.  <a href="#ace03fa2f7cc38e87cccfe28089232b67">More...</a><br/></td></tr>
<tr class="separator:ace03fa2f7cc38e87cccfe28089232b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae873393c70df82d18ad9a55ff258cc3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae873393c70df82d18ad9a55ff258cc3d">tuple_select</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;true_value, const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;false_value)</td></tr>
<tr class="memdesc:ae873393c70df82d18ad9a55ff258cc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalents of some standard operators for tuples.  <a href="#ae873393c70df82d18ad9a55ff258cc3d">More...</a><br/></td></tr>
<tr class="separator:ae873393c70df82d18ad9a55ff258cc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a709cf1e833f387da9fbf94a075f38f02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02">_</a></td></tr>
<tr class="memdesc:a709cf1e833f387da9fbf94a075f38f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder variable for infered arguments.  <a href="#a709cf1e833f387da9fbf94a075f38f02">More...</a><br/></td></tr>
<tr class="separator:a709cf1e833f387da9fbf94a075f38f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a57841c7113c6794d0178568f74b1de75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a57841c7113c6794d0178568f74b1de75">_0</a></td></tr>
<tr class="memdesc:a57841c7113c6794d0178568f74b1de75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first ten implicit Vars for use in scheduling.  <a href="#a57841c7113c6794d0178568f74b1de75">More...</a><br/></td></tr>
<tr class="separator:a57841c7113c6794d0178568f74b1de75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6eac61e701ea87443086c3597f13752"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af6eac61e701ea87443086c3597f13752">_1</a></td></tr>
<tr class="memdesc:af6eac61e701ea87443086c3597f13752"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first ten implicit Vars for use in scheduling.  <a href="#af6eac61e701ea87443086c3597f13752">More...</a><br/></td></tr>
<tr class="separator:af6eac61e701ea87443086c3597f13752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645530ef64903e9cd3aacc00436d860e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a645530ef64903e9cd3aacc00436d860e">_2</a></td></tr>
<tr class="memdesc:a645530ef64903e9cd3aacc00436d860e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first ten implicit Vars for use in scheduling.  <a href="#a645530ef64903e9cd3aacc00436d860e">More...</a><br/></td></tr>
<tr class="separator:a645530ef64903e9cd3aacc00436d860e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34aa6b48f5d654ce7efef0065be96d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a34aa6b48f5d654ce7efef0065be96d0e">_3</a></td></tr>
<tr class="memdesc:a34aa6b48f5d654ce7efef0065be96d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first ten implicit Vars for use in scheduling.  <a href="#a34aa6b48f5d654ce7efef0065be96d0e">More...</a><br/></td></tr>
<tr class="separator:a34aa6b48f5d654ce7efef0065be96d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf0b1d78a0f5f446ebc76dbc636a912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2bf0b1d78a0f5f446ebc76dbc636a912">_4</a></td></tr>
<tr class="memdesc:a2bf0b1d78a0f5f446ebc76dbc636a912"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first ten implicit Vars for use in scheduling.  <a href="#a2bf0b1d78a0f5f446ebc76dbc636a912">More...</a><br/></td></tr>
<tr class="separator:a2bf0b1d78a0f5f446ebc76dbc636a912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fae07413aae9b6c672adf92150d1ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a16fae07413aae9b6c672adf92150d1ac">_5</a></td></tr>
<tr class="memdesc:a16fae07413aae9b6c672adf92150d1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first ten implicit Vars for use in scheduling.  <a href="#a16fae07413aae9b6c672adf92150d1ac">More...</a><br/></td></tr>
<tr class="separator:a16fae07413aae9b6c672adf92150d1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1fb09d56f46575b0f5f50bb379805f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4a1fb09d56f46575b0f5f50bb379805f">_6</a></td></tr>
<tr class="memdesc:a4a1fb09d56f46575b0f5f50bb379805f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first ten implicit Vars for use in scheduling.  <a href="#a4a1fb09d56f46575b0f5f50bb379805f">More...</a><br/></td></tr>
<tr class="separator:a4a1fb09d56f46575b0f5f50bb379805f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7108f092c0886f9eb9dca85276bba0f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7108f092c0886f9eb9dca85276bba0f5">_7</a></td></tr>
<tr class="memdesc:a7108f092c0886f9eb9dca85276bba0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first ten implicit Vars for use in scheduling.  <a href="#a7108f092c0886f9eb9dca85276bba0f5">More...</a><br/></td></tr>
<tr class="separator:a7108f092c0886f9eb9dca85276bba0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64608cba6f828b3b157f893c07dee47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab64608cba6f828b3b157f893c07dee47">_8</a></td></tr>
<tr class="memdesc:ab64608cba6f828b3b157f893c07dee47"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first ten implicit Vars for use in scheduling.  <a href="#ab64608cba6f828b3b157f893c07dee47">More...</a><br/></td></tr>
<tr class="separator:ab64608cba6f828b3b157f893c07dee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700c8bfac61eb32454726b4f791302d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a700c8bfac61eb32454726b4f791302d6">_9</a></td></tr>
<tr class="memdesc:a700c8bfac61eb32454726b4f791302d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first ten implicit Vars for use in scheduling.  <a href="#a700c8bfac61eb32454726b4f791302d6">More...</a><br/></td></tr>
<tr class="separator:a700c8bfac61eb32454726b4f791302d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines methods for solving equations. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ad7b585cf844dcb14fa12386d743cbb24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_halide_1_1_stage.html">Stage</a> <a class="el" href="namespace_halide.html#ad7b585cf844dcb14fa12386d743cbb24">Halide::ScheduleHandle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l00165">165</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="aa26c7f430d2b1c44ba3e1d3f6df2ba6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">Halide::DeviceAPI</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing a type of device API. </p>
<p>Used by schedules, and in the For loop IR node. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aa26c7f430d2b1c44ba3e1d3f6df2ba6ea30269022e9d8f51beaabb52e5d0de2b7"></a>Parent</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa26c7f430d2b1c44ba3e1d3f6df2ba6eac2ca16d048ec66e04bca283eab048ec2"></a>Host</em>&#160;</td><td class="fielddoc">
<p>Used to denote for loops that inherit their device from where they are used, generally the default. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8"></a>Default_GPU</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa26c7f430d2b1c44ba3e1d3f6df2ba6eaa33b7755e5f9b504d2d038eaca4ff28d"></a>CUDA</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa26c7f430d2b1c44ba3e1d3f6df2ba6ea7982b09a852b37f2afb1227eaf552e47"></a>OpenCL</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa26c7f430d2b1c44ba3e1d3f6df2ba6ea2a2c1392bcbaececf702b611e7d7df25"></a>GLSL</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa26c7f430d2b1c44ba3e1d3f6df2ba6eab79f9fcb64263765842486e340edd503"></a>Renderscript</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa26c7f430d2b1c44ba3e1d3f6df2ba6ea3adf0945d2bbb4c868f37d38e02684d5"></a>OpenGLCompute</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_expr_8h_source.html#l00220">220</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad1953af304956bd6a5d0bd780b135f56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">Halide::StmtOutputFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to determine if the output printed to file should be as a normal string or as an HTML file which can be opened in a browerser and manipulated via JS and CSS. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91"></a>Text</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad1953af304956bd6a5d0bd780b135f56a0e7445a36a4c4afba58997fbc4871f3b"></a>HTML</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_pipeline_8h_source.html#l00033">33</a> of file <a class="el" href="_pipeline_8h_source.html">Pipeline.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9a5775a4f39e7579b10ceb1f2b611ffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> llvm::Module* Halide::codegen_llvm </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> module, generate an llvm::Module. </p>

</div>
</div>
<a class="anchor" id="a7b3021087fa785031812f050398edfec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an expression on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a81fb1fd38f327c0271eaebaf446ec700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide type on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="ac6d27a04e65a9c083f68fc8c895f3205"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::exceptions_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> was compiled with exceptions. </p>

</div>
</div>
<a class="anchor" id="af1c76d9a6be91f972dbeb1c46ce2f68b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::set_custom_compile_time_error_reporter </td>
          <td>(</td>
          <td class="paramtype">CompileTimeErrorReporter *&#160;</td>
          <td class="paramname"><em>error_reporter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default error reporter logs to stderr, then throws an exception (if WITH_EXCEPTIONS) or calls abort (if not). </p>
<p>This allows customization of that behavior if a more gentle response to error reporting is desired. Note that error_reporter is expected to remain valid across all <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> usage; it is up to the caller to ensure that this is the case (and to do any cleanup necessary). </p>

</div>
</div>
<a class="anchor" id="aced4b4be21fc5bd6c85f354b59e301ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_integer_divide </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer division by small values can be done exactly as multiplies and shifts. </p>
<p>This function does integer division for numerators of various integer types (8, 16, 32 bit signed and unsigned) numerators and uint8 denominators. The type of the result is the type of the numerator. The unsigned version is faster than the signed version, so cast the numerator to an unsigned int if you know it's positive.</p>
<p>If your divisor is compile-time constant, <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> performs a slightly better optimization automatically, so there's no need to use this function (but it won't hurt).</p>
<p>This function vectorizes well on arm, and well on x86 for 16 and 8 bit vectors. For 32-bit vectors on x86 you're better off using native integer division.</p>
<p>Also, this routine treats division by zero as division by</p>
<ol type="1">
<li>I.e. it interprets the uint8 divisor as a number from 1 to 256 inclusive. </li>
</ol>

</div>
</div>
<a class="anchor" id="a10bc862e5fcc7aeb2b41bc049e86754d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> T Halide::evaluate </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT-Compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> expression. </p>
<p>This can be thought of as a scalar version of <a class="el" href="class_halide_1_1_func.html#af4b4feae2b40e2ee5f29e2d1d99ae190">Func::realize</a> </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01558">1558</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="acb1194370b946274598cf0ee1a18997d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::evaluate </td>
          <td>(</td>
          <td class="paramtype">Tuple&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a>. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01572">1572</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a1fa9be2c78e0e4b0abc44f4733242e5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::evaluate </td>
          <td>(</td>
          <td class="paramtype">Tuple&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a>. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01590">1590</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a91f02c03e717890f1180421d3a63cfb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , typename C , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::evaluate </td>
          <td>(</td>
          <td class="paramtype">Tuple&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a>. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01613">1613</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a95ff5a8bb22ddc8770198df1be5c0d49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> T Halide::evaluate_may_gpu </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT-Compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> expression. </p>
<p>This can be thought of as a scalar version of <a class="el" href="class_halide_1_1_func.html#af4b4feae2b40e2ee5f29e2d1d99ae190">Func::realize</a>. Can use GPU if jit target from environment specifies one. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01648">1648</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment()</a>, <a class="el" href="class_halide_1_1_func.html#a2b1fe099bd3039ed95c724b24290aa9e">Halide::Func::gpu_single_thread()</a>, <a class="el" href="_target_8h_source.html#l00146">Halide::Target::has_gpu_feature()</a>, <a class="el" href="class_halide_1_1_func.html#af4b4feae2b40e2ee5f29e2d1d99ae190">Halide::Func::realize()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a4be0745af91288408f802b3a9cc7277c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::evaluate_may_gpu </td>
          <td>(</td>
          <td class="paramtype">Tuple&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a>. </p>
<p>Can use GPU if jit target from environment specifies one. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01667">1667</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment()</a>, <a class="el" href="class_halide_1_1_func.html#a2b1fe099bd3039ed95c724b24290aa9e">Halide::Func::gpu_single_thread()</a>, <a class="el" href="_target_8h_source.html#l00146">Halide::Target::has_gpu_feature()</a>, <a class="el" href="class_halide_1_1_func.html#af4b4feae2b40e2ee5f29e2d1d99ae190">Halide::Func::realize()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="ac56e7fb0463482dfbca7b9a7f2b524d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::evaluate_may_gpu </td>
          <td>(</td>
          <td class="paramtype">Tuple&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a>. </p>
<p>Can use GPU if jit target from environment specifies one. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01689">1689</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment()</a>, <a class="el" href="class_halide_1_1_func.html#a2b1fe099bd3039ed95c724b24290aa9e">Halide::Func::gpu_single_thread()</a>, <a class="el" href="_target_8h_source.html#l00146">Halide::Target::has_gpu_feature()</a>, <a class="el" href="class_halide_1_1_func.html#af4b4feae2b40e2ee5f29e2d1d99ae190">Halide::Func::realize()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="af55e8726f3fd36995b1cf186992be163"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , typename C , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::evaluate_may_gpu </td>
          <td>(</td>
          <td class="paramtype">Tuple&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JIT-compile and run enough code to evaluate a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a>. </p>
<p>Can use GPU if jit target from environment specifies one. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01715">1715</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment()</a>, <a class="el" href="class_halide_1_1_func.html#a2b1fe099bd3039ed95c724b24290aa9e">Halide::Func::gpu_single_thread()</a>, <a class="el" href="_target_8h_source.html#l00146">Halide::Target::has_gpu_feature()</a>, <a class="el" href="class_halide_1_1_func.html#af4b4feae2b40e2ee5f29e2d1d99ae190">Halide::Func::realize()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a1cdc5fefb67660314f83e00869bb2d07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sum </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;sum&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An inline reduction. </p>
<p>This is suitable for convolution-type operations - the reduction will be computed in the innermost loop that it is used in. The argument may contain free or implicit variables, and must refer to some reduction domain. The free variables are still free in the return value, but the reduction domain is captured - the result expression does not refer to a reduction domain and can be used in a pure function definition.</p>
<p>An example using <a class="el" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a> :</p>
<div class="fragment"><div class="line">Func f, g;</div>
<div class="line">Var x;</div>
<div class="line">RDom r(0, 10);</div>
<div class="line">f(x) = x*x;</div>
<div class="line">g(x) = <a class="code" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a>(f(x + r));</div>
</div><!-- fragment --><p>Here g computes some blur of x, but g is still a pure function. The sum is being computed by an anonymous reduction function that is scheduled innermost within g. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a21">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1e465dd41437622c34d8ca57fae46986"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::product </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;product&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An inline reduction. </p>
<p>This is suitable for convolution-type operations - the reduction will be computed in the innermost loop that it is used in. The argument may contain free or implicit variables, and must refer to some reduction domain. The free variables are still free in the return value, but the reduction domain is captured - the result expression does not refer to a reduction domain and can be used in a pure function definition.</p>
<p>An example using <a class="el" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a> :</p>
<div class="fragment"><div class="line">Func f, g;</div>
<div class="line">Var x;</div>
<div class="line">RDom r(0, 10);</div>
<div class="line">f(x) = x*x;</div>
<div class="line">g(x) = <a class="code" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a>(f(x + r));</div>
</div><!-- fragment --><p>Here g computes some blur of x, but g is still a pure function. The sum is being computed by an anonymous reduction function that is scheduled innermost within g. </p>

</div>
</div>
<a class="anchor" id="aea53a4bc91b3d69eb68d3e712d81c39c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::maximum </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;maximum&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An inline reduction. </p>
<p>This is suitable for convolution-type operations - the reduction will be computed in the innermost loop that it is used in. The argument may contain free or implicit variables, and must refer to some reduction domain. The free variables are still free in the return value, but the reduction domain is captured - the result expression does not refer to a reduction domain and can be used in a pure function definition.</p>
<p>An example using <a class="el" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a> :</p>
<div class="fragment"><div class="line">Func f, g;</div>
<div class="line">Var x;</div>
<div class="line">RDom r(0, 10);</div>
<div class="line">f(x) = x*x;</div>
<div class="line">g(x) = <a class="code" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a>(f(x + r));</div>
</div><!-- fragment --><p>Here g computes some blur of x, but g is still a pure function. The sum is being computed by an anonymous reduction function that is scheduled innermost within g. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a24">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9d7999c3871839488df9d591b3f55adf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::minimum </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;minimum&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An inline reduction. </p>
<p>This is suitable for convolution-type operations - the reduction will be computed in the innermost loop that it is used in. The argument may contain free or implicit variables, and must refer to some reduction domain. The free variables are still free in the return value, but the reduction domain is captured - the result expression does not refer to a reduction domain and can be used in a pure function definition.</p>
<p>An example using <a class="el" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a> :</p>
<div class="fragment"><div class="line">Func f, g;</div>
<div class="line">Var x;</div>
<div class="line">RDom r(0, 10);</div>
<div class="line">f(x) = x*x;</div>
<div class="line">g(x) = <a class="code" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a>(f(x + r));</div>
</div><!-- fragment --><p>Here g computes some blur of x, but g is still a pure function. The sum is being computed by an anonymous reduction function that is scheduled innermost within g. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a25">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aec1e5cfe69baa638e262daa16177736f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sum </td>
          <td>(</td>
          <td class="paramtype">RDom&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;sum&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the inline reduction in which the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> is stated explicitly. </p>
<p>The expression can refer to multiple RDoms, and only the inner one is captured by the reduction. This allows you to write expressions like: </p>
<div class="fragment"><div class="line">RDom r1(0, 10), r2(0, 10), r3(0, 10);</div>
<div class="line">Expr e = <a class="code" href="namespace_halide.html#a9d7999c3871839488df9d591b3f55adf">minimum</a>(r1, <a class="code" href="namespace_halide.html#a1e465dd41437622c34d8ca57fae46986">product</a>(r2, <a class="code" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a>(r3, r1 + r2 + r3)));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a2092393018c8d8165427967451631185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::product </td>
          <td>(</td>
          <td class="paramtype">RDom&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;product&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the inline reduction in which the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> is stated explicitly. </p>
<p>The expression can refer to multiple RDoms, and only the inner one is captured by the reduction. This allows you to write expressions like: </p>
<div class="fragment"><div class="line">RDom r1(0, 10), r2(0, 10), r3(0, 10);</div>
<div class="line">Expr e = <a class="code" href="namespace_halide.html#a9d7999c3871839488df9d591b3f55adf">minimum</a>(r1, <a class="code" href="namespace_halide.html#a1e465dd41437622c34d8ca57fae46986">product</a>(r2, <a class="code" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a>(r3, r1 + r2 + r3)));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a353213213553142464571f4c3514d659"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::maximum </td>
          <td>(</td>
          <td class="paramtype">RDom&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;maximum&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the inline reduction in which the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> is stated explicitly. </p>
<p>The expression can refer to multiple RDoms, and only the inner one is captured by the reduction. This allows you to write expressions like: </p>
<div class="fragment"><div class="line">RDom r1(0, 10), r2(0, 10), r3(0, 10);</div>
<div class="line">Expr e = <a class="code" href="namespace_halide.html#a9d7999c3871839488df9d591b3f55adf">minimum</a>(r1, <a class="code" href="namespace_halide.html#a1e465dd41437622c34d8ca57fae46986">product</a>(r2, <a class="code" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a>(r3, r1 + r2 + r3)));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a185933a66a6d413535479a3c23de9496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::minimum </td>
          <td>(</td>
          <td class="paramtype">RDom&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;minimum&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the inline reduction in which the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> is stated explicitly. </p>
<p>The expression can refer to multiple RDoms, and only the inner one is captured by the reduction. This allows you to write expressions like: </p>
<div class="fragment"><div class="line">RDom r1(0, 10), r2(0, 10), r3(0, 10);</div>
<div class="line">Expr e = <a class="code" href="namespace_halide.html#a9d7999c3871839488df9d591b3f55adf">minimum</a>(r1, <a class="code" href="namespace_halide.html#a1e465dd41437622c34d8ca57fae46986">product</a>(r2, <a class="code" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07">sum</a>(r3, r1 + r2 + r3)));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a5425a1934f889823896247c98e76e7b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::argmax </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;argmax&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a> representing the coordinates of the point in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> which minimizes or maximizes the expression. </p>
<p>The expression must refer to some <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a>. Also returns the extreme value of the expression as the last element of the tuple. </p>

</div>
</div>
<a class="anchor" id="a6b42c8c37893bacb33261bdec53303d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::argmin </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;argmin&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a> representing the coordinates of the point in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> which minimizes or maximizes the expression. </p>
<p>The expression must refer to some <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a>. Also returns the extreme value of the expression as the last element of the tuple. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a18">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af56a7432d40bcac783f5292258fd00cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::argmax </td>
          <td>(</td>
          <td class="paramtype">RDom&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;argmax&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a> representing the coordinates of the point in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> which minimizes or maximizes the expression. </p>
<p>The expression must refer to some <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a>. Also returns the extreme value of the expression as the last element of the tuple. </p>

</div>
</div>
<a class="anchor" id="a4f4c116dc964ccc81984ed9fba6e5ac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::argmin </td>
          <td>(</td>
          <td class="paramtype">RDom&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>&quot;argmin&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a> representing the coordinates of the point in the <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> which minimizes or maximizes the expression. </p>
<p>The expression must refer to some <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a>. Also returns the extreme value of the expression as the last element of the tuple. </p>

</div>
</div>
<a class="anchor" id="a51c6da1a731c0804063458b531e8a849"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::cast </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast an expression to the halide type corresponding to the C++ type T. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a12">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00158">158</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00163">cast()</a>, <a class="el" href="_generator_8h_source.html#l00355">Halide::NamesInterface::cast()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00896">ceil()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00379">clamp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00882">floor()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00936">is_nan()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01128">lerp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00977">operator&amp;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00243">operator*=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00199">operator+=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00226">operator-=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00265">operator/=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01011">operator^()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00994">operator|()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00911">round()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01401">Halide::Internal::scalar_to_constant_expr()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00924">trunc()</a>.</p>

</div>
</div>
<a class="anchor" id="a69ce0e6da961a52ace4b8fa8444fac20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::cast </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast an expression to a new type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00163">163</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00247">Halide::Runtime::Internal::a</a>, <a class="el" href="_expr_8h_source.html#l00117">Halide::Internal::IRHandle::as()</a>, <a class="el" href="runtime__internal_8h_source.html#l00248">Halide::Runtime::Internal::b</a>, <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00095">Halide::Type::element_of()</a>, <a class="el" href="_error_8h_source.html#l00147">internal_assert</a>, <a class="el" href="_type_8h_source.html#l00077">Halide::Type::is_handle()</a>, <a class="el" href="_type_8h_source.html#l00065">Halide::Type::is_scalar()</a>, <a class="el" href="_type_8h_source.html#l00062">Halide::Type::is_vector()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_cast.html#a2cb095f14221bcad0c21bb59083f1ce5">Halide::Internal::Cast::make()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html#a539dac4ccf5a16757b7eeec7fbc2ab78">Halide::Internal::Broadcast::make()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, <a class="el" href="_error_8h_source.html#l00149">user_assert</a>, <a class="el" href="_error_8h_source.html#l00148">user_error</a>, and <a class="el" href="_type_8h_source.html#l00042">Halide::Type::width</a>.</p>

</div>
</div>
<a class="anchor" id="a2db532b84ba55ff72555c4b427fc42bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator+ </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sum of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a16">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00190">190</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_add.html#a6d7aa4e1bbd2d9d5a9c39f7030d98e1f">Halide::Internal::Add::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="acd77e71422999076fa3339829ac8c30d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::operator+= </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the first expression to be the sum of two expressions, without changing its type. </p>
<p>This casts the second argument to match the type of the first. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00199">199</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00247">Halide::Runtime::Internal::a</a>, <a class="el" href="runtime__internal_8h_source.html#l00248">Halide::Runtime::Internal::b</a>, <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_add.html#a6d7aa4e1bbd2d9d5a9c39f7030d98e1f">Halide::Internal::Add::make()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a86f3eb27005363158ca0e934811c98ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator- </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the difference of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00207">207</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_sub.html#aafc3e579723d814afeb55256b86f4fe0">Halide::Internal::Sub::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a80881209a15ed749e168d6edbcb6f687"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator- </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the negative of the argument. </p>
<p>Does no type casting, so more formally: return that number which when added to the original, yields zero of the same type. For unsigned integers the negative is still an unsigned integer. E.g. in UInt(8), the negative of 56 is 200, because 56 + 200 == 0 </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00218">218</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_sub.html#aafc3e579723d814afeb55256b86f4fe0">Halide::Internal::Sub::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a57fedf535d58f8900f8b7c00aa15ece8">Halide::Internal::make_zero()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a94db82f1af5cd7492bb503c2238ade8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::operator-= </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the first expression to be the difference of two expressions, without changing its type. </p>
<p>This casts the second argument to match the type of the first. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00226">226</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00247">Halide::Runtime::Internal::a</a>, <a class="el" href="runtime__internal_8h_source.html#l00248">Halide::Runtime::Internal::b</a>, <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_sub.html#aafc3e579723d814afeb55256b86f4fe0">Halide::Internal::Sub::make()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a908c6748ab34a4a66274b196b6900af5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator* </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the product of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a17">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00234">234</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_mul.html#a884745bf32ff3f7105ba385197c66f50">Halide::Internal::Mul::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="ac0c84f284a38d6018e2d4e5d075c8b5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::operator*= </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the first expression to be the product of two expressions, without changing its type. </p>
<p>This casts the second argument to match the type of the first. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00243">243</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00247">Halide::Runtime::Internal::a</a>, <a class="el" href="runtime__internal_8h_source.html#l00248">Halide::Runtime::Internal::b</a>, <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_mul.html#a884745bf32ff3f7105ba385197c66f50">Halide::Internal::Mul::make()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a73e12ddd6395e3a1c1286e2e3c51e675"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator/ </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the ratio of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>
<p>Note that signed integer division in <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> rounds towards minus infinity, unlike C, which rounds towards zero. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00253">253</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab370d99a882a8163ae91d43b94d79d02">Halide::Internal::is_const()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_div.html#a99f9301a7060bbfdfa77561fab181eb5">Halide::Internal::Div::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a3c0da6820c40a5911fb23d973283487f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::operator/= </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify the first expression to be the ratio of two expressions, without changing its type. </p>
<p>This casts the second argument to match the type of the first. Note that signed integer division in <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> rounds towards minus infinity, unlike C, which rounds towards zero. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00265">265</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00247">Halide::Runtime::Internal::a</a>, <a class="el" href="runtime__internal_8h_source.html#l00248">Halide::Runtime::Internal::b</a>, <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab370d99a882a8163ae91d43b94d79d02">Halide::Internal::is_const()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_div.html#a99f9301a7060bbfdfa77561fab181eb5">Halide::Internal::Div::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="abc191ed3318e2072d18f42d11f5b01d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator% </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first argument reduced modulo the second, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>
<p>For signed integers, the sign of the result matches the sign of the second argument (unlike in C, where it matches the sign of the first argument). For example, this means that x%2 is always either zero or one, even if x is negative. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00278">278</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab370d99a882a8163ae91d43b94d79d02">Halide::Internal::is_const()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_mod.html#ad7387cdf6a660158ddfebf745479fb29">Halide::Internal::Mod::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="af9105ae9f0995f450825e522170f5d1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is greater than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00288">288</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_g_t.html#a6e93e82e1614584a1e9348d5c63a47bd">Halide::Internal::GT::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="abbad5ee20448455260670dec22c76a21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is less than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00297">297</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_l_t.html#aaae9b710b9222a4b7c40f9f064587db9">Halide::Internal::LT::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="ad297e6fa5deb0ba4e8ad7fe344629706"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is less than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00306">306</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_l_e.html#a897051fc3b8417ad85bd975b6622715d">Halide::Internal::LE::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a8f2e815b9cc7475802c0fb6a7e7ae6ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is greater than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00316">316</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_g_e.html#adf5197dc1f81a17d7ea4f425d58c10bc">Halide::Internal::GE::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="abfbbb2e5820938f4d8f0a8b2324776df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator== </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00325">325</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_e_q.html#a1fd834322820e9d57103e97bb7b4cfef">Halide::Internal::EQ::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a8d3d11c86964dbb2586103744cac1614"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide.html#afb54256bfab344b6720775cf2e0936e0">Halide::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a boolean expression that tests whether the first argument is not equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00334">334</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_n_e.html#a555a2885a87eac19363aaed91d952e8e">Halide::Internal::NE::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a02df159d6ed5236cc8e02d04bf72be4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logical and of the two arguments. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00341">341</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_internal_1_1_and.html#a1052a9e67b2ade30bb38e7b02a40c162">Halide::Internal::And::make()</a>.</p>

</div>
</div>
<a class="anchor" id="a3528931d7929d533103ada2badca092c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator|| </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logical or of the two arguments. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00346">346</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_internal_1_1_or.html#a2f11259a323ba74dc409248511396e66">Halide::Internal::Or::make()</a>.</p>

</div>
</div>
<a class="anchor" id="afb54256bfab344b6720775cf2e0936e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator! </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logical not the argument. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00351">351</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_internal_1_1_not.html#a1ab3f0f662fb2441d7a2b993a9d89c3c">Halide::Internal::Not::make()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a00cabb9f57b4cf5d101b2af338f5ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::max </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression representing the greater of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>
<p>Vectorizes cleanly on most platforms (with the exception of integer types on x86 without SSE4). </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a19">tutorial/lesson_09_update_definitions.cpp</a>, and <a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a12">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00359">359</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_max.html#ac2e01439563a937de09b129e9ce41ff8">Halide::Internal::Max::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a38b5db24ca379dda8241433c0014c940"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::min </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression representing the lesser of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>. </p>
<p>Vectorizes cleanly on most platforms (with the exception of integer types on x86 without SSE4). </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_02_input_image_8cpp-example.html#a4">tutorial/lesson_02_input_image.cpp</a>, <a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a13">tutorial/lesson_05_scheduling_1.cpp</a>, and <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a18">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00370">370</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_min.html#ab8c0866d834909f3dc7c02cb3dab9ef3">Halide::Internal::Min::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a41fc11b69e1ae900cebae51c319a1caa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::clamp </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clamps an expression to lie within the given bounds. </p>
<p>The bounds are type-cast to match the expression. Vectorizes as well as min/max. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_07_multi_stage_pipelines_8cpp-example.html#a8">tutorial/lesson_07_multi_stage_pipelines.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a23">tutorial/lesson_09_update_definitions.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a3">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00379">379</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_min.html#ab8c0866d834909f3dc7c02cb3dab9ef3">Halide::Internal::Min::make()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_max.html#ac2e01439563a937de09b129e9ce41ff8">Halide::Internal::Max::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="ae698f4bfd37d3d15cee4bf22c4627e0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::abs </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the absolute value of a signed integer or floating-point expression. </p>
<p>Vectorizes cleanly. Unlike in C, abs of a signed integer returns an unsigned integer of the same bit width. This means that abs of the most negative integer doesn't overflow. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00391">391</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00247">Halide::Runtime::Internal::a</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::abs</a>, <a class="el" href="struct_halide_1_1_type.html#a7d85142bec2162ff5b366a60a62dda1d">Halide::Type::code</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, <a class="el" href="_type_8h_source.html#l00030">Halide::Type::UInt</a>, <a class="el" href="_error_8h_source.html#l00149">user_assert</a>, and <a class="el" href="_error_8h_source.html#l00150">user_warning</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00410">absd()</a>, and <a class="el" href="_simplify_8h_source.html#l00050">Halide::Internal::mod_imp()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d96f6e421c7a9a25f3d027283c7149d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::absd </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the absolute difference between two values. </p>
<p>Vectorizes cleanly. Returns an unsigned value of the same bit width. There are various ways to write this yourself, but they contain numerous gotchas and don't always compile to good code, so use this instead. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00410">410</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00247">Halide::Runtime::Internal::a</a>, <a class="el" href="_i_r_operator_8h_source.html#l00391">abs()</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::absd</a>, <a class="el" href="struct_halide_1_1_type.html#a7d85142bec2162ff5b366a60a62dda1d">Halide::Type::code</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="_type_8h_source.html#l00068">Halide::Type::is_float()</a>, <a class="el" href="_type_8h_source.html#l00071">Halide::Type::is_int()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, <a class="el" href="_type_8h_source.html#l00030">Halide::Type::UInt</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a9d6371892ae38e7eb681fd3f23945b06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>true_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>false_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an expression similar to the ternary operator in C, except that it always evaluates all arguments. </p>
<p>If the first argument is true, then return the second, else return the third. Typically vectorizes cleanly, but benefits from SSE41 or newer on x86. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a2">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00434">434</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#a68b76ccfb1d4e7cc35ff65f15f9b0077">Halide::Internal::as_const_int()</a>, <a class="el" href="_type_8h_source.html#l00143">Bool()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_type_8h_source.html#l00059">Halide::Type::is_bool()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_select.html#aa486d1f4fa49efffe53ae78cf66896c2">Halide::Internal::Select::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00852">fast_pow()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00466">select()</a>, and <a class="el" href="_tuple_8h_source.html#l00114">tuple_select()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1900511e3091424d6d19a0d603dadf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>default_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs. </p>
<p>Evaluates to the first value for which the condition is true. Returns the final value if all conditions are false. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00466">466</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>.</p>

</div>
</div>
<a class="anchor" id="aad0bf94c96070c9b106c6c6408fc6156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>default_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs. </p>
<p>Evaluates to the first value for which the condition is true. Returns the final value if all conditions are false. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00472">472</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb8fa9965b4ef3bf72a2e3633b12b9e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>default_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs. </p>
<p>Evaluates to the first value for which the condition is true. Returns the final value if all conditions are false. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00480">480</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1a49177bcb9cb40c5f481e7087d9f72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>default_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs. </p>
<p>Evaluates to the first value for which the condition is true. Returns the final value if all conditions are false. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00490">490</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a47e5c5ecf7b044dab0f974dc24a043"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>default_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs. </p>
<p>Evaluates to the first value for which the condition is true. Returns the final value if all conditions are false. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00502">502</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>.</p>

</div>
</div>
<a class="anchor" id="addef8a58fdaf0c263e2e0d45458e0af9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>default_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs. </p>
<p>Evaluates to the first value for which the condition is true. Returns the final value if all conditions are false. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00516">516</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>.</p>

</div>
</div>
<a class="anchor" id="a22d20138fa0526da4dbbfc1b1b59371c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>default_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs. </p>
<p>Evaluates to the first value for which the condition is true. Returns the final value if all conditions are false. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00532">532</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>.</p>

</div>
</div>
<a class="anchor" id="a37ca1bfac3b49e9ed6705da557f52c9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>default_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs. </p>
<p>Evaluates to the first value for which the condition is true. Returns the final value if all conditions are false. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00550">550</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>.</p>

</div>
</div>
<a class="anchor" id="a9746d55ef95c2dd61350c69f0e5c5792"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::select </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>v10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>default_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs. </p>
<p>Evaluates to the first value for which the condition is true. Returns the final value if all conditions are false. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00570">570</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e1fca22f79625765096133e39caee5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sin </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a6">tutorial/lesson_04_debugging_2.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a2">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a3">tutorial/lesson_13_tuples.cpp</a>, and <a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a11">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00597">597</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a3bfc77a80e6b40a6c00899a8e2ad1f28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::asin </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the arcsine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00609">609</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a7e1ef33189b99c7b8bc73b5e10121834"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::cos </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cosine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a7">tutorial/lesson_04_debugging_2.cpp</a>, and <a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#a4">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00621">621</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a722a64d3ef272e07177d95b624968951"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::acos </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the arccosine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00633">633</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="ad18f43994d3cf73c20b7eb62b243076e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::tan </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tangent of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00645">645</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="abe3b0ec19519602bc880a1ae0236f1c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::atan </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the arctangent of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00657">657</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a5646de466ac31efd07ec5af1e4603cbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::atan2 </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the angle of a floating-point gradient. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00669">669</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="abe05bc670b713a278f8182457a750bd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sinh </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic sine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00685">685</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="abb5d3eac37ebfab1c8a2abf7ab1ebfaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::asinh </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic arcsinhe of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00697">697</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a68aff5fc199ecbabe209ce32ec507292"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::cosh </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic cosine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00709">709</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a2ce048ac6f7c309d26c83fbc3132be2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::acosh </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic arccosine of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00721">721</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="acb15a9760067c05d2e5a343f529188be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::tanh </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic tangent of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00733">733</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="acd93e33e8d82be7cf9487e881d834ec9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::atanh </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the hyperbolic arctangent of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Does not vectorize well. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00745">745</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="abc7f08f13439b86581a47162e1a2d2de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::sqrt </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square root of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Typically vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00757">757</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00769">hypot()</a>.</p>

</div>
</div>
<a class="anchor" id="a4fb75ff010919c00492e4f654a4d8f85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::hypot </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the square root of the sum of the squares of two floating-point expressions. </p>
<p>If the argument is not floating-point, it is cast to Float(32). Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00769">769</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00757">sqrt()</a>.</p>

</div>
</div>
<a class="anchor" id="a877c6187068d6e839e548776dfa7dde3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::exp </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the exponential of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). For Float(64) arguments, this calls the system exp function, and does not vectorize well. For Float(32) arguments, this function is vectorizable, does the right thing for extremely small or extremely large inputs, and is accurate up to the last bit of the mantissa. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00780">780</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a02f1c38239e6e977fea90b94217499ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::log </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the logarithm of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). For Float(64) arguments, this calls the system log function, and does not vectorize well. For Float(32) arguments, this function is vectorizable, does the right thing for inputs &lt;= 0 (returns -inf or nan), and is accurate up to the last bit of the mantissa. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00796">796</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a4dd83996070aa3e4bc3a102a654176fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::pow </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return one floating point expression raised to the power of another. </p>
<p>The type of the result is given by the type of the first argument. If the first argument is not a floating-point type, it is cast to Float(32). For Float(32), cleanly vectorizable, and accurate up to the last few bits of the mantissa. Gets worse when approaching overflow. Vectorizes cleanly. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a4">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00811">811</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#a68b76ccfb1d4e7cc35ff65f15f9b0077">Halide::Internal::as_const_int()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ac5890bd4a8aae2f1f6a2c43496d8ddae">Halide::Internal::raise_to_integer_power()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a9a80df08887f9457c9bffc349f834ce1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::erf </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the error function erf. </p>
<p>Only available for Float(32). Accurate up to the last three bits of the mantissa. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00831">831</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a3d36eef829f9c1e2d6aaf9218b2e0e66">Halide::Internal::halide_erf()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a7df3f02c28d9710c836194f5b2e9e8c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_log </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast approximate cleanly vectorizable log for Float(32). </p>
<p>Returns nonsense for x &lt;= 0.0f. Accurate up to the last 5 bits of the mantissa. Vectorizes cleanly. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00852">fast_pow()</a>.</p>

</div>
</div>
<a class="anchor" id="a5df130f96d92c066478cd28148d8af53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_exp </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast approximate cleanly vectorizable exp for Float(32). </p>
<p>Returns nonsense for inputs that would overflow or underflow. Typically accurate up to the last 5 bits of the mantissa. Gets worse when approaching overflow. Vectorizes cleanly. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00852">fast_pow()</a>.</p>

</div>
</div>
<a class="anchor" id="a958457cd688f84d583779e649c9e52e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_pow </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast approximate cleanly vectorizable pow for Float(32). </p>
<p>Returns nonsense for x &lt; 0.0f. Accurate up to the last 5 bits of the mantissa for typical exponents. Gets worse when approaching overflow. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00852">852</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#a68b76ccfb1d4e7cc35ff65f15f9b0077">Halide::Internal::as_const_int()</a>, <a class="el" href="namespace_halide.html#a5df130f96d92c066478cd28148d8af53">fast_exp()</a>, <a class="el" href="namespace_halide.html#a7df3f02c28d9710c836194f5b2e9e8c7">fast_log()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ac5890bd4a8aae2f1f6a2c43496d8ddae">Halide::Internal::raise_to_integer_power()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>.</p>

</div>
</div>
<a class="anchor" id="a343eac4b4aa329e52c7cbf8167902696"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_inverse </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast approximate inverse for Float(32). </p>
<p>Corresponds to the rcpps instruction on x86, and the vrecpe instruction on ARM. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00865">865</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="ad4424b070b363f53107a6c2705bbe50b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fast_inverse_sqrt </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast approximate inverse square root for Float(32). </p>
<p>Corresponds to the rsqrtps instruction on x86, and the vrsqrte instruction on ARM. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00873">873</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="aed670387016322f8db2b7abdecdc0e4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::floor </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the greatest whole number less than or equal to a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). The return value is still in floating point, despite being a whole number. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00882">882</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00095">Halide::Type::element_of()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, <a class="el" href="_error_8h_source.html#l00149">user_assert</a>, and <a class="el" href="_type_8h_source.html#l00042">Halide::Type::width</a>.</p>

<p>Referenced by <a class="el" href="_simplify_8h_source.html#l00082">Halide::Internal::mod_imp&lt; double &gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a070dde32195d1ae83082c15fd11d5d90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::ceil </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the least whole number greater than or equal to a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). The return value is still in floating point, despite being a whole number. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00896">896</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00095">Halide::Type::element_of()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, <a class="el" href="_error_8h_source.html#l00149">user_assert</a>, and <a class="el" href="_type_8h_source.html#l00042">Halide::Type::width</a>.</p>

</div>
</div>
<a class="anchor" id="a9d2090a77072af682d9e2daea086d2fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::round </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the whole number closest to a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). The return value is still in floating point, despite being a whole number. On ties, we follow IEEE754 conventions and round to the nearest even number. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00911">911</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00095">Halide::Type::element_of()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, <a class="el" href="_error_8h_source.html#l00149">user_assert</a>, and <a class="el" href="_type_8h_source.html#l00042">Halide::Type::width</a>.</p>

</div>
</div>
<a class="anchor" id="a287f93889910a28197d2a1631486a433"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::trunc </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the integer part of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). The return value is still in floating point, despite being a whole number. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00924">924</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00095">Halide::Type::element_of()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, <a class="el" href="_error_8h_source.html#l00149">user_assert</a>, and <a class="el" href="_type_8h_source.html#l00042">Halide::Type::width</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00951">fract()</a>.</p>

</div>
</div>
<a class="anchor" id="ab71c5b6b09e0f679724ccfb95515b338"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::is_nan </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the argument is a Not a Number (NaN). </p>
<p>Requires a floating point argument. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00936">936</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00143">Bool()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_type_8h_source.html#l00095">Halide::Type::element_of()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Extern</a>, <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="_type_8h_source.html#l00068">Halide::Type::is_float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, <a class="el" href="_error_8h_source.html#l00149">user_assert</a>, and <a class="el" href="_type_8h_source.html#l00042">Halide::Type::width</a>.</p>

</div>
</div>
<a class="anchor" id="a57fd83b219755aef0e53062cffc111bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::fract </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the fractional part of a floating-point expression. </p>
<p>If the argument is not floating-point, it is cast to Float(32). The return value has the same sign as the original expression. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00951">951</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00924">trunc()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a0f13f0a9e97bf7673ca5a8e04b1bd9a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::reinterpret </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinterpret the bits of one value as another type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00957">957</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00036">Halide::Type::bits</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::reinterpret</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, <a class="el" href="_error_8h_source.html#l00149">user_assert</a>, and <a class="el" href="_type_8h_source.html#l00042">Halide::Type::width</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00977">operator&amp;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01011">operator^()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00994">operator|()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00970">reinterpret()</a>.</p>

</div>
</div>
<a class="anchor" id="a2012c20f1666555e7a229c9db1b64091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::reinterpret </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00970">970</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00957">reinterpret()</a>.</p>

</div>
</div>
<a class="anchor" id="a4ec8e49b0b42230077ee6bdca669d299"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bitwise and of two expressions (which need not have the same type). </p>
<p>The type of the result is the type of the first argument. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00977">977</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00036">Halide::Type::bits</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::bitwise_and</a>, <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00957">reinterpret()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="abe8bec8d2f6194f4db7b88e554173f05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator| </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bitwise or of two expressions (which need not have the same type). </p>
<p>The type of the result is the type of the first argument. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00994">994</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00036">Halide::Type::bits</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::bitwise_or</a>, <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00957">reinterpret()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="afdde4dd479f4eb59631e09148897ad2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator^ </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bitwise exclusive or of two expressions (which need not have the same type). </p>
<p>The type of the result is the type of the first argument. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01011">1011</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00036">Halide::Type::bits</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::bitwise_xor</a>, <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00957">reinterpret()</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="afc9c07e39289b14103ccd45ee31630a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator~ </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bitwise not of an expression. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01026">1026</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::bitwise_not</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a39865d2369d130f6c8e435c860cafb14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the bits of an integer value left. </p>
<p>This is actually less efficient than multiplying by 2^n, because <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s optimization passes understand multiplication, and will compile it to shifting. This operator is only for if you really really need bit shifting (e.g. because the exponent is a run-time parameter). The type of the result is equal to the type of the first argument. Both arguments must have integer type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01038">1038</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="_type_8h_source.html#l00068">Halide::Type::is_float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::shift_left</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a0615561baf45c3d84e7d36c77204ee3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the bits of an integer value right. </p>
<p>Does sign extension for signed integers. This is less efficient than dividing by a power of two. <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s definition of division (always round to negative infinity) means that all divisions by powers of two get compiled to bit-shifting, and <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s optimization routines understand division and can work with it. The type of the result is equal to the type of the first argument. Both arguments must have integer type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01054">1054</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="_type_8h_source.html#l00068">Halide::Type::is_float()</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types()</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::shift_right</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a55158f5f229510194c425dfae256d530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::lerp </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>zero_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>one_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linear interpolate between the two values according to a weight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zero_val</td><td>The result when weight is 0 </td></tr>
    <tr><td class="paramname">one_val</td><td>The result when weight is 1 </td></tr>
    <tr><td class="paramname">weight</td><td>The interpolation amount</td></tr>
  </table>
  </dd>
</dl>
<p>Both zero_val and one_val must have the same type. All types are supported, including bool.</p>
<p>The weight is treated as its own type and must be float or an unsigned integer type. It is scaled to the bit-size of the type of x and y if they are integer, or converted to float if they are float. Integer weights are converted to float via division by the full-range value of the weight's type. Floating-point weights used to interpolate between integer values must be between 0.0f and 1.0f, and an error may be signaled if it is not provably so. (clamp operators can be added to provide proof. Currently an error is only signalled for constant weights.)</p>
<p>For integer linear interpolation, out of range values cannot be represented. In particular, weights that are conceptually less than 0 or greater than 1.0 are not representable. As such the result is always between x and y (inclusive of course). For lerp with floating-point values and floating-point weight, the full range of a float is valid, however underflow and overflow can still occur.</p>
<p>Ordering is not required between zero_val and one_val: lerp(42, 69, .5f) == lerp(69, 42, .5f) == 56</p>
<p>Results for integer types are for exactly rounded arithmetic. As such, there are cases where 16-bit and float differ because 32-bit floating-point (float) does not have enough precision to produce the exact result. (Likely true for 32-bit integer vs. double-precision floating-point as well.)</p>
<p>At present, double precision and 64-bit integers are not supported.</p>
<p>Generally, lerp will vectorize as if it were an operation on a type twice the bit size of the inferred type for x and y.</p>
<p>Some examples: </p>
<div class="fragment"><div class="line"><span class="comment">// Since Halide does not have direct type delcarations, casts</span></div>
<div class="line"><span class="comment">// below are used to indicate the types of the parameters.</span></div>
<div class="line"><span class="comment">// Such casts not required or expected in actual code where types</span></div>
<div class="line"><span class="comment">// are inferred.</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">lerp</a>(cast&lt;float&gt;(x), cast&lt;float&gt;(y), cast&lt;float&gt;(w)) -&gt;</div>
<div class="line">  x * (1.0f - w) + y * w</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">lerp</a>(cast&lt;uint8_t&gt;(x), cast&lt;uint8_t&gt;(y), cast&lt;uint8_t&gt;(w)) -&gt;</div>
<div class="line">  cast&lt;uint8_t&gt;(cast&lt;uint8_t&gt;(x) * (1.0f - cast&lt;uint8_t&gt;(w) / 255.0f) +</div>
<div class="line">                cast&lt;uint8_t&gt;(y) * cast&lt;uint8_t&gt;(w) / 255.0f + .5f)</div>
<div class="line"></div>
<div class="line"><span class="comment">// Note addition in Halide promoted uint8_t + int8_t to int16_t already,</span></div>
<div class="line"><span class="comment">// the outer cast is added for clarity.</span></div>
<div class="line"><a class="code" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">lerp</a>(cast&lt;uint8_t&gt;(x), cast&lt;int8_t&gt;(y), cast&lt;uint8_t&gt;(w)) -&gt;</div>
<div class="line">  cast&lt;int16_t&gt;(cast&lt;uint8_t&gt;(x) * (1.0f - cast&lt;uint8_t&gt;(w) / 255.0f) +</div>
<div class="line">                cast&lt;int8_t&gt;(y) * cast&lt;uint8_t&gt;(w) / 255.0f + .5f)</div>
<div class="line"></div>
<div class="line"><a class="code" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">lerp</a>(cast&lt;int8_t&gt;(x), cast&lt;int8_t&gt;(y), cast&lt;float&gt;(w)) -&gt;</div>
<div class="line">  cast&lt;int8_t&gt;(cast&lt;int8_t&gt;(x) * (1.0f - cast&lt;float&gt;(w)) +</div>
<div class="line">               cast&lt;int8_t&gt;(y) * cast&lt;uint8_t&gt;(w))</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01128">1128</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#af2a9edb743eaf6d8074867314247a970">Halide::Internal::as_const_float()</a>, <a class="el" href="namespace_halide_1_1_internal.html#a68b76ccfb1d4e7cc35ff65f15f9b0077">Halide::Internal::as_const_int()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00158">cast()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="_type_8h_source.html#l00068">Halide::Type::is_float()</a>, <a class="el" href="_type_8h_source.html#l00074">Halide::Type::is_uint()</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::lerp</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, <a class="el" href="_error_8h_source.html#l00149">user_assert</a>, and <a class="el" href="_type_8h_source.html#l00042">Halide::Type::width</a>.</p>

</div>
</div>
<a class="anchor" id="a41dd5e65a4c167c112de447c628c099a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::popcount </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of set bits in an expression. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01170">1170</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::popcount</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a0e39642cc99af99045ec5f424cde8709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::count_leading_zeros </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of leading zero bits in an expression. </p>
<p>The result is undefined if the value of the expression is zero. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01178">1178</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::count_leading_zeros</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="aa0042ff9c2283a15cda1a1e72de460ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::count_trailing_zeros </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of trailing zero bits in an expression. </p>
<p>The result is undefined if the value of the expression is zero. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01186">1186</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::count_trailing_zeros</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a59bd57263c72c6712b643ab6486ed026"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::random_float </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>seed</em> = <code>Expr()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a random variable representing a uniformly distributed float in the half-open interval [0.0f, 1.0f). </p>
<p>For random numbers of other types, use lerp with a random float as the last parameter.</p>
<p>Optionally takes a seed.</p>
<p>Note that: </p>
<div class="fragment"><div class="line">Expr x = <a class="code" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">random_float</a>();</div>
<div class="line">Expr y = x + x;</div>
</div><!-- fragment --><p>is very different to</p>
<div class="fragment"><div class="line">Expr y = <a class="code" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">random_float</a>() + <a class="code" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">random_float</a>();</div>
</div><!-- fragment --><p>The first doubles a random variable, and the second adds two independent random variables.</p>
<p>A given random variable takes on a unique value that depends deterministically on the pure variables of the function they belong to, the identity of the function itself, and which definition of the function it is used in. They are, however, shared across tuple elements.</p>
<p>This function vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01221">1221</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00134">Float()</a>, <a class="el" href="_type_8h_source.html#l00116">Int()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::random</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="aaed5b59d6a43446e311633912427b2b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::random_int </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>seed</em> = <code>Expr()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a random variable representing a uniformly distributed 32-bit integer. </p>
<p>See <a class="el" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">random_float</a>. Vectorizes cleanly. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01241">1241</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00116">Int()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::random</a>, and <a class="el" href="_error_8h_source.html#l00149">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="ab9255b9f7b5c046d86588a9a157a6e8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::print </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints out its value whenever it is evaluated. </p>
<p>It also prints out everything else in the arguments list, separated by spaces. This can include string literals. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a8">tutorial/lesson_04_debugging_2.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01286">print()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb8758515155309d9f2370ae4b2e9665"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::print </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints out its value whenever it is evaluated. </p>
<p>It also prints out everything else in the arguments list, separated by spaces. This can include string literals. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01286">1286</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l01262">Halide::Internal::collect_print_args()</a>, and <a class="el" href="namespace_halide.html#ab9255b9f7b5c046d86588a9a157a6e8d">print()</a>.</p>

</div>
</div>
<a class="anchor" id="a5196456d46ad1c58095aea036b2a740c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::print_when </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints whenever it is evaluated, provided that the condition is true. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a10">tutorial/lesson_04_debugging_2.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01299">print_when()</a>.</p>

</div>
</div>
<a class="anchor" id="ab127f9210b8a9e121eb44c921475b29a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::print_when </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints whenever it is evaluated, provided that the condition is true. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01299">1299</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l01262">Halide::Internal::collect_print_args()</a>, and <a class="el" href="namespace_halide.html#a5196456d46ad1c58095aea036b2a740c">print_when()</a>.</p>

</div>
</div>
<a class="anchor" id="a9389bcacbed602df70eae94826312e03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::undef </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an undef value of the given type. </p>
<p><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> skips stores that depend on undef values, so you can use this to mean "do not modify
this memory location". This is an escape hatch that can be used for several things:</p>
<p>You can define a reduction with no pure step, by setting the pure step to undef. Do this only if you're confident that the update steps are sufficient to correctly fill in the domain.</p>
<p>For a tuple-valued reduction, you can write an update step that only updates some tuple elements.</p>
<p>You can define single-stage pipeline that only has update steps, and depends on the values already in the output buffer.</p>
<p>Use this feature with great caution, as you can use it to load from uninitialized memory. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01326">1326</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, and <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::undef</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01333">undef()</a>.</p>

</div>
</div>
<a class="anchor" id="a4f29c5417077b940483e88cc9c1c74b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::undef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01333">1333</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l01326">undef()</a>.</p>

</div>
</div>
<a class="anchor" id="a565353875dc8c5c2ba41046679d6dacc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::memoize_tag </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache_key_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the values used in the memoization cache key for memoize. </p>
<p>Normally parameters and other external dependencies are automatically inferred and added to the cache key. The memoize_tag operator allows computing one expression and using either the computed value, or one or more other expressions in the cache key instead of the parameter dependencies of the computation. The single argument version is completely safe in that the cache key will use the actual computed value &ndash; it is difficult or imposible to produce erroneous caching this way. The more-than-one argument version allows generating cache keys that do not uniquely identify the computation and thus can result in caching errors.</p>
<p>A potential use for the single argument version is to handle a floating-point parameter that is quantized to a small integer. Mutliple values of the float will produce the same integer and moving the caching to using the integer for the key is more efficient.</p>
<p>The main use for the more-than-one argument version is to provide cache key information for Handles and ImageParams, which otherwise are not allowed inside compute_cached operations. E.g. when passing a group of parameters to an external array function via a Handle, memoize_tag can be used to isolate the actual values used by that computation. If an <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a> is a constant image with a persistent digest, memoize_tag can be used to key computations using that image on the digest. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01367">memoize_tag()</a>.</p>

</div>
</div>
<a class="anchor" id="a5eeb91fa3045dfba9643ea7deabff8c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::memoize_tag </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control the values used in the memoization cache key for memoize. </p>
<p>Normally parameters and other external dependencies are automatically inferred and added to the cache key. The memoize_tag operator allows computing one expression and using either the computed value, or one or more other expressions in the cache key instead of the parameter dependencies of the computation. The single argument version is completely safe in that the cache key will use the actual computed value &ndash; it is difficult or imposible to produce erroneous caching this way. The more-than-one argument version allows generating cache keys that do not uniquely identify the computation and thus can result in caching errors.</p>
<p>A potential use for the single argument version is to handle a floating-point parameter that is quantized to a small integer. Mutliple values of the float will produce the same integer and moving the caching to using the integer for the key is more efficient.</p>
<p>The main use for the more-than-one argument version is to provide cache key information for Handles and ImageParams, which otherwise are not allowed inside compute_cached operations. E.g. when passing a group of parameters to an external array function via a Handle, memoize_tag can be used to isolate the actual values used by that computation. If an <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a> is a constant image with a persistent digest, memoize_tag can be used to key computations using that image on the digest. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01367">1367</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00085">Halide::Internal::collect_args()</a>, and <a class="el" href="namespace_halide.html#a565353875dc8c5c2ba41046679d6dacc">memoize_tag()</a>.</p>

</div>
</div>
<a class="anchor" id="afbf18e1b8bab056f8f8e8f1af8cbd764"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::likely </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expressions tagged with this intrinsic are considered to be part of the steady state of some loop with a nasty beginning and end (e.g. </p>
<p>a boundary condition). When <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> encounters likely intrinsics, it splits the containing loop body into three, and tries to simplify down all conditions that lead to the likely. For example, given the expression: select(x &lt; 1, bar, x &gt; 10, bar, likely(foo)), <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> will split the loop over x into portions where x &lt; 1, 1 &lt;= x &lt;= 10, and x &gt; 10.</p>
<p>You're unlikely to want to call this directly. You probably want to use the boundary condition helpers in the <a class="el" href="namespace_halide_1_1_boundary_conditions.html" title="namespace to hold functions for imposing boundary conditions on Halide Funcs. ">BoundaryConditions</a> namespace instead. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01387">1387</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="_i_r_8h_source.html#l00368">Halide::Internal::Call::likely</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, and <a class="el" href="_expr_8h_source.html#l00205">Halide::Expr::type()</a>.</p>

</div>
</div>
<a class="anchor" id="abc875da0916176e83384df58d3ac2a08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a5d02e8a7a68192f0f5f9d404ef23c977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DeviceAPI &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide device api type in a human readable form. </p>

</div>
</div>
<a class="anchor" id="a57190a14ea6851c5ce46eaedaa77d21a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a zero-dimensional halide function that returns the given expression. </p>
<p>The function may have more dimensions if the expression contains implicit arguments. </p>

<p>Definition at line <a class="el" href="_lambda_8h_source.html#l00017">17</a> of file <a class="el" href="_lambda_8h_source.html">Lambda.h</a>.</p>

<p>References <a class="el" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02">_</a>, and <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name()</a>.</p>

<p>Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00071">Halide::BoundaryConditions::Internal::func_like_to_func()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7305aa7d85b97f0900d7f035578ce41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 1-D halide function in the first argument that returns the second argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments and the list of <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions. ">Var</a> arguments contains a placeholder ("_"). </p>

<p>Definition at line <a class="el" href="_lambda_8h_source.html#l00027">27</a> of file <a class="el" href="_lambda_8h_source.html">Lambda.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name()</a>.</p>

</div>
</div>
<a class="anchor" id="a53bcf8b4f9e47c294dc8eb7f3784fed2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 2-D halide function in the first two arguments that returns the last argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments and the list of <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions. ">Var</a> arguments contains a placeholder ("_"). </p>

<p>Definition at line <a class="el" href="_lambda_8h_source.html#l00037">37</a> of file <a class="el" href="_lambda_8h_source.html">Lambda.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name()</a>.</p>

</div>
</div>
<a class="anchor" id="a938729e358e952cd3142850e6307adf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 3-D halide function in the first three arguments that returns the last argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments and the list of <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions. ">Var</a> arguments contains a placeholder ("_"). </p>

<p>Definition at line <a class="el" href="_lambda_8h_source.html#l00047">47</a> of file <a class="el" href="_lambda_8h_source.html">Lambda.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name()</a>.</p>

</div>
</div>
<a class="anchor" id="ae8e105f7398081a2353df028af3ca79a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 4-D halide function in the first four arguments that returns the last argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments and the list of <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions. ">Var</a> arguments contains a placeholder ("_"). </p>

<p>Definition at line <a class="el" href="_lambda_8h_source.html#l00057">57</a> of file <a class="el" href="_lambda_8h_source.html">Lambda.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name()</a>.</p>

</div>
</div>
<a class="anchor" id="aafda8d7cc6c2d679bd829e6817f56a7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::lambda </td>
          <td>(</td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Var&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a 5-D halide function in the first five arguments that returns the last argument. </p>
<p>The function may have more dimensions if the expression contains implicit arguments and the list of <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions. ">Var</a> arguments contains a placeholder ("_"). </p>

<p>Definition at line <a class="el" href="_lambda_8h_source.html#l00067">67</a> of file <a class="el" href="_lambda_8h_source.html">Lambda.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name()</a>.</p>

</div>
</div>
<a class="anchor" id="a969024cbe87c46ebf6a613214a761599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::get_target_options </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::TargetOptions &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>mcpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>mattrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get given an llvm <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a>, get the target options by extracting the <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> metadata. </p>

</div>
</div>
<a class="anchor" id="aa8efcd232035200a0a7c0454e48bd499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::clone_target_options </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1a7ebc81a80165f5f96e217a11191b4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> llvm::Module* Halide::compile_module_to_llvm_module </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an LLVM module. </p>

</div>
</div>
<a class="anchor" id="a5563684748f3d29a87b48289e5ec7c79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_llvm_module_to_object </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile an LLVM module to native targets (objects, native assembly). </p>

</div>
</div>
<a class="anchor" id="ab5945ed78882b686ae07213066e36230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_llvm_module_to_assembly </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile an LLVM module to native targets (objects, native assembly). </p>

</div>
</div>
<a class="anchor" id="aab98f07b395e5d7a7e0d23a88e9b4d81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_llvm_module_to_native </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>object_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>assembly_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile an LLVM module to native targets (objects, native assembly). </p>

</div>
</div>
<a class="anchor" id="a8d15365efbf0065d77c4b9b0d6a5dedb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_llvm_module_to_llvm_bitcode </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile an LLVM module to LLVM targets (bitcode, LLVM assembly). </p>

</div>
</div>
<a class="anchor" id="a9563890fe279a4bfb3ecf74c8ae6bd7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_llvm_module_to_llvm_assembly </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile an LLVM module to LLVM targets (bitcode, LLVM assembly). </p>

</div>
</div>
<a class="anchor" id="a1a21fc8271c35f04a6f60cbe0e1591f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_llvm_module_to_llvm </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bitcode_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>llvm_assembly_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile an LLVM module to LLVM targets (bitcode, LLVM assembly). </p>

</div>
</div>
<a class="anchor" id="aa04503a9bc12b1befcfd19b0dce65d42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_module.html">Module</a> Halide::link_modules </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Module &gt; &amp;&#160;</td>
          <td class="paramname"><em>modules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Link a set of modules together into one module. </p>

</div>
</div>
<a class="anchor" id="adac5160f4a239637bb36262056242d53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_module_to_object </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to a native target (object file, native assembly). </p>
<p>The function that compiles both is more efficient because it re-uses internal results. The default filename is the name of the module with the default extension for the target type (.o for objects, .s for assembly). </p>

</div>
</div>
<a class="anchor" id="a654ac5098b03984a6b9d7a2cc312e089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_module_to_assembly </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to a native target (object file, native assembly). </p>
<p>The function that compiles both is more efficient because it re-uses internal results. The default filename is the name of the module with the default extension for the target type (.o for objects, .s for assembly). </p>

</div>
</div>
<a class="anchor" id="a1615912d73b01b9ae4a4b5bb03e7a77b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_module_to_native </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>object_filename</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>assembly_filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to a native target (object file, native assembly). </p>
<p>The function that compiles both is more efficient because it re-uses internal results. The default filename is the name of the module with the default extension for the target type (.o for objects, .s for assembly). </p>

</div>
</div>
<a class="anchor" id="aa3e04d1bc61fad0068cabefd30a6bf59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_module_to_llvm_bitcode </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to an LLVM target (bitcode file, llvm assembly). </p>
<p>The function that compiles both is more efficient because it re-uses internal results. The default filename is the name of the module with the default extension for the target type (.bc for bitcode, .ll for llvm assembly). </p>

</div>
</div>
<a class="anchor" id="a8412692458a649fc1078343017767ea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_module_to_llvm_assembly </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to an LLVM target (bitcode file, llvm assembly). </p>
<p>The function that compiles both is more efficient because it re-uses internal results. The default filename is the name of the module with the default extension for the target type (.bc for bitcode, .ll for llvm assembly). </p>

</div>
</div>
<a class="anchor" id="a1b1a2025e9962d2f1e3646a7c218a9b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_module_to_llvm </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>bitcode_filename</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>llvm_assembly_filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile a halide <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to an LLVM target (bitcode file, llvm assembly). </p>
<p>The function that compiles both is more efficient because it re-uses internal results. The default filename is the name of the module with the default extension for the target type (.bc for bitcode, .ll for llvm assembly). </p>

</div>
</div>
<a class="anchor" id="a10dce0459c985f45589de29e95636084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_module_to_c_header </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the module to C header/source code. </p>
<p>The default filename is the name of the module with the appropriate extension (.h/.c). </p>

</div>
</div>
<a class="anchor" id="a0f919e399c8c96c5c5002ce8ab63ff21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_module_to_c_source </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the module to C header/source code. </p>
<p>The default filename is the name of the module with the appropriate extension (.h/.c). </p>

</div>
</div>
<a class="anchor" id="a62be5e3c52d9d798c1a829e9f737486e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_module_to_c </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>h_filename</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>c_filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the module to C header/source code. </p>
<p>The default filename is the name of the module with the appropriate extension (.h/.c). </p>

</div>
</div>
<a class="anchor" id="aef96845759806d27c854a43343bc2dff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_module_to_html </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the module to HTML. </p>
<p>The default filename is the name of the module with the extension .html. </p>

</div>
</div>
<a class="anchor" id="a4a4a0e8caaf508ece646727fecf5eb32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_module_to_text </td>
          <td>(</td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the module to a text statement file. </p>
<p>The default filename is the name of the module with the extension .stmt. </p>

</div>
</div>
<a class="anchor" id="a572e74d280e8f818abd508f5282eb2dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::compile_standalone_runtime </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>object_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Target&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an object file containing the <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> runtime for a given target. </p>
<p>For use with <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa90bf2d575c86cf9ca5a2302afbfb9f6b" title="Do not include a copy of the Halide runtime in any generated object file or assembly. ">Target::NoRuntime</a>. </p>

</div>
</div>
<a class="anchor" id="ada8877b8b863a6b16d6ff13e196ec457"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::user_context_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> corresponding to the user context passed to the function (if any). </p>
<p>It is rare that this function is necessary (e.g. to pass the user context to an extern function written in C). </p>

<p>Definition at line <a class="el" href="_param_8h_source.html#l00177">177</a> of file <a class="el" href="_param_8h_source.html">Param.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00148">Handle()</a>, and <a class="el" href="_i_r_8h_source.html#l00472">Halide::Internal::Variable::make()</a>.</p>

</div>
</div>
<a class="anchor" id="a526ddeb0daa2a8445c23381817eea573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RVar&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an <a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom). ">RVar</a> in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a4ccef6c4dd64764e831b56cd14e410c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RDom&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit an <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a4fb1734eaadb362e875519e6ab68158e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::get_host_target </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the target corresponding to the host machine. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a8">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2d655bb0051fc525e3e5d73997f93cdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::get_target_from_environment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the target that <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> will use. </p>
<p>If HL_TARGET is set it uses that. Otherwise calls <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e">get_host_target</a> </p>

</div>
</div>
<a class="anchor" id="afdb2fdc9b09935c4f2825d425359da37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::get_jit_target_from_environment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the target that <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> will use for jit-compilation. </p>
<p>If HL_JIT_TARGET is set it uses that. Otherwise calls <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e">get_host_target</a>. Throws an error if the architecture, bit width, and OS of the target do not match the host target, so this is only useful for controlling the feature set. </p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01648">evaluate_may_gpu()</a>.</p>

</div>
</div>
<a class="anchor" id="a41200d3966083bac5cfc95a0b4f06c26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::parse_target_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a string of the form used in HL_TARGET (e.g. </p>
<p>"x86-64-avx"), return the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> it specifies. Note that this always starts with the result of <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e" title="Return the target corresponding to the host machine. ">get_host_target()</a>, replacing only the parts found in the target string, so if you omit (say) an OS specification, the host OS will be used instead. An empty string is exactly equivalent to <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e" title="Return the target corresponding to the host machine. ">get_host_target()</a>. </p>

</div>
</div>
<a class="anchor" id="ace03fa2f7cc38e87cccfe28089232b67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::tuple_select </td>
          <td>(</td>
          <td class="paramtype">Tuple&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>true_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>false_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalents of some standard operators for tuples. </p>

<p>Definition at line <a class="el" href="_tuple_8h_source.html#l00114">114</a> of file <a class="el" href="_tuple_8h_source.html">Tuple.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>, and <a class="el" href="_tuple_8h_source.html#l00025">Halide::Tuple::size()</a>.</p>

</div>
</div>
<a class="anchor" id="ae873393c70df82d18ad9a55ff258cc3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a> Halide::tuple_select </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>true_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>false_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalents of some standard operators for tuples. </p>

<p>Definition at line <a class="el" href="_tuple_8h_source.html#l00122">122</a> of file <a class="el" href="_tuple_8h_source.html">Tuple.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>, and <a class="el" href="_tuple_8h_source.html#l00025">Halide::Tuple::size()</a>.</p>

</div>
</div>
<a class="anchor" id="acf59f500385c448b26d0d245f55b23f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Int </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructing a signed integer type. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a5">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_type_8h_source.html#l00116">116</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00036">Halide::Type::bits</a>, <a class="el" href="struct_halide_1_1_type.html#a7d85142bec2162ff5b366a60a62dda1d">Halide::Type::code</a>, <a class="el" href="_type_8h_source.html#l00029">Halide::Type::Int</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, and <a class="el" href="_type_8h_source.html#l00042">Halide::Type::width</a>.</p>

<p>Referenced by <a class="el" href="_generator_8h_source.html#l00361">Halide::NamesInterface::Int()</a>, <a class="el" href="_expr_8h_source.html#l00129">Halide::Internal::IntImm::make()</a>, <a class="el" href="_var_8h_source.html#l00148">Halide::Var::operator Expr()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01221">random_float()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01241">random_int()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01423">Halide::Internal::scalar_to_constant_expr()</a>.</p>

</div>
</div>
<a class="anchor" id="addc1a3eb6d907e515712a228e1d5cbc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::UInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructing an unsigned integer type. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a12">tutorial/lesson_12_using_the_gpu.cpp</a>, and <a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a4">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_type_8h_source.html#l00125">125</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00036">Halide::Type::bits</a>, <a class="el" href="struct_halide_1_1_type.html#a7d85142bec2162ff5b366a60a62dda1d">Halide::Type::code</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, <a class="el" href="_type_8h_source.html#l00030">Halide::Type::UInt</a>, and <a class="el" href="_type_8h_source.html#l00042">Halide::Type::width</a>.</p>

<p>Referenced by <a class="el" href="_type_8h_source.html#l00143">Bool()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01430">Halide::Internal::scalar_to_constant_expr()</a>, and <a class="el" href="_generator_8h_source.html#l00362">Halide::NamesInterface::UInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a63a7b9a74aa0b0598f6a37b5137bab68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Float </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a floating-point type. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a6">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_type_8h_source.html#l00134">134</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00036">Halide::Type::bits</a>, <a class="el" href="struct_halide_1_1_type.html#a7d85142bec2162ff5b366a60a62dda1d">Halide::Type::code</a>, <a class="el" href="_type_8h_source.html#l00031">Halide::Type::Float</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, and <a class="el" href="_type_8h_source.html#l00042">Halide::Type::width</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00633">acos()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00721">acosh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00609">asin()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00697">asinh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00657">atan()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00669">atan2()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00745">atanh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00896">ceil()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00621">cos()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00709">cosh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00831">erf()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00780">exp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00865">fast_inverse()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00873">fast_inverse_sqrt()</a>, <a class="el" href="_generator_8h_source.html#l00360">Halide::NamesInterface::Float()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00882">floor()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00936">is_nan()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00796">log()</a>, <a class="el" href="_expr_8h_source.html#l00149">Halide::Internal::FloatImm::make()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00811">pow()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01221">random_float()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00911">round()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01407">Halide::Internal::scalar_to_constant_expr()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00597">sin()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00685">sinh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00757">sqrt()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00645">tan()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00733">tanh()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00924">trunc()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b918730b9d45b139cabdcef54b25773"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Bool </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a boolean type. </p>

<p>Definition at line <a class="el" href="_type_8h_source.html#l00143">143</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00125">UInt()</a>.</p>

<p>Referenced by <a class="el" href="_generator_8h_source.html#l00359">Halide::NamesInterface::Bool()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00936">is_nan()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00434">select()</a>.</p>

</div>
</div>
<a class="anchor" id="ae838ee5f6db542dad3500ba3a4b3c495"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Handle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a handle type. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_14_types_8cpp-example.html#a7">tutorial/lesson_14_types.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_type_8h_source.html#l00148">148</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00036">Halide::Type::bits</a>, <a class="el" href="struct_halide_1_1_type.html#a7d85142bec2162ff5b366a60a62dda1d">Halide::Type::code</a>, <a class="el" href="_type_8h_source.html#l00032">Halide::Type::Handle</a>, <a class="el" href="runtime__internal_8h_source.html#l00246">Halide::Runtime::Internal::t</a>, and <a class="el" href="_type_8h_source.html#l00042">Halide::Type::width</a>.</p>

<p>Referenced by <a class="el" href="_expr_8h_source.html#l00161">Halide::Internal::StringImm::make()</a>, and <a class="el" href="_param_8h_source.html#l00177">user_context_value()</a>.</p>

</div>
</div>
<a class="anchor" id="a230bbc98235cdeaea250aa9ab19f3312"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::type_of </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the halide equivalent of a C type. </p>

<p>Definition at line <a class="el" href="_type_8h_source.html#l00224">224</a> of file <a class="el" href="_type_8h_source.html">Type.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a709cf1e833f387da9fbf94a075f38f02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a> Halide::_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A placeholder variable for infered arguments. </p>
<p>See <a class="el" href="class_halide_1_1_var.html#a333e72cf9af6339530cb3544b7fe1324">Var::implicit</a> </p>

<p>Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00071">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, <a class="el" href="_lambda_8h_source.html#l00017">lambda()</a>, <a class="el" href="_image_8h_source.html#l00291">Halide::Image&lt; T &gt;::operator Expr()</a>, <a class="el" href="_param_8h_source.html#l00356">Halide::ImageParam::operator Expr()</a>, and <a class="el" href="_func_8h_source.html#l01533">Halide::Func::operator Expr()</a>.</p>

</div>
</div>
<a class="anchor" id="a57841c7113c6794d0178568f74b1de75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a> Halide::_0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first ten implicit Vars for use in scheduling. </p>
<p>See <a class="el" href="class_halide_1_1_var.html#a333e72cf9af6339530cb3544b7fe1324">Var::implicit</a> </p>

</div>
</div>
<a class="anchor" id="af6eac61e701ea87443086c3597f13752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a> Halide::_1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first ten implicit Vars for use in scheduling. </p>
<p>See <a class="el" href="class_halide_1_1_var.html#a333e72cf9af6339530cb3544b7fe1324">Var::implicit</a> </p>

</div>
</div>
<a class="anchor" id="a645530ef64903e9cd3aacc00436d860e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a> Halide::_2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first ten implicit Vars for use in scheduling. </p>
<p>See <a class="el" href="class_halide_1_1_var.html#a333e72cf9af6339530cb3544b7fe1324">Var::implicit</a> </p>

</div>
</div>
<a class="anchor" id="a34aa6b48f5d654ce7efef0065be96d0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a> Halide::_3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first ten implicit Vars for use in scheduling. </p>
<p>See <a class="el" href="class_halide_1_1_var.html#a333e72cf9af6339530cb3544b7fe1324">Var::implicit</a> </p>

</div>
</div>
<a class="anchor" id="a2bf0b1d78a0f5f446ebc76dbc636a912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a> Halide::_4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first ten implicit Vars for use in scheduling. </p>
<p>See <a class="el" href="class_halide_1_1_var.html#a333e72cf9af6339530cb3544b7fe1324">Var::implicit</a> </p>

</div>
</div>
<a class="anchor" id="a16fae07413aae9b6c672adf92150d1ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a> Halide::_5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first ten implicit Vars for use in scheduling. </p>
<p>See <a class="el" href="class_halide_1_1_var.html#a333e72cf9af6339530cb3544b7fe1324">Var::implicit</a> </p>

</div>
</div>
<a class="anchor" id="a4a1fb09d56f46575b0f5f50bb379805f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a> Halide::_6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first ten implicit Vars for use in scheduling. </p>
<p>See <a class="el" href="class_halide_1_1_var.html#a333e72cf9af6339530cb3544b7fe1324">Var::implicit</a> </p>

</div>
</div>
<a class="anchor" id="a7108f092c0886f9eb9dca85276bba0f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a> Halide::_7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first ten implicit Vars for use in scheduling. </p>
<p>See <a class="el" href="class_halide_1_1_var.html#a333e72cf9af6339530cb3544b7fe1324">Var::implicit</a> </p>

</div>
</div>
<a class="anchor" id="ab64608cba6f828b3b157f893c07dee47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a> Halide::_8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first ten implicit Vars for use in scheduling. </p>
<p>See <a class="el" href="class_halide_1_1_var.html#a333e72cf9af6339530cb3544b7fe1324">Var::implicit</a> </p>

</div>
</div>
<a class="anchor" id="a700c8bfac61eb32454726b4f791302d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_var.html">Var</a> Halide::_9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first ten implicit Vars for use in scheduling. </p>
<p>See <a class="el" href="class_halide_1_1_var.html#a333e72cf9af6339530cb3544b7fe1324">Var::implicit</a> </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
