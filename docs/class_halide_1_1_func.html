<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Halide: Halide::Func Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_halide_1_1_func.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Func Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Halide::Func" -->
<p>A halide function.  
 <a href="class_halide_1_1_func.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_func_8h_source.html">Func.h</a>&gt;</code></p>

<p><a href="class_halide_1_1_func-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a265d4e8c8c6225fb5455f4b6c3496db0">Func</a> (const std::string &amp;<a class="el" href="class_halide_1_1_func.html#a1c36026717d2f74a842983d65e6b3bf8">name</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a new undefined function with the given name.  <a href="#a265d4e8c8c6225fb5455f4b6c3496db0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b">Func</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a new undefined function with an automatically-generated unique name.  <a href="#aed876d44c3e1dd0a72c4111afc63018b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a89aa00c3ee27c264979fd1b90f271085">Func</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a new function with an automatically-generated unique name, and define it to return the given expression (which may not contain free variables).  <a href="#a89aa00c3ee27c264979fd1b90f271085"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a297da02c042addeb2556a656b2931614">Func</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a> f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to wrap an existing, already-define Function object.  <a href="#a297da02c042addeb2556a656b2931614"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aae9623ffff43b170735b65c490b68ffb">compile_to_header</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const std::string &amp;fn_name=&quot;&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a header file with the given filename for this function.  <a href="#aae9623ffff43b170735b65c490b68ffb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#afff013625f408efd641c2a0c0db04827">compile_to_c</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const std::string &amp;fn_name=&quot;&quot;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to C source code.  <a href="#afff013625f408efd641c2a0c0db04827"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a1c52d590b142458b600dcf420401c485">compile_to_lowered_stmt</a> (const std::string &amp;filename, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code.  <a href="#a1c52d590b142458b600dcf420401c485"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a4bb020bfc9d7e83325dc59b271513dfc">compile_jit</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Eagerly jit compile the function to machine code.  <a href="#a4bb020bfc9d7e83325dc59b271513dfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a043d5e26caec7bc3afb32c770699e3de">set_error_handler</a> (void(*handler)(void *, const char *))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the error handler function that be called in the case of runtime errors during halide pipelines.  <a href="#a043d5e26caec7bc3afb32c770699e3de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#accac17bd1d0e40c50d50b515e082d922">set_custom_allocator</a> (void *(*<a class="el" href="runtime__internal_8h.html#a1c8580582aae58105f16108d4ec89e9a">malloc</a>)(void *, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>), void(*<a class="el" href="runtime__internal_8h.html#af07d89f5ceaea0c7c8252cc41fd75f37">free</a>)(void *, void *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a18eb1fc8785fa98c27b44f0f3926c7fa">set_custom_do_task</a> (int(*custom_do_task)(void *, int(*)(void *, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *), int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom task handler to be called by the parallel for loop.  <a href="#a18eb1fc8785fa98c27b44f0f3926c7fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#afd38942fde8f87b6851d47bf99513ba1">set_custom_do_par_for</a> (int(*custom_do_par_for)(void *, int(*)(void *, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *), int, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom parallel for loop launcher.  <a href="#afd38942fde8f87b6851d47bf99513ba1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aad5f2b878005cd24c3b49c4856652971">set_custom_trace</a> (<a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_compiled_module.html#ac96e1d288eaaa85933cda36bad19c5ef">Internal::JITCompiledModule::TraceFn</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set custom routines to call when tracing is enabled.  <a href="#aad5f2b878005cd24c3b49c4856652971"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad4f476e156406c4a07c80a6c5be3597c">set_custom_print</a> (void(*handler)(void *, const char *))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the function called to print messages from the runtime.  <a href="#ad4f476e156406c4a07c80a6c5be3597c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#adefe791b9c16f1674a1df2e1c5c75099">memoization_cache_set_size</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of bytes used by memoization caching.  <a href="#adefe791b9c16f1674a1df2e1c5c75099"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad698122392e50574c38e3d19b0c9c41e">debug_to_file</a> (const std::string &amp;filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">When this function is compiled, include code that dumps its values to a file after it is realized, for the purpose of debugging.  <a href="#ad698122392e50574c38e3d19b0c9c41e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a1c36026717d2f74a842983d65e6b3bf8">name</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of this function, either given during construction, or automatically generated.  <a href="#a1c36026717d2f74a842983d65e6b3bf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a830f40950d6695281dc4c5057767ca4f">args</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pure arguments.  <a href="#a830f40950d6695281dc4c5057767ca4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a184f385b265e7ba488a2eed66a10b41a">value</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The right-hand-side value of the pure definition of this function.  <a href="#a184f385b265e7ba488a2eed66a10b41a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a2d2b62cf0249b0dcd24f41b246d82b3a">values</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The values returned by this function.  <a href="#a2d2b62cf0249b0dcd24f41b246d82b3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6744d1c69eeba054cc16c019a99e888d">defined</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this function have at least a pure definition.  <a href="#a6744d1c69eeba054cc16c019a99e888d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a574a2ab983f3b4da9baf94b379a2b2b4">update_args</a> (int idx=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the left-hand-side of the update definition.  <a href="#a574a2ab983f3b4da9baf94b379a2b2b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a7303885a8686f7bfb848a3d21214edfd">update_value</a> (int idx=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the right-hand-side of an update definition.  <a href="#a7303885a8686f7bfb848a3d21214edfd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ac2c3df8403e8f990331525e4e7138e51">update_values</a> (int idx=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the right-hand-side of an update definition for functions that returns multiple values.  <a href="#ac2c3df8403e8f990331525e4e7138e51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aa7c366ab3a5c6a472e19f5860b309eda">reduction_domain</a> (int idx=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reduction domain for an update definition, if there is one.  <a href="#aa7c366ab3a5c6a472e19f5860b309eda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a68f35881fbc6bcbed6442b1f6dfb6f6c">has_update_definition</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this function have at least one update definition?  <a href="#a68f35881fbc6bcbed6442b1f6dfb6f6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a75792d22e6a8774a34785a2bc80a7d65">num_update_definitions</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">How many update definitions does this function have?  <a href="#a75792d22e6a8774a34785a2bc80a7d65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a10ea6486f854455c7c6275c5a34400f8">is_extern</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this function an external stage? That is, was it defined using define_extern?  <a href="#a10ea6486f854455c7c6275c5a34400f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a0622c8a11c948787eafbee82a0853030">output_types</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the types of the outputs of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="#a0622c8a11c948787eafbee82a0853030"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a2ddfd0eef6173d668c0f76d6c52cefb7">outputs</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of outputs of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="#a2ddfd0eef6173d668c0f76d6c52cefb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aeb3bd4ac6913bc0137f91ea7b6412acd">extern_function_name</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the extern function called for an extern definition.  <a href="#aeb3bd4ac6913bc0137f91ea7b6412acd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a8993a73f9eb2d0c7ccc58028447d42f3">dimensions</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimensionality (number of arguments) of this function.  <a href="#a8993a73f9eb2d0c7ccc58028447d42f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a52a4cace19fc024959cda3a7e82dd9f6">split</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> old, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> outer, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> inner, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> factor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension into inner and outer subdimensions with the given names, where the inner dimension iterates from 0 to factor-1.  <a href="#a52a4cace19fc024959cda3a7e82dd9f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a07ae6163527e6319a9352f7648afd875">fuse</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> inner, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> outer, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> fused)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Join two dimensions into a single fused dimenion.  <a href="#a07ae6163527e6319a9352f7648afd875"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a0cc4478f55fbba3e25ed8ee5ea30d461">serial</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be traversed serially.  <a href="#a0cc4478f55fbba3e25ed8ee5ea30d461"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aa0050c604179b43a8deb42b62dedd29d">parallel</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be traversed in parallel.  <a href="#aa0050c604179b43a8deb42b62dedd29d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ac2cb83a295d98281e93b11a2c1881eae">parallel</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> var, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> task_size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension by the given task_size, and the parallelize the outer dimension.  <a href="#ac2cb83a295d98281e93b11a2c1881eae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a7b1857a62deca8bc9a477c1b26720950">vectorize</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be computed all-at-once as a single vector.  <a href="#a7b1857a62deca8bc9a477c1b26720950"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a75c97910f964410df65f04f7a85e3518">unroll</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a dimension to be completely unrolled.  <a href="#a75c97910f964410df65f04f7a85e3518"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a76cc0eb4dd4d5ce2144fc536c5ad2218">vectorize</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> var, int factor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension by the given factor, then vectorize the inner dimension.  <a href="#a76cc0eb4dd4d5ce2144fc536c5ad2218"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aff8b6136345c72f4976ec1e2d99d0a39">unroll</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> var, int factor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a dimension by the given factor, then unroll the inner dimension.  <a href="#aff8b6136345c72f4976ec1e2d99d0a39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#afadd04bc51ed5999496eaa876a4ee790">bound</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> var, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940">min</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically declare that the range over which a function should be evaluated is given by the second and third arguments.  <a href="#afadd04bc51ed5999496eaa876a4ee790"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ab15001cd4af9e8c2808f45ff53b81582">tile</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> xo, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> yo, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> xi, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> yi, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> xfactor, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> yfactor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi, yi, xo, yo from innermost outwards.  <a href="#ab15001cd4af9e8c2808f45ff53b81582"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad2cd7aab5ed429755a6c6a2c3cd608b9">tile</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> xi, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> yi, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> xfactor, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> yfactor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A shorter form of tile, which reuses the old variable names as the new outer dimensions.  <a href="#ad2cd7aab5ed429755a6c6a2c3cd608b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754">reorder</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;vars)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder variables to have the given nesting order, from innermost out.  <a href="#a2ad991bc3ebd940906187a0552ef7754"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a623981c5b7da85fc511d4fa5a2cc0e9c">reorder</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder two dimensions so that x is traversed inside y.  <a href="#a623981c5b7da85fc511d4fa5a2cc0e9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a9325061ec4e13c7c689f57f40fd1a245">reorder</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder three dimensions to have the given nesting order, from innermost out.  <a href="#a9325061ec4e13c7c689f57f40fd1a245"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a448833656daa9b8c15dde144f4b37624">reorder</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> z, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder four dimensions to have the given nesting order, from innermost out.  <a href="#a448833656daa9b8c15dde144f4b37624"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a65789828fc8ae0e60b47b5e2fef1c9f2">reorder</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> z, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> w, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder five dimensions to have the given nesting order, from innermost out.  <a href="#a65789828fc8ae0e60b47b5e2fef1c9f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a7f533dd5f9cac7780a91602c7265c707">reorder</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> z, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> w, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t1, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder six dimensions to have the given nesting order, from innermost out.  <a href="#a7f533dd5f9cac7780a91602c7265c707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a17ca21cd1540a7a426bad4f8439022d7">reorder</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> z, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> w, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t1, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t2, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder seven dimensions to have the given nesting order, from innermost out.  <a href="#a17ca21cd1540a7a426bad4f8439022d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aec6164c247a777e0525027ccc6ad5490">reorder</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> z, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> w, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t1, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t2, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t3, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder eight dimensions to have the given nesting order, from innermost out.  <a href="#aec6164c247a777e0525027ccc6ad5490"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#adbdb24c59648086d558e35f0a5e7020b">reorder</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> z, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> w, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t1, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t2, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t3, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t4, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder nine dimensions to have the given nesting order, from innermost out.  <a href="#adbdb24c59648086d558e35f0a5e7020b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a34fb43d08a61f6a4e06175c18491ecea">reorder</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> z, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> w, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t1, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t2, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t3, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t4, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t5, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> t6)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder ten dimensions to have the given nesting order, from innermost out.  <a href="#a34fb43d08a61f6a4e06175c18491ecea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a7d9dd3771ece9a9525bf9129b5339aae">rename</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> old_name, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> new_name)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a dimension.  <a href="#a7d9dd3771ece9a9525bf9129b5339aae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#af060692f2192e9d777a3cee8b87c5e88">allow_race_conditions</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify that race conditions are permitted for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, which enables parallelizing over RVars even when <a class="el" href="namespace_halide.html">Halide</a> cannot prove that it is safe to do so.  <a href="#af060692f2192e9d777a3cee8b87c5e88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aa4053da66218dfd7769ea4d974e252b5">specialize</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialize a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="#aa4053da66218dfd7769ea4d974e252b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aeff457fc695a5ff574c2a2f935c1e77f">gpu_single_thread</a> (<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> to run this stage using a single gpu thread and block.  <a href="#aeff457fc695a5ff574c2a2f935c1e77f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a74d3a0c590fbedb255cdef354a204da8">glsl</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule for execution using GLSL.  <a href="#a74d3a0c590fbedb255cdef354a204da8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">compute_at</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f, <a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute this function as needed for each unique value of the given var for the given calling function f.  <a href="#a11de589971243d53709563789ef09273"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#addf97325c7449720d8d84115353a2c7d">compute_at</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f, <a class="el" href="class_halide_1_1_r_var.html">RVar</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a function to be computed within the iteration over some dimension of an update domain.  <a href="#addf97325c7449720d8d84115353a2c7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a7f4db7e4884fe76399bf2a673567eab5">compute_root</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all of this function once ahead of time.  <a href="#a7f4db7e4884fe76399bf2a673567eab5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a5f5bb4a59d9f96187b1fa71fa5f7677b">memoize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the halide_memoization_cache_...  <a href="#a5f5bb4a59d9f96187b1fa71fa5f7677b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7">store_at</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f, <a class="el" href="class_halide_1_1_var.html">Var</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage for this function within f's loop over var.  <a href="#a33cb0d00bc9585bf3027011ecb1412b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a61980a1317bdbd1017f284414865deac">store_at</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f, <a class="el" href="class_halide_1_1_r_var.html">RVar</a> var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to the version of store_at that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>, but schedules storage within the loop over a dimension of a reduction domain.  <a href="#a61980a1317bdbd1017f284414865deac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a7048eaf680bc0c78961c0bef48d37f85">store_root</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <a class="el" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7">Func::store_at</a>, but schedules storage outside the outermost loop.  <a href="#a7048eaf680bc0c78961c0bef48d37f85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6b824c681a83aba8e318652bade047dc">compute_inline</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggressively inline all uses of this function.  <a href="#a6b824c681a83aba8e318652bade047dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ae2013b9623e9c24a47930ef1874d2b4b">update</a> (int idx=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle on an update step for the purposes of scheduling it.  <a href="#ae2013b9623e9c24a47930ef1874d2b4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a375c44be83cecdc181115a0018a7f31b">trace_loads</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace all loads from this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by emitting calls to halide_trace.  <a href="#a375c44be83cecdc181115a0018a7f31b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace all stores to the buffer backing this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by emitting calls to halide_trace.  <a href="#ad88d11ad4164bce72320f2c064fc87d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aa3981c97ffef96ab12c229371d766fef">trace_realizations</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace all realizations of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by emitting calls to halide_trace.  <a href="#aa3981c97ffef96ab12c229371d766fef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#af53d44302c15c4335e55a2887e2f780e">function</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle on the internal halide function that this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> represents.  <a href="#af53d44302c15c4335e55a2887e2f780e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a58c0a7588e5e59a1d78cafadeff030b9">operator Stage</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">You can cast a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to its pure stage for the purposes of scheduling it.  <a href="#a58c0a7588e5e59a1d78cafadeff030b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#af30b03fbc4252d7e3c4baa63feedf8bd">operator Expr</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Casting a function to an expression is equivalent to calling the function with zero arguments.  <a href="#af30b03fbc4252d7e3c4baa63feedf8bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ab1d5c8ddfd40f829429c143ff05f9c9d">operator ExternFuncArgument</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> as an argument to an external stage.  <a href="#ab1d5c8ddfd40f829429c143ff05f9c9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ab824df0221818707668c86baad5e926e">infer_arguments</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the arguments to the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, sorted into a canonical order: all buffers (sorted alphabetically by name), followed by all non-buffers (sorted alphabetically by name).  <a href="#ab824df0221818707668c86baad5e926e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">realize</a> (std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &gt; sizes, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function over some rectangular domain and return the resulting buffer or buffers.  <a href="#a1fb0423663cc62b6e5ad0fef2195352b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a50243b677a9e8e48ff5d8b507f9d8d79">realize</a> (int x_size, int y_size, int z_size, int w_size, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function over some rectangular domain and return the resulting buffer or buffers.  <a href="#a50243b677a9e8e48ff5d8b507f9d8d79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a36daa6eddab145ab5db0e1727a6e3bdb">realize</a> (int x_size, int y_size, int z_size, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function over some rectangular domain and return the resulting buffer or buffers.  <a href="#a36daa6eddab145ab5db0e1727a6e3bdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad1417c4ea538a86154e75f6d65f795ac">realize</a> (int x_size, int y_size, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function over some rectangular domain and return the resulting buffer or buffers.  <a href="#ad1417c4ea538a86154e75f6d65f795ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a628660a6e87e11def3e6dd306807c5b9">realize</a> (int x_size=0, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function over some rectangular domain and return the resulting buffer or buffers.  <a href="#a628660a6e87e11def3e6dd306807c5b9"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a1f749d8761a6cf35a6f2f3c319d66729">realize</a> (<a class="el" href="class_halide_1_1_realization.html">Realization</a> dst, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function into an existing allocated buffer or buffers.  <a href="#a1f749d8761a6cf35a6f2f3c319d66729"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a38cb04953efab010a1261fb167fff53e">realize</a> (<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> dst, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function into an existing allocated buffer or buffers.  <a href="#a38cb04953efab010a1261fb167fff53e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a8e495dc44606bdf388d36885dff4ef9a">realize</a> (<a class="el" href="class_halide_1_1_image.html">Image</a>&lt; T &gt; dst, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function into an existing allocated buffer or buffers.  <a href="#a8e495dc44606bdf388d36885dff4ef9a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a7e4e93d5c38bf8094b6357e8900e5bd6">infer_input_bounds</a> (int x_size=0, int y_size=0, int z_size=0, int w_size=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given size of output, or a given output buffer, determine the bounds required of all unbound ImageParams referenced.  <a href="#a7e4e93d5c38bf8094b6357e8900e5bd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a159b2ebdfebcf09676d8706d221e981d">infer_input_bounds</a> (<a class="el" href="class_halide_1_1_realization.html">Realization</a> dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given size of output, or a given output buffer, determine the bounds required of all unbound ImageParams referenced.  <a href="#a159b2ebdfebcf09676d8706d221e981d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a0701ee43a21643855a9985b362a8eade">infer_input_bounds</a> (<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> dst)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given size of output, or a given output buffer, determine the bounds required of all unbound ImageParams referenced.  <a href="#a0701ee43a21643855a9985b362a8eade"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#af62325fc687b6bdbc809baf892144519">compile_to_bitcode</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to llvm bitcode, with the given filename (which should probably end in .bc), type signature, and C function name (which defaults to the same name as this halide function.  <a href="#af62325fc687b6bdbc809baf892144519"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#abe87cdf969c454a54e8a16590f94e4d2">compile_to_bitcode</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to llvm bitcode, with the given filename (which should probably end in .bc), type signature, and C function name (which defaults to the same name as this halide function.  <a href="#abe87cdf969c454a54e8a16590f94e4d2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a4536dcff3d4d9b8331745c230704961f">compile_to_object</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to an object file, with the given filename (which should probably end in .o or .obj), type signature, and C function name (which defaults to the same name as this halide function.  <a href="#a4536dcff3d4d9b8331745c230704961f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad08a26e17b8fa729727b184b43abe22f">compile_to_object</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to an object file, with the given filename (which should probably end in .o or .obj), type signature, and C function name (which defaults to the same name as this halide function.  <a href="#ad08a26e17b8fa729727b184b43abe22f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a5db5d045e2246ebf3bdac5557768760a">compile_to_assembly</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to text assembly equivalent to the object file generated by compile_to_object.  <a href="#a5db5d045e2246ebf3bdac5557768760a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a0b91ec2a301a6168f0794a6097c322d2">compile_to_assembly</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile this function to text assembly equivalent to the object file generated by compile_to_object.  <a href="#a0b91ec2a301a6168f0794a6097c322d2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">compile_to_simplified_lowered_stmt</a> (const std::string &amp;filename, <a class="el" href="class_halide_1_1_realization.html">Realization</a> dst, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;additional_replacements, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values.  <a href="#a052a6f0c9ef689593bad537b4e0a37b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad3253a9777b144e85ae36f9054c198d4">compile_to_simplified_lowered_stmt</a> (const std::string &amp;filename, <a class="el" href="class_halide_1_1_realization.html">Realization</a> dst, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values.  <a href="#ad3253a9777b144e85ae36f9054c198d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad3a762853758fe9e93acd83e7d306098">compile_to_simplified_lowered_stmt</a> (const std::string &amp;filename, <a class="el" href="class_halide_1_1_buffer.html">Buffer</a> dst, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;additional_replacements, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values.  <a href="#ad3a762853758fe9e93acd83e7d306098"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6a17018363e4280c3fd3ad006a13aec3">compile_to_simplified_lowered_stmt</a> (const std::string &amp;filename, <a class="el" href="class_halide_1_1_buffer.html">Buffer</a> dst, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values.  <a href="#a6a17018363e4280c3fd3ad006a13aec3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a7b751d0d0ee264b2289e19370f1088d3">compile_to_simplified_lowered_stmt</a> (const std::string &amp;filename, int x_size, int y_size, int z_size, int w_size, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;additional_replacements, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values.  <a href="#a7b751d0d0ee264b2289e19370f1088d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a54bbebf67261249763d22c62da5dfab3">compile_to_simplified_lowered_stmt</a> (const std::string &amp;filename, int x_size, int y_size, int z_size, int w_size, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values.  <a href="#a54bbebf67261249763d22c62da5dfab3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#abe5c7b26866592a10f02332e221d3d2e">compile_to_simplified_lowered_stmt</a> (const std::string &amp;filename, int x_size, int y_size, int z_size, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;additional_replacements, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values.  <a href="#abe5c7b26866592a10f02332e221d3d2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a5fb10452d9464e74ba77889164a6220c">compile_to_simplified_lowered_stmt</a> (const std::string &amp;filename, int x_size, int y_size, int z_size, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values.  <a href="#a5fb10452d9464e74ba77889164a6220c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad56fb6b49848e4365d3a388eaff9628b">compile_to_simplified_lowered_stmt</a> (const std::string &amp;filename, int x_size, int y_size, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;additional_replacements, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values.  <a href="#ad56fb6b49848e4365d3a388eaff9628b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6d8d4731f2efcd8366e6489877f3e540">compile_to_simplified_lowered_stmt</a> (const std::string &amp;filename, int x_size, int y_size, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values.  <a href="#a6d8d4731f2efcd8366e6489877f3e540"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6164382e764b2019c2ccc0d7fd2d2c6f">compile_to_simplified_lowered_stmt</a> (const std::string &amp;filename, int x_size, const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;additional_replacements, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values.  <a href="#a6164382e764b2019c2ccc0d7fd2d2c6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ac3d1f17ec058bc3edba0e276194aa524">compile_to_simplified_lowered_stmt</a> (const std::string &amp;filename, int x_size, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values.  <a href="#ac3d1f17ec058bc3edba0e276194aa524"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e">compile_to_file</a> (const std::string &amp;filename_prefix, std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; <a class="el" href="class_halide_1_1_func.html#a830f40950d6695281dc4c5057767ca4f">args</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#a5eba1cca2827f4210244deba8a71a64e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ae3d24751ea39c59fa73916d106c817d2">compile_to_file</a> (const std::string &amp;filename_prefix, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#ae3d24751ea39c59fa73916d106c817d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a5e01e6b52f6bbde5fa778976c742a941">compile_to_file</a> (const std::string &amp;filename_prefix, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> a, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#a5e01e6b52f6bbde5fa778976c742a941"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a456dbaa5e13796295e18bac45395d966">compile_to_file</a> (const std::string &amp;filename_prefix, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> a, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> b, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#a456dbaa5e13796295e18bac45395d966"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a608fe7fb5ca4f440b3e59746d5d3068a">compile_to_file</a> (const std::string &amp;filename_prefix, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> a, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> b, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> c, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#a608fe7fb5ca4f440b3e59746d5d3068a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a26affdda5332f89c923838ee5a4563cf">compile_to_file</a> (const std::string &amp;filename_prefix, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> a, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> b, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> c, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> d, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#a26affdda5332f89c923838ee5a4563cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a93975dcc63c67d8dccea66d16c853cd2">compile_to_file</a> (const std::string &amp;filename_prefix, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> a, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> b, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> c, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> d, <a class="el" href="struct_halide_1_1_argument.html">Argument</a> e, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#a93975dcc63c67d8dccea66d16c853cd2"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ab0c6a7f94cc7fdb8c42f2bcbc9013bfc">define_extern</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;params, <a class="el" href="struct_halide_1_1_type.html">Type</a> t, int dimensionality)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an extern definition for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="#ab0c6a7f94cc7fdb8c42f2bcbc9013bfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a7d51d585fac78c964b611eb4fcad522d">define_extern</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;params, const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;types, int dimensionality)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an extern definition for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="#a7d51d585fac78c964b611eb4fcad522d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f">operator()</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#afb028626864f2a3f39641d00af78910f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6ce0f0c6d8463c32f9ceacb0fe045051">operator()</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#a6ce0f0c6d8463c32f9ceacb0fe045051"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a60a31dc608a3f44d6aadb2a6edc8f7e1">operator()</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#a60a31dc608a3f44d6aadb2a6edc8f7e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a0f2a51dc115473368299e9966979e530">operator()</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#a0f2a51dc115473368299e9966979e530"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#af64144c733800b0b6bc0f1d8108e2ddc">operator()</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#af64144c733800b0b6bc0f1d8108e2ddc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aafd2a13dff2a024e86445e56c719503a">operator()</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> u) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#aafd2a13dff2a024e86445e56c719503a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad155774acf0b530a7bf1fb5f1b513c16">operator()</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> u, <a class="el" href="class_halide_1_1_var.html">Var</a> v) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#ad155774acf0b530a7bf1fb5f1b513c16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ae126902d07bdf0bb9595ef9c36ce857c">operator()</a> (std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments.  <a href="#ae126902d07bdf0bb9595ef9c36ce857c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a85c51b6c4753623f6c85d067bbe367ff">operator()</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#a85c51b6c4753623f6c85d067bbe367ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ae37eb8a056b41e7983fc7127471c1350">operator()</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#ae37eb8a056b41e7983fc7127471c1350"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a27b5159835278ac904ee9512608d2acb">operator()</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> z) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#a27b5159835278ac904ee9512608d2acb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a2722b4f2538ddc74a966419d13b73b2f">operator()</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> z, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> w) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#a2722b4f2538ddc74a966419d13b73b2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a16ae313b5ed4cd15232e85d2901cb97f">operator()</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> z, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> w, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> u) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#a16ae313b5ed4cd15232e85d2901cb97f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6b31299fe9c9d0c7e3ba7e34be4e8df5">operator()</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> y, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> z, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> w, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> u, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> v) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#a6b31299fe9c9d0c7e3ba7e34be4e8df5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ac86c1602915f8a423faf62926201ad9a">operator()</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>).  <a href="#ac86c1602915f8a423faf62926201ad9a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a97c3902ed0f891864746831a87530c60">gpu_threads</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_x, <a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU thread indices.  <a href="#a97c3902ed0f891864746831a87530c60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a4016eff4c2a6b845e35eab4562a699e3">gpu_threads</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_y, <a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU thread indices.  <a href="#a4016eff4c2a6b845e35eab4562a699e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a761d0f61353523419e685be8569e464d">gpu_threads</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_z, <a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU thread indices.  <a href="#a761d0f61353523419e685be8569e464d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ae462cad7fa20b9fd13c7efb718e673fa">cuda_threads</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a3029a8718f7dd3bcd84de725c0fd7f59">cuda_threads</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a57ddd7f746722ce8a0ced0deb6463ea7">cuda_threads</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_z)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a1c0d1afe7ec485ec0eb77c533f703018">gpu_blocks</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_x, <a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU block indices.  <a href="#a1c0d1afe7ec485ec0eb77c533f703018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#aba2d154464141d13c06ef3ee8d5dace3">gpu_blocks</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_y, <a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU block indices.  <a href="#aba2d154464141d13c06ef3ee8d5dace3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a031df9d1f7861f576768c770a580e3c8">gpu_blocks</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_z, <a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU block indices.  <a href="#a031df9d1f7861f576768c770a580e3c8"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a743f2ff1caf93d68b7c2c349f3649f38">cuda_blocks</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a4e12a129fa134ced57e57de72280a587">cuda_blocks</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a5db8fd04dabbdd24b96c5d1fc7a617ac">cuda_blocks</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_z)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a8d61e1d357736d9b5b944eeaa966f97b">gpu</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_x, <a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU block indices and thread indices.  <a href="#a8d61e1d357736d9b5b944eeaa966f97b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a478a8fbfc94817180e20ac63b7c0d608">gpu</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_y, <a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU block indices and thread indices.  <a href="#a478a8fbfc94817180e20ac63b7c0d608"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a000fbae88d4e9b8b2657e034cba7a2dc">gpu</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_z, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_z, <a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU block indices and thread indices.  <a href="#a000fbae88d4e9b8b2657e034cba7a2dc"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#acd9a14b35baf855b4ece625497ef9d52">cuda</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a248af06bc93b2998a967f4e978be4989">cuda</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a36804531fb15cb4d3d394aad1cfaa473">cuda</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> block_z, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> thread_z)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a5f5fc7359a2ca66e557a9f129088c223">gpu_tile</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, int x_size, <a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates within each tile to GPU thread indices.  <a href="#a5f5fc7359a2ca66e557a9f129088c223"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6e719ccbc30fa907ad71443ffb40af30">gpu_tile</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, int x_size, int y_size, <a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates within each tile to GPU thread indices.  <a href="#a6e719ccbc30fa907ad71443ffb40af30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#adfcc33f4d9e75bb568cbfda245f9ed6a">gpu_tile</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> z, int x_size, int y_size, int z_size, <a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api=<a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates within each tile to GPU thread indices.  <a href="#adfcc33f4d9e75bb568cbfda245f9ed6a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a0139c3cc5bf66f738fa36ec83f379d56">cuda_tile</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, int x_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ab5b665bd3d2dc436da342fd127354946">cuda_tile</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, int x_size, int y_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a6a5fb83e26ebe218658e18f84ff6ad6d">cuda_tile</a> (<a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> x, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> y, <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> z, int x_size, int y_size, int z_size)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a08d7274c38d341388f0c2c9c9b32f287">reorder_storage</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify how the storage for the function is laid out.  <a href="#a08d7274c38d341388f0c2c9c9b32f287"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ad59d05f644880806b781b2ac638fd842">reorder_storage</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify how the storage for the function is laid out.  <a href="#ad59d05f644880806b781b2ac638fd842"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a011438ae4c5e938a32aef32606e98e3a">reorder_storage</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify how the storage for the function is laid out.  <a href="#a011438ae4c5e938a32aef32606e98e3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#ab6cf3f2c80e072fdd666172fd5426443">reorder_storage</a> (<a class="el" href="class_halide_1_1_var.html">Var</a> x, <a class="el" href="class_halide_1_1_var.html">Var</a> y, <a class="el" href="class_halide_1_1_var.html">Var</a> z, <a class="el" href="class_halide_1_1_var.html">Var</a> w, <a class="el" href="class_halide_1_1_var.html">Var</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify how the storage for the function is laid out.  <a href="#ab6cf3f2c80e072fdd666172fd5426443"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_output_image_param.html">OutputImageParam</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a7ed1d8e36969e549cb42e2deb062ef37">output_buffer</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle on the output buffer for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="#a7ed1d8e36969e549cb42e2deb062ef37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_halide_1_1_output_image_param.html">OutputImageParam</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#a196fa4dd98145740fe20e0a834b7d296">output_buffers</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle on the output buffer for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  <a href="#a196fa4dd98145740fe20e0a834b7d296"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_func.html#adaf012731a0385693a9b5829f7146f4e">test</a> ()</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A halide function. </p>
<p>This class represents one stage in a <a class="el" href="namespace_halide.html">Halide</a> pipeline, and is the unit by which we schedule things. By default they are aggressively inlined, so you are encouraged to make lots of little functions, rather than storing things in Exprs. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_01_basics_8cpp-example.html#_a0">tutorial/lesson_01_basics.cpp</a>, <a class="el" href="tutorial_2lesson_02_input_image_8cpp-example.html#_a1">tutorial/lesson_02_input_image.cpp</a>, <a class="el" href="tutorial_2lesson_03_debugging_1_8cpp-example.html#_a0">tutorial/lesson_03_debugging_1.cpp</a>, <a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#_a0">tutorial/lesson_04_debugging_2.cpp</a>, <a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#_a1">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_06_realizing_over_shifted_domains_8cpp-example.html#_a0">tutorial/lesson_06_realizing_over_shifted_domains.cpp</a>, <a class="el" href="tutorial_2lesson_07_multi_stage_pipelines_8cpp-example.html#_a2">tutorial/lesson_07_multi_stage_pipelines.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#_a1">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#_a2">tutorial/lesson_09_update_definitions.cpp</a>, <a class="el" href="tutorial_2lesson_10_aot_compilation_generate_8cpp-example.html#_a0">tutorial/lesson_10_aot_compilation_generate.cpp</a>, <a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#_a0">tutorial/lesson_11_cross_compilation.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#_a1">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_func_8h_source.html#l00339">339</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a265d4e8c8c6225fb5455f4b6c3496db0"></a><!-- doxytag: member="Halide::Func::Func" ref="a265d4e8c8c6225fb5455f4b6c3496db0" args="(const std::string &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html#a265d4e8c8c6225fb5455f4b6c3496db0">Halide::Func::Func</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare a new undefined function with the given name. </p>

</div>
</div>
<a class="anchor" id="aed876d44c3e1dd0a72c4111afc63018b"></a><!-- doxytag: member="Halide::Func::Func" ref="aed876d44c3e1dd0a72c4111afc63018b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html#a265d4e8c8c6225fb5455f4b6c3496db0">Halide::Func::Func</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare a new undefined function with an automatically-generated unique name. </p>

</div>
</div>
<a class="anchor" id="a89aa00c3ee27c264979fd1b90f271085"></a><!-- doxytag: member="Halide::Func::Func" ref="a89aa00c3ee27c264979fd1b90f271085" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html#a265d4e8c8c6225fb5455f4b6c3496db0">Halide::Func::Func</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declare a new function with an automatically-generated unique name, and define it to return the given expression (which may not contain free variables). </p>

</div>
</div>
<a class="anchor" id="a297da02c042addeb2556a656b2931614"></a><!-- doxytag: member="Halide::Func::Func" ref="a297da02c042addeb2556a656b2931614" args="(Internal::Function f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html#a265d4e8c8c6225fb5455f4b6c3496db0">Halide::Func::Func</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a new <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to wrap an existing, already-define Function object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adaf012731a0385693a9b5829f7146f4e"></a><!-- doxytag: member="Halide::Func::test" ref="adaf012731a0385693a9b5829f7146f4e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#adaf012731a0385693a9b5829f7146f4e">Halide::Func::test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1fb0423663cc62b6e5ad0fef2195352b"></a><!-- doxytag: member="Halide::Func::realize" ref="a1fb0423663cc62b6e5ad0fef2195352b" args="(std::vector&lt; int32_t &gt; sizes, const Target &amp;target=get_jit_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a> <a class="el" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">Halide::Func::realize</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate this function over some rectangular domain and return the resulting buffer or buffers. </p>
<p>Performs compilation if the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has not previously been realized and jit_compile has not been called. The returned <a class="el" href="class_halide_1_1_buffer.html" title="The internal representation of an image, or other dense array data.">Buffer</a> should probably be instantly wrapped in an <a class="el" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image</a> class of the appropriate type. That is, do this:</p>
<div class="fragment"><pre class="fragment">     f(x) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x);
     Image&lt;float&gt; im = f.realize(...);
</pre></div><p>not this:</p>
<div class="fragment"><pre class="fragment">     f(x) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x)
     Buffer im = f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(...)
</pre></div><p>If your <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has multiple values, because you defined it using a <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a>, then casting the result of a realize call to a buffer or image will produce a run-time error. Instead you should do the following:</p>
<div class="fragment"><pre class="fragment">     f(x) = Tuple(x, <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x));
     Realization r = f.realize(...);
     Image&lt;int&gt; im0 = r[0];
     Image&lt;float&gt; im1 = r[1];
</pre></div> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_01_basics_8cpp-example.html#a4">tutorial/lesson_01_basics.cpp</a>, <a class="el" href="tutorial_2lesson_03_debugging_1_8cpp-example.html#a3">tutorial/lesson_03_debugging_1.cpp</a>, <a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a4">tutorial/lesson_04_debugging_2.cpp</a>, <a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a4">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_06_realizing_over_shifted_domains_8cpp-example.html#a4">tutorial/lesson_06_realizing_over_shifted_domains.cpp</a>, <a class="el" href="tutorial_2lesson_07_multi_stage_pipelines_8cpp-example.html#a6">tutorial/lesson_07_multi_stage_pipelines.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a4">tutorial/lesson_08_scheduling_2.cpp</a>, and <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a3">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="_func_8h_source.html#l01782">Halide::evaluate_may_gpu()</a>, and <a class="el" href="_func_8h_source.html#l00501">realize()</a>.</p>

</div>
</div>
<a class="anchor" id="a50243b677a9e8e48ff5d8b507f9d8d79"></a><!-- doxytag: member="Halide::Func::realize" ref="a50243b677a9e8e48ff5d8b507f9d8d79" args="(int x_size, int y_size, int z_size, int w_size, const Target &amp;target=get_jit_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a> <a class="el" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">Halide::Func::realize</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate this function over some rectangular domain and return the resulting buffer or buffers. </p>
<p>Performs compilation if the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has not previously been realized and jit_compile has not been called. The returned <a class="el" href="class_halide_1_1_buffer.html" title="The internal representation of an image, or other dense array data.">Buffer</a> should probably be instantly wrapped in an <a class="el" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image</a> class of the appropriate type. That is, do this:</p>
<div class="fragment"><pre class="fragment">     f(x) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x);
     Image&lt;float&gt; im = f.realize(...);
</pre></div><p>not this:</p>
<div class="fragment"><pre class="fragment">     f(x) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x)
     Buffer im = f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(...)
</pre></div><p>If your <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has multiple values, because you defined it using a <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a>, then casting the result of a realize call to a buffer or image will produce a run-time error. Instead you should do the following:</p>
<div class="fragment"><pre class="fragment">     f(x) = Tuple(x, <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x));
     Realization r = f.realize(...);
     Image&lt;int&gt; im0 = r[0];
     Image&lt;float&gt; im1 = r[1];
</pre></div> 
</div>
</div>
<a class="anchor" id="a36daa6eddab145ab5db0e1727a6e3bdb"></a><!-- doxytag: member="Halide::Func::realize" ref="a36daa6eddab145ab5db0e1727a6e3bdb" args="(int x_size, int y_size, int z_size, const Target &amp;target=get_jit_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a> <a class="el" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">Halide::Func::realize</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate this function over some rectangular domain and return the resulting buffer or buffers. </p>
<p>Performs compilation if the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has not previously been realized and jit_compile has not been called. The returned <a class="el" href="class_halide_1_1_buffer.html" title="The internal representation of an image, or other dense array data.">Buffer</a> should probably be instantly wrapped in an <a class="el" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image</a> class of the appropriate type. That is, do this:</p>
<div class="fragment"><pre class="fragment">     f(x) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x);
     Image&lt;float&gt; im = f.realize(...);
</pre></div><p>not this:</p>
<div class="fragment"><pre class="fragment">     f(x) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x)
     Buffer im = f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(...)
</pre></div><p>If your <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has multiple values, because you defined it using a <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a>, then casting the result of a realize call to a buffer or image will produce a run-time error. Instead you should do the following:</p>
<div class="fragment"><pre class="fragment">     f(x) = Tuple(x, <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x));
     Realization r = f.realize(...);
     Image&lt;int&gt; im0 = r[0];
     Image&lt;float&gt; im1 = r[1];
</pre></div> 
</div>
</div>
<a class="anchor" id="ad1417c4ea538a86154e75f6d65f795ac"></a><!-- doxytag: member="Halide::Func::realize" ref="ad1417c4ea538a86154e75f6d65f795ac" args="(int x_size, int y_size, const Target &amp;target=get_jit_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a> <a class="el" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">Halide::Func::realize</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate this function over some rectangular domain and return the resulting buffer or buffers. </p>
<p>Performs compilation if the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has not previously been realized and jit_compile has not been called. The returned <a class="el" href="class_halide_1_1_buffer.html" title="The internal representation of an image, or other dense array data.">Buffer</a> should probably be instantly wrapped in an <a class="el" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image</a> class of the appropriate type. That is, do this:</p>
<div class="fragment"><pre class="fragment">     f(x) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x);
     Image&lt;float&gt; im = f.realize(...);
</pre></div><p>not this:</p>
<div class="fragment"><pre class="fragment">     f(x) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x)
     Buffer im = f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(...)
</pre></div><p>If your <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has multiple values, because you defined it using a <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a>, then casting the result of a realize call to a buffer or image will produce a run-time error. Instead you should do the following:</p>
<div class="fragment"><pre class="fragment">     f(x) = Tuple(x, <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x));
     Realization r = f.realize(...);
     Image&lt;int&gt; im0 = r[0];
     Image&lt;float&gt; im1 = r[1];
</pre></div> 
</div>
</div>
<a class="anchor" id="a628660a6e87e11def3e6dd306807c5b9"></a><!-- doxytag: member="Halide::Func::realize" ref="a628660a6e87e11def3e6dd306807c5b9" args="(int x_size=0, const Target &amp;target=get_jit_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a> <a class="el" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">Halide::Func::realize</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate this function over some rectangular domain and return the resulting buffer or buffers. </p>
<p>Performs compilation if the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has not previously been realized and jit_compile has not been called. The returned <a class="el" href="class_halide_1_1_buffer.html" title="The internal representation of an image, or other dense array data.">Buffer</a> should probably be instantly wrapped in an <a class="el" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image</a> class of the appropriate type. That is, do this:</p>
<div class="fragment"><pre class="fragment">     f(x) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x);
     Image&lt;float&gt; im = f.realize(...);
</pre></div><p>not this:</p>
<div class="fragment"><pre class="fragment">     f(x) = <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x)
     Buffer im = f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(...)
</pre></div><p>If your <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has multiple values, because you defined it using a <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a>, then casting the result of a realize call to a buffer or image will produce a run-time error. Instead you should do the following:</p>
<div class="fragment"><pre class="fragment">     f(x) = Tuple(x, <a class="code" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e" title="Return the sine of a floating-point expression.">sin</a>(x));
     Realization r = f.realize(...);
     Image&lt;int&gt; im0 = r[0];
     Image&lt;float&gt; im1 = r[1];
</pre></div> 
</div>
</div>
<a class="anchor" id="a1f749d8761a6cf35a6f2f3c319d66729"></a><!-- doxytag: member="Halide::Func::realize" ref="a1f749d8761a6cf35a6f2f3c319d66729" args="(Realization dst, const Target &amp;target=get_jit_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">Halide::Func::realize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate this function into an existing allocated buffer or buffers. </p>
<p>If the buffer is also one of the arguments to the function, strange things may happen, as the pipeline isn't necessarily safe to run in-place. If you pass multiple buffers, they must have matching sizes. </p>

</div>
</div>
<a class="anchor" id="a38cb04953efab010a1261fb167fff53e"></a><!-- doxytag: member="Halide::Func::realize" ref="a38cb04953efab010a1261fb167fff53e" args="(Buffer dst, const Target &amp;target=get_jit_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">Halide::Func::realize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate this function into an existing allocated buffer or buffers. </p>
<p>If the buffer is also one of the arguments to the function, strange things may happen, as the pipeline isn't necessarily safe to run in-place. If you pass multiple buffers, they must have matching sizes. </p>

</div>
</div>
<a class="anchor" id="a8e495dc44606bdf388d36885dff4ef9a"></a><!-- doxytag: member="Halide::Func::realize" ref="a8e495dc44606bdf388d36885dff4ef9a" args="(Image&lt; T &gt; dst, const Target &amp;target=get_jit_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">Halide::Func::realize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_image.html">Image</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate this function into an existing allocated buffer or buffers. </p>
<p>If the buffer is also one of the arguments to the function, strange things may happen, as the pipeline isn't necessarily safe to run in-place. If you pass multiple buffers, they must have matching sizes. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l00501">501</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_image_base.html#a5bbd5216ab692601e742e258ea93a6a0">Halide::ImageBase::copy_to_host()</a>, and <a class="el" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">realize()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e4e93d5c38bf8094b6357e8900e5bd6"></a><!-- doxytag: member="Halide::Func::infer_input_bounds" ref="a7e4e93d5c38bf8094b6357e8900e5bd6" args="(int x_size=0, int y_size=0, int z_size=0, int w_size=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a7e4e93d5c38bf8094b6357e8900e5bd6">Halide::Func::infer_input_bounds</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For a given size of output, or a given output buffer, determine the bounds required of all unbound ImageParams referenced. </p>
<p>Communicates the result by allocating new buffers of the appropriate size and binding them to the unbound ImageParams. </p>

</div>
</div>
<a class="anchor" id="a159b2ebdfebcf09676d8706d221e981d"></a><!-- doxytag: member="Halide::Func::infer_input_bounds" ref="a159b2ebdfebcf09676d8706d221e981d" args="(Realization dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a7e4e93d5c38bf8094b6357e8900e5bd6">Halide::Func::infer_input_bounds</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For a given size of output, or a given output buffer, determine the bounds required of all unbound ImageParams referenced. </p>
<p>Communicates the result by allocating new buffers of the appropriate size and binding them to the unbound ImageParams. </p>

</div>
</div>
<a class="anchor" id="a0701ee43a21643855a9985b362a8eade"></a><!-- doxytag: member="Halide::Func::infer_input_bounds" ref="a0701ee43a21643855a9985b362a8eade" args="(Buffer dst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a7e4e93d5c38bf8094b6357e8900e5bd6">Halide::Func::infer_input_bounds</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For a given size of output, or a given output buffer, determine the bounds required of all unbound ImageParams referenced. </p>
<p>Communicates the result by allocating new buffers of the appropriate size and binding them to the unbound ImageParams. </p>

</div>
</div>
<a class="anchor" id="af62325fc687b6bdbc809baf892144519"></a><!-- doxytag: member="Halide::Func::compile_to_bitcode" ref="af62325fc687b6bdbc809baf892144519" args="(const std::string &amp;filename, std::vector&lt; Argument &gt;, const std::string &amp;fn_name, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#af62325fc687b6bdbc809baf892144519">Halide::Func::compile_to_bitcode</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statically compile this function to llvm bitcode, with the given filename (which should probably end in .bc), type signature, and C function name (which defaults to the same name as this halide function. </p>

</div>
</div>
<a class="anchor" id="abe87cdf969c454a54e8a16590f94e4d2"></a><!-- doxytag: member="Halide::Func::compile_to_bitcode" ref="abe87cdf969c454a54e8a16590f94e4d2" args="(const std::string &amp;filename, std::vector&lt; Argument &gt;, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#af62325fc687b6bdbc809baf892144519">Halide::Func::compile_to_bitcode</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statically compile this function to llvm bitcode, with the given filename (which should probably end in .bc), type signature, and C function name (which defaults to the same name as this halide function. </p>

</div>
</div>
<a class="anchor" id="a4536dcff3d4d9b8331745c230704961f"></a><!-- doxytag: member="Halide::Func::compile_to_object" ref="a4536dcff3d4d9b8331745c230704961f" args="(const std::string &amp;filename, std::vector&lt; Argument &gt;, const std::string &amp;fn_name, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a4536dcff3d4d9b8331745c230704961f">Halide::Func::compile_to_object</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statically compile this function to an object file, with the given filename (which should probably end in .o or .obj), type signature, and C function name (which defaults to the same name as this halide function. </p>
<p>You probably don't want to use this directly; call compile_to_file instead. </p>

</div>
</div>
<a class="anchor" id="ad08a26e17b8fa729727b184b43abe22f"></a><!-- doxytag: member="Halide::Func::compile_to_object" ref="ad08a26e17b8fa729727b184b43abe22f" args="(const std::string &amp;filename, std::vector&lt; Argument &gt;, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a4536dcff3d4d9b8331745c230704961f">Halide::Func::compile_to_object</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statically compile this function to an object file, with the given filename (which should probably end in .o or .obj), type signature, and C function name (which defaults to the same name as this halide function. </p>
<p>You probably don't want to use this directly; call compile_to_file instead. </p>

</div>
</div>
<a class="anchor" id="aae9623ffff43b170735b65c490b68ffb"></a><!-- doxytag: member="Halide::Func::compile_to_header" ref="aae9623ffff43b170735b65c490b68ffb" args="(const std::string &amp;filename, std::vector&lt; Argument &gt;, const std::string &amp;fn_name=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#aae9623ffff43b170735b65c490b68ffb">Halide::Func::compile_to_header</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emit a header file with the given filename for this function. </p>
<p>The header will define a function with the type signature given by the second argument, and a name given by the third. The name defaults to the same name as this halide function. You don't actually have to have defined this function yet to call this. You probably don't want to use this directly; call compile_to_file instead. </p>

</div>
</div>
<a class="anchor" id="a5db5d045e2246ebf3bdac5557768760a"></a><!-- doxytag: member="Halide::Func::compile_to_assembly" ref="a5db5d045e2246ebf3bdac5557768760a" args="(const std::string &amp;filename, std::vector&lt; Argument &gt;, const std::string &amp;fn_name, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a5db5d045e2246ebf3bdac5557768760a">Halide::Func::compile_to_assembly</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statically compile this function to text assembly equivalent to the object file generated by compile_to_object. </p>
<p>This is useful for checking what <a class="el" href="namespace_halide.html">Halide</a> is producing without having to disassemble anything, or if you need to feed the assembly into some custom toolchain to produce an object file (e.g. iOS) </p>

</div>
</div>
<a class="anchor" id="a0b91ec2a301a6168f0794a6097c322d2"></a><!-- doxytag: member="Halide::Func::compile_to_assembly" ref="a0b91ec2a301a6168f0794a6097c322d2" args="(const std::string &amp;filename, std::vector&lt; Argument &gt;, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a5db5d045e2246ebf3bdac5557768760a">Halide::Func::compile_to_assembly</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statically compile this function to text assembly equivalent to the object file generated by compile_to_object. </p>
<p>This is useful for checking what <a class="el" href="namespace_halide.html">Halide</a> is producing without having to disassemble anything, or if you need to feed the assembly into some custom toolchain to produce an object file (e.g. iOS) </p>

</div>
</div>
<a class="anchor" id="afff013625f408efd641c2a0c0db04827"></a><!-- doxytag: member="Halide::Func::compile_to_c" ref="afff013625f408efd641c2a0c0db04827" args="(const std::string &amp;filename, std::vector&lt; Argument &gt;, const std::string &amp;fn_name=&quot;&quot;, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#afff013625f408efd641c2a0c0db04827">Halide::Func::compile_to_c</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statically compile this function to C source code. </p>
<p>This is useful for providing fallback code paths that will compile on many platforms. Vectorization will fail, and parallelization will produce serial code. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_03_debugging_1_8cpp-example.html#a4">tutorial/lesson_03_debugging_1.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1c52d590b142458b600dcf420401c485"></a><!-- doxytag: member="Halide::Func::compile_to_lowered_stmt" ref="a1c52d590b142458b600dcf420401c485" args="(const std::string &amp;filename, StmtOutputFormat fmt=Text, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a1c52d590b142458b600dcf420401c485">Halide::Func::compile_to_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code. </p>
<p>Useful for analyzing and debugging scheduling. Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="a052a6f0c9ef689593bad537b4e0a37b8"></a><!-- doxytag: member="Halide::Func::compile_to_simplified_lowered_stmt" ref="a052a6f0c9ef689593bad537b4e0a37b8" args="(const std::string &amp;filename, Realization dst, const std::map&lt; std::string, Expr &gt; &amp;additional_replacements, StmtOutputFormat fmt=Text, const Target &amp;t=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">Halide::Func::compile_to_simplified_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>additional_replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="ad3253a9777b144e85ae36f9054c198d4"></a><!-- doxytag: member="Halide::Func::compile_to_simplified_lowered_stmt" ref="ad3253a9777b144e85ae36f9054c198d4" args="(const std::string &amp;filename, Realization dst, StmtOutputFormat fmt=Text, const Target &amp;t=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">Halide::Func::compile_to_simplified_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="ad3a762853758fe9e93acd83e7d306098"></a><!-- doxytag: member="Halide::Func::compile_to_simplified_lowered_stmt" ref="ad3a762853758fe9e93acd83e7d306098" args="(const std::string &amp;filename, Buffer dst, const std::map&lt; std::string, Expr &gt; &amp;additional_replacements, StmtOutputFormat fmt=Text, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">Halide::Func::compile_to_simplified_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>additional_replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="a6a17018363e4280c3fd3ad006a13aec3"></a><!-- doxytag: member="Halide::Func::compile_to_simplified_lowered_stmt" ref="a6a17018363e4280c3fd3ad006a13aec3" args="(const std::string &amp;filename, Buffer dst, StmtOutputFormat fmt=Text, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">Halide::Func::compile_to_simplified_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="a7b751d0d0ee264b2289e19370f1088d3"></a><!-- doxytag: member="Halide::Func::compile_to_simplified_lowered_stmt" ref="a7b751d0d0ee264b2289e19370f1088d3" args="(const std::string &amp;filename, int x_size, int y_size, int z_size, int w_size, const std::map&lt; std::string, Expr &gt; &amp;additional_replacements, StmtOutputFormat fmt=Text, const Target &amp;t=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">Halide::Func::compile_to_simplified_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>additional_replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="a54bbebf67261249763d22c62da5dfab3"></a><!-- doxytag: member="Halide::Func::compile_to_simplified_lowered_stmt" ref="a54bbebf67261249763d22c62da5dfab3" args="(const std::string &amp;filename, int x_size, int y_size, int z_size, int w_size, StmtOutputFormat fmt=Text, const Target &amp;t=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">Halide::Func::compile_to_simplified_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="abe5c7b26866592a10f02332e221d3d2e"></a><!-- doxytag: member="Halide::Func::compile_to_simplified_lowered_stmt" ref="abe5c7b26866592a10f02332e221d3d2e" args="(const std::string &amp;filename, int x_size, int y_size, int z_size, const std::map&lt; std::string, Expr &gt; &amp;additional_replacements, StmtOutputFormat fmt=Text, const Target &amp;t=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">Halide::Func::compile_to_simplified_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>additional_replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="a5fb10452d9464e74ba77889164a6220c"></a><!-- doxytag: member="Halide::Func::compile_to_simplified_lowered_stmt" ref="a5fb10452d9464e74ba77889164a6220c" args="(const std::string &amp;filename, int x_size, int y_size, int z_size, StmtOutputFormat fmt=Text, const Target &amp;t=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">Halide::Func::compile_to_simplified_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="ad56fb6b49848e4365d3a388eaff9628b"></a><!-- doxytag: member="Halide::Func::compile_to_simplified_lowered_stmt" ref="ad56fb6b49848e4365d3a388eaff9628b" args="(const std::string &amp;filename, int x_size, int y_size, const std::map&lt; std::string, Expr &gt; &amp;additional_replacements, StmtOutputFormat fmt=Text, const Target &amp;t=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">Halide::Func::compile_to_simplified_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>additional_replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="a6d8d4731f2efcd8366e6489877f3e540"></a><!-- doxytag: member="Halide::Func::compile_to_simplified_lowered_stmt" ref="a6d8d4731f2efcd8366e6489877f3e540" args="(const std::string &amp;filename, int x_size, int y_size, StmtOutputFormat fmt=Text, const Target &amp;t=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">Halide::Func::compile_to_simplified_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="a6164382e764b2019c2ccc0d7fd2d2c6f"></a><!-- doxytag: member="Halide::Func::compile_to_simplified_lowered_stmt" ref="a6164382e764b2019c2ccc0d7fd2d2c6f" args="(const std::string &amp;filename, int x_size, const std::map&lt; std::string, Expr &gt; &amp;additional_replacements, StmtOutputFormat fmt=Text, const Target &amp;t=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">Halide::Func::compile_to_simplified_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>additional_replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="ac3d1f17ec058bc3edba0e276194aa524"></a><!-- doxytag: member="Halide::Func::compile_to_simplified_lowered_stmt" ref="ac3d1f17ec058bc3edba0e276194aa524" args="(const std::string &amp;filename, int x_size, StmtOutputFormat fmt=Text, const Target &amp;t=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a052a6f0c9ef689593bad537b4e0a37b8">Halide::Func::compile_to_simplified_lowered_stmt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out an internal representation of lowered code as above but simplified using the provided realization bounds and other concrete parameter values. </p>
<p>Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="a5eba1cca2827f4210244deba8a71a64e"></a><!-- doxytag: member="Halide::Func::compile_to_file" ref="a5eba1cca2827f4210244deba8a71a64e" args="(const std::string &amp;filename_prefix, std::vector&lt; Argument &gt; args, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e">Halide::Func::compile_to_file</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_10_aot_compilation_generate_8cpp-example.html#a6">tutorial/lesson_10_aot_compilation_generate.cpp</a>, and <a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a6">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae3d24751ea39c59fa73916d106c817d2"></a><!-- doxytag: member="Halide::Func::compile_to_file" ref="ae3d24751ea39c59fa73916d106c817d2" args="(const std::string &amp;filename_prefix, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e">Halide::Func::compile_to_file</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="a5e01e6b52f6bbde5fa778976c742a941"></a><!-- doxytag: member="Halide::Func::compile_to_file" ref="a5e01e6b52f6bbde5fa778976c742a941" args="(const std::string &amp;filename_prefix, Argument a, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e">Halide::Func::compile_to_file</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="a456dbaa5e13796295e18bac45395d966"></a><!-- doxytag: member="Halide::Func::compile_to_file" ref="a456dbaa5e13796295e18bac45395d966" args="(const std::string &amp;filename_prefix, Argument a, Argument b, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e">Halide::Func::compile_to_file</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="a608fe7fb5ca4f440b3e59746d5d3068a"></a><!-- doxytag: member="Halide::Func::compile_to_file" ref="a608fe7fb5ca4f440b3e59746d5d3068a" args="(const std::string &amp;filename_prefix, Argument a, Argument b, Argument c, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e">Halide::Func::compile_to_file</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="a26affdda5332f89c923838ee5a4563cf"></a><!-- doxytag: member="Halide::Func::compile_to_file" ref="a26affdda5332f89c923838ee5a4563cf" args="(const std::string &amp;filename_prefix, Argument a, Argument b, Argument c, Argument d, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e">Halide::Func::compile_to_file</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="a93975dcc63c67d8dccea66d16c853cd2"></a><!-- doxytag: member="Halide::Func::compile_to_file" ref="a93975dcc63c67d8dccea66d16c853cd2" args="(const std::string &amp;filename_prefix, Argument a, Argument b, Argument c, Argument d, Argument e, const Target &amp;target=get_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e">Halide::Func::compile_to_file</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_argument.html">Argument</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the first argument. </p>

</div>
</div>
<a class="anchor" id="a4bb020bfc9d7e83325dc59b271513dfc"></a><!-- doxytag: member="Halide::Func::compile_jit" ref="a4bb020bfc9d7e83325dc59b271513dfc" args="(const Target &amp;target=get_jit_target_from_environment())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void* <a class="el" href="class_halide_1_1_func.html#a4bb020bfc9d7e83325dc59b271513dfc">Halide::Func::compile_jit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Eagerly jit compile the function to machine code. </p>
<p>This normally happens on the first call to realize. If you're running your halide pipeline inside time-sensitive code and wish to avoid including the time taken to compile a pipeline, then you can call this ahead of time. Returns the raw function pointer to the compiled pipeline. Default is to use the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> returned from <a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">Halide::get_jit_target_from_environment()</a> </p>

</div>
</div>
<a class="anchor" id="a043d5e26caec7bc3afb32c770699e3de"></a><!-- doxytag: member="Halide::Func::set_error_handler" ref="a043d5e26caec7bc3afb32c770699e3de" args="(void(*handler)(void *, const char *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a043d5e26caec7bc3afb32c770699e3de">Halide::Func::set_error_handler</a> </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *, const char *)&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the error handler function that be called in the case of runtime errors during halide pipelines. </p>
<p>If you are compiling statically, you can also just define your own function with signature </p>
<div class="fragment"><pre class="fragment">     <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> <a class="code" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8" title="Define halide_error to catch errors messages at runtime, for example bounds checking failures...">halide_error</a>(<span class="keywordtype">void</span> *user_context, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
</pre></div><p> This will clobber <a class="el" href="namespace_halide.html">Halide</a>'s version. </p>

</div>
</div>
<a class="anchor" id="accac17bd1d0e40c50d50b515e082d922"></a><!-- doxytag: member="Halide::Func::set_custom_allocator" ref="accac17bd1d0e40c50d50b515e082d922" args="(void *(*malloc)(void *, size_t), void(*free)(void *, void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#accac17bd1d0e40c50d50b515e082d922">Halide::Func::set_custom_allocator</a> </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)&#160;</td>
          <td class="paramname"><em>malloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>free</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a18eb1fc8785fa98c27b44f0f3926c7fa"></a><!-- doxytag: member="Halide::Func::set_custom_do_task" ref="a18eb1fc8785fa98c27b44f0f3926c7fa" args="(int(*custom_do_task)(void *, int(*)(void *, int, uint8_t *), int, uint8_t *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#a18eb1fc8785fa98c27b44f0f3926c7fa">Halide::Func::set_custom_do_task</a> </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *, int(*)(void *, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *), int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)&#160;</td>
          <td class="paramname"><em>custom_do_task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a custom task handler to be called by the parallel for loop. </p>
<p>It is useful to set this if you want to do some additional bookkeeping at the granularity of parallel tasks. The default implementation does this: </p>
<div class="fragment"><pre class="fragment">     <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span> halide_do_task(<span class="keywordtype">void</span> *user_context,
                                   <span class="keywordtype">int</span> (*f)(<span class="keywordtype">void</span> *, <span class="keywordtype">int</span>, <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *),
                                   <span class="keywordtype">int</span> idx, <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *state) {
         <span class="keywordflow">return</span> f(user_context, idx, state);
     }
</pre></div><p> If you are statically compiling, you can also just define your own version of the above function, and it will clobber <a class="el" href="namespace_halide.html">Halide</a>'s version.</p>
<p>If you're trying to use a custom parallel runtime, you probably don't want to call this. See instead <a class="el" href="class_halide_1_1_func.html#afd38942fde8f87b6851d47bf99513ba1">Func::set_custom_do_par_for</a> . </p>

</div>
</div>
<a class="anchor" id="afd38942fde8f87b6851d47bf99513ba1"></a><!-- doxytag: member="Halide::Func::set_custom_do_par_for" ref="afd38942fde8f87b6851d47bf99513ba1" args="(int(*custom_do_par_for)(void *, int(*)(void *, int, uint8_t *), int, int, uint8_t *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#afd38942fde8f87b6851d47bf99513ba1">Halide::Func::set_custom_do_par_for</a> </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *, int(*)(void *, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *), int, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)&#160;</td>
          <td class="paramname"><em>custom_do_par_for</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a custom parallel for loop launcher. </p>
<p>Useful if your app already manages a thread pool. The default implementation is equivalent to this: </p>
<div class="fragment"><pre class="fragment">     <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span> <a class="code" href="_halide_runtime_8h.html#a05193f80c8fc7df76ceadd82c4ce7b56" title="Define halide_do_par_for to replace the default thread pool implementation.">halide_do_par_for</a>(<span class="keywordtype">void</span> *user_context,
                                      <span class="keywordtype">int</span> (*f)(<span class="keywordtype">void</span> *, <span class="keywordtype">int</span>, <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *),
                                      <span class="keywordtype">int</span> <a class="code" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940" title="Returns an expression representing the lesser of the two arguments, after doing any necessary type co...">min</a>, <span class="keywordtype">int</span> extent, <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *state) {
         <span class="keywordtype">int</span> exit_status = 0;
         <a class="code" href="class_halide_1_1_func.html#aa0050c604179b43a8deb42b62dedd29d" title="Mark a dimension to be traversed in parallel.">parallel</a> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = min; idx &lt; min+extent; idx++) {
             <span class="keywordtype">int</span> job_status = halide_do_task(user_context, f, idx, state);
             <span class="keywordflow">if</span> (job_status) exit_status = job_status;
         }
         <span class="keywordflow">return</span> exit_status;
     }
</pre></div><p>However, notwithstanding the above example code, if one task fails, we may skip over other tasks, and if two tasks return different error codes, we may select one arbitrarily to return.</p>
<p>If you are statically compiling, you can also just define your own version of the above function, and it will clobber <a class="el" href="namespace_halide.html">Halide</a>'s version. </p>

</div>
</div>
<a class="anchor" id="aad5f2b878005cd24c3b49c4856652971"></a><!-- doxytag: member="Halide::Func::set_custom_trace" ref="aad5f2b878005cd24c3b49c4856652971" args="(Internal::JITCompiledModule::TraceFn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#aad5f2b878005cd24c3b49c4856652971">Halide::Func::set_custom_trace</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_compiled_module.html#ac96e1d288eaaa85933cda36bad19c5ef">Internal::JITCompiledModule::TraceFn</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set custom routines to call when tracing is enabled. </p>
<p>Call this on the output <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> of your pipeline. This then sets custom routines for the entire pipeline, not just calls to this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.</p>
<p>If you are statically compiling, you can also just define your own versions of the tracing functions (see <a class="el" href="_halide_runtime_8h.html" title="Set a custom malloc and free for halide to use.">HalideRuntime.h</a>), and they will clobber <a class="el" href="namespace_halide.html">Halide</a>'s versions. </p>

</div>
</div>
<a class="anchor" id="ad4f476e156406c4a07c80a6c5be3597c"></a><!-- doxytag: member="Halide::Func::set_custom_print" ref="ad4f476e156406c4a07c80a6c5be3597c" args="(void(*handler)(void *, const char *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#ad4f476e156406c4a07c80a6c5be3597c">Halide::Func::set_custom_print</a> </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *, const char *)&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the function called to print messages from the runtime. </p>
<p>If you are compiling statically, you can also just define your own function with signature </p>
<div class="fragment"><pre class="fragment">     <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> <a class="code" href="_halide_runtime_8h.html#a96fe1dd85166a7f0da1b8f82f734296a" title="Unformatted print used to support halide_printf.">halide_print</a>(<span class="keywordtype">void</span> *user_context, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
</pre></div><p> This will clobber <a class="el" href="namespace_halide.html">Halide</a>'s version. </p>

</div>
</div>
<a class="anchor" id="adefe791b9c16f1674a1df2e1c5c75099"></a><!-- doxytag: member="Halide::Func::memoization_cache_set_size" ref="adefe791b9c16f1674a1df2e1c5c75099" args="(uint64_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#adefe791b9c16f1674a1df2e1c5c75099">Halide::Func::memoization_cache_set_size</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the maximum number of bytes used by memoization caching. </p>
<p>If you are compiling statically, you should include <a class="el" href="_halide_runtime_8h.html" title="Set a custom malloc and free for halide to use.">HalideRuntime.h</a> and call <a class="el" href="_halide_runtime_8h.html#abf85692a77aec0b887f345d0d3ca6777" title="Set the soft maximum amount of memory, in bytes, that the LRU cache will use to memoize Func results...">halide_memoization_cache_set_size()</a> instead. </p>

</div>
</div>
<a class="anchor" id="ad698122392e50574c38e3d19b0c9c41e"></a><!-- doxytag: member="Halide::Func::debug_to_file" ref="ad698122392e50574c38e3d19b0c9c41e" args="(const std::string &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#ad698122392e50574c38e3d19b0c9c41e">Halide::Func::debug_to_file</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When this function is compiled, include code that dumps its values to a file after it is realized, for the purpose of debugging. </p>
<p>If filename ends in ".tif" or ".tiff" (case insensitive) the file is in TIFF format and can be read by standard tools. Oherwise, the file format is as follows:</p>
<p>All data is in the byte-order of the target platform. First, a 20 byte-header containing four 32-bit ints, giving the extents of the first four dimensions. Dimensions beyond four are folded into the fourth. Then, a fifth 32-bit int giving the data type of the function. The typecodes are given by: float = 0, double = 1, uint8_t = 2, int8_t = 3, uint16_t = 4, int16_t = 5, uint32_t = 6, int32_t = 7, uint64_t = 8, int64_t = 9. The data follows the header, as a densely packed array of the given size and the given type. If given the extension .tmp, this file format can be natively read by the program ImageStack. </p>

</div>
</div>
<a class="anchor" id="a1c36026717d2f74a842983d65e6b3bf8"></a><!-- doxytag: member="Halide::Func::name" ref="a1c36026717d2f74a842983d65e6b3bf8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::string&amp; <a class="el" href="class_halide_1_1_func.html#a1c36026717d2f74a842983d65e6b3bf8">Halide::Func::name</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The name of this function, either given during construction, or automatically generated. </p>

</div>
</div>
<a class="anchor" id="a830f40950d6695281dc4c5057767ca4f"></a><!-- doxytag: member="Halide::Func::args" ref="a830f40950d6695281dc4c5057767ca4f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;<a class="el" href="class_halide_1_1_var.html">Var</a>&gt; <a class="el" href="class_halide_1_1_func.html#a830f40950d6695281dc4c5057767ca4f">Halide::Func::args</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the pure arguments. </p>

</div>
</div>
<a class="anchor" id="a184f385b265e7ba488a2eed66a10b41a"></a><!-- doxytag: member="Halide::Func::value" ref="a184f385b265e7ba488a2eed66a10b41a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="class_halide_1_1_func.html#a184f385b265e7ba488a2eed66a10b41a">Halide::Func::value</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The right-hand-side value of the pure definition of this function. </p>
<p>Causes an error if there's no pure definition, or if the function is defined to return multiple values. </p>

</div>
</div>
<a class="anchor" id="a2d2b62cf0249b0dcd24f41b246d82b3a"></a><!-- doxytag: member="Halide::Func::values" ref="a2d2b62cf0249b0dcd24f41b246d82b3a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> <a class="el" href="class_halide_1_1_func.html#a2d2b62cf0249b0dcd24f41b246d82b3a">Halide::Func::values</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The values returned by this function. </p>
<p>An error if the function has not been been defined. Returns a <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> with one element for functions defined to return a single value. </p>

</div>
</div>
<a class="anchor" id="a6744d1c69eeba054cc16c019a99e888d"></a><!-- doxytag: member="Halide::Func::defined" ref="a6744d1c69eeba054cc16c019a99e888d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="class_halide_1_1_func.html#a6744d1c69eeba054cc16c019a99e888d">Halide::Func::defined</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does this function have at least a pure definition. </p>

</div>
</div>
<a class="anchor" id="a574a2ab983f3b4da9baf94b379a2b2b4"></a><!-- doxytag: member="Halide::Func::update_args" ref="a574a2ab983f3b4da9baf94b379a2b2b4" args="(int idx=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; <a class="el" href="class_halide_1_1_func.html#a574a2ab983f3b4da9baf94b379a2b2b4">Halide::Func::update_args</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the left-hand-side of the update definition. </p>
<p>An empty vector if there's no update definition. If there are multiple update definitions for this function, use the argument to select which one you want. </p>

</div>
</div>
<a class="anchor" id="a7303885a8686f7bfb848a3d21214edfd"></a><!-- doxytag: member="Halide::Func::update_value" ref="a7303885a8686f7bfb848a3d21214edfd" args="(int idx=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="class_halide_1_1_func.html#a7303885a8686f7bfb848a3d21214edfd">Halide::Func::update_value</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the right-hand-side of an update definition. </p>
<p>An error if there's no update definition. If there are multiple update definitions for this function, use the argument to select which one you want. </p>

</div>
</div>
<a class="anchor" id="ac2c3df8403e8f990331525e4e7138e51"></a><!-- doxytag: member="Halide::Func::update_values" ref="ac2c3df8403e8f990331525e4e7138e51" args="(int idx=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> <a class="el" href="class_halide_1_1_func.html#ac2c3df8403e8f990331525e4e7138e51">Halide::Func::update_values</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the right-hand-side of an update definition for functions that returns multiple values. </p>
<p>An error if there's no update definition. Returns a <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> with one element for functions that return a single value. </p>

</div>
</div>
<a class="anchor" id="aa7c366ab3a5c6a472e19f5860b309eda"></a><!-- doxytag: member="Halide::Func::reduction_domain" ref="aa7c366ab3a5c6a472e19f5860b309eda" args="(int idx=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_r_dom.html">RDom</a> <a class="el" href="class_halide_1_1_func.html#aa7c366ab3a5c6a472e19f5860b309eda">Halide::Func::reduction_domain</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the reduction domain for an update definition, if there is one. </p>

</div>
</div>
<a class="anchor" id="a68f35881fbc6bcbed6442b1f6dfb6f6c"></a><!-- doxytag: member="Halide::Func::has_update_definition" ref="a68f35881fbc6bcbed6442b1f6dfb6f6c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="class_halide_1_1_func.html#a68f35881fbc6bcbed6442b1f6dfb6f6c">Halide::Func::has_update_definition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does this function have at least one update definition? </p>

</div>
</div>
<a class="anchor" id="a75792d22e6a8774a34785a2bc80a7d65"></a><!-- doxytag: member="Halide::Func::num_update_definitions" ref="a75792d22e6a8774a34785a2bc80a7d65" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int <a class="el" href="class_halide_1_1_func.html#a75792d22e6a8774a34785a2bc80a7d65">Halide::Func::num_update_definitions</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>How many update definitions does this function have? </p>

</div>
</div>
<a class="anchor" id="a10ea6486f854455c7c6275c5a34400f8"></a><!-- doxytag: member="Halide::Func::is_extern" ref="a10ea6486f854455c7c6275c5a34400f8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="class_halide_1_1_func.html#a10ea6486f854455c7c6275c5a34400f8">Halide::Func::is_extern</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is this function an external stage? That is, was it defined using define_extern? </p>

</div>
</div>
<a class="anchor" id="ab0c6a7f94cc7fdb8c42f2bcbc9013bfc"></a><!-- doxytag: member="Halide::Func::define_extern" ref="ab0c6a7f94cc7fdb8c42f2bcbc9013bfc" args="(const std::string &amp;function_name, const std::vector&lt; ExternFuncArgument &gt; &amp;params, Type t, int dimensionality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#ab0c6a7f94cc7fdb8c42f2bcbc9013bfc">Halide::Func::define_extern</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensionality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an extern definition for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>This lets you define a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> that represents an external pipeline stage. You can, for example, use it to wrap a call to an extern library such as fftw. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l00860">860</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7d51d585fac78c964b611eb4fcad522d"></a><!-- doxytag: member="Halide::Func::define_extern" ref="a7d51d585fac78c964b611eb4fcad522d" args="(const std::string &amp;function_name, const std::vector&lt; ExternFuncArgument &gt; &amp;params, const std::vector&lt; Type &gt; &amp;types, int dimensionality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="class_halide_1_1_func.html#ab0c6a7f94cc7fdb8c42f2bcbc9013bfc">Halide::Func::define_extern</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensionality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an extern definition for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>This lets you define a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> that represents an external pipeline stage. You can, for example, use it to wrap a call to an extern library such as fftw. </p>

</div>
</div>
<a class="anchor" id="a0622c8a11c948787eafbee82a0853030"></a><!-- doxytag: member="Halide::Func::output_types" ref="a0622c8a11c948787eafbee82a0853030" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::vector&lt;<a class="el" href="struct_halide_1_1_type.html">Type</a>&gt;&amp; <a class="el" href="class_halide_1_1_func.html#a0622c8a11c948787eafbee82a0853030">Halide::Func::output_types</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the types of the outputs of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>

</div>
</div>
<a class="anchor" id="a2ddfd0eef6173d668c0f76d6c52cefb7"></a><!-- doxytag: member="Halide::Func::outputs" ref="a2ddfd0eef6173d668c0f76d6c52cefb7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int <a class="el" href="class_halide_1_1_func.html#a2ddfd0eef6173d668c0f76d6c52cefb7">Halide::Func::outputs</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of outputs of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>Corresponds to the size of the <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> was defined to return. </p>

</div>
</div>
<a class="anchor" id="aeb3bd4ac6913bc0137f91ea7b6412acd"></a><!-- doxytag: member="Halide::Func::extern_function_name" ref="aeb3bd4ac6913bc0137f91ea7b6412acd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::string&amp; <a class="el" href="class_halide_1_1_func.html#aeb3bd4ac6913bc0137f91ea7b6412acd">Halide::Func::extern_function_name</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of the extern function called for an extern definition. </p>

</div>
</div>
<a class="anchor" id="a8993a73f9eb2d0c7ccc58028447d42f3"></a><!-- doxytag: member="Halide::Func::dimensions" ref="a8993a73f9eb2d0c7ccc58028447d42f3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int <a class="el" href="class_halide_1_1_func.html#a8993a73f9eb2d0c7ccc58028447d42f3">Halide::Func::dimensions</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The dimensionality (number of arguments) of this function. </p>
<p>Zero if the function is not yet defined. </p>

</div>
</div>
<a class="anchor" id="afb028626864f2a3f39641d00af78910f"></a><!-- doxytag: member="Halide::Func::operator()" ref="afb028626864f2a3f39641d00af78910f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a6ce0f0c6d8463c32f9ceacb0fe045051"></a><!-- doxytag: member="Halide::Func::operator()" ref="a6ce0f0c6d8463c32f9ceacb0fe045051" args="(Var x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a60a31dc608a3f44d6aadb2a6edc8f7e1"></a><!-- doxytag: member="Halide::Func::operator()" ref="a60a31dc608a3f44d6aadb2a6edc8f7e1" args="(Var x, Var y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a0f2a51dc115473368299e9966979e530"></a><!-- doxytag: member="Halide::Func::operator()" ref="a0f2a51dc115473368299e9966979e530" args="(Var x, Var y, Var z) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="af64144c733800b0b6bc0f1d8108e2ddc"></a><!-- doxytag: member="Halide::Func::operator()" ref="af64144c733800b0b6bc0f1d8108e2ddc" args="(Var x, Var y, Var z, Var w) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="aafd2a13dff2a024e86445e56c719503a"></a><!-- doxytag: member="Halide::Func::operator()" ref="aafd2a13dff2a024e86445e56c719503a" args="(Var x, Var y, Var z, Var w, Var u) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="ad155774acf0b530a7bf1fb5f1b513c16"></a><!-- doxytag: member="Halide::Func::operator()" ref="ad155774acf0b530a7bf1fb5f1b513c16" args="(Var x, Var y, Var z, Var w, Var u, Var v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="ae126902d07bdf0bb9595ef9c36ce857c"></a><!-- doxytag: member="Halide::Func::operator()" ref="ae126902d07bdf0bb9595ef9c36ce857c" args="(std::vector&lt; Var &gt;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_halide_1_1_var.html">Var</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct either the left-hand-side of a definition, or a call to a functions that happens to only contain vars as arguments. </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a85c51b6c4753623f6c85d067bbe367ff"></a><!-- doxytag: member="Halide::Func::operator()" ref="a85c51b6c4753623f6c85d067bbe367ff" args="(Expr x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="ae37eb8a056b41e7983fc7127471c1350"></a><!-- doxytag: member="Halide::Func::operator()" ref="ae37eb8a056b41e7983fc7127471c1350" args="(Expr x, Expr y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a27b5159835278ac904ee9512608d2acb"></a><!-- doxytag: member="Halide::Func::operator()" ref="a27b5159835278ac904ee9512608d2acb" args="(Expr x, Expr y, Expr z) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a2722b4f2538ddc74a966419d13b73b2f"></a><!-- doxytag: member="Halide::Func::operator()" ref="a2722b4f2538ddc74a966419d13b73b2f" args="(Expr x, Expr y, Expr z, Expr w) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a16ae313b5ed4cd15232e85d2901cb97f"></a><!-- doxytag: member="Halide::Func::operator()" ref="a16ae313b5ed4cd15232e85d2901cb97f" args="(Expr x, Expr y, Expr z, Expr w, Expr u) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a6b31299fe9c9d0c7e3ba7e34be4e8df5"></a><!-- doxytag: member="Halide::Func::operator()" ref="a6b31299fe9c9d0c7e3ba7e34be4e8df5" args="(Expr x, Expr y, Expr z, Expr w, Expr u, Expr v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="ac86c1602915f8a423faf62926201ad9a"></a><!-- doxytag: member="Halide::Func::operator()" ref="ac86c1602915f8a423faf62926201ad9a" args="(std::vector&lt; Expr &gt;) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func_ref_expr.html">FuncRefExpr</a> Halide::Func::operator() </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Either calls to the function, or the left-hand-side of a update definition (see <a class="el" href="class_halide_1_1_r_dom.html">RDom</a>). </p>
<p>If the function has already been defined, and fewer arguments are given than the function has dimensions, then enough implicit vars are added to the end of the argument list to make up the difference. (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>) </p>

</div>
</div>
<a class="anchor" id="a52a4cace19fc024959cda3a7e82dd9f6"></a><!-- doxytag: member="Halide::Func::split" ref="a52a4cace19fc024959cda3a7e82dd9f6" args="(VarOrRVar old, VarOrRVar outer, VarOrRVar inner, Expr factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a52a4cace19fc024959cda3a7e82dd9f6">Halide::Func::split</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a dimension into inner and outer subdimensions with the given names, where the inner dimension iterates from 0 to factor-1. </p>
<p>The inner and outer subdimensions can then be dealt with using the other scheduling calls. It's ok to reuse the old variable name as either the inner or outer variable. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a6">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a9">tutorial/lesson_08_scheduling_2.cpp</a>, and <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a25">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a07ae6163527e6319a9352f7648afd875"></a><!-- doxytag: member="Halide::Func::fuse" ref="a07ae6163527e6319a9352f7648afd875" args="(VarOrRVar inner, VarOrRVar outer, VarOrRVar fused)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a07ae6163527e6319a9352f7648afd875">Halide::Func::fuse</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>fused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Join two dimensions into a single fused dimenion. </p>
<p>The fused dimension covers the product of the extents of the inner and outer dimensions given. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a7">tutorial/lesson_05_scheduling_1.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a0cc4478f55fbba3e25ed8ee5ea30d461"></a><!-- doxytag: member="Halide::Func::serial" ref="a0cc4478f55fbba3e25ed8ee5ea30d461" args="(VarOrRVar var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a0cc4478f55fbba3e25ed8ee5ea30d461">Halide::Func::serial</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark a dimension to be traversed serially. </p>
<p>This is the default. </p>

</div>
</div>
<a class="anchor" id="aa0050c604179b43a8deb42b62dedd29d"></a><!-- doxytag: member="Halide::Func::parallel" ref="aa0050c604179b43a8deb42b62dedd29d" args="(VarOrRVar var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#aa0050c604179b43a8deb42b62dedd29d">Halide::Func::parallel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark a dimension to be traversed in parallel. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a5">tutorial/lesson_04_debugging_2.cpp</a>, <a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a11">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a10">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a10">tutorial/lesson_09_update_definitions.cpp</a>, <a class="el" href="tutorial_2lesson_10_aot_compilation_generate_8cpp-example.html#a5">tutorial/lesson_10_aot_compilation_generate.cpp</a>, and <a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a5">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac2cb83a295d98281e93b11a2c1881eae"></a><!-- doxytag: member="Halide::Func::parallel" ref="ac2cb83a295d98281e93b11a2c1881eae" args="(VarOrRVar var, Expr task_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#aa0050c604179b43a8deb42b62dedd29d">Halide::Func::parallel</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>task_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a dimension by the given task_size, and the parallelize the outer dimension. </p>
<p>This creates parallel tasks that have size task_size. After this call, var refers to the outer dimension of the split. The inner dimension has a new anonymous name. If you wish to mutate it, or schedule with respect to it, do the split manually. </p>

</div>
</div>
<a class="anchor" id="a7b1857a62deca8bc9a477c1b26720950"></a><!-- doxytag: member="Halide::Func::vectorize" ref="a7b1857a62deca8bc9a477c1b26720950" args="(VarOrRVar var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a7b1857a62deca8bc9a477c1b26720950">Halide::Func::vectorize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark a dimension to be computed all-at-once as a single vector. </p>
<p>The dimension should have constant extent - e.g. because it is the inner dimension following a split by a constant factor. For most uses of vectorize you want the two argument form. The variable to be vectorized should be the innermost one. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a8">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a11">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a9">tutorial/lesson_09_update_definitions.cpp</a>, <a class="el" href="tutorial_2lesson_10_aot_compilation_generate_8cpp-example.html#a4">tutorial/lesson_10_aot_compilation_generate.cpp</a>, and <a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a4">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a75c97910f964410df65f04f7a85e3518"></a><!-- doxytag: member="Halide::Func::unroll" ref="a75c97910f964410df65f04f7a85e3518" args="(VarOrRVar var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a75c97910f964410df65f04f7a85e3518">Halide::Func::unroll</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mark a dimension to be completely unrolled. </p>
<p>The dimension should have constant extent - e.g. because it is the inner dimension following a split by a constant factor. For most uses of unroll you want the two-argument form. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a9">tutorial/lesson_05_scheduling_1.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a76cc0eb4dd4d5ce2144fc536c5ad2218"></a><!-- doxytag: member="Halide::Func::vectorize" ref="a76cc0eb4dd4d5ce2144fc536c5ad2218" args="(VarOrRVar var, int factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a7b1857a62deca8bc9a477c1b26720950">Halide::Func::vectorize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a dimension by the given factor, then vectorize the inner dimension. </p>
<p>This is how you vectorize a loop of unknown size. The variable to be vectorized should be the innermost one. After this call, var refers to the outer dimension of the split. </p>

</div>
</div>
<a class="anchor" id="aff8b6136345c72f4976ec1e2d99d0a39"></a><!-- doxytag: member="Halide::Func::unroll" ref="aff8b6136345c72f4976ec1e2d99d0a39" args="(VarOrRVar var, int factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a75c97910f964410df65f04f7a85e3518">Halide::Func::unroll</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a dimension by the given factor, then unroll the inner dimension. </p>
<p>This is how you unroll a loop of unknown size by some constant factor. After this call, var refers to the outer dimension of the split. </p>

</div>
</div>
<a class="anchor" id="afadd04bc51ed5999496eaa876a4ee790"></a><!-- doxytag: member="Halide::Func::bound" ref="afadd04bc51ed5999496eaa876a4ee790" args="(Var var, Expr min, Expr extent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#afadd04bc51ed5999496eaa876a4ee790">Halide::Func::bound</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statically declare that the range over which a function should be evaluated is given by the second and third arguments. </p>
<p>This can let <a class="el" href="namespace_halide.html">Halide</a> perform some optimizations. E.g. if you know there are going to be 4 color channels, you can completely vectorize the color channel dimension without the overhead of splitting it up. If bounds inference decides that it requires more of this function than the bounds you have stated, a runtime error will occur when you try to run your pipeline. </p>

</div>
</div>
<a class="anchor" id="ab15001cd4af9e8c2808f45ff53b81582"></a><!-- doxytag: member="Halide::Func::tile" ref="ab15001cd4af9e8c2808f45ff53b81582" args="(VarOrRVar x, VarOrRVar y, VarOrRVar xo, VarOrRVar yo, VarOrRVar xi, VarOrRVar yi, Expr xfactor, Expr yfactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#ab15001cd4af9e8c2808f45ff53b81582">Halide::Func::tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>xo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>yo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>xfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>yfactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi, yi, xo, yo from innermost outwards. </p>
<p>This gives a tiled traversal. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a10">tutorial/lesson_05_scheduling_1.cpp</a>, and <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a8">tutorial/lesson_08_scheduling_2.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad2cd7aab5ed429755a6c6a2c3cd608b9"></a><!-- doxytag: member="Halide::Func::tile" ref="ad2cd7aab5ed429755a6c6a2c3cd608b9" args="(VarOrRVar x, VarOrRVar y, VarOrRVar xi, VarOrRVar yi, Expr xfactor, Expr yfactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#ab15001cd4af9e8c2808f45ff53b81582">Halide::Func::tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>xfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>yfactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A shorter form of tile, which reuses the old variable names as the new outer dimensions. </p>

</div>
</div>
<a class="anchor" id="a2ad991bc3ebd940906187a0552ef7754"></a><!-- doxytag: member="Halide::Func::reorder" ref="a2ad991bc3ebd940906187a0552ef7754" args="(const std::vector&lt; VarOrRVar &gt; &amp;vars)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754">Halide::Func::reorder</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder variables to have the given nesting order, from innermost out. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a5">tutorial/lesson_05_scheduling_1.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a623981c5b7da85fc511d4fa5a2cc0e9c"></a><!-- doxytag: member="Halide::Func::reorder" ref="a623981c5b7da85fc511d4fa5a2cc0e9c" args="(VarOrRVar x, VarOrRVar y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754">Halide::Func::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder two dimensions so that x is traversed inside y. </p>
<p>Does not affect the nesting order of other dimensions. E.g, if you say foo(x, y, z, w) = bar; foo.reorder(w, x); then foo will be traversed in the order (w, y, z, x), from innermost outwards. </p>

</div>
</div>
<a class="anchor" id="a9325061ec4e13c7c689f57f40fd1a245"></a><!-- doxytag: member="Halide::Func::reorder" ref="a9325061ec4e13c7c689f57f40fd1a245" args="(VarOrRVar x, VarOrRVar y, VarOrRVar z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754">Halide::Func::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder three dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a448833656daa9b8c15dde144f4b37624"></a><!-- doxytag: member="Halide::Func::reorder" ref="a448833656daa9b8c15dde144f4b37624" args="(VarOrRVar x, VarOrRVar y, VarOrRVar z, VarOrRVar w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754">Halide::Func::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder four dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a65789828fc8ae0e60b47b5e2fef1c9f2"></a><!-- doxytag: member="Halide::Func::reorder" ref="a65789828fc8ae0e60b47b5e2fef1c9f2" args="(VarOrRVar x, VarOrRVar y, VarOrRVar z, VarOrRVar w, VarOrRVar t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754">Halide::Func::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder five dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a7f533dd5f9cac7780a91602c7265c707"></a><!-- doxytag: member="Halide::Func::reorder" ref="a7f533dd5f9cac7780a91602c7265c707" args="(VarOrRVar x, VarOrRVar y, VarOrRVar z, VarOrRVar w, VarOrRVar t1, VarOrRVar t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754">Halide::Func::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder six dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a17ca21cd1540a7a426bad4f8439022d7"></a><!-- doxytag: member="Halide::Func::reorder" ref="a17ca21cd1540a7a426bad4f8439022d7" args="(VarOrRVar x, VarOrRVar y, VarOrRVar z, VarOrRVar w, VarOrRVar t1, VarOrRVar t2, VarOrRVar t3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754">Halide::Func::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder seven dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="aec6164c247a777e0525027ccc6ad5490"></a><!-- doxytag: member="Halide::Func::reorder" ref="aec6164c247a777e0525027ccc6ad5490" args="(VarOrRVar x, VarOrRVar y, VarOrRVar z, VarOrRVar w, VarOrRVar t1, VarOrRVar t2, VarOrRVar t3, VarOrRVar t4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754">Halide::Func::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder eight dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="adbdb24c59648086d558e35f0a5e7020b"></a><!-- doxytag: member="Halide::Func::reorder" ref="adbdb24c59648086d558e35f0a5e7020b" args="(VarOrRVar x, VarOrRVar y, VarOrRVar z, VarOrRVar w, VarOrRVar t1, VarOrRVar t2, VarOrRVar t3, VarOrRVar t4, VarOrRVar t5)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754">Halide::Func::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder nine dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a34fb43d08a61f6a4e06175c18491ecea"></a><!-- doxytag: member="Halide::Func::reorder" ref="a34fb43d08a61f6a4e06175c18491ecea" args="(VarOrRVar x, VarOrRVar y, VarOrRVar z, VarOrRVar w, VarOrRVar t1, VarOrRVar t2, VarOrRVar t3, VarOrRVar t4, VarOrRVar t5, VarOrRVar t6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754">Halide::Func::reorder</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>t6</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder ten dimensions to have the given nesting order, from innermost out. </p>

</div>
</div>
<a class="anchor" id="a7d9dd3771ece9a9525bf9129b5339aae"></a><!-- doxytag: member="Halide::Func::rename" ref="a7d9dd3771ece9a9525bf9129b5339aae" args="(VarOrRVar old_name, VarOrRVar new_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a7d9dd3771ece9a9525bf9129b5339aae">Halide::Func::rename</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>new_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rename a dimension. </p>
<p>Equivalent to split with a inner size of one. </p>

</div>
</div>
<a class="anchor" id="af060692f2192e9d777a3cee8b87c5e88"></a><!-- doxytag: member="Halide::Func::allow_race_conditions" ref="af060692f2192e9d777a3cee8b87c5e88" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#af060692f2192e9d777a3cee8b87c5e88">Halide::Func::allow_race_conditions</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify that race conditions are permitted for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, which enables parallelizing over RVars even when <a class="el" href="namespace_halide.html">Halide</a> cannot prove that it is safe to do so. </p>
<p>Use this with great caution, and only if you can prove to yourself that this is safe, as it may result in a non-deterministic routine that returns different values at different times or on different machines. </p>

</div>
</div>
<a class="anchor" id="aa4053da66218dfd7769ea4d974e252b5"></a><!-- doxytag: member="Halide::Func::specialize" ref="aa4053da66218dfd7769ea4d974e252b5" args="(Expr condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_stage.html">Stage</a> <a class="el" href="class_halide_1_1_func.html#aa4053da66218dfd7769ea4d974e252b5">Halide::Func::specialize</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specialize a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>This creates a special-case version of the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> where the given condition is true. The most effective conditions are those of the form param == value, and boolean Params. Consider a simple example: </p>
<div class="fragment"><pre class="fragment">     f(x) = x + <a class="code" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06" title="Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...">select</a>(cond, 0, 1);
     f.compute_root();
</pre></div><p> This is equivalent to: </p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
       f[x] = x + (cond ? 0 : 1);
     }
</pre></div><p> Adding the scheduling directive: </p>
<div class="fragment"><pre class="fragment">     f.specialize(cond)
</pre></div><p> makes it equivalent to: </p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">if</span> (cond) {
       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
         f[x] = x;
       }
     } <span class="keywordflow">else</span> {
       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
         f[x] = x + 1;
       }
     }
</pre></div><p> Note that the inner loops have been simplified. In the first path <a class="el" href="namespace_halide.html">Halide</a> knows that cond is true, and in the second path <a class="el" href="namespace_halide.html">Halide</a> knows that it is false.</p>
<p>The specialized version gets its own schedule, which inherits every directive made about the parent <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s schedule so far except for its specializations. This method returns a handle to the new schedule. If you wish to retrieve the specialized sub-schedule again later, you can call this method with the same condition. Consider the following example of scheduling the specialized version:</p>
<div class="fragment"><pre class="fragment">     f(x) = x;
     f.compute_root();
     f.specialize(width &gt; 1).unroll(x, 2);
</pre></div><p> Assuming for simplicity that width is even, this is equivalent to: </p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">if</span> (width &gt; 1) {
       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width/2; x++) {
         f[2*x] = 2*x;
         f[2*x + 1] = 2*x + 1;
       }
     } <span class="keywordflow">else</span> {
       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width/2; x++) {
         f[x] = x;
       }
     }
</pre></div><p> For this case, it may be better to schedule the un-specialized case instead: </p>
<div class="fragment"><pre class="fragment">     f(x) = x;
     f.compute_root();
     f.specialize(width == 1); <span class="comment">// Creates a copy of the schedule so far.</span>
     f.unroll(x, 2); <span class="comment">// Only applies to the unspecialized case.</span>
</pre></div><p> This is equivalent to: </p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">if</span> (width == 1) {
       f[0] = 0;
     } <span class="keywordflow">else</span> {
       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width/2; x++) {
         f[2*x] = 2*x;
         f[2*x + 1] = 2*x + 1;
       }
     }
</pre></div><p> This can be a good way to write a pipeline that splits, vectorizes, or tiles, but can still handle small inputs.</p>
<p>If a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has several specializations, the first matching one will be used, so the order in which you define specializations is significant. For example:</p>
<div class="fragment"><pre class="fragment">     f(x) = x + <a class="code" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06" title="Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...">select</a>(cond1, a, b) - <a class="code" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06" title="Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...">select</a>(cond2, c, d);
     f.specialize(cond1);
     f.specialize(cond2);
</pre></div><p> is equivalent to: </p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">if</span> (cond1) {
       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
         f[x] = x + a - (cond2 ? c : d);
       }
     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cond2) {
       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
         f[x] = x + b - c;
       }
     } <span class="keywordflow">else</span> {
       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
         f[x] = x + b - d;
       }
     }
</pre></div><p>Specializations may in turn be specialized, which creates a nested if statement in the generated code.</p>
<div class="fragment"><pre class="fragment">     f(x) = x + <a class="code" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06" title="Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...">select</a>(cond1, a, b) - <a class="code" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06" title="Returns an expression similar to the ternary operator in C, except that it always evaluates all argum...">select</a>(cond2, c, d);
     f.specialize(cond1).specialize(cond2);
</pre></div><p> This is equivalent to: </p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">if</span> (cond1) {
       <span class="keywordflow">if</span> (cond2) {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
           f[x] = x + a - c;
         }
       } <span class="keywordflow">else</span> {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
           f[x] = x + a - d;
         }
       }
     } <span class="keywordflow">else</span> {
       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
         f[x] = x + b - (cond2 ? c : d);
       }
     }
</pre></div><p> To create a 4-way if statement that simplifies away all of the ternary operators above, you could say: </p>
<div class="fragment"><pre class="fragment">     f.specialize(cond1).specialize(cond2);
     f.specialize(cond2);
</pre></div><p> or </p>
<div class="fragment"><pre class="fragment">     f.specialize(cond1 &amp;&amp; cond2);
     f.specialize(cond1);
     f.specialize(cond2);
</pre></div><p>Any prior <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> which is compute_at some variable of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> gets separately included in all paths of the generated if statement. The <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> in the compute_at call to must exist in all paths, but it may have been generated via a different path of splits, fuses, and renames. This can be used somewhat creatively. Consider the following code: </p>
<div class="fragment"><pre class="fragment">     g(x, y) = 8*x;
     f(x, y) = g(x, y) + 1;
     f.compute_root().specialize(cond);
     Var g_loop;
     f.specialize(cond).rename(y, g_loop);
     f.rename(x, g_loop);
     g.compute_at(f, g_loop);
</pre></div><p> When cond is true, this is equivalent to g.compute_at(f,y). When it is false, this is equivalent to g.compute_at(f,x). </p>

</div>
</div>
<a class="anchor" id="a97c3902ed0f891864746831a87530c60"></a><!-- doxytag: member="Halide::Func::gpu_threads" ref="a97c3902ed0f891864746831a87530c60" args="(VarOrRVar thread_x, GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a97c3902ed0f891864746831a87530c60">Halide::Func::gpu_threads</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU thread indices. </p>
<p>This is useful if you compute a producer function within the block indices of a consumer function, and want to control how that function's dimensions map to GPU threads. If the selected target is not an appropriate GPU, this just marks those dimensions as parallel. </p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01251">cuda_threads()</a>.</p>

</div>
</div>
<a class="anchor" id="a4016eff4c2a6b845e35eab4562a699e3"></a><!-- doxytag: member="Halide::Func::gpu_threads" ref="a4016eff4c2a6b845e35eab4562a699e3" args="(VarOrRVar thread_x, VarOrRVar thread_y, GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a97c3902ed0f891864746831a87530c60">Halide::Func::gpu_threads</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU thread indices. </p>
<p>This is useful if you compute a producer function within the block indices of a consumer function, and want to control how that function's dimensions map to GPU threads. If the selected target is not an appropriate GPU, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="a761d0f61353523419e685be8569e464d"></a><!-- doxytag: member="Halide::Func::gpu_threads" ref="a761d0f61353523419e685be8569e464d" args="(VarOrRVar thread_x, VarOrRVar thread_y, VarOrRVar thread_z, GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a97c3902ed0f891864746831a87530c60">Halide::Func::gpu_threads</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU thread indices. </p>
<p>This is useful if you compute a producer function within the block indices of a consumer function, and want to control how that function's dimensions map to GPU threads. If the selected target is not an appropriate GPU, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="aeff457fc695a5ff574c2a2f935c1e77f"></a><!-- doxytag: member="Halide::Func::gpu_single_thread" ref="aeff457fc695a5ff574c2a2f935c1e77f" args="(GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#aeff457fc695a5ff574c2a2f935c1e77f">Halide::Func::gpu_single_thread</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> to run this stage using a single gpu thread and block. </p>
<p>This is not an efficient use of your GPU, but it can be useful to avoid copy-back for intermediate update stages that touch a very small part of your <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01782">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a class="anchor" id="ae462cad7fa20b9fd13c7efb718e673fa"></a><!-- doxytag: member="Halide::Func::cuda_threads" ref="ae462cad7fa20b9fd13c7efb718e673fa" args="(VarOrRVar thread_x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#ae462cad7fa20b9fd13c7efb718e673fa">Halide::Func::cuda_threads</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Old name for <a class="el" href="class_halide_1_1_func.html#a97c3902ed0f891864746831a87530c60" title="Tell Halide that the following dimensions correspond to GPU thread indices.">gpu_threads</a>.</dd></dl>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01251">1251</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_func.html#a97c3902ed0f891864746831a87530c60">gpu_threads()</a>.</p>

</div>
</div>
<a class="anchor" id="a3029a8718f7dd3bcd84de725c0fd7f59"></a><!-- doxytag: member="Halide::Func::cuda_threads" ref="a3029a8718f7dd3bcd84de725c0fd7f59" args="(VarOrRVar thread_x, VarOrRVar thread_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#ae462cad7fa20b9fd13c7efb718e673fa">Halide::Func::cuda_threads</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Old name for <a class="el" href="class_halide_1_1_func.html#a97c3902ed0f891864746831a87530c60" title="Tell Halide that the following dimensions correspond to GPU thread indices.">gpu_threads</a>.</dd></dl>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01254">1254</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_func.html#a97c3902ed0f891864746831a87530c60">gpu_threads()</a>.</p>

</div>
</div>
<a class="anchor" id="a57ddd7f746722ce8a0ced0deb6463ea7"></a><!-- doxytag: member="Halide::Func::cuda_threads" ref="a57ddd7f746722ce8a0ced0deb6463ea7" args="(VarOrRVar thread_x, VarOrRVar thread_y, VarOrRVar thread_z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#ae462cad7fa20b9fd13c7efb718e673fa">Halide::Func::cuda_threads</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Old name for <a class="el" href="class_halide_1_1_func.html#a97c3902ed0f891864746831a87530c60" title="Tell Halide that the following dimensions correspond to GPU thread indices.">gpu_threads</a>.</dd></dl>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01257">1257</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_func.html#a97c3902ed0f891864746831a87530c60">gpu_threads()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c0d1afe7ec485ec0eb77c533f703018"></a><!-- doxytag: member="Halide::Func::gpu_blocks" ref="a1c0d1afe7ec485ec0eb77c533f703018" args="(VarOrRVar block_x, GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a1c0d1afe7ec485ec0eb77c533f703018">Halide::Func::gpu_blocks</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU block indices. </p>
<p>This is useful for scheduling stages that will run serially within each GPU block. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01274">cuda_blocks()</a>.</p>

</div>
</div>
<a class="anchor" id="aba2d154464141d13c06ef3ee8d5dace3"></a><!-- doxytag: member="Halide::Func::gpu_blocks" ref="aba2d154464141d13c06ef3ee8d5dace3" args="(VarOrRVar block_x, VarOrRVar block_y, GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a1c0d1afe7ec485ec0eb77c533f703018">Halide::Func::gpu_blocks</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU block indices. </p>
<p>This is useful for scheduling stages that will run serially within each GPU block. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="a031df9d1f7861f576768c770a580e3c8"></a><!-- doxytag: member="Halide::Func::gpu_blocks" ref="a031df9d1f7861f576768c770a580e3c8" args="(VarOrRVar block_x, VarOrRVar block_y, VarOrRVar block_z, GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a1c0d1afe7ec485ec0eb77c533f703018">Halide::Func::gpu_blocks</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU block indices. </p>
<p>This is useful for scheduling stages that will run serially within each GPU block. If the selected target is not ptx, this just marks those dimensions as parallel. </p>

</div>
</div>
<a class="anchor" id="a743f2ff1caf93d68b7c2c349f3649f38"></a><!-- doxytag: member="Halide::Func::cuda_blocks" ref="a743f2ff1caf93d68b7c2c349f3649f38" args="(VarOrRVar block_x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a743f2ff1caf93d68b7c2c349f3649f38">Halide::Func::cuda_blocks</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Old name for <a class="el" href="class_halide_1_1_func.html#a1c0d1afe7ec485ec0eb77c533f703018" title="Tell Halide that the following dimensions correspond to GPU block indices.">gpu_blocks</a>.</dd></dl>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01274">1274</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_func.html#a1c0d1afe7ec485ec0eb77c533f703018">gpu_blocks()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e12a129fa134ced57e57de72280a587"></a><!-- doxytag: member="Halide::Func::cuda_blocks" ref="a4e12a129fa134ced57e57de72280a587" args="(VarOrRVar block_x, VarOrRVar block_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a743f2ff1caf93d68b7c2c349f3649f38">Halide::Func::cuda_blocks</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Old name for <a class="el" href="class_halide_1_1_func.html#a1c0d1afe7ec485ec0eb77c533f703018" title="Tell Halide that the following dimensions correspond to GPU block indices.">gpu_blocks</a>.</dd></dl>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01277">1277</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_func.html#a1c0d1afe7ec485ec0eb77c533f703018">gpu_blocks()</a>.</p>

</div>
</div>
<a class="anchor" id="a5db8fd04dabbdd24b96c5d1fc7a617ac"></a><!-- doxytag: member="Halide::Func::cuda_blocks" ref="a5db8fd04dabbdd24b96c5d1fc7a617ac" args="(VarOrRVar block_x, VarOrRVar block_y, VarOrRVar block_z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a743f2ff1caf93d68b7c2c349f3649f38">Halide::Func::cuda_blocks</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Old name for <a class="el" href="class_halide_1_1_func.html#a1c0d1afe7ec485ec0eb77c533f703018" title="Tell Halide that the following dimensions correspond to GPU block indices.">gpu_blocks</a>.</dd></dl>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01280">1280</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_func.html#a1c0d1afe7ec485ec0eb77c533f703018">gpu_blocks()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d61e1d357736d9b5b944eeaa966f97b"></a><!-- doxytag: member="Halide::Func::gpu" ref="a8d61e1d357736d9b5b944eeaa966f97b" args="(VarOrRVar block_x, VarOrRVar thread_x, GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a8d61e1d357736d9b5b944eeaa966f97b">Halide::Func::gpu</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU block indices and thread indices. </p>
<p>If the selected target is not ptx, these just mark the given dimensions as parallel. The dimensions are consumed by this call, so do all other unrolling, reordering, etc first. </p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01300">cuda()</a>.</p>

</div>
</div>
<a class="anchor" id="a478a8fbfc94817180e20ac63b7c0d608"></a><!-- doxytag: member="Halide::Func::gpu" ref="a478a8fbfc94817180e20ac63b7c0d608" args="(VarOrRVar block_x, VarOrRVar block_y, VarOrRVar thread_x, VarOrRVar thread_y, GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a8d61e1d357736d9b5b944eeaa966f97b">Halide::Func::gpu</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU block indices and thread indices. </p>
<p>If the selected target is not ptx, these just mark the given dimensions as parallel. The dimensions are consumed by this call, so do all other unrolling, reordering, etc first. </p>

</div>
</div>
<a class="anchor" id="a000fbae88d4e9b8b2657e034cba7a2dc"></a><!-- doxytag: member="Halide::Func::gpu" ref="a000fbae88d4e9b8b2657e034cba7a2dc" args="(VarOrRVar block_x, VarOrRVar block_y, VarOrRVar block_z, VarOrRVar thread_x, VarOrRVar thread_y, VarOrRVar thread_z, GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a8d61e1d357736d9b5b944eeaa966f97b">Halide::Func::gpu</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="namespace_halide.html">Halide</a> that the following dimensions correspond to GPU block indices and thread indices. </p>
<p>If the selected target is not ptx, these just mark the given dimensions as parallel. The dimensions are consumed by this call, so do all other unrolling, reordering, etc first. </p>

</div>
</div>
<a class="anchor" id="acd9a14b35baf855b4ece625497ef9d52"></a><!-- doxytag: member="Halide::Func::cuda" ref="acd9a14b35baf855b4ece625497ef9d52" args="(VarOrRVar block_x, VarOrRVar thread_x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#acd9a14b35baf855b4ece625497ef9d52">Halide::Func::cuda</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Old name for <a class="el" href="class_halide_1_1_func.html#a8d61e1d357736d9b5b944eeaa966f97b" title="Tell Halide that the following dimensions correspond to GPU block indices and thread indices...">gpu</a>.</dd></dl>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01300">1300</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_func.html#a8d61e1d357736d9b5b944eeaa966f97b">gpu()</a>.</p>

</div>
</div>
<a class="anchor" id="a248af06bc93b2998a967f4e978be4989"></a><!-- doxytag: member="Halide::Func::cuda" ref="a248af06bc93b2998a967f4e978be4989" args="(VarOrRVar block_x, VarOrRVar block_y, VarOrRVar thread_x, VarOrRVar thread_y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#acd9a14b35baf855b4ece625497ef9d52">Halide::Func::cuda</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Old name for <a class="el" href="class_halide_1_1_func.html#a8d61e1d357736d9b5b944eeaa966f97b" title="Tell Halide that the following dimensions correspond to GPU block indices and thread indices...">gpu</a>.</dd></dl>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01303">1303</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_func.html#a8d61e1d357736d9b5b944eeaa966f97b">gpu()</a>.</p>

</div>
</div>
<a class="anchor" id="a36804531fb15cb4d3d394aad1cfaa473"></a><!-- doxytag: member="Halide::Func::cuda" ref="a36804531fb15cb4d3d394aad1cfaa473" args="(VarOrRVar block_x, VarOrRVar block_y, VarOrRVar block_z, VarOrRVar thread_x, VarOrRVar thread_y, VarOrRVar thread_z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#acd9a14b35baf855b4ece625497ef9d52">Halide::Func::cuda</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>block_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>thread_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Old name for <a class="el" href="class_halide_1_1_func.html#a8d61e1d357736d9b5b944eeaa966f97b" title="Tell Halide that the following dimensions correspond to GPU block indices and thread indices...">gpu</a>.</dd></dl>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01307">1307</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_func.html#a8d61e1d357736d9b5b944eeaa966f97b">gpu()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f5fc7359a2ca66e557a9f129088c223"></a><!-- doxytag: member="Halide::Func::gpu_tile" ref="a5f5fc7359a2ca66e557a9f129088c223" args="(VarOrRVar x, int x_size, GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a5f5fc7359a2ca66e557a9f129088c223">Halide::Func::gpu_tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates within each tile to GPU thread indices. </p>
<p>Consumes the variables given, so do all other scheduling first. </p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01326">cuda_tile()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e719ccbc30fa907ad71443ffb40af30"></a><!-- doxytag: member="Halide::Func::gpu_tile" ref="a6e719ccbc30fa907ad71443ffb40af30" args="(VarOrRVar x, VarOrRVar y, int x_size, int y_size, GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a5f5fc7359a2ca66e557a9f129088c223">Halide::Func::gpu_tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates within each tile to GPU thread indices. </p>
<p>Consumes the variables given, so do all other scheduling first. </p>

</div>
</div>
<a class="anchor" id="adfcc33f4d9e75bb568cbfda245f9ed6a"></a><!-- doxytag: member="Halide::Func::gpu_tile" ref="adfcc33f4d9e75bb568cbfda245f9ed6a" args="(VarOrRVar x, VarOrRVar y, VarOrRVar z, int x_size, int y_size, int z_size, GPUAPI gpu_api=GPU_Default)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a5f5fc7359a2ca66e557a9f129088c223">Halide::Func::gpu_tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a>&#160;</td>
          <td class="paramname"><em>gpu_api</em> = <code><a class="el" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates within each tile to GPU thread indices. </p>
<p>Consumes the variables given, so do all other scheduling first. </p>

</div>
</div>
<a class="anchor" id="a0139c3cc5bf66f738fa36ec83f379d56"></a><!-- doxytag: member="Halide::Func::cuda_tile" ref="a0139c3cc5bf66f738fa36ec83f379d56" args="(VarOrRVar x, int x_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a0139c3cc5bf66f738fa36ec83f379d56">Halide::Func::cuda_tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Old name for <a class="el" href="class_halide_1_1_func.html#a5f5fc7359a2ca66e557a9f129088c223" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>.</dd></dl>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01326">1326</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_func.html#a5f5fc7359a2ca66e557a9f129088c223">gpu_tile()</a>.</p>

</div>
</div>
<a class="anchor" id="ab5b665bd3d2dc436da342fd127354946"></a><!-- doxytag: member="Halide::Func::cuda_tile" ref="ab5b665bd3d2dc436da342fd127354946" args="(VarOrRVar x, VarOrRVar y, int x_size, int y_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a0139c3cc5bf66f738fa36ec83f379d56">Halide::Func::cuda_tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Old name for <a class="el" href="class_halide_1_1_func.html#a5f5fc7359a2ca66e557a9f129088c223" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>.</dd></dl>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01329">1329</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_func.html#a5f5fc7359a2ca66e557a9f129088c223">gpu_tile()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a5fb83e26ebe218658e18f84ff6ad6d"></a><!-- doxytag: member="Halide::Func::cuda_tile" ref="a6a5fb83e26ebe218658e18f84ff6ad6d" args="(VarOrRVar x, VarOrRVar y, VarOrRVar z, int x_size, int y_size, int z_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a0139c3cc5bf66f738fa36ec83f379d56">Halide::Func::cuda_tile</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Old name for <a class="el" href="class_halide_1_1_func.html#a5f5fc7359a2ca66e557a9f129088c223" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>.</dd></dl>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01332">1332</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_func.html#a5f5fc7359a2ca66e557a9f129088c223">gpu_tile()</a>.</p>

</div>
</div>
<a class="anchor" id="a74d3a0c590fbedb255cdef354a204da8"></a><!-- doxytag: member="Halide::Func::glsl" ref="a74d3a0c590fbedb255cdef354a204da8" args="(Var x, Var y, Var c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a74d3a0c590fbedb255cdef354a204da8">Halide::Func::glsl</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule for execution using GLSL. </p>
<p>Conceptually, this is similar to parallelization over 'x' and 'y' (since GLSL shaders compute individual output pixels in parallel) and vectorization over 'c' (since GLSL implicitly vectorizes the color channel). </p>

</div>
</div>
<a class="anchor" id="a08d7274c38d341388f0c2c9c9b32f287"></a><!-- doxytag: member="Halide::Func::reorder_storage" ref="a08d7274c38d341388f0c2c9c9b32f287" args="(Var x, Var y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a08d7274c38d341388f0c2c9c9b32f287">Halide::Func::reorder_storage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify how the storage for the function is laid out. </p>
<p>These calls let you specify the nesting order of the dimensions. For example, foo.reorder_storage(y, x) tells <a class="el" href="namespace_halide.html">Halide</a> to use column-major storage for any realizations of foo, without changing how you refer to foo in the code. You may want to do this if you intend to vectorize across y. When representing color images, foo.reorder_storage(c, x, y) specifies packed storage (red, green, and blue values adjacent in memory), and foo.reorder_storage(x, y, c) specifies planar storage (entire red, green, and blue images one after the other in memory).</p>
<p>If you leave out some dimensions, those remain in the same positions in the nesting order while the specified variables are reordered around them. </p>

</div>
</div>
<a class="anchor" id="ad59d05f644880806b781b2ac638fd842"></a><!-- doxytag: member="Halide::Func::reorder_storage" ref="ad59d05f644880806b781b2ac638fd842" args="(Var x, Var y, Var z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a08d7274c38d341388f0c2c9c9b32f287">Halide::Func::reorder_storage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify how the storage for the function is laid out. </p>
<p>These calls let you specify the nesting order of the dimensions. For example, foo.reorder_storage(y, x) tells <a class="el" href="namespace_halide.html">Halide</a> to use column-major storage for any realizations of foo, without changing how you refer to foo in the code. You may want to do this if you intend to vectorize across y. When representing color images, foo.reorder_storage(c, x, y) specifies packed storage (red, green, and blue values adjacent in memory), and foo.reorder_storage(x, y, c) specifies planar storage (entire red, green, and blue images one after the other in memory).</p>
<p>If you leave out some dimensions, those remain in the same positions in the nesting order while the specified variables are reordered around them. </p>

</div>
</div>
<a class="anchor" id="a011438ae4c5e938a32aef32606e98e3a"></a><!-- doxytag: member="Halide::Func::reorder_storage" ref="a011438ae4c5e938a32aef32606e98e3a" args="(Var x, Var y, Var z, Var w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a08d7274c38d341388f0c2c9c9b32f287">Halide::Func::reorder_storage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify how the storage for the function is laid out. </p>
<p>These calls let you specify the nesting order of the dimensions. For example, foo.reorder_storage(y, x) tells <a class="el" href="namespace_halide.html">Halide</a> to use column-major storage for any realizations of foo, without changing how you refer to foo in the code. You may want to do this if you intend to vectorize across y. When representing color images, foo.reorder_storage(c, x, y) specifies packed storage (red, green, and blue values adjacent in memory), and foo.reorder_storage(x, y, c) specifies planar storage (entire red, green, and blue images one after the other in memory).</p>
<p>If you leave out some dimensions, those remain in the same positions in the nesting order while the specified variables are reordered around them. </p>

</div>
</div>
<a class="anchor" id="ab6cf3f2c80e072fdd666172fd5426443"></a><!-- doxytag: member="Halide::Func::reorder_storage" ref="ab6cf3f2c80e072fdd666172fd5426443" args="(Var x, Var y, Var z, Var w, Var t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a08d7274c38d341388f0c2c9c9b32f287">Halide::Func::reorder_storage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify how the storage for the function is laid out. </p>
<p>These calls let you specify the nesting order of the dimensions. For example, foo.reorder_storage(y, x) tells <a class="el" href="namespace_halide.html">Halide</a> to use column-major storage for any realizations of foo, without changing how you refer to foo in the code. You may want to do this if you intend to vectorize across y. When representing color images, foo.reorder_storage(c, x, y) specifies packed storage (red, green, and blue values adjacent in memory), and foo.reorder_storage(x, y, c) specifies planar storage (entire red, green, and blue images one after the other in memory).</p>
<p>If you leave out some dimensions, those remain in the same positions in the nesting order while the specified variables are reordered around them. </p>

</div>
</div>
<a class="anchor" id="a11de589971243d53709563789ef09273"></a><!-- doxytag: member="Halide::Func::compute_at" ref="a11de589971243d53709563789ef09273" args="(Func f, Var var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">Halide::Func::compute_at</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute this function as needed for each unique value of the given var for the given calling function f. </p>
<p>For example, consider the simple pipeline: </p>
<div class="fragment"><pre class="fragment">     <a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a> f, g;
     Var x, y;
     g(x, y) = x*y;
     f(x, y) = g(x, y) + g(x, y+1) + g(x+1, y) + g(x+1, y+1);
</pre></div><p>If we schedule f like so:</p>
<div class="fragment"><pre class="fragment">     g.compute_at(f, x);
</pre></div><p>Then the C code equivalent to this pipeline will look like this</p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">int</span> f[height][width];
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
             <span class="keywordtype">int</span> g[2][2];
             g[0][0] = x*y;
             g[0][1] = (x+1)*y;
             g[1][0] = x*(y+1);
             g[1][1] = (x+1)*(y+1);
             f[y][x] = g[0][0] + g[1][0] + g[0][1] + g[1][1];
         }
     }
</pre></div><p>The allocation and computation of g is within f's loop over x, and enough of g is computed to satisfy all that f will need for that iteration. This has excellent locality - values of g are used as soon as they are computed, but it does redundant work. Each value of g ends up getting computed four times. If we instead schedule f like so:</p>
<div class="fragment"><pre class="fragment">     g.compute_at(f, y);
</pre></div><p>The equivalent C code is:</p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">int</span> f[height][width];
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {
         <span class="keywordtype">int</span> g[2][width+1];
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
             g[0][x] = x*y;
             g[1][x] = x*(y+1);
         }
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
             f[y][x] = g[0][x] + g[1][x] + g[0][x+1] + g[1][x+1];
         }
     }
</pre></div><p>The allocation and computation of g is within f's loop over y, and enough of g is computed to satisfy all that f will need for that iteration. This does less redundant work (each point in g ends up being evaluated twice), but the locality is not quite as good, and we have to allocate more temporary memory to store g. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a6">tutorial/lesson_08_scheduling_2.cpp</a>, and <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a14">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="addf97325c7449720d8d84115353a2c7d"></a><!-- doxytag: member="Halide::Func::compute_at" ref="addf97325c7449720d8d84115353a2c7d" args="(Func f, RVar var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">Halide::Func::compute_at</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_r_var.html">RVar</a>&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Schedule a function to be computed within the iteration over some dimension of an update domain. </p>
<p>Produces equivalent code to the version of compute_at that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>. </p>

</div>
</div>
<a class="anchor" id="a7f4db7e4884fe76399bf2a673567eab5"></a><!-- doxytag: member="Halide::Func::compute_root" ref="a7f4db7e4884fe76399bf2a673567eab5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a7f4db7e4884fe76399bf2a673567eab5">Halide::Func::compute_root</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute all of this function once ahead of time. </p>
<p>Reusing the example in <a class="el" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">Func::compute_at</a> :</p>
<div class="fragment"><pre class="fragment">     <a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a> f, g;
     Var x, y;
     g(x, y) = x*y;
     f(x, y) = g(x, y) + g(x, y+1) + g(x+1, y) + g(x+1, y+1);

     g.compute_root();
</pre></div><p>is equivalent to</p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">int</span> f[height][width];
     <span class="keywordtype">int</span> g[height+1][width+1];
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height+1; y++) {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width+1; x++) {
             g[y][x] = x*y;
         }
     }
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
             f[y][x] = g[y][x] + g[y+1][x] + g[y][x+1] + g[y+1][x+1];
         }
     }
</pre></div><p>g is computed once ahead of time, and enough is computed to satisfy all uses of it. This does no redundant work (each point in g is evaluated once), but has poor locality (values of g are probably not still in cache when they are used by f), and allocates lots of temporary memory to store g. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a5">tutorial/lesson_08_scheduling_2.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5f5bb4a59d9f96187b1fa71fa5f7677b"></a><!-- doxytag: member="Halide::Func::memoize" ref="a5f5bb4a59d9f96187b1fa71fa5f7677b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a5f5bb4a59d9f96187b1fa71fa5f7677b">Halide::Func::memoize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use the halide_memoization_cache_... </p>
<p>interface to store a computed version of this function across invocations of the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>

</div>
</div>
<a class="anchor" id="a33cb0d00bc9585bf3027011ecb1412b7"></a><!-- doxytag: member="Halide::Func::store_at" ref="a33cb0d00bc9585bf3027011ecb1412b7" args="(Func f, Var var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7">Halide::Func::store_at</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_var.html">Var</a>&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate storage for this function within f's loop over var. </p>
<p>Scheduling storage is optional, and can be used to separate the loop level at which storage occurs from the loop level at which computation occurs to trade off between locality and redundant work. This can open the door for two types of optimization.</p>
<p>Consider again the pipeline from <a class="el" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">Func::compute_at</a> : </p>
<div class="fragment"><pre class="fragment">     <a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a> f, g;
     Var x, y;
     g(x, y) = x*y;
     f(x, y) = g(x, y) + g(x+1, y) + g(x, y+1) + g(x+1, y+1);
</pre></div><p>If we schedule it like so:</p>
<div class="fragment"><pre class="fragment">     g.compute_at(f, x).store_at(f, y);
</pre></div><p>Then the computation of g takes place within the loop over x, but the storage takes place within the loop over y:</p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">int</span> f[height][width];
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {
         <span class="keywordtype">int</span> g[2][width+1];
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
             g[0][x] = x*y;
             g[0][x+1] = (x+1)*y;
             g[1][x] = x*(y+1);
             g[1][x+1] = (x+1)*(y+1);
             f[y][x] = g[0][x] + g[1][x] + g[0][x+1] + g[1][x+1];
         }
     }
</pre></div><p>Provided the for loop over x is serial, halide then automatically performs the following sliding window optimization:</p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">int</span> f[height][width];
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {
         <span class="keywordtype">int</span> g[2][width+1];
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
             <span class="keywordflow">if</span> (x == 0) {
                 g[0][x] = x*y;
                 g[1][x] = x*(y+1);
             }
             g[0][x+1] = (x+1)*y;
             g[1][x+1] = (x+1)*(y+1);
             f[y][x] = g[0][x] + g[1][x] + g[0][x+1] + g[1][x+1];
         }
     }
</pre></div><p>Two of the assignments to g only need to be done when x is zero. The rest of the time, those sites have already been filled in by a previous iteration. This version has the locality of compute_at(f, x), but allocates more memory and does much less redundant work.</p>
<p><a class="el" href="namespace_halide.html">Halide</a> then further optimizes this pipeline like so:</p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">int</span> f[height][width];
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {
         <span class="keywordtype">int</span> g[2][2];
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
             <span class="keywordflow">if</span> (x == 0) {
                 g[0][0] = x*y;
                 g[1][0] = x*(y+1);
             }
             g[0][(x+1)%2] = (x+1)*y;
             g[1][(x+1)%2] = (x+1)*(y+1);
             f[y][x] = g[0][x%2] + g[1][x%2] + g[0][(x+1)%2] + g[1][(x+1)%2];
         }
     }
</pre></div><p><a class="el" href="namespace_halide.html">Halide</a> has detected that it's possible to use a circular buffer to represent g, and has reduced all accesses to g modulo 2 in the x dimension. This optimization only triggers if the for loop over x is serial, and if halide can statically determine some power of two large enough to cover the range needed. For powers of two, the modulo operator compiles to more efficient bit-masking. This optimization reduces memory usage, and also improves locality by reusing recently-accessed memory instead of pulling new memory into cache. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a12">tutorial/lesson_08_scheduling_2.cpp</a>, and <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a26">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a61980a1317bdbd1017f284414865deac"></a><!-- doxytag: member="Halide::Func::store_at" ref="a61980a1317bdbd1017f284414865deac" args="(Func f, RVar var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7">Halide::Func::store_at</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_r_var.html">RVar</a>&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equivalent to the version of store_at that takes a <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>, but schedules storage within the loop over a dimension of a reduction domain. </p>

</div>
</div>
<a class="anchor" id="a7048eaf680bc0c78961c0bef48d37f85"></a><!-- doxytag: member="Halide::Func::store_root" ref="a7048eaf680bc0c78961c0bef48d37f85" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a7048eaf680bc0c78961c0bef48d37f85">Halide::Func::store_root</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equivalent to <a class="el" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7">Func::store_at</a>, but schedules storage outside the outermost loop. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a7">tutorial/lesson_08_scheduling_2.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6b824c681a83aba8e318652bade047dc"></a><!-- doxytag: member="Halide::Func::compute_inline" ref="a6b824c681a83aba8e318652bade047dc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a6b824c681a83aba8e318652bade047dc">Halide::Func::compute_inline</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Aggressively inline all uses of this function. </p>
<p>This is the default schedule, so you're unlikely to need to call this. For a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> with an update definition, that means it gets computed as close to the innermost loop as possible.</p>
<p>Consider once more the pipeline from <a class="el" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">Func::compute_at</a> :</p>
<div class="fragment"><pre class="fragment">     <a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a> f, g;
     Var x, y;
     g(x, y) = x*y;
     f(x, y) = g(x, y) + g(x+1, y) + g(x, y+1) + g(x+1, y+1);
</pre></div><p>Leaving g as inline, this compiles to code equivalent to the following C:</p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">int</span> f[height][width];
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++) {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; x++) {
             f[y][x] = x*y + x*(y+1) + (x+1)*y + (x+1)*(y+1);
         }
     }
</pre></div> 
</div>
</div>
<a class="anchor" id="ae2013b9623e9c24a47930ef1874d2b4b"></a><!-- doxytag: member="Halide::Func::update" ref="ae2013b9623e9c24a47930ef1874d2b4b" args="(int idx=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_stage.html">Stage</a> <a class="el" href="class_halide_1_1_func.html#ae2013b9623e9c24a47930ef1874d2b4b">Halide::Func::update</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a handle on an update step for the purposes of scheduling it. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a11">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a375c44be83cecdc181115a0018a7f31b"></a><!-- doxytag: member="Halide::Func::trace_loads" ref="a375c44be83cecdc181115a0018a7f31b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#a375c44be83cecdc181115a0018a7f31b">Halide::Func::trace_loads</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trace all loads from this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by emitting calls to halide_trace. </p>
<p>If the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is inlined, this has no effect. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a4">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad88d11ad4164bce72320f2c064fc87d2"></a><!-- doxytag: member="Halide::Func::trace_stores" ref="ad88d11ad4164bce72320f2c064fc87d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">Halide::Func::trace_stores</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trace all stores to the buffer backing this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by emitting calls to halide_trace. </p>
<p>If the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> is inlined, this call has no effect. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#a2">tutorial/lesson_04_debugging_2.cpp</a>, <a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#a2">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_06_realizing_over_shifted_domains_8cpp-example.html#a2">tutorial/lesson_06_realizing_over_shifted_domains.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a3">tutorial/lesson_08_scheduling_2.cpp</a>, and <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a5">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa3981c97ffef96ab12c229371d766fef"></a><!-- doxytag: member="Halide::Func::trace_realizations" ref="aa3981c97ffef96ab12c229371d766fef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&amp; <a class="el" href="class_halide_1_1_func.html#aa3981c97ffef96ab12c229371d766fef">Halide::Func::trace_realizations</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Trace all realizations of this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> by emitting calls to halide_trace. </p>

</div>
</div>
<a class="anchor" id="af53d44302c15c4335e55a2887e2f780e"></a><!-- doxytag: member="Halide::Func::function" ref="af53d44302c15c4335e55a2887e2f780e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a> <a class="el" href="class_halide_1_1_func.html#af53d44302c15c4335e55a2887e2f780e">Halide::Func::function</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a handle on the internal halide function that this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> represents. </p>
<p>Useful if you want to do introspection on <a class="el" href="namespace_halide.html">Halide</a> functions </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01637">1637</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<a class="anchor" id="a58c0a7588e5e59a1d78cafadeff030b9"></a><!-- doxytag: member="Halide::Func::operator Stage" ref="a58c0a7588e5e59a1d78cafadeff030b9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func::operator <a class="el" href="class_halide_1_1_stage.html">Stage</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>You can cast a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to its pure stage for the purposes of scheduling it. </p>

</div>
</div>
<a class="anchor" id="a7ed1d8e36969e549cb42e2deb062ef37"></a><!-- doxytag: member="Halide::Func::output_buffer" ref="a7ed1d8e36969e549cb42e2deb062ef37" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_output_image_param.html">OutputImageParam</a> <a class="el" href="class_halide_1_1_func.html#a7ed1d8e36969e549cb42e2deb062ef37">Halide::Func::output_buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a handle on the output buffer for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>Only relevant if this is the output <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> in a pipeline. Useful for making static promises about strides, mins, and extents. </p>

</div>
</div>
<a class="anchor" id="a196fa4dd98145740fe20e0a834b7d296"></a><!-- doxytag: member="Halide::Func::output_buffers" ref="a196fa4dd98145740fe20e0a834b7d296" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;<a class="el" href="class_halide_1_1_output_image_param.html">OutputImageParam</a>&gt; <a class="el" href="class_halide_1_1_func.html#a196fa4dd98145740fe20e0a834b7d296">Halide::Func::output_buffers</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a handle on the output buffer for this <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>Only relevant if this is the output <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> in a pipeline. Useful for making static promises about strides, mins, and extents. </p>

</div>
</div>
<a class="anchor" id="af30b03fbc4252d7e3c4baa63feedf8bd"></a><!-- doxytag: member="Halide::Func::operator Expr" ref="af30b03fbc4252d7e3c4baa63feedf8bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func::operator <a class="el" href="struct_halide_1_1_expr.html">Expr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Casting a function to an expression is equivalent to calling the function with zero arguments. </p>
<p>Implicit variables will be injected according to the function's dimensionality (see <a class="el" href="class_halide_1_1_var.html#a2e033e439e668e4f1ced0ce854682117">Var::implicit</a>).</p>
<p>This lets you write things like:</p>
<div class="fragment"><pre class="fragment">     <a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a> f, g;
     Var x;
     g(x) = ...
     f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = g * 2;
</pre></div> 
<p>Definition at line <a class="el" href="_func_8h_source.html#l01667">1667</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02">Halide::_</a>.</p>

</div>
</div>
<a class="anchor" id="ab1d5c8ddfd40f829429c143ff05f9c9d"></a><!-- doxytag: member="Halide::Func::operator ExternFuncArgument" ref="ab1d5c8ddfd40f829429c143ff05f9c9d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Func::operator <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> as an argument to an external stage. </p>

<p>Definition at line <a class="el" href="_func_8h_source.html#l01672">1672</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab824df0221818707668c86baad5e926e"></a><!-- doxytag: member="Halide::Func::infer_arguments" ref="ab824df0221818707668c86baad5e926e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;<a class="el" href="struct_halide_1_1_argument.html">Argument</a>&gt; <a class="el" href="class_halide_1_1_func.html#ab824df0221818707668c86baad5e926e">Halide::Func::infer_arguments</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Infer the arguments to the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, sorted into a canonical order: all buffers (sorted alphabetically by name), followed by all non-buffers (sorted alphabetically by name). </p>
<p>This lets you write things like: </p>
<div class="fragment"><pre class="fragment">     func.compile_to_assembly(<span class="stringliteral">&quot;/dev/stdout&quot;</span>, func.infer_arguments());
</pre></div> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_func_8h_source.html">Func.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a>      </li>
      <li class="navelem"><a class="el" href="class_halide_1_1_func.html">Func</a>      </li>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
