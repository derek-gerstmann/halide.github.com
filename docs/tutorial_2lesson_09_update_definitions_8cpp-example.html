<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Halide: tutorial/lesson_09_update_definitions.cpp</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('tutorial_2lesson_09_update_definitions_8cpp-example.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">tutorial/lesson_09_update_definitions.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><span class="comment">// Halide tutorial lesson 9</span>

<span class="comment">// This lesson demonstrates how to define a Func in multiple passes, including scattering.</span>

<span class="comment">// On linux, you can compile and run it like so:</span>
<span class="comment">// g++ lesson_09*.cpp -I ../include -L ../bin -lHalide -lpthread -ldl -lpng -fopenmp -o lesson_09</span>
<span class="comment">// LD_LIBRARY_PATH=../bin ./lesson_09</span>

<span class="comment">// On os x:</span>
<span class="comment">// g++ lesson_09*.cpp -I ../include -L ../bin -lHalide -lpng -fopenmp -o lesson_09</span>
<span class="comment">// DYLD_LIBRARY_PATH=../bin ./lesson_09</span>

<span class="preprocessor">#include &lt;Halide.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="comment">// We&#39;re going to be using x86 SSE intrinsics later on in this lesson.</span>
<span class="preprocessor">#ifdef __SSE2__</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;emmintrin.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">// We&#39;ll also need a clock to do performance testing at the end. We&#39;ll</span>
<span class="comment">// steal the one used in the performance tests.</span>
<span class="preprocessor">#include &quot;../test/performance/clock.h&quot;</span>

<span class="keyword">using namespace </span>Halide;

<span class="comment">// Support code for loading pngs.</span>
<span class="preprocessor">#include &quot;../apps/support/image_io.h&quot;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
    <span class="comment">// Declare some Vars to use below.</span>
    <a name="_a0"></a><a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);

    <span class="comment">// Load a grayscale image to use as an input.</span>
    <a name="_a1"></a><a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;uint8_t&gt;</a> input = load&lt;uint8_t&gt;(<span class="stringliteral">&quot;../apps/images/gray.png&quot;</span>);

    <span class="comment">// You can define a Func in multiple passes. Let&#39;s see a toy</span>
    <span class="comment">// example first.</span>
    {
        <span class="comment">// The first definition must be one like we have seen already</span>
        <span class="comment">// - a mapping from Vars to an Expr:</span>
        <a name="_a2"></a><a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f;
        f(x, y) = x + y;
        <span class="comment">// We call this first definition the &quot;pure&quot; definition.</span>

        <span class="comment">// But the later definitions can include computed expressions on</span>
        <span class="comment">// both sides. The simplest example is modifying a single point:</span>
        f(3, 7) = 42;

        <span class="comment">// We call these extra definitions &quot;update&quot; definitions, or</span>
        <span class="comment">// &quot;reduction&quot; definitions. A reduction definition is an</span>
        <span class="comment">// update definition that recursively refers back to the</span>
        <span class="comment">// function&#39;s current value at the same site:</span>
        f(x, y) = f(x, y) + 17;

        <span class="comment">// If we confine our update to a single row, we can</span>
        <span class="comment">// recursively refer to values in the same column:</span>
        f(x, 3) = f(x, 0) * f(x, 10);

        <span class="comment">// Similarly, if we confine our update to a single column, we</span>
        <span class="comment">// can recursively refer to other values in the same row.</span>
        f(0, y) = f(0, y) / f(3, y);

        <span class="comment">// The general rule is: Each Var used in an update definition</span>
        <span class="comment">// must appear unadorned in the same position as in the pure</span>
        <span class="comment">// definition in all references to the function on the left-</span>
        <span class="comment">// and right-hand sides. So the following definitions are</span>
        <span class="comment">// legal updates:</span>
        f(x, 17) = x + 8; <span class="comment">// x is used, so all uses of f must have x as the first argument.</span>
        f(0, y) = y * 8;  <span class="comment">// y is used, so all uses of f must have y as the second argument.</span>
        f(x, x + 1) = x + 8;
        f(y/2, y) = f(0, y) * 17;

        <span class="comment">// But these ones would cause an error:</span>
        <span class="comment">// f(x, 0) = f(x + 1, 0) &lt;- First argument to f on the right-hand-side must be &#39;x&#39;, not &#39;x + 1&#39;.</span>
        <span class="comment">// f(y, y + 1) = y + 8   &lt;- Second argument to f on the left-hand-side must be &#39;y&#39;, not &#39;y + 1&#39;.</span>
        <span class="comment">// f(y, x) = y - x;      &lt;- Arguments to f on the left-hand-side are in the wrong places.</span>
        <span class="comment">// f(3, 4) = x + y;      &lt;- Free variables appear on the right-hand-side but not the left-hand-side.</span>

        <span class="comment">// We&#39;ll realize this one just to make sure it compiles. The</span>
        <span class="comment">// second-to-last definition forces us to realize over a</span>
        <span class="comment">// domain that is taller than it is wide.</span>
        f.<a name="a3"></a><a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(100, 101);

        <span class="comment">// For each realization of f, each step runs in its entirety</span>
        <span class="comment">// before the next one begins. Let&#39;s trace the loads and</span>
        <span class="comment">// stores for a simpler example:</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> g(<span class="stringliteral">&quot;g&quot;</span>);
        g(x, y) = x + y;   <span class="comment">// Pure definition</span>
        g(2, 1) = 42;      <span class="comment">// First update definition</span>
        g(x, 0) = g(x, 1); <span class="comment">// Second update definition</span>

        g.<a name="a4"></a><a class="code" href="class_halide_1_1_func.html#a375c44be83cecdc181115a0018a7f31b" title="Trace all loads from this Func by emitting calls to halide_trace.">trace_loads</a>();
        g.<a name="a5"></a><a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        g.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        <span class="comment">// Reading the log, we see that each pass is applied in turn. The equivalent C is:</span>
        <span class="keywordtype">int</span> result[4][4];
        <span class="comment">// Pure definition</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {
                result[y][x] = x + y;
            }
        }
        <span class="comment">// First update definition</span>
        result[1][2] = 42;
        <span class="comment">// Second update definition</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {
            result[0][x] = result[1][x];
        }
    }

    <span class="comment">// Putting update passes inside loops.</span>
    {
        <span class="comment">// Starting with this pure definition:</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f;
        f(x, y) = x + y;

        <span class="comment">// Say we want an update that squares the first fifty rows. We</span>
        <span class="comment">// could do this by adding 50 update definitions:</span>

        <span class="comment">// f(x, 0) = f(x, 0) * f(x, 0);</span>
        <span class="comment">// f(x, 1) = f(x, 1) * f(x, 1);</span>
        <span class="comment">// f(x, 2) = f(x, 2) * f(x, 2);</span>
        <span class="comment">// ...</span>
        <span class="comment">// f(x, 49) = f(x, 49) * f(x, 49);</span>

        <span class="comment">// Or equivalently using a compile-time loop in our C++:</span>
        <span class="comment">// for (int i = 0; i &lt; 50; i++) {</span>
        <span class="comment">//   f(x, i) = f(x, i) * f(x, i);</span>
        <span class="comment">// }</span>

        <span class="comment">// But it&#39;s more manageable and more flexible to put the loop</span>
        <span class="comment">// in the generated code. We do this by defining a &quot;reduction</span>
        <span class="comment">// domain&quot; and using it inside an update definition:</span>
        <a name="_a6"></a><a class="code" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> r(0, 50);
        f(x, r) = f(x, r) * f(x, r);
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> halide_result = f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(100, 100);

        <span class="comment">// The equivalent C is:</span>
        <span class="keywordtype">int</span> c_result[100][100];
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 100; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 100; x++) {
                c_result[y][x] = x + y;
            }
        }
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 100; x++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; 50; r++) {
                <span class="comment">// The loop over the reduction domain occurs inside of</span>
                <span class="comment">// the loop over any pure variables used in the update</span>
                <span class="comment">// step:</span>
                c_result[r][x] = c_result[r][x] * c_result[r][x];
            }
        }

        <span class="comment">// Check the results match:</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 100; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 100; x++) {
                <span class="keywordflow">if</span> (halide_result(x, y) != c_result[y][x]) {
                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,
                           x, y, halide_result(x, y), c_result[y][x]);
                    <span class="keywordflow">return</span> -1;
                }
            }
        }
    }

    <span class="comment">// Now we&#39;ll examine a real-world use for an update definition:</span>
    <span class="comment">// computing a histogram.</span>
    {

        <span class="comment">// Some operations on images can&#39;t be cleanly expressed as a pure</span>
        <span class="comment">// function from the output coordinates to the value stored</span>
        <span class="comment">// there. The classic example is computing a histogram. The</span>
        <span class="comment">// natural way to do it is to iterate over the input image,</span>
        <span class="comment">// updating histogram buckets. Here&#39;s how you do that in Halide:</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> histogram(<span class="stringliteral">&quot;histogram&quot;</span>);

        <span class="comment">// Histogram buckets start as zero.</span>
        histogram(x) = 0;

        <span class="comment">// Define a multi-dimensional reduction domain over the input image:</span>
        <a class="code" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> r(0, input.<a name="a7"></a><a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>(), 0, input.<a name="a8"></a><a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>());

        <span class="comment">// For every point in the reduction domain, increment the</span>
        <span class="comment">// histogram bucket corresponding to the intensity of the</span>
        <span class="comment">// input image at that point.</span>
        histogram(input(r.x, r.y)) += 1;

        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> halide_result = histogram.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(256);

        <span class="comment">// The equivalent C is:</span>
        <span class="keywordtype">int</span> c_result[256];
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 256; x++) {
            c_result[x] = 0;
        }
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r_y = 0; r_y &lt; input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>(); r_y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r_x = 0; r_x &lt; input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>(); r_x++) {
                c_result[input(r_x, r_y)] += 1;
            }
        }

        <span class="comment">// Check the answers agree:</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 256; x++) {
            <span class="keywordflow">if</span> (c_result[x] != halide_result(x)) {
                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,
                       x, halide_result(x), c_result[x]);
                <span class="keywordflow">return</span> -1;
            }
        }
    }

    <span class="comment">// Scheduling update steps</span>
    {
        <span class="comment">// The pure variables in an update step and can be</span>
        <span class="comment">// parallelized, vectorized, split, etc as usual. The</span>
        <span class="comment">// variables that are part of the reduction domain (e.g. r.x</span>
        <span class="comment">// in our histogram example) can&#39;t be modified, as this risks</span>
        <span class="comment">// changing the meaning of the update step (because the</span>
        <span class="comment">// function may recursively refer back to itself).</span>

        <span class="comment">// Consider the definition:</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f;
        f(x, y) = x*y;
        <span class="comment">// Set the second row to equal the first row.</span>
        f(x, 1) = f(x, 0);
        <span class="comment">// Set the second column to equal the first column plus 2.</span>
        f(1, y) = f(0, y) + 2;

        <span class="comment">// The pure variables in each stage can be scheduled</span>
        <span class="comment">// independently. To control the pure definition, we schedule</span>
        <span class="comment">// as we have done in the past. The following code vectorizes</span>
        <span class="comment">// and parallelizes the pure definition only.</span>
        f.<a name="a9"></a><a class="code" href="class_halide_1_1_func.html#a1cbde565654302d9c0ab9383a0e42708" title="Mark a dimension to be computed all-at-once as a single vector.">vectorize</a>(x, 4).<a name="a10"></a><a class="code" href="class_halide_1_1_func.html#a93ee31a00e40c4531af6f58187ee19b9" title="Mark a dimension to be traversed in parallel.">parallel</a>(y);

        <span class="comment">// We use Func::update(int) to get a handle to an update step</span>
        <span class="comment">// for the purposes of scheduling. The following line</span>
        <span class="comment">// vectorizes the first update step across x. We can&#39;t do</span>
        <span class="comment">// anything with y for this update step, because it doesn&#39;t</span>
        <span class="comment">// use y.</span>
        f.<a name="a11"></a><a class="code" href="class_halide_1_1_func.html#a5fd179a3631bfc16fc2e0cb3bb29ae0b" title="Get a handle on an update step of a reduction for the purposes of scheduling it.">update</a>(0).<a name="a12"></a><a class="code" href="class_halide_1_1_schedule_handle.html#a965ef3a905df60c3f59ca3743cbf668d" title="Scheduling calls that control how the domain of this update is traversed.">vectorize</a>(x, 4);

        <span class="comment">// No we parallelize the second update step in chunks of size</span>
        <span class="comment">// 4.</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> yo, yi;
        f.<a class="code" href="class_halide_1_1_func.html#a5fd179a3631bfc16fc2e0cb3bb29ae0b" title="Get a handle on an update step of a reduction for the purposes of scheduling it.">update</a>(1).<a name="a13"></a><a class="code" href="class_halide_1_1_schedule_handle.html#a82dcba5e287a284bfdb2eba997659daa" title="Scheduling calls that control how the domain of this update is traversed.">split</a>(y, yo, yi, 4).<a name="a14"></a><a class="code" href="class_halide_1_1_schedule_handle.html#a341ae03504ed0261b1ffba9935844c2d" title="Scheduling calls that control how the domain of this update is traversed.">parallel</a>(yo);

        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> halide_result = f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(16, 16);

        <span class="comment">// Here&#39;s the equivalent (serial) C:</span>
        <span class="keywordtype">int</span> c_result[16][16];

        <span class="comment">// Pure step. Vectorized in x and parallelized in y.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 16; y++) { <span class="comment">// Should be a parallel for loop</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; 4; x_vec++) {
                <span class="keywordtype">int</span> x[] = {x_vec*4, x_vec*4+1, x_vec*4+2, x_vec*4+3};
                c_result[y][x[0]] = x[0] * y;
                c_result[y][x[1]] = x[1] * y;
                c_result[y][x[2]] = x[2] * y;
                c_result[y][x[3]] = x[3] * y;
            }
        }

        <span class="comment">// First update. Vectorized in x.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; 4; x_vec++) {
            <span class="keywordtype">int</span> x[] = {x_vec*4, x_vec*4+1, x_vec*4+2, x_vec*4+3};
            c_result[1][x[0]] = c_result[0][x[0]];
            c_result[1][x[1]] = c_result[0][x[1]];
            c_result[1][x[2]] = c_result[0][x[2]];
            c_result[1][x[3]] = c_result[0][x[3]];
        }

        <span class="comment">// Second update. Parallelized in chunks of size 4 in y.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yo = 0; yo &lt; 4; yo++) { <span class="comment">// Should be a parallel for loop</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yi = 0; yi &lt; 4; yi++) {
                <span class="keywordtype">int</span> y = yo*4 + yi;
                c_result[y][1] = c_result[y][0] + 2;
            }
        }

        <span class="comment">// Check the C and Halide results match:</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 16; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 16; x++) {
                <span class="keywordflow">if</span> (halide_result(x, y) != c_result[y][x]) {
                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,
                           x, y, halide_result(x, y), c_result[y][x]);
                    <span class="keywordflow">return</span> -1;
                }
            }
        }
    }

    <span class="comment">// That covers how to schedule the variables within a Func that</span>
    <span class="comment">// uses update steps, but what about producer-consumer</span>
    <span class="comment">// relationships that involve compute_at and store_at? Let&#39;s</span>
    <span class="comment">// examine a reduction as a producer, in a producer-consumer pair.</span>
    {
        <span class="comment">// Because an update does multiple passes over a stored array,</span>
        <span class="comment">// it&#39;s not meaningful to inline them. So the default schedule</span>
        <span class="comment">// for them does the closest thing possible. It computes them</span>
        <span class="comment">// in the innermost loop of their consumer. Consider this</span>
        <span class="comment">// trivial example:</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer, consumer;
        producer(x) = x*17;
        producer(x) += 1;
        consumer(x) = 2 * producer(x);
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> halide_result = consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(10);

        <span class="comment">// The equivalent C is:</span>
        <span class="keywordtype">int</span> c_result[10];
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++)  {
            <span class="keywordtype">int</span> producer_storage[1];
            <span class="comment">// Pure step for producer</span>
            producer_storage[0] = x * 17;
            <span class="comment">// Update step for producer</span>
            producer_storage[0] = producer_storage[0] + 1;
            <span class="comment">// Pure step for consumer</span>
            c_result[x] = 2 * producer_storage[0];
        }

        <span class="comment">// Check the results match</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
            <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {
                printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,
                       x, halide_result(x), c_result[x]);
                <span class="keywordflow">return</span> -1;
            }
        }

        <span class="comment">// For all other compute_at/store_at options, the reduction</span>
        <span class="comment">// gets placed where you would expect, somewhere in the loop</span>
        <span class="comment">// nest of the consumer.</span>
    }

    <span class="comment">// Now let&#39;s consider a reduction as a consumer in a</span>
    <span class="comment">// producer-consumer pair. This is a little more involved.</span>
    {
        {
            <span class="comment">// Case 1: The consumer references the producer in the pure step only.</span>
            <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer, consumer;
            <span class="comment">// The producer is pure.</span>
            producer(x) = x*17;
            consumer(x) = 2 * producer(x);
            consumer(x) += 1;

            <span class="comment">// The valid schedules for the producer in this case are</span>
            <span class="comment">// the default schedule - inlined, and also:</span>
            <span class="comment">//</span>
            <span class="comment">// 1) producer.compute_at(x), which places the computation of</span>
            <span class="comment">// the producer inside the loop over x in the pure step of the</span>
            <span class="comment">// consumer.</span>
            <span class="comment">//</span>
            <span class="comment">// 2) producer.compute_root(), which computes all of the</span>
            <span class="comment">// producer ahead of time.</span>
            <span class="comment">//</span>
            <span class="comment">// 3) producer.store_root().compute_at(x), which allocates</span>
            <span class="comment">// space for the consumer outside the loop over x, but fills</span>
            <span class="comment">// it in as needed inside the loop.</span>
            <span class="comment">//</span>
            <span class="comment">// Let&#39;s use option 1.</span>

            producer.<a name="a15"></a><a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(consumer, x);

            <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> halide_result = consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(10);

            <span class="comment">// The equivalent C is:</span>
            <span class="keywordtype">int</span> c_result[10];
            <span class="comment">// Pure step for the consumer</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++)  {
                <span class="comment">// Pure step for producer</span>
                <span class="keywordtype">int</span> producer_storage[1];
                producer_storage[0] = x * 17;
                c_result[x] = 2 * producer_storage[0];
            }
            <span class="comment">// Update step for the consumer</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
                c_result[x] += 1;
            }

            <span class="comment">// All of the pure step is evaluated before any of the</span>
            <span class="comment">// update step, so there are two separate loops over x.</span>

            <span class="comment">// Check the results match</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
                <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {
                    printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,
                           x, halide_result(x), c_result[x]);
                    <span class="keywordflow">return</span> -1;
                }
            }
        }

        {
            <span class="comment">// Case 2: The consumer references the producer in the update step only</span>
            <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer, consumer;
            producer(x) = x * 17;
            consumer(x) = x;
            consumer(x) += producer(x);

            <span class="comment">// Again we compute the producer per x coordinate of the</span>
            <span class="comment">// consumer. This places producer code inside the update</span>
            <span class="comment">// step of the producer, because that&#39;s the only step that</span>
            <span class="comment">// uses the producer.</span>
            producer.<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(consumer, x);

            <span class="comment">// Note however, that we didn&#39;t say:</span>
            <span class="comment">//</span>
            <span class="comment">// producer.compute_at(consumer.update(0), x).</span>
            <span class="comment">//</span>
            <span class="comment">// Scheduling is done with respect to Vars of a Func, and</span>
            <span class="comment">// the Vars of a Func are shared across the pure and</span>
            <span class="comment">// update steps.</span>

            <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> halide_result = consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(10);

            <span class="comment">// The equivalent C is:</span>
            <span class="keywordtype">int</span> c_result[10];
            <span class="comment">// Pure step for the consumer</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++)  {
                c_result[x] = x;
            }
            <span class="comment">// Update step for the consumer</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
                <span class="comment">// Pure step for producer</span>
                <span class="keywordtype">int</span> producer_storage[1];
                producer_storage[0] = x * 17;
                c_result[x] += producer_storage[0];
            }


            <span class="comment">// Check the results match</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
                <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {
                    printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,
                           x, halide_result(x), c_result[x]);
                    <span class="keywordflow">return</span> -1;
                }
            }
        }

        {
            <span class="comment">// Case 3: The consumer references the producer in</span>
            <span class="comment">// multiple steps that share common variables</span>
            <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer, consumer;
            producer(x) = x * 17;
            consumer(x) = producer(x) * x;
            consumer(x) += producer(x);

            <span class="comment">// Again we compute the producer per x coordinate of the</span>
            <span class="comment">// consumer. This places producer code inside both the</span>
            <span class="comment">// pure and the update step of the producer. So there ends</span>
            <span class="comment">// up being two separate realizations of the producer, and</span>
            <span class="comment">// redundant work occurs.</span>
            producer.<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(consumer, x);

            <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> halide_result = consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(10);

            <span class="comment">// The equivalent C is:</span>
            <span class="keywordtype">int</span> c_result[10];
            <span class="comment">// Pure step for the consumer</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++)  {
                <span class="comment">// Pure step for producer</span>
                <span class="keywordtype">int</span> producer_storage[1];
                producer_storage[0] = x * 17;
                c_result[x] = producer_storage[0] * x;
            }
            <span class="comment">// Update step for the consumer</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
                <span class="comment">// Another copy of the pure step for producer</span>
                <span class="keywordtype">int</span> producer_storage[1];
                producer_storage[0] = x * 17;
                c_result[x] += producer_storage[0];
            }

            <span class="comment">// Check the results match</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
                <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {
                    printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,
                           x, halide_result(x), c_result[x]);
                    <span class="keywordflow">return</span> -1;
                }
            }
        }

        {
            <span class="comment">// Case 4: The consumer references the producer in</span>
            <span class="comment">// multiple steps that do not share common variables</span>
            <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer, consumer;
            producer(x, y) = x*y;
            consumer(x, y) = x + y;
            consumer(x, 0) = producer(x, x-1);
            consumer(0, y) = producer(y, y-1);

            <span class="comment">// In this case neither producer.compute_at(consumer, x)</span>
            <span class="comment">// nor producer.compute_at(consumer, y) will work, because</span>
            <span class="comment">// either one fails to cover one of the uses of the</span>
            <span class="comment">// producer. So we&#39;d have to inline producer, or use</span>
            <span class="comment">// producer.compute_root().</span>

            <span class="comment">// Let&#39;s say we really really want producer to be</span>
            <span class="comment">// compute_at the inner loops of both consumer update</span>
            <span class="comment">// steps. Halide doesn&#39;t allow multiple different</span>
            <span class="comment">// schedules for a single Func, but we can work around it</span>
            <span class="comment">// by making two wrappers around producer, and scheduling</span>
            <span class="comment">// those instead:</span>

            <span class="comment">// Attempt 2:</span>
            <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer_wrapper_1, producer_wrapper_2, consumer_2;
            producer_wrapper_1(x, y) = producer(x, y);
            producer_wrapper_2(x, y) = producer(x, y);

            consumer_2(x, y) = x + y;
            consumer_2(x, 0) += producer_wrapper_1(x, x-1);
            consumer_2(0, y) += producer_wrapper_2(y, y-1);

            <span class="comment">// The wrapper functions give us two separate handles on</span>
            <span class="comment">// the producer, so we can schedule them differently.</span>
            producer_wrapper_1.<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(consumer_2, x);
            producer_wrapper_2.<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(consumer_2, y);

            <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> halide_result = consumer_2.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(10, 10);

            <span class="comment">// The equivalent C is:</span>
            <span class="keywordtype">int</span> c_result[10][10];
            <span class="comment">// Pure step for the consumer</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 10; y++) {
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
                    c_result[y][x] = x + y;
                }
            }
            <span class="comment">// First update step for consumer</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
                <span class="keywordtype">int</span> producer_wrapper_1_storage[1];
                producer_wrapper_1_storage[0] = x * (x-1);
                c_result[0][x] += producer_wrapper_1_storage[0];
            }
            <span class="comment">// Second update step for consumer</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 10; y++) {
                <span class="keywordtype">int</span> producer_wrapper_2_storage[1];
                producer_wrapper_2_storage[0] = y * (y-1);
                c_result[y][0] += producer_wrapper_2_storage[0];
            }

            <span class="comment">// Check the results match</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 10; y++) {
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
                    <span class="keywordflow">if</span> (halide_result(x, y) != c_result[y][x]) {
                        printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,
                               x, y, halide_result(x, y), c_result[y][x]);
                        <span class="keywordflow">return</span> -1;
                    }
                }
            }
        }

        {
            <span class="comment">// Case 5: Scheduling a producer under a reduction domain</span>
            <span class="comment">// variable of the consumer.</span>

            <span class="comment">// We are not just restricted to scheduling producers at</span>
            <span class="comment">// the loops over the pure variables of the consumer. If a</span>
            <span class="comment">// producer is only used within a loop over a reduction</span>
            <span class="comment">// domain (RDom) variable, we can also schedule the</span>
            <span class="comment">// producer there.</span>

            <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer, consumer;

            <a class="code" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> r(0, 5);
            producer(x) = x * 17;
            consumer(x) = x + 10;
            consumer(x) += r + producer(x + r);

            producer.compute_at(consumer, r);

            <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> halide_result = consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(10);

            <span class="comment">// The equivalent C is:</span>
            <span class="keywordtype">int</span> c_result[10];
            <span class="comment">// Pure step for the consumer.</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++)  {
                c_result[x] = x + 10;
            }
            <span class="comment">// Update step for the consumer.</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; 5; r++) { <span class="comment">// The loop over the reduction domain is always the inner loop.</span>
                    <span class="comment">// We&#39;ve schedule the storage and computation of</span>
                    <span class="comment">// the producer here. We just need a single value.</span>
                    <span class="keywordtype">int</span> producer_storage[1];
                    <span class="comment">// Pure step of the producer.</span>
                    producer_storage[0] = (x + r) * 17;

                    <span class="comment">// Now use it in the update step of the consumer.</span>
                    c_result[x] += r + producer_storage[0];
                }
            }

            <span class="comment">// Check the results match</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
                <span class="keywordflow">if</span> (halide_result(x) != c_result[x]) {
                    printf(<span class="stringliteral">&quot;halide_result(%d) = %d instead of %d\n&quot;</span>,
                           x, halide_result(x), c_result[x]);
                    <span class="keywordflow">return</span> -1;
                }
            }


        }
    }


    <span class="comment">// A real-world example of a reduction inside a producer-consumer chain.</span>
    {
        <span class="comment">// The default schedule for a reduction is a good one for</span>
        <span class="comment">// convolution-like operations. For example, the following</span>
        <span class="comment">// computes a 5x5 box-blur of our grayscale test image with a</span>
        <span class="comment">// clamp-to-edge boundary condition:</span>

        <span class="comment">// First add the boundary condition.</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> clamped;
        <a name="_a16"></a><a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> x_clamped = <a name="a17"></a><a class="code" href="namespace_halide.html#a41fc11b69e1ae900cebae51c319a1caa" title="Clamps an expression to lie within the given bounds.">clamp</a>(x, 0, input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>()-1);
        <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> y_clamped = <a class="code" href="namespace_halide.html#a41fc11b69e1ae900cebae51c319a1caa" title="Clamps an expression to lie within the given bounds.">clamp</a>(y, 0, input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>()-1);
        clamped(x, y) = input(x_clamped, y_clamped);

        <span class="comment">// Define a 5x5 box that starts at (-2, -2)</span>
        <a class="code" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> r(-2, 5, -2, 5);

        <span class="comment">// Compute the 5x5 sum around each pixel.</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> local_sum;
        local_sum(x, y) = 0; <span class="comment">// Compute the sum as a 32-bit integer</span>
        local_sum(x, y) += clamped(x + r.<a name="a18"></a><a class="code" href="class_halide_1_1_r_dom.html#a9c41992ecccbe2eea2430a65a1dc7614" title="Direct access to the four dimensions of the reduction domain.">x</a>, y + r.<a name="a19"></a><a class="code" href="class_halide_1_1_r_dom.html#ab9ec82ccc25c587c18ea174a9c7a46ff" title="Direct access to the four dimensions of the reduction domain.">y</a>);

        <span class="comment">// Divide the sum by 25 to make it an average</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> blurry;
        blurry(x, y) = cast&lt;uint8_t&gt;(local_sum(x, y) / 25);

        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;uint8_t&gt;</a> halide_result = blurry.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>(), input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>());

        <span class="comment">// The default schedule will inline &#39;clamped&#39; into the update</span>
        <span class="comment">// step of &#39;local_sum&#39;, because clamped only has a pure</span>
        <span class="comment">// definition, and so its default schedule is fully-inlined.</span>
        <span class="comment">// We will then compute local_sum per x coordinate of blurry,</span>
        <span class="comment">// because the default schedule for reductions is</span>
        <span class="comment">// compute-innermost. Here&#39;s the equivalent C:</span>

        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;uint8_t&gt;</a> c_result(input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>(), input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>());
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>(); y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>(); x++) {
                <span class="keywordtype">int</span> local_sum[1];
                <span class="comment">// Pure step of local_sum</span>
                local_sum[0] = 0;
                <span class="comment">// Update step of local_sum</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r_y = -2; r_y &lt;= 2; r_y++) {
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r_x = -2; r_x &lt;= 2; r_x++) {
                        <span class="comment">// The clamping has been inlined into the update step.</span>
                        <span class="keywordtype">int</span> clamped_x = <a name="a20"></a><a class="code" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940" title="Returns an expression representing the lesser of the two arguments, after doing any necessary type co...">std::min</a>(<a name="a21"></a><a class="code" href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec" title="Returns an expression representing the greater of the two arguments, after doing any necessary type c...">std::max</a>(x + r_x, 0), input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>()-1);
                        <span class="keywordtype">int</span> clamped_y = <a class="code" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940" title="Returns an expression representing the lesser of the two arguments, after doing any necessary type co...">std::min</a>(<a class="code" href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec" title="Returns an expression representing the greater of the two arguments, after doing any necessary type c...">std::max</a>(y + r_y, 0), input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>()-1);
                        local_sum[0] += input(clamped_x, clamped_y);
                    }
                }
                <span class="comment">// Pure step of blurry</span>
                c_result(x, y) = (<a name="a22"></a><a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a>)(local_sum[0] / 25);
            }
        }

        <span class="comment">// Check the results match</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>(); y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>(); x++) {
                <span class="keywordflow">if</span> (halide_result(x, y) != c_result(x, y)) {
                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,
                           x, y, halide_result(x, y), c_result(x, y));
                    <span class="keywordflow">return</span> -1;
                }
            }
        }
    }

    <span class="comment">// Reduction helpers.</span>
    {
        <span class="comment">// There are several reduction helper functions provided in</span>
        <span class="comment">// Halide.h, which compute small reductions and schedule them</span>
        <span class="comment">// innermost into their consumer. The most useful one is</span>
        <span class="comment">// &quot;sum&quot;.</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f1;
        <a class="code" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> r(0, 100);
        f1(x) = <a name="a23"></a><a class="code" href="namespace_halide.html#a1cdc5fefb67660314f83e00869bb2d07" title="An inline reduction.">sum</a>(r + x) * 7;

        <span class="comment">// Sum creates a small anonymous Func to do the reduction. It&#39;s equivalent to:</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f2;
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> anon;
        anon(x) = 0;
        anon(x) += r + x;
        f2(x) = anon(x) * 7;

        <span class="comment">// So even though f1 references a reduction domain, it is a</span>
        <span class="comment">// pure function. The reduction domain has been swallowed to</span>
        <span class="comment">// define the inner anonymous reduction.</span>

        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> halide_result_1 = f1.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(10);
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> halide_result_2 = f2.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(10);

        <span class="comment">// The equivalent C is:</span>
        <span class="keywordtype">int</span> c_result[10];
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
            <span class="keywordtype">int</span> anon[1];
            anon[0] = 0;
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; 100; r++) {
                anon[0] += r + x;
            }
            c_result[x] = anon[0] * 7;
        }

        <span class="comment">// Check they all match.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 10; x++) {
            <span class="keywordflow">if</span> (halide_result_1(x) != c_result[x]) {
                printf(<span class="stringliteral">&quot;halide_result_1(%d) = %d instead of %d\n&quot;</span>,
                       x, halide_result_1(x), c_result[x]);
                <span class="keywordflow">return</span> -1;
            }
            <span class="keywordflow">if</span> (halide_result_2(x) != c_result[x]) {
                printf(<span class="stringliteral">&quot;halide_result_2(%d) = %d instead of %d\n&quot;</span>,
                       x, halide_result_2(x), c_result[x]);
                <span class="keywordflow">return</span> -1;
            }
        }
    }


    <span class="comment">// A complex example that uses reduction helpers.</span>
    {
        <span class="comment">// Other reduction helpers include &quot;product&quot;, &quot;minimum&quot;,</span>
        <span class="comment">// &quot;maximum&quot;, &quot;argmin&quot;, and &quot;argmax&quot;. Using argmin and argmax</span>
        <span class="comment">// requires understanding tuples, which come in a later</span>
        <span class="comment">// lesson. Let&#39;s use minimum and maximum to compute the local</span>
        <span class="comment">// spread of our grayscale image.</span>

        <span class="comment">// First, add a boundary condition to the input.</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> clamped;
        <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> x_clamped = <a class="code" href="namespace_halide.html#a41fc11b69e1ae900cebae51c319a1caa" title="Clamps an expression to lie within the given bounds.">clamp</a>(x, 0, input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>()-1);
        <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> y_clamped = <a class="code" href="namespace_halide.html#a41fc11b69e1ae900cebae51c319a1caa" title="Clamps an expression to lie within the given bounds.">clamp</a>(y, 0, input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>()-1);
        clamped(x, y) = input(x_clamped, y_clamped);

        <a class="code" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> box(-2, 5, -2, 5);
        <span class="comment">// Compute the local maximum minus the local minimum:</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> spread;
        spread(x, y) = (<a name="a24"></a><a class="code" href="namespace_halide.html#aea53a4bc91b3d69eb68d3e712d81c39c" title="An inline reduction.">maximum</a>(clamped(x + box.<a class="code" href="class_halide_1_1_r_dom.html#a9c41992ecccbe2eea2430a65a1dc7614" title="Direct access to the four dimensions of the reduction domain.">x</a>, y + box.<a class="code" href="class_halide_1_1_r_dom.html#ab9ec82ccc25c587c18ea174a9c7a46ff" title="Direct access to the four dimensions of the reduction domain.">y</a>)) -
                        <a name="a25"></a><a class="code" href="namespace_halide.html#a9d7999c3871839488df9d591b3f55adf" title="An inline reduction.">minimum</a>(clamped(x + box.<a class="code" href="class_halide_1_1_r_dom.html#a9c41992ecccbe2eea2430a65a1dc7614" title="Direct access to the four dimensions of the reduction domain.">x</a>, y + box.<a class="code" href="class_halide_1_1_r_dom.html#ab9ec82ccc25c587c18ea174a9c7a46ff" title="Direct access to the four dimensions of the reduction domain.">y</a>)));

        <span class="comment">// Compute the result in strips of 32 scanlines</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> yo, yi;
        spread.<a name="a26"></a><a class="code" href="class_halide_1_1_func.html#abefe6262e23d34d161c7cc0b85e07187" title="Split a dimension into inner and outer subdimensions with the given names, where the inner dimension ...">split</a>(y, yo, yi, 32).<a class="code" href="class_halide_1_1_func.html#a93ee31a00e40c4531af6f58187ee19b9" title="Mark a dimension to be traversed in parallel.">parallel</a>(yo);

        <span class="comment">// Vectorize across x within the strips. This implicitly</span>
        <span class="comment">// vectorizes stuff that is computed within the loop over x in</span>
        <span class="comment">// spread, which includes our minimum and maximum helpers, so</span>
        <span class="comment">// they get vectorized too.</span>
        spread.<a class="code" href="class_halide_1_1_func.html#a1cbde565654302d9c0ab9383a0e42708" title="Mark a dimension to be computed all-at-once as a single vector.">vectorize</a>(x, 16);

        <span class="comment">// We&#39;ll apply the boundary condition by padding each scanline</span>
        <span class="comment">// as we need it in a circular buffer (see lesson 08).</span>
        clamped.<a name="a27"></a><a class="code" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7" title="Allocate storage for this function within f&#39;s loop over var.">store_at</a>(spread, yo).<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(spread, yi);

        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;uint8_t&gt;</a> halide_result = spread.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>(), input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>());

        <span class="comment">// The C equivalent is almost too horrible to contemplate (and</span>
        <span class="comment">// took me a long time to debug). This time I want to time</span>
        <span class="comment">// both the Halide version and the C version, so I&#39;ll use sse</span>
        <span class="comment">// intrinsics for the vectorization, and openmp to do the</span>
        <span class="comment">// parallel for loop (you&#39;ll need to compile with -fopenmp or</span>
        <span class="comment">// similar to get correct timing).</span>
<span class="preprocessor">        #ifdef __SSE2__</span>
<span class="preprocessor"></span>
        <span class="comment">// Don&#39;t include the time required to allocate the output buffer.</span>
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;uint8_t&gt;</a> c_result(input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>(), input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>());

        <span class="keywordtype">double</span> t1 = currentTime();

        <span class="comment">// Run this one hundred times so we can average the timing results.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iters = 0; iters &lt; 100; iters++) {

<span class="preprocessor">            #pragma omp parallel for</span>
<span class="preprocessor"></span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yo = 0; yo &lt; (input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>() + 31)/32; yo++) {
                <span class="keywordtype">int</span> y_base = <a class="code" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940" title="Returns an expression representing the lesser of the two arguments, after doing any necessary type co...">std::min</a>(yo * 32, input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>() - 32);

                <span class="comment">// Compute clamped in a circular buffer of size 8</span>
                <span class="comment">// (smallest power of two greater than 5). Each thread</span>
                <span class="comment">// needs its own allocation, so it must occur here.</span>

                <span class="keywordtype">int</span> clamped_width = input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>() + 4;
                <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *clamped_storage = (<a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *)malloc(clamped_width * 8);

                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yi = 0; yi &lt; 32; yi++) {
                    <span class="keywordtype">int</span> y = y_base + yi;

                    <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *output_row = &amp;c_result(0, y);

                    <span class="comment">// Compute clamped for this scanline, skipping rows</span>
                    <span class="comment">// already computed within this slice.</span>
                    <span class="keywordtype">int</span> min_y_clamped = (yi == 0) ? (y - 2) : (y + 2);
                    <span class="keywordtype">int</span> max_y_clamped = (y + 2);
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> cy = min_y_clamped; cy &lt;= max_y_clamped; cy++) {
                        <span class="comment">// Figure out which row of the circular buffer</span>
                        <span class="comment">// we&#39;re filling in using bitmasking:</span>
                        <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *clamped_row = clamped_storage + (cy &amp; 7) * clamped_width;

                        <span class="comment">// Figure out which row of the input we&#39;re reading</span>
                        <span class="comment">// from by clamping the y coordinate:</span>
                        <span class="keywordtype">int</span> clamped_y = <a class="code" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940" title="Returns an expression representing the lesser of the two arguments, after doing any necessary type co...">std::min</a>(<a class="code" href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec" title="Returns an expression representing the greater of the two arguments, after doing any necessary type c...">std::max</a>(cy, 0), input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>()-1);
                        <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *input_row = &amp;input(0, clamped_y);

                        <span class="comment">// Fill it in with the padding.</span>
                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = -2; x &lt; input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>() + 2; x++) {
                            <span class="keywordtype">int</span> clamped_x = <a class="code" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940" title="Returns an expression representing the lesser of the two arguments, after doing any necessary type co...">std::min</a>(<a class="code" href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec" title="Returns an expression representing the greater of the two arguments, after doing any necessary type c...">std::max</a>(x, 0), input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>()-1);
                            *clamped_row++ = input_row[clamped_x];
                        }
                    }

                    <span class="comment">// Now iterate over vectors of x for the pure step of the output.</span>
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; (input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>() + 15)/16; x_vec++) {
                        <span class="keywordtype">int</span> x_base = <a class="code" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940" title="Returns an expression representing the lesser of the two arguments, after doing any necessary type co...">std::min</a>(x_vec * 16, input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>() - 16);

                        <span class="comment">// Allocate storage for the minimum and maximum</span>
                        <span class="comment">// helpers. One vector is enough.</span>
                        __m128i minimum_storage, maximum_storage;

                        <span class="comment">// The pure step for the maximum is a vector of zeros</span>
                        maximum_storage = (__m128i)_mm_setzero_ps();

                        <span class="comment">// The update step for maximum</span>
                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> max_y = y - 2; max_y &lt;= y + 2; max_y++) {
                            <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *clamped_row = clamped_storage + (max_y &amp; 7) * clamped_width;
                            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> max_x = x_base - 2; max_x &lt;= x_base + 2; max_x++) {
                                __m128i v = _mm_loadu_si128((__m128i <span class="keyword">const</span> *)(clamped_row + max_x + 2));
                                maximum_storage = _mm_max_epu8(maximum_storage, v);
                            }
                        }

                        <span class="comment">// The pure step for the minimum is a vector of</span>
                        <span class="comment">// ones. Create it by comparing something to</span>
                        <span class="comment">// itself.</span>
                        minimum_storage = (__m128i)_mm_cmpeq_ps(_mm_setzero_ps(),
                                                                _mm_setzero_ps());

                        <span class="comment">// The update step for minimum.</span>
                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> min_y = y - 2; min_y &lt;= y + 2; min_y++) {
                            <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *clamped_row = clamped_storage + (min_y &amp; 7) * clamped_width;
                            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> min_x = x_base - 2; min_x &lt;= x_base + 2; min_x++) {
                                __m128i v = _mm_loadu_si128((__m128i <span class="keyword">const</span> *)(clamped_row + min_x + 2));
                                minimum_storage = _mm_min_epu8(minimum_storage, v);
                            }
                        }

                        <span class="comment">// Now compute the spread.</span>
                        __m128i spread = _mm_sub_epi8(maximum_storage, minimum_storage);

                        <span class="comment">// Store it.</span>
                        _mm_storeu_si128((__m128i *)(output_row + x_base), spread);

                    }
                }

                free(clamped_storage);
            }
        }

        <span class="keywordtype">double</span> t2 = currentTime();

        <span class="comment">// Skip the timing comparison if we don&#39;t have openmp</span>
        <span class="comment">// enabled. Otherwise it&#39;s unfair to C.</span>
<span class="preprocessor">        #ifdef _OPENMP</span>
<span class="preprocessor"></span>
        <span class="comment">// Now run the Halide version again without the</span>
        <span class="comment">// jit-compilation overhead. Also run it one hundred times.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iters = 0; iters &lt; 100; iters++) {
            spread.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(halide_result);
        }

        <span class="keywordtype">double</span> t3 = currentTime();

        <span class="comment">// Report the timings. On my machine they both take about 3ms</span>
        <span class="comment">// for the 4-megapixel input (fast!), which makes sense,</span>
        <span class="comment">// because they&#39;re using the same vectorization and</span>
        <span class="comment">// parallelization strategy. However I find the Halide easier</span>
        <span class="comment">// to read, write, debug, modify, and port.</span>
        printf(<span class="stringliteral">&quot;Halide spread took %f ms. C equivalent took %f ms\n&quot;</span>,
               (t3 - t2)/100, (t2 - t1)/100);

<span class="preprocessor">        #endif // _OPENMP</span>
<span class="preprocessor"></span>
        <span class="comment">// Check the results match:</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; input.<a class="code" href="class_halide_1_1_image.html#a04704be92bef97bce8ae46562ab7193b" title="Get the extent of dimension 1, which by convention we use as the height of the image.">height</a>(); y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; input.<a class="code" href="class_halide_1_1_image.html#a182c020608c997186eba7c01ea717a49" title="Get the extent of dimension 0, which by convention we use as the width of the image.">width</a>(); x++) {
                <span class="keywordflow">if</span> (halide_result(x, y) != c_result(x, y)) {
                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %d instead of %d\n&quot;</span>,
                           x, y, halide_result(x, y), c_result(x, y));
                    <span class="keywordflow">return</span> -1;
                }
            }
        }

<span class="preprocessor">        #endif // __SSE2__</span>
<span class="preprocessor"></span>
    }

    printf(<span class="stringliteral">&quot;Success!\n&quot;</span>);
    <span class="keywordflow">return</span> 0;
}
</pre></div> </div><!-- contents -->
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
