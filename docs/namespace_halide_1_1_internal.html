<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Halide: Halide::Internal Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('namespace_halide_1_1_internal.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Internal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_integer_division.html">IntegerDivision</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen.html">CodeGen</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator abstract base class.  <a href="class_halide_1_1_internal_1_1_code_gen.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___a_r_m.html">CodeGen_ARM</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits ARM code from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___a_r_m.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___c.html">CodeGen_C</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class emits C++ code equivalent to a halide <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Stmt</a>.  <a href="class_halide_1_1_internal_1_1_code_gen___c.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_p_u___argument.html">GPU_Argument</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A bit more information attached to an argument useful for GPU backends.  <a href="struct_halide_1_1_internal_1_1_g_p_u___argument.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_p_u___host.html">CodeGen_GPU_Host</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___g_p_u___host.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to manage closures.  <a href="class_halide_1_1_internal_1_1_closure.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___open_c_l___dev.html">CodeGen_OpenCL_Dev</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___open_g_l___dev.html">CodeGen_OpenGL_Dev</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l.html">CodeGen_GLSL</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile one statement into GLSL.  <a href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___p_na_cl.html">CodeGen_PNaCl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits pnacl bitcode from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___p_na_cl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits posix code from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___posix.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___p_t_x___dev.html">CodeGen_PTX_Dev</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___p_t_x___dev.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___x86.html">CodeGen_X86</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits x86 code from a given <a class="el" href="namespace_halide.html">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___x86.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1debug.html">debug</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> optional debugging during codegen, use the debug class as follows:  <a href="struct_halide_1_1_internal_1_1debug.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_error_report.html">ErrorReport</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_expr_uses_vars.html">ExprUsesVars</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_definition.html">ReductionDefinition</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_function_contents.html">FunctionContents</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to <a class="el" href="namespace_halide.html">Halide</a>'s internal representation of a function.  <a href="class_halide_1_1_internal_1_1_function.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a reference count to be used with <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html" title="Intrusive shared pointers have a reference count (a RefCount object) stored in the class itself...">IntrusivePtr</a>.  <a href="class_halide_1_1_internal_1_1_ref_count.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive shared pointers have a reference count (a <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> object) stored in the class itself.  <a href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_node_type.html">IRNodeType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a type of IR node (e.g.  <a href="struct_halide_1_1_internal_1_1_i_r_node_type.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base classes for a node in the <a class="el" href="namespace_halide.html">Halide</a> IR.  <a href="struct_halide_1_1_internal_1_1_i_r_node.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_stmt_node.html">BaseStmtNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are split into expressions and statements.  <a href="struct_halide_1_1_internal_1_1_base_stmt_node.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for expression nodes.  <a href="struct_halide_1_1_internal_1_1_base_expr_node.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_node.html">ExprNode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">We use the "curiously recurring template pattern" to avoid duplicated code in the IR Nodes.  <a href="struct_halide_1_1_internal_1_1_expr_node.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt_node.html">StmtNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are passed around opaque handles to them.  <a href="struct_halide_1_1_internal_1_1_i_r_handle.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html">IntImm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer constants.  <a href="struct_halide_1_1_internal_1_1_int_imm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html">FloatImm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point constants.  <a href="struct_halide_1_1_internal_1_1_float_imm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html">StringImm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String constants.  <a href="struct_halide_1_1_internal_1_1_string_imm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a statement node.  <a href="struct_halide_1_1_internal_1_1_stmt.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="Cast a node from one type to another.">Cast</a> a node from one type to another.  <a href="struct_halide_1_1_internal_1_1_cast.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of two expressions.  <a href="struct_halide_1_1_internal_1_1_add.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The difference of two expressions.  <a href="struct_halide_1_1_internal_1_1_sub.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The product of two expressions.  <a href="struct_halide_1_1_internal_1_1_mul.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The ratio of two expressions.  <a href="struct_halide_1_1_internal_1_1_div.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of a / b.  <a href="struct_halide_1_1_internal_1_1_mod.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The lesser of two values.  <a href="struct_halide_1_1_internal_1_1_min.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater of two values.  <a href="struct_halide_1_1_internal_1_1_max.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression equal to the second.  <a href="struct_halide_1_1_internal_1_1_e_q.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression not equal to the second.  <a href="struct_halide_1_1_internal_1_1_n_e.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than the second.  <a href="struct_halide_1_1_internal_1_1_l_t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_l_e.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than the second.  <a href="struct_halide_1_1_internal_1_1_g_t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_g_e.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and - are both expressions true.  <a href="struct_halide_1_1_internal_1_1_and.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or - is at least one of the expression true.  <a href="struct_halide_1_1_internal_1_1_or.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_not.html">Not</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical not - true if the expression false.  <a href="struct_halide_1_1_internal_1_1_not.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_select.html">Select</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A ternary operator.  <a href="struct_halide_1_1_internal_1_1_select.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_load.html">Load</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer.">Load</a> a value from a named buffer.  <a href="struct_halide_1_1_internal_1_1_load.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_ramp.html">Ramp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear ramp vector node.  <a href="struct_halide_1_1_internal_1_1_ramp.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html">Broadcast</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector with 'width' elements, in which every element is 'value'.  <a href="struct_halide_1_1_internal_1_1_broadcast.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let.html">Let</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A let expression, like you might find in a functional language.  <a href="struct_halide_1_1_internal_1_1_let.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html">LetStmt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The statement form of a let node.  <a href="struct_halide_1_1_internal_1_1_let_stmt.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_assert_stmt.html">AssertStmt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the 'condition' is false, then bail out printing the 'message' to stderr.  <a href="struct_halide_1_1_internal_1_1_assert_stmt.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_pipeline.html">Pipeline</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This node is a helpful annotation to do with permissions.  <a href="struct_halide_1_1_internal_1_1_pipeline.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_for.html">For</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A for loop.  <a href="struct_halide_1_1_internal_1_1_for.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_store.html">Store</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;.">Store</a> a 'value' to the buffer called 'name' at a given 'index'.  <a href="struct_halide_1_1_internal_1_1_store.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_provide.html">Provide</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines the value of a function at a multi-dimensional location.  <a href="struct_halide_1_1_internal_1_1_provide.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html">Allocate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> a scratch area called with the given name, type, and size.  <a href="struct_halide_1_1_internal_1_1_allocate.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_free.html">Free</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_free.html" title="Free the resources associated with the given buffer.">Free</a> the resources associated with the given buffer.  <a href="struct_halide_1_1_internal_1_1_free.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-dimensional span.  <a href="struct_halide_1_1_internal_1_1_range.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_realize.html">Realize</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> a multi-dimensional buffer of the given type and size.  <a href="struct_halide_1_1_internal_1_1_realize.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_block.html">Block</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of statements to be executed in-order.  <a href="struct_halide_1_1_internal_1_1_block.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_if_then_else.html">IfThenElse</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An if-then-else block.  <a href="struct_halide_1_1_internal_1_1_if_then_else.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html">Evaluate</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect.">Evaluate</a> and discard an expression, presumably because it has some side-effect.  <a href="struct_halide_1_1_internal_1_1_evaluate.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function call.  <a href="struct_halide_1_1_internal_1_1_call.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_variable.html">Variable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A named variable.  <a href="struct_halide_1_1_internal_1_1_variable.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_deep_compare.html">ExprDeepCompare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A compare struct suitable for use in std::map and std::set that uses the ordering defined by deep_compare.  <a href="struct_halide_1_1_internal_1_1_expr_deep_compare.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt_deep_compare.html">StmtDeepCompare</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A compare struct suitable for use in std::map and std::set that uses the ordering defined by deep_compare.  <a href="struct_halide_1_1_internal_1_1_stmt_deep_compare.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for passes over the IR which modify it (e.g.  <a href="class_halide_1_1_internal_1_1_i_r_mutator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_printer.html">IRPrinter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR.">IRVisitor</a> that emits IR to the given output stream in a human readable form.  <a href="class_halide_1_1_internal_1_1_i_r_printer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that need to recursively walk over the IR.  <a href="class_halide_1_1_internal_1_1_i_r_visitor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html">IRGraphVisitor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that walk recursively over the IR without visiting the same node twice.  <a href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_compiled_module.html">JITCompiledModule</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> pointers into a compiled halide module.  <a href="struct_halide_1_1_internal_1_1_j_i_t_compiled_module.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of modulus_remainder analysis.  <a href="struct_halide_1_1_internal_1_1_modulus_remainder.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Parameter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a parameter to a halide pipeline.  <a href="class_halide_1_1_internal_1_1_parameter.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html">ReductionVariable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A single named dimension of a reduction domain.  <a href="struct_halide_1_1_internal_1_1_reduction_variable.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_domain_contents.html">ReductionDomainContents</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle on a reduction domain, which is just a vector of <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html" title="A single named dimension of a reduction domain.">ReductionVariable</a>.  <a href="class_halide_1_1_internal_1_1_reduction_domain.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_loop_level.html">LoopLevel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a site in a <a class="el" href="namespace_halide.html">Halide</a> statement at the top of the body of a particular for loop.  <a href="struct_halide_1_1_internal_1_1_loop_level.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_bound.html">Bound</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_schedule.html">Schedule</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A schedule for a single stage of a <a class="el" href="namespace_halide.html">Halide</a> pipeline.  <a href="class_halide_1_1_internal_1_1_schedule.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_small_stack.html">SmallStack</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack which can store one item very efficiently.  <a href="class_halide_1_1_internal_1_1_small_stack.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A common pattern when traversing <a class="el" href="namespace_halide.html">Halide</a> IR is that you need to keep track of stuff when you find a <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language.">Let</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node.">LetStmt</a>, and that it should hide previous values with the same name until you leave the <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language.">Let</a> or <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node.">LetStmt</a> nodes This class helps with that.  <a href="class_halide_1_1_internal_1_1_scope.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_stmt_compiler.html">StmtCompiler</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::pair<br class="typebreak"/>
&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional box.  <a href="#abd1b9521b6f1f513178f281d8f395335"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">MonotonicResult</a> { <a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3eaad87898a017f26e62737125de2b4a9335">Constant</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa6d17c1a787b2f3a7331fde1759083637">MonotonicIncreasing</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa799183e45407f014ab370a9b4bcd2dc3">MonotonicDecreasing</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa33f442ca80fb5f8ce55a5becac9a30cf">Unknown</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown.  <a href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a410eac3ad68dfb697c5ee97100f2053f">allocation_bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;func_bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes in terms of variables, and define values for those variables.  <a href="#a410eac3ad68dfb697c5ee97100f2053f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab7f7e59492cfa4804a6dece2d867a5db">bounds_of_expr_in_scope</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope, const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression.  <a href="#ab7f7e59492cfa4804a6dece2d867a5db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac2f62c0ee3ace8de2be57a9db369a3e4">merge_boxes</a> (<a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0b807d0d1524fb2f20b1533d05032c02">compute_function_value_bounds</a> (const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum and minimum possible value for each function in an environment.  <a href="#a0b807d0d1524fb2f20b1533d05032c02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a439ef9127bf30f5e2a67963eb8db0323">bounds_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9f57a77cbbb8e2e2e7212a75a470fec7">bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::vector&lt; std::string &gt; &amp;realization_order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;environment, const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;func_bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds.  <a href="#a9f57a77cbbb8e2e2e7212a75a470fec7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a71f10140e29131153c3be98d2899b090">llvm_type_of</a> (llvm::LLVMContext *context, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the llvm type equivalent to a given halide type.  <a href="#a71f10140e29131153c3be98d2899b090"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8dec1d917db83734b33d5a208e9ca973">constant_allocation_size</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;extents, const std::string &amp;name, <a class="el" href="mini__stdint_8h.html#a32f2e37ee053cf2ce8ca28d1f74630e5">int32_t</a> &amp;size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to check if a list of extents are all constants, and if so verify the total size is less than 2^31 - 1.  <a href="#a8dec1d917db83734b33d5a208e9ca973"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8e29c6b91cae0cfa7734ff1e13e82ca4">common_subexpression_elimination</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable.  <a href="#a8e29c6b91cae0cfa7734ff1e13e82ca4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a86003b87f257d83c080b54bcc6dce216">common_subexpression_elimination</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Do common-subexpression-elimination on each expression in a statement.  <a href="#a86003b87f257d83c080b54bcc6dce216"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab98f0a702bd775e67baed5bcd986ae27">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide statement on an output stream (such as std::cout) in a human-readable form.  <a href="#ab98f0a702bd775e67baed5bcd986ae27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0694c89a8349199080a71443202acd43">debug_to_file</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string output, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes still unlowered.  <a href="#a0694c89a8349199080a71443202acd43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaa9b678f3916b022dd8b8415c9ca0750">extract_odd_lanes</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the odd-numbered lanes in a vector.  <a href="#aaa9b678f3916b022dd8b8415c9ca0750"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a017315ab942e526e9915325f05d406a0">extract_even_lanes</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the even-numbered lanes in a vector.  <a href="#a017315ab942e526e9915325f05d406a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a750c306ff019e4f332238799979c9345">extract_lane</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">vec</a>, int lane)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the nth lane of a vector.  <a href="#a750c306ff019e4f332238799979c9345"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac1233a717a83d74121106b95245ce81a">rewrite_interleavings</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic.  <a href="#ac1233a717a83d74121106b95245ce81a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8dc1b0ff156c8b0ca5fd26956ee482a9">deinterleave_vector_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a534a3b8f52a0441dbb0fb7ab2aed3341">finite_difference</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, const std::string &amp;var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the analytic derivative of the expression with respect to the variable.  <a href="#a534a3b8f52a0441dbb0fb7ab2aed3341"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">MonotonicResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af7ad39c95e126e3cdfe7ce5a72fa5f51">is_monotonic</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;var)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5aedffca433bdfab639e4956779040e6">inject_early_frees</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation.  <a href="#a5aedffca433bdfab639e4956779040e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af239670eead776a941de1cb3f1a93202">expr_uses_var</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an expression references the given variable.  <a href="#af239670eead776a941de1cb3f1a93202"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaada81b273cd0d0f1b9f722fbd758e4a">expr_uses_vars</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an expression references any of the variables in a scope.  <a href="#aaada81b273cd0d0f1b9f722fbd758e4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a16b42e90ad180f1254cdd3be0ae7be89">find_direct_calls</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition object for all <a class="el" href="namespace_halide.html">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, including in update definitions, update index expressions, and <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> extents.  <a href="#a16b42e90ad180f1254cdd3be0ae7be89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a770da2a7374eb2a8ac60f5c9d90b88ad">find_transitive_calls</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition object for all <a class="el" href="namespace_halide.html">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, or indirectly in those functions' definitions, recursively.  <a href="#a770da2a7374eb2a8ac60f5c9d90b88ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0081752824625e87b5e95bfae979499f">fuse_gpu_thread_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="namespace_halide.html">Halide</a>'s GPGPU IR to the OpenCL/CUDA model.  <a href="#a0081752824625e87b5e95bfae979499f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab5ba1224136725f64d43e7c83d4ed603">inject_host_dev_buffer_copies</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject calls to halide_dev_malloc, halide_copy_to_dev, and halide_copy_to_host as needed.  <a href="#ab5ba1224136725f64d43e7c83d4ed603"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a70fcc88dde228e4f70a90d4848ddb773">inject_dev_frees</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject calls to halide_dev_free as needed.  <a href="#a70fcc88dde228e4f70a90d4848ddb773"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94843d09c24cd65c12aa022e0ae3bb70">inject_opengl_intrinsics</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for kernel for loops and turn loads and stores inside the loops into OpenGL texture load and store intrinsics.  <a href="#a94843d09c24cd65c12aa022e0ae3bb70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a66571ec4623be1b2eb6d37e05372dbf0">get_variable_name</a> (const void *, const std::string &amp;expected_type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a stack variable from its address.  <a href="#a66571ec4623be1b2eb6d37e05372dbf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a91836225c3f9b432897eb22c67962465">get_source_location</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the source location in the call stack, skipping over calls in the <a class="el" href="namespace_halide.html">Halide</a> namespace.  <a href="#a91836225c3f9b432897eb22c67962465"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a118e692f18d13b851c0d537b172b2f10">test_compilation_unit</a> (bool(*test)(), void(*calib)())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acc591095a8e56d4d6f6587c66239fdb3">ref_count&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7e3867f02d52edd32b4cfe38e5ee55a1">destroy&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af22936be5f74cc50d73a4e478bd9271e">expr_match</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> pattern, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument.  <a href="#af22936be5f74cc50d73a4e478bd9271e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1eed932bc0eb3a15edcb20795bfb8c2f">expr_match_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab370d99a882a8163ae91d43b94d79d02">is_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="Cast a node from one type to another.">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node.">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same.  <a href="#ab370d99a882a8163ae91d43b94d79d02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b709fdbc5a6944248187216b5df5b2e">is_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="Cast a node from one type to another.">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same.  <a href="#a4b709fdbc5a6944248187216b5df5b2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a68b76ccfb1d4e7cc35ff65f15f9b0077">as_const_int</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, return a pointer to its value.  <a href="#a68b76ccfb1d4e7cc35ff65f15f9b0077"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af2a9edb743eaf6d8074867314247a970">as_const_float</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, return a pointer to its value.  <a href="#af2a9edb743eaf6d8074867314247a970"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2399da4e027488064c4d14a2469f9fc3">is_const_power_of_two</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int *bits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a constant integer power of two.  <a href="#a2399da4e027488064c4d14a2469f9fc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad050aaa17987fa4cbb8fd4d41c952e04">is_positive_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression)  <a href="#ad050aaa17987fa4cbb8fd4d41c952e04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acc39652dfc1d64fb82d02dc4064185d7">is_negative_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression)  <a href="#acc39652dfc1d64fb82d02dc4064185d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1a521ef987e7964954b997e6dcc5e65b">is_zero</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression)  <a href="#a1a521ef987e7964954b997e6dcc5e65b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a940b37091a8f16bf1e4a78db7764274e">is_one</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression)  <a href="#a940b37091a8f16bf1e4a78db7764274e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abeed2f66190d11ee6e56e4089a1f441b">is_two</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression)  <a href="#abeed2f66190d11ee6e56e4089a1f441b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a225fbecd4560e77ea24cb16541fe6b15">int_cast_constant</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, int val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an integer value, cast it into a designated integer type and return the bits as int.  <a href="#a225fbecd4560e77ea24cb16541fe6b15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab48739c460778f7af77999cfd251d5af">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, int val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const of the given type.  <a href="#ab48739c460778f7af77999cfd251d5af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1e258c84149c36aad7d93cced54cd173">make_bool</a> (bool val, int width=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean constant from a C++ boolean value.  <a href="#a1e258c84149c36aad7d93cced54cd173"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a57fedf535d58f8900f8b7c00aa15ece8">make_zero</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of zero in the given type.  <a href="#a57fedf535d58f8900f8b7c00aa15ece8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ace305dbdd7fed2cf9d5057d4c02067c9">make_one</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of one in the given type.  <a href="#ace305dbdd7fed2cf9d5057d4c02067c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afc35f0dc3562ffb5bb777021679435e2">make_two</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of two in the given type.  <a href="#afc35f0dc3562ffb5bb777021679435e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0f8e27a136a9facf0e97e6ac6bd71c23">const_true</a> (int width=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean true.  <a href="#a0f8e27a136a9facf0e97e6ac6bd71c23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6c5d4e90106e92aa21840547b6588eb3">const_false</a> (int width=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean false.  <a href="#a6c5d4e90106e92aa21840547b6588eb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">match_types</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce the two expressions to have the same type, using C-style casting rules.  <a href="#ab40a26aac941b763435e9915851cd073"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac5890bd4a8aae2f1f6a2c43496d8ddae">raise_to_integer_power</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise an expression to an integer power by repeatedly multiplying it by itself.  <a href="#ac5890bd4a8aae2f1f6a2c43496d8ddae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa67dad74ce8739ca7773f6032e51d5c6">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_for.html#a58f191c4b166630d13829e4f1840d5c6">For::ForType</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide for loop type (vectorized, serial, etc) in a human readable form.  <a href="#aa67dad74ce8739ca7773f6032e51d5c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2c00a579c3d86ae40920d5fc4ffe64cf">lower_lerp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> zero_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> one_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> weight)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="namespace_halide.html">Halide</a> IR that computes a lerp.  <a href="#a2c00a579c3d86ae40920d5fc4ffe64cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a95f0cfbb7653be4145fe4cedd9a15dfa">lift_loop_invariants</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull all let statements as far out as possible.  <a href="#a95f0cfbb7653be4145fe4cedd9a15dfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d53906d81dae46b049456d5430abedd">lower</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a halide function with a schedule, create a statement that evaluates it.  <a href="#a3d53906d81dae46b049456d5430abedd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d3bfe43201bab68cf4820993fe1469b">lower_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7298e57b1434cccc072c45b6f5c6efef">modulus_remainder</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant.  <a href="#a7298e57b1434cccc072c45b6f5c6efef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8489fb5b4449835f26313a57e856c4b3">modulus_remainder</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;scope)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder:  <a href="#a8489fb5b4449835f26313a57e856c4b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af210d0f6ae102d704259f49bb32adc2f">reduce_expr_modulo</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int modulus, int *remainder)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an expression modulo some integer.  <a href="#af210d0f6ae102d704259f49bb32adc2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a789149daec96e933f8758f71f8474dd6">modulus_remainder_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a50891465f948d4f9b30b9253ce1640b1">gcd</a> (int, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The greatest common divisor of two integers.  <a href="#a50891465f948d4f9b30b9253ce1640b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab56d2d1c54f988f23aa03ae70cdfd857">lcm</a> (int, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The least common multiple of two integers.  <a href="#ab56d2d1c54f988f23aa03ae70cdfd857"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a36620e2156363b215b17fae00eec44ea">is_one_to_one</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conservatively determine whether an integer expression is one-to-one in its variables.  <a href="#a36620e2156363b215b17fae00eec44ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acd3b8d6aeed9a003fe228ad1aba7322f">is_one_to_one_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0ce66817377fbb1918bbe7510ab47b29">check_call_arg_types</a> (const std::string &amp;name, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; *args, int dims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate arguments to a call to a func, image or imageparam.  <a href="#a0ce66817377fbb1918bbe7510ab47b29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a568a0554db6866ee8560c3f599bceadd">inject_profiling</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, std::string)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline, and (depending on the environment variable HL_PROFILE), insert high-resolution timing into the generated code; summaries of execution times and counts will be logged at the end.  <a href="#a568a0554db6866ee8560c3f599bceadd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae828a911751c5115cb503d05afb1dcbe">profiling_level</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current profiling level (by reading HL_PROFILE)  <a href="#ae828a911751c5115cb503d05afb1dcbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#add0c1d3ac79fd83cb609d37831253957">qualify</a> (const std::string &amp;prefix, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix all variable names in the given expression with the prefix string.  <a href="#add0c1d3ac79fd83cb609d37831253957"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a795f343747d7f716a33198907c3e7d25">random_float</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random floating-point number between zero and one that varies deterministically based on the input expressions.  <a href="#a795f343747d7f716a33198907c3e7d25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae4e64539c6d89123f6200b919ec28fbb">random_int</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random unsigned integer between zero and 2^32-1 that varies deterministically based on the input expressions (which must be integers).  <a href="#ae4e64539c6d89123f6200b919ec28fbb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0f875bf4d528885d68581fbd198bf356">lower_random</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::vector&lt; std::string &gt; &amp;free_vars, int tag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert calls to random() to IR generated by random_float and random_int.  <a href="#a0f875bf4d528885d68581fbd198bf356"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a445fa778b28abf135eb1b1d0c8389efc">remove_trivial_for_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert for loops of size 1 into <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node.">LetStmt</a> nodes, which allows for further simplification.  <a href="#a445fa778b28abf135eb1b1d0c8389efc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a078fe646230de310959c4506c76de02e">remove_undef</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes stores that depend on undef values, and statements that only contain such stores.  <a href="#a078fe646230de310959c4506c76de02e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4242a0b28a7409d2a2489a74795914ef">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0faf83270a59e0cf2e3821be2a4666c2">simplify_exprs</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify expressions found in a statement, but don't simplify across different statements.  <a href="#a0faf83270a59e0cf2e3821be2a4666c2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">mod_imp</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html">Halide</a>.  <a href="#a6cd3908859c82249a2c7f10158883a97"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adff5495089b812474881ee939c4701c4">mod_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac9a60708c880da445554b8eeb778c034">mod_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">div_imp</a> (T a, T b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7feea16442755d0a73ec2de1b8889106">simplify_test</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8489422fe4da6e486b5fd7831aab8bfb">skip_stages</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; std::string &gt; &amp;order)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Avoid computing certain stages if we can infer a runtime condition to check that tells us they won't be used.  <a href="#a8489422fe4da6e486b5fd7831aab8bfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a07bde9012b280aad21a569ea008ed296">sliding_window</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sliding window optimizations on a halide statement.  <a href="#a07bde9012b280aad21a569ea008ed296"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab3d6d20f5581d4711c83a2b1755c2716">specialize_clamped_ramps</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;.">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer.">Load</a> nodes respectively.  <a href="#ab3d6d20f5581d4711c83a2b1755c2716"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a36bbe2f07f16d251525ee4beaa68c102">storage_flattening</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;.">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer.">Load</a> nodes respectively.  <a href="#a36bbe2f07f16d251525ee4beaa68c102"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9eefd272612c586d9c3e4dba31d1c215">storage_folding</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold storage of functions if possible.  <a href="#a9eefd272612c586d9c3e4dba31d1c215"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9cec67b9b23c3f0047874cc432591ae6">substitute</a> (std::string name, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within expr.  <a href="#a9cec67b9b23c3f0047874cc432591ae6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa5f3a31a571b877aeff8804b204b78ec">substitute</a> (std::string name, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within stmt.  <a href="#aa5f3a31a571b877aeff8804b204b78ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::Module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a320fa7575718308bc5b1e7a1b6d42d31">get_initial_module_for_target</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a>, llvm::LLVMContext *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for a given target.  <a href="#a320fa7575718308bc5b1e7a1b6d42d31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">llvm::Module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa9f98b98cbded4d63028df71771ca835">get_initial_module_for_ptx_device</a> (llvm::LLVMContext *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for ptx device.  <a href="#aa9f98b98cbded4d63028df71771ca835"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3cd3f1d683bcca49a2df7179d42245d0">inject_tracing</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> output)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations.  <a href="#a3cd3f1d683bcca49a2df7179d42245d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0b6c445013b15af0a32bd54f5bb6bdc3">unify_duplicate_lets</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find let statements that all define the same value, and make later ones just reuse the symbol names of the earlier ones.  <a href="#a0b6c445013b15af0a32bd54f5bb6bdc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abf197e316b7d0a6adb96c25976612c1b">uniquify_variable_names</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a statement so that every internally-defined variable name is unique.  <a href="#abf197e316b7d0a6adb96c25976612c1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adc1c49e552297672b3751ac988bf70c3">unroll_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement.  <a href="#adc1c49e552297672b3751ac988bf70c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0aeffeff26578021bc780e1506bfa448">int_to_string</a> (int x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer to a string.  <a href="#a0aeffeff26578021bc780e1506bfa448"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename DstType , typename SrcType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DstType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94816d6979fdadb6e206a5d0a668e008">reinterpret_bits</a> (const SrcType &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An aggressive form of reinterpret cast used for correct type-punning.  <a href="#a94816d6979fdadb6e206a5d0a668e008"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2eb97978547d98141752de6b614195f4">make_entity_name</a> (void *stack_ptr, const std::string &amp;type, char prefix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a unique name for an object based on the name of the stack variable passed in.  <a href="#a2eb97978547d98141752de6b614195f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">unique_name</a> (char prefix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given character.  <a href="#acd575ab182df12cc793dba4aa241c1a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aafd40e47c06b4ccb5d2173528ae0523f">unique_name</a> (const std::string &amp;name, bool user=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given string.  <a href="#aafd40e47c06b4ccb5d2173528ae0523f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa7703083cfe592de68f37796533724ed">starts_with</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the first string starts with the second string.  <a href="#aa7703083cfe592de68f37796533724ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a230079281175545b9b90b2285106ab28">ends_with</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the first string ends with the second string.  <a href="#a230079281175545b9b90b2285106ab28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac91d88c24b89bb17c7b69c671c723516">base_name</a> (const std::string &amp;name, char delim= '.')</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the final token of the name string using the given delimiter.  <a href="#ac91d88c24b89bb17c7b69c671c723516"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abe70c3a9d0ecd59908b1837a11d01de0">vectorize_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors.  <a href="#abe70c3a9d0ecd59908b1837a11d01de0"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a33cd6d9b32f181c1211dbe9e1e424b73">boxes_required</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s to each function that occurs within a given statement or expression.  <a href="#a33cd6d9b32f181c1211dbe9e1e424b73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae6fb22d11724b089991db60f756d1d10">boxes_required</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s to each function that occurs within a given statement or expression.  <a href="#ae6fb22d11724b089991db60f756d1d10"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5328f15f4cb29712a15fa55c816eb364">boxes_provided</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression.  <a href="#a5328f15f4cb29712a15fa55c816eb364"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a574c160ef19ae345a0735509b0c4bbaa">boxes_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression.  <a href="#a574c160ef19ae345a0735509b0c4bbaa"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2676f1d8c8216f928a36519b8f88ee16">boxes_touched</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression.  <a href="#a2676f1d8c8216f928a36519b8f88ee16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a88d65d44fb681c60085987b64147d015">boxes_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression.  <a href="#a88d65d44fb681c60085987b64147d015"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a33bbf8251b1d8dac5dacafce1154efaf">box_required</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a33bbf8251b1d8dac5dacafce1154efaf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acba10e3537efa9b1847e99937e8fd8c8">box_required</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#acba10e3537efa9b1847e99937e8fd8c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4a35dd99e377e0ca106576137d01cd43">box_provided</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a4a35dd99e377e0ca106576137d01cd43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6e45cc297657b1d8ce623231b166f3b7">box_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a6e45cc297657b1d8ce623231b166f3b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4cff75ebb135ac249fd4c3a7e1a1ab69">box_touched</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a4cff75ebb135ac249fd4c3a7e1a1ab69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a32cbaa6984dbc7c0c5a867ee6acc0d25">box_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a32cbaa6984dbc7c0c5a867ee6acc0d25"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#add5bcb9d6d286355a3cb9b8f289e0985">remove_lets</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all lets from a statement or expression by substituting them in.  <a href="#add5bcb9d6d286355a3cb9b8f289e0985"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7f56ee3ea320c3c0b452722edab42470">remove_lets</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all lets from a statement or expression by substituting them in.  <a href="#a7f56ee3ea320c3c0b452722edab42470"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a38c4753b75f784e928d24b5f085ed383">inline_function</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a single named function, which must be pure.  <a href="#a38c4753b75f784e928d24b5f085ed383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a839846970613235cae5c8904a5fda794">inline_function</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a single named function, which must be pure.  <a href="#a839846970613235cae5c8904a5fda794"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9ff5beef3c5a4ec908d9c2bbe99a71f9">ref_count</a> (const T *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here.  <a href="#a9ff5beef3c5a4ec908d9c2bbe99a71f9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ada37ff426984f7459fe0bbe38b9e11f0">destroy</a> (const T *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here.  <a href="#ada37ff426984f7459fe0bbe38b9e11f0"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a31dc49947eec58e14aab236c7b0182ee">equal</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a31dc49947eec58e14aab236c7b0182ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d404e95dced22ae673144c0351f186f">equal</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> a, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a4d404e95dced22ae673144c0351f186f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a65590b80d11a0b92f74cf17d9fa5cf49">deep_compare</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a lexical ordering on IR nodes.  <a href="#a65590b80d11a0b92f74cf17d9fa5cf49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a19c9545816a6a6e120b5681d20bf7055">deep_compare</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> a, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a lexical ordering on IR nodes.  <a href="#a19c9545816a6a6e120b5681d20bf7055"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af36627bf7242718b1c73214296dc9090">halide_log</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html">Halide</a>'s vectorizable transcendentals.  <a href="#af36627bf7242718b1c73214296dc9090"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5688772a963296ea52d2bd9ac5913e79">halide_exp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html">Halide</a>'s vectorizable transcendentals.  <a href="#a5688772a963296ea52d2bd9ac5913e79"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad7b681bba7782bb83ff3bfd6341fd5a9">simplify</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, bool remove_dead_lets=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc.  <a href="#ad7b681bba7782bb83ff3bfd6341fd5a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a71eca1a06e6305effb6bc10941d397f0">simplify</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, bool remove_dead_lets=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc.  <a href="#a71eca1a06e6305effb6bc10941d397f0"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac546c55fe301504146a0ea9e19a4ac00">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with names in the map.  <a href="#ac546c55fe301504146a0ea9e19a4ac00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9d3e92b9c76f56e57b4590f89d6cd073">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with names in the map.  <a href="#a9d3e92b9c76f56e57b4590f89d6cd073"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">vec</a> (T a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#a1581b658edf919ea8aae58ad09b4f829"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a60049819a1e4ee7971c624c18a26210a">vec</a> (T a, T b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#a60049819a1e4ee7971c624c18a26210a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a57308fdf8df2d93ff56d7dc8d2f621b1">vec</a> (T a, T b, T c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#a57308fdf8df2d93ff56d7dc8d2f621b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a643930ad0d00b2138183abfb01ba7083">vec</a> (T a, T b, T c, T d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#a643930ad0d00b2138183abfb01ba7083"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a33cbb76cabe65d3b5fc27f6d4866ce0b">vec</a> (T a, T b, T c, T d, T e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#a33cbb76cabe65d3b5fc27f6d4866ce0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac29a0bceb82c876dc7b2d9d15ea0f5b7">vec</a> (T a, T b, T c, T d, T e, T f)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#ac29a0bceb82c876dc7b2d9d15ea0f5b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6e0218a6965fff6add01901838ccef67">vec</a> (T a, T b, T c, T d, T e, T f, T g)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#a6e0218a6965fff6add01901838ccef67"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab96724ccfd5edca25ce01a24fce53a66">vec</a> (T a, T b, T c, T d, T e, T f, T g, T h)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 6 elements.  <a href="#ab96724ccfd5edca25ce01a24fce53a66"></a><br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aaa0611a86047e2c583dd061a620dcc6e"></a><!-- doxytag: member="Halide::Internal::FuncValueBounds" ref="aaa0611a86047e2c583dd061a620dcc6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::pair&lt;std::string, int&gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">Halide::Internal::FuncValueBounds</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_bounds_8h_source.html#l00022">22</a> of file <a class="el" href="_bounds_8h_source.html">Bounds.h</a>.</p>

</div>
</div>
<a class="anchor" id="abd1b9521b6f1f513178f281d8f395335"></a><!-- doxytag: member="Halide::Internal::Region" ref="abd1b9521b6f1f513178f281d8f395335" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Halide::Internal::Region</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A multi-dimensional box. </p>
<p>The outer product of the elements </p>

<p>Definition at line <a class="el" href="_i_r_8h_source.html#l00853">853</a> of file <a class="el" href="_i_r_8h_source.html">IR.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3ea"></a><!-- doxytag: member="Halide::Internal::MonotonicResult" ref="a6d77bcd7bf9bfb0b3f5e66010d9ff3ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">Halide::Internal::MonotonicResult</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown. </p>
<p>Returns -1, 0, or 1 for decreasing, unknown, and increasing. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaad87898a017f26e62737125de2b4a9335"></a><!-- doxytag: member="Constant" ref="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaad87898a017f26e62737125de2b4a9335" args="" -->Constant</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa6d17c1a787b2f3a7331fde1759083637"></a><!-- doxytag: member="MonotonicIncreasing" ref="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa6d17c1a787b2f3a7331fde1759083637" args="" -->MonotonicIncreasing</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa799183e45407f014ab370a9b4bcd2dc3"></a><!-- doxytag: member="MonotonicDecreasing" ref="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa799183e45407f014ab370a9b4bcd2dc3" args="" -->MonotonicDecreasing</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa33f442ca80fb5f8ce55a5becac9a30cf"></a><!-- doxytag: member="Unknown" ref="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa33f442ca80fb5f8ce55a5becac9a30cf" args="" -->Unknown</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_derivative_8h_source.html#l00040">40</a> of file <a class="el" href="_derivative_8h_source.html">Derivative.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a410eac3ad68dfb697c5ee97100f2053f"></a><!-- doxytag: member="Halide::Internal::allocation_bounds_inference" ref="a410eac3ad68dfb697c5ee97100f2053f" args="(Stmt s, const std::map&lt; std::string, Function &gt; &amp;env, const std::map&lt; std::pair&lt; std::string, int &gt;, Interval &gt; &amp;func_bounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a410eac3ad68dfb697c5ee97100f2053f">Halide::Internal::allocation_bounds_inference</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; std::string, int &gt;, Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a partially statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes in terms of variables, and define values for those variables. </p>

</div>
</div>
<a class="anchor" id="ab7f7e59492cfa4804a6dece2d867a5db"></a><!-- doxytag: member="Halide::Internal::bounds_of_expr_in_scope" ref="ab7f7e59492cfa4804a6dece2d867a5db" args="(Expr expr, const Scope&lt; Interval &gt; &amp;scope, const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> <a class="el" href="namespace_halide_1_1_internal.html#ab7f7e59492cfa4804a6dece2d867a5db">Halide::Internal::bounds_of_expr_in_scope</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_max.html" title="The greater of two values.">Max</a> or min may be undefined expressions if the value is not bounded above or below.</p>
<p>This is for tasks such as deducing the region of a buffer loaded by a chunk of code. </p>

</div>
</div>
<a class="anchor" id="ac2f62c0ee3ace8de2be57a9db369a3e4"></a><!-- doxytag: member="Halide::Internal::merge_boxes" ref="ac2f62c0ee3ace8de2be57a9db369a3e4" args="(Box &amp;a, const Box &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#ac2f62c0ee3ace8de2be57a9db369a3e4">Halide::Internal::merge_boxes</a> </td>
          <td>(</td>
          <td class="paramtype">Box &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a33cd6d9b32f181c1211dbe9e1e424b73"></a><!-- doxytag: member="Halide::Internal::boxes_required" ref="a33cd6d9b32f181c1211dbe9e1e424b73" args="(Expr e, const Scope&lt; Interval &gt; &amp;scope=Scope&lt; Interval &gt;(), const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#a33cd6d9b32f181c1211dbe9e1e424b73">Halide::Internal::boxes_required</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s to each function that occurs within a given statement or expression. </p>
<p>This is useful for figuring out what regions of things to evaluate. </p>

</div>
</div>
<a class="anchor" id="ae6fb22d11724b089991db60f756d1d10"></a><!-- doxytag: member="Halide::Internal::boxes_required" ref="ae6fb22d11724b089991db60f756d1d10" args="(Stmt s, const Scope&lt; Interval &gt; &amp;scope=Scope&lt; Interval &gt;(), const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#a33cd6d9b32f181c1211dbe9e1e424b73">Halide::Internal::boxes_required</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s to each function that occurs within a given statement or expression. </p>
<p>This is useful for figuring out what regions of things to evaluate. </p>

</div>
</div>
<a class="anchor" id="a5328f15f4cb29712a15fa55c816eb364"></a><!-- doxytag: member="Halide::Internal::boxes_provided" ref="a5328f15f4cb29712a15fa55c816eb364" args="(Expr e, const Scope&lt; Interval &gt; &amp;scope=Scope&lt; Interval &gt;(), const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#a5328f15f4cb29712a15fa55c816eb364">Halide::Internal::boxes_provided</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="a574c160ef19ae345a0735509b0c4bbaa"></a><!-- doxytag: member="Halide::Internal::boxes_provided" ref="a574c160ef19ae345a0735509b0c4bbaa" args="(Stmt s, const Scope&lt; Interval &gt; &amp;scope=Scope&lt; Interval &gt;(), const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#a5328f15f4cb29712a15fa55c816eb364">Halide::Internal::boxes_provided</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="a2676f1d8c8216f928a36519b8f88ee16"></a><!-- doxytag: member="Halide::Internal::boxes_touched" ref="a2676f1d8c8216f928a36519b8f88ee16" args="(Expr e, const Scope&lt; Interval &gt; &amp;scope=Scope&lt; Interval &gt;(), const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#a2676f1d8c8216f928a36519b8f88ee16">Halide::Internal::boxes_touched</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="a88d65d44fb681c60085987b64147d015"></a><!-- doxytag: member="Halide::Internal::boxes_touched" ref="a88d65d44fb681c60085987b64147d015" args="(Stmt s, const Scope&lt; Interval &gt; &amp;scope=Scope&lt; Interval &gt;(), const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#a2676f1d8c8216f928a36519b8f88ee16">Halide::Internal::boxes_touched</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="a33bbf8251b1d8dac5dacafce1154efaf"></a><!-- doxytag: member="Halide::Internal::box_required" ref="a33bbf8251b1d8dac5dacafce1154efaf" args="(Expr e, std::string fn, const Scope&lt; Interval &gt; &amp;scope=Scope&lt; Interval &gt;(), const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> <a class="el" href="namespace_halide_1_1_internal.html#a33bbf8251b1d8dac5dacafce1154efaf">Halide::Internal::box_required</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="acba10e3537efa9b1847e99937e8fd8c8"></a><!-- doxytag: member="Halide::Internal::box_required" ref="acba10e3537efa9b1847e99937e8fd8c8" args="(Stmt s, std::string fn, const Scope&lt; Interval &gt; &amp;scope=Scope&lt; Interval &gt;(), const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> <a class="el" href="namespace_halide_1_1_internal.html#a33bbf8251b1d8dac5dacafce1154efaf">Halide::Internal::box_required</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a4a35dd99e377e0ca106576137d01cd43"></a><!-- doxytag: member="Halide::Internal::box_provided" ref="a4a35dd99e377e0ca106576137d01cd43" args="(Expr e, std::string fn, const Scope&lt; Interval &gt; &amp;scope=Scope&lt; Interval &gt;(), const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> <a class="el" href="namespace_halide_1_1_internal.html#a4a35dd99e377e0ca106576137d01cd43">Halide::Internal::box_provided</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a6e45cc297657b1d8ce623231b166f3b7"></a><!-- doxytag: member="Halide::Internal::box_provided" ref="a6e45cc297657b1d8ce623231b166f3b7" args="(Stmt s, std::string fn, const Scope&lt; Interval &gt; &amp;scope=Scope&lt; Interval &gt;(), const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> <a class="el" href="namespace_halide_1_1_internal.html#a4a35dd99e377e0ca106576137d01cd43">Halide::Internal::box_provided</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a4cff75ebb135ac249fd4c3a7e1a1ab69"></a><!-- doxytag: member="Halide::Internal::box_touched" ref="a4cff75ebb135ac249fd4c3a7e1a1ab69" args="(Expr e, std::string fn, const Scope&lt; Interval &gt; &amp;scope=Scope&lt; Interval &gt;(), const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> <a class="el" href="namespace_halide_1_1_internal.html#a4cff75ebb135ac249fd4c3a7e1a1ab69">Halide::Internal::box_touched</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a32cbaa6984dbc7c0c5a867ee6acc0d25"></a><!-- doxytag: member="Halide::Internal::box_touched" ref="a32cbaa6984dbc7c0c5a867ee6acc0d25" args="(Stmt s, std::string fn, const Scope&lt; Interval &gt; &amp;scope=Scope&lt; Interval &gt;(), const FuncValueBounds &amp;func_bounds=FuncValueBounds())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> <a class="el" href="namespace_halide_1_1_internal.html#a4cff75ebb135ac249fd4c3a7e1a1ab69">Halide::Internal::box_touched</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a0b807d0d1524fb2f20b1533d05032c02"></a><!-- doxytag: member="Halide::Internal::compute_function_value_bounds" ref="a0b807d0d1524fb2f20b1533d05032c02" args="(const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, Function &gt; &amp;env)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> <a class="el" href="namespace_halide_1_1_internal.html#a0b807d0d1524fb2f20b1533d05032c02">Halide::Internal::compute_function_value_bounds</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the maximum and minimum possible value for each function in an environment. </p>

</div>
</div>
<a class="anchor" id="a439ef9127bf30f5e2a67963eb8db0323"></a><!-- doxytag: member="Halide::Internal::bounds_test" ref="a439ef9127bf30f5e2a67963eb8db0323" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a439ef9127bf30f5e2a67963eb8db0323">Halide::Internal::bounds_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9f57a77cbbb8e2e2e7212a75a470fec7"></a><!-- doxytag: member="Halide::Internal::bounds_inference" ref="a9f57a77cbbb8e2e2e7212a75a470fec7" args="(Stmt, const std::vector&lt; std::string &gt; &amp;realization_order, const std::map&lt; std::string, Function &gt; &amp;environment, const std::map&lt; std::pair&lt; std::string, int &gt;, Interval &gt; &amp;func_bounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a9f57a77cbbb8e2e2e7212a75a470fec7">Halide::Internal::bounds_inference</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>realization_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>environment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; std::string, int &gt;, Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds. </p>

</div>
</div>
<a class="anchor" id="a71f10140e29131153c3be98d2899b090"></a><!-- doxytag: member="Halide::Internal::llvm_type_of" ref="a71f10140e29131153c3be98d2899b090" args="(llvm::LLVMContext *context, Halide::Type t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* <a class="el" href="namespace_halide_1_1_internal.html#a71f10140e29131153c3be98d2899b090">Halide::Internal::llvm_type_of</a> </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the llvm type equivalent to a given halide type. </p>

</div>
</div>
<a class="anchor" id="a8dec1d917db83734b33d5a208e9ca973"></a><!-- doxytag: member="Halide::Internal::constant_allocation_size" ref="a8dec1d917db83734b33d5a208e9ca973" args="(const std::vector&lt; Expr &gt; &amp;extents, const std::string &amp;name, int32_t &amp;size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_halide_1_1_internal.html#a8dec1d917db83734b33d5a208e9ca973">Halide::Internal::constant_allocation_size</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mini__stdint_8h.html#a32f2e37ee053cf2ce8ca28d1f74630e5">int32_t</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A routine to check if a list of extents are all constants, and if so verify the total size is less than 2^31 - 1. </p>
<p>If the result is constant, but overflows, this routine asserts. The name parameter is used in the assertion message. </p>

</div>
</div>
<a class="anchor" id="a8e29c6b91cae0cfa7734ff1e13e82ca4"></a><!-- doxytag: member="Halide::Internal::common_subexpression_elimination" ref="a8e29c6b91cae0cfa7734ff1e13e82ca4" args="(Expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a8e29c6b91cae0cfa7734ff1e13e82ca4">Halide::Internal::common_subexpression_elimination</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable. </p>
<p>This is important to do within <a class="el" href="namespace_halide.html">Halide</a> (instead of punting to llvm), because exprs that come in from the front-end are small when considered as a graph, but combinatorially large when considered as a tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> an example of a such a case, see test/code_explosion.cpp </p>

</div>
</div>
<a class="anchor" id="a86003b87f257d83c080b54bcc6dce216"></a><!-- doxytag: member="Halide::Internal::common_subexpression_elimination" ref="a86003b87f257d83c080b54bcc6dce216" args="(Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a8e29c6b91cae0cfa7734ff1e13e82ca4">Halide::Internal::common_subexpression_elimination</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do common-subexpression-elimination on each expression in a statement. </p>
<p>Does not introduce let statements. </p>

</div>
</div>
<a class="anchor" id="add5bcb9d6d286355a3cb9b8f289e0985"></a><!-- doxytag: member="Halide::Internal::remove_lets" ref="add5bcb9d6d286355a3cb9b8f289e0985" args="(Expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#add5bcb9d6d286355a3cb9b8f289e0985">Halide::Internal::remove_lets</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove all lets from a statement or expression by substituting them in. </p>
<p>All sub-expressions will exist once in memory, but may have many pointers to them, so this doesn't cause a combinatorial explosion. If you walk over this as if it were a tree, however, you're going to have a bad time. </p>

</div>
</div>
<a class="anchor" id="a7f56ee3ea320c3c0b452722edab42470"></a><!-- doxytag: member="Halide::Internal::remove_lets" ref="a7f56ee3ea320c3c0b452722edab42470" args="(Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#add5bcb9d6d286355a3cb9b8f289e0985">Halide::Internal::remove_lets</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove all lets from a statement or expression by substituting them in. </p>
<p>All sub-expressions will exist once in memory, but may have many pointers to them, so this doesn't cause a combinatorial explosion. If you walk over this as if it were a tree, however, you're going to have a bad time. </p>

</div>
</div>
<a class="anchor" id="ab98f0a702bd775e67baed5bcd986ae27"></a><!-- doxytag: member="Halide::Internal::operator&lt;&lt;" ref="ab98f0a702bd775e67baed5bcd986ae27" args="(std::ostream &amp;stream, const Stmt &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Stmt &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emit a halide statement on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a0694c89a8349199080a71443202acd43"></a><!-- doxytag: member="Halide::Internal::debug_to_file" ref="a0694c89a8349199080a71443202acd43" args="(Stmt s, std::string output, const std::map&lt; std::string, Function &gt; &amp;env)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a0694c89a8349199080a71443202acd43">Halide::Internal::debug_to_file</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a> nodes still unlowered. </p>
<p>If the corresponding functions have a debug_file set, then inject code that will dump the contents of those functions to a file after the realization. </p>

</div>
</div>
<a class="anchor" id="aaa9b678f3916b022dd8b8415c9ca0750"></a><!-- doxytag: member="Halide::Internal::extract_odd_lanes" ref="aaa9b678f3916b022dd8b8415c9ca0750" args="(Expr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#aaa9b678f3916b022dd8b8415c9ca0750">Halide::Internal::extract_odd_lanes</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract the odd-numbered lanes in a vector. </p>

</div>
</div>
<a class="anchor" id="a017315ab942e526e9915325f05d406a0"></a><!-- doxytag: member="Halide::Internal::extract_even_lanes" ref="a017315ab942e526e9915325f05d406a0" args="(Expr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a017315ab942e526e9915325f05d406a0">Halide::Internal::extract_even_lanes</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract the even-numbered lanes in a vector. </p>

</div>
</div>
<a class="anchor" id="a750c306ff019e4f332238799979c9345"></a><!-- doxytag: member="Halide::Internal::extract_lane" ref="a750c306ff019e4f332238799979c9345" args="(Expr vec, int lane)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a750c306ff019e4f332238799979c9345">Halide::Internal::extract_lane</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract the nth lane of a vector. </p>

</div>
</div>
<a class="anchor" id="ac1233a717a83d74121106b95245ce81a"></a><!-- doxytag: member="Halide::Internal::rewrite_interleavings" ref="ac1233a717a83d74121106b95245ce81a" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#ac1233a717a83d74121106b95245ce81a">Halide::Internal::rewrite_interleavings</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic. </p>

</div>
</div>
<a class="anchor" id="a8dc1b0ff156c8b0ca5fd26956ee482a9"></a><!-- doxytag: member="Halide::Internal::deinterleave_vector_test" ref="a8dc1b0ff156c8b0ca5fd26956ee482a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a8dc1b0ff156c8b0ca5fd26956ee482a9">Halide::Internal::deinterleave_vector_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a534a3b8f52a0441dbb0fb7ab2aed3341"></a><!-- doxytag: member="Halide::Internal::finite_difference" ref="a534a3b8f52a0441dbb0fb7ab2aed3341" args="(Expr expr, const std::string &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a534a3b8f52a0441dbb0fb7ab2aed3341">Halide::Internal::finite_difference</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the analytic derivative of the expression with respect to the variable. </p>
<p>May returned an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> if it's non-differentiable. Compute the finite difference version of the derivative: expr(var+1) - expr(var). The reason to do this as a derivative, instead of just explicitly constructing expr(var+1) - expr(var), is so that we don't have to do so much simplification later. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, the finite-difference derivative of 2*x is trivially 2, whereas 2*(x+1) - 2*x may or may not simplify down to 2, depending on the quality of our simplification routine.</p>
<p>Most rules for the finite difference and the true derivative are the same. The quotient and product rules are not. </p>

</div>
</div>
<a class="anchor" id="af7ad39c95e126e3cdfe7ce5a72fa5f51"></a><!-- doxytag: member="Halide::Internal::is_monotonic" ref="af7ad39c95e126e3cdfe7ce5a72fa5f51" args="(Expr e, const std::string &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">MonotonicResult</a> <a class="el" href="namespace_halide_1_1_internal.html#af7ad39c95e126e3cdfe7ce5a72fa5f51">Halide::Internal::is_monotonic</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5aedffca433bdfab639e4956779040e6"></a><!-- doxytag: member="Halide::Internal::inject_early_frees" ref="a5aedffca433bdfab639e4956779040e6" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a5aedffca433bdfab639e4956779040e6">Halide::Internal::inject_early_frees</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation. </p>
<p>Targets may use this to free buffers earlier than the close of their <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a> node. </p>

</div>
</div>
<a class="anchor" id="af239670eead776a941de1cb3f1a93202"></a><!-- doxytag: member="Halide::Internal::expr_uses_var" ref="af239670eead776a941de1cb3f1a93202" args="(Expr e, const std::string &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_halide_1_1_internal.html#af239670eead776a941de1cb3f1a93202">Halide::Internal::expr_uses_var</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if an expression references the given variable. </p>

</div>
</div>
<a class="anchor" id="aaada81b273cd0d0f1b9f722fbd758e4a"></a><!-- doxytag: member="Halide::Internal::expr_uses_vars" ref="aaada81b273cd0d0f1b9f722fbd758e4a" args="(Expr e, const Scope&lt; T &gt; &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_halide_1_1_internal.html#aaada81b273cd0d0f1b9f722fbd758e4a">Halide::Internal::expr_uses_vars</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if an expression references any of the variables in a scope. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00035">35</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_i_r_8h_source.html#l00110">Halide::Internal::IRHandle::accept()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00030">Halide::Internal::ExprUsesVars&lt; T &gt;::result</a>.</p>

</div>
</div>
<a class="anchor" id="a16b42e90ad180f1254cdd3be0ae7be89"></a><!-- doxytag: member="Halide::Internal::find_direct_calls" ref="a16b42e90ad180f1254cdd3be0ae7be89" args="(Function f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#a16b42e90ad180f1254cdd3be0ae7be89">Halide::Internal::find_direct_calls</a> </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition object for all <a class="el" href="namespace_halide.html">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, including in update definitions, update index expressions, and <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> extents. </p>
<p>This map _does not_ include the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, unless it is called recursively by itself. </p>

</div>
</div>
<a class="anchor" id="a770da2a7374eb2a8ac60f5c9d90b88ad"></a><!-- doxytag: member="Halide::Internal::find_transitive_calls" ref="a770da2a7374eb2a8ac60f5c9d90b88ad" args="(Function f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#a770da2a7374eb2a8ac60f5c9d90b88ad">Halide::Internal::find_transitive_calls</a> </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> definition object for all <a class="el" href="namespace_halide.html">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f, or indirectly in those functions' definitions, recursively. </p>
<p>This map always _includes_ the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Function</a> f. </p>

</div>
</div>
<a class="anchor" id="a0081752824625e87b5e95bfae979499f"></a><!-- doxytag: member="Halide::Internal::fuse_gpu_thread_loops" ref="a0081752824625e87b5e95bfae979499f" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a0081752824625e87b5e95bfae979499f">Halide::Internal::fuse_gpu_thread_loops</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts <a class="el" href="namespace_halide.html">Halide</a>'s GPGPU IR to the OpenCL/CUDA model. </p>
<p>Within every loop over gpu block indices, fuse the inner loops over thread indices into a single loop (with predication to turn off threads). Also injects synchronization points as needed, and hoists allocations at the block level out into a single shared memory array. </p>

</div>
</div>
<a class="anchor" id="ab5ba1224136725f64d43e7c83d4ed603"></a><!-- doxytag: member="Halide::Internal::inject_host_dev_buffer_copies" ref="ab5ba1224136725f64d43e7c83d4ed603" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#ab5ba1224136725f64d43e7c83d4ed603">Halide::Internal::inject_host_dev_buffer_copies</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inject calls to halide_dev_malloc, halide_copy_to_dev, and halide_copy_to_host as needed. </p>

</div>
</div>
<a class="anchor" id="a70fcc88dde228e4f70a90d4848ddb773"></a><!-- doxytag: member="Halide::Internal::inject_dev_frees" ref="a70fcc88dde228e4f70a90d4848ddb773" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a70fcc88dde228e4f70a90d4848ddb773">Halide::Internal::inject_dev_frees</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inject calls to halide_dev_free as needed. </p>

</div>
</div>
<a class="anchor" id="a94843d09c24cd65c12aa022e0ae3bb70"></a><!-- doxytag: member="Halide::Internal::inject_opengl_intrinsics" ref="a94843d09c24cd65c12aa022e0ae3bb70" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a94843d09c24cd65c12aa022e0ae3bb70">Halide::Internal::inject_opengl_intrinsics</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement with for kernel for loops and turn loads and stores inside the loops into OpenGL texture load and store intrinsics. </p>
<p>Should only be run when the OpenGL target is active. </p>

</div>
</div>
<a class="anchor" id="a38c4753b75f784e928d24b5f085ed383"></a><!-- doxytag: member="Halide::Internal::inline_function" ref="a38c4753b75f784e928d24b5f085ed383" args="(Stmt, Function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a38c4753b75f784e928d24b5f085ed383">Halide::Internal::inline_function</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inline a single named function, which must be pure. </p>

</div>
</div>
<a class="anchor" id="a839846970613235cae5c8904a5fda794"></a><!-- doxytag: member="Halide::Internal::inline_function" ref="a839846970613235cae5c8904a5fda794" args="(Expr, Function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a38c4753b75f784e928d24b5f085ed383">Halide::Internal::inline_function</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inline a single named function, which must be pure. </p>

</div>
</div>
<a class="anchor" id="a66571ec4623be1b2eb6d37e05372dbf0"></a><!-- doxytag: member="Halide::Internal::get_variable_name" ref="a66571ec4623be1b2eb6d37e05372dbf0" args="(const void *, const std::string &amp;expected_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string <a class="el" href="namespace_halide_1_1_internal.html#a66571ec4623be1b2eb6d37e05372dbf0">Halide::Internal::get_variable_name</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expected_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of a stack variable from its address. </p>
<p>The stack variable must be in a compilation unit compiled with -g to work. The expected type helps distinguish between variables at the same address, e.g a class instance vs its first member. </p>

</div>
</div>
<a class="anchor" id="a91836225c3f9b432897eb22c67962465"></a><!-- doxytag: member="Halide::Internal::get_source_location" ref="a91836225c3f9b432897eb22c67962465" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string <a class="el" href="namespace_halide_1_1_internal.html#a91836225c3f9b432897eb22c67962465">Halide::Internal::get_source_location</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the source location in the call stack, skipping over calls in the <a class="el" href="namespace_halide.html">Halide</a> namespace. </p>

<p>Referenced by <a class="el" href="_error_8h_source.html#l00055">Halide::Internal::ErrorReport::ErrorReport()</a>.</p>

</div>
</div>
<a class="anchor" id="a118e692f18d13b851c0d537b172b2f10"></a><!-- doxytag: member="Halide::Internal::test_compilation_unit" ref="a118e692f18d13b851c0d537b172b2f10" args="(bool(*test)(), void(*calib)())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="namespace_halide_1_1_internal.html#a118e692f18d13b851c0d537b172b2f10">Halide::Internal::test_compilation_unit</a> </td>
          <td>(</td>
          <td class="paramtype">bool(*)()&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>calib</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ff5beef3c5a4ec908d9c2bbe99a71f9"></a><!-- doxytag: member="Halide::Internal::ref_count" ref="a9ff5beef3c5a4ec908d9c2bbe99a71f9" args="(const T *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; <a class="el" href="namespace_halide_1_1_internal.html#a9ff5beef3c5a4ec908d9c2bbe99a71f9">Halide::Internal::ref_count</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here. </p>
<p>E.g. if you want to use IntrusivePtr&lt;MyClass&gt;, then you should define something like this in MyClass.cpp (assuming MyClass has a field: mutable <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> ref_count):</p>
<p>template&lt;&gt; <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> &amp;ref_count&lt;MyClass&gt;(const MyClass *c) {return c-&gt;ref_count;} template&lt;&gt; void destroy&lt;MyClass&gt;(const MyClass *c) {delete c;} </p>

</div>
</div>
<a class="anchor" id="ada37ff426984f7459fe0bbe38b9e11f0"></a><!-- doxytag: member="Halide::Internal::destroy" ref="ada37ff426984f7459fe0bbe38b9e11f0" args="(const T *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="namespace_halide_1_1_internal.html#ada37ff426984f7459fe0bbe38b9e11f0">Halide::Internal::destroy</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here. </p>
<p>E.g. if you want to use IntrusivePtr&lt;MyClass&gt;, then you should define something like this in MyClass.cpp (assuming MyClass has a field: mutable <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> ref_count):</p>
<p>template&lt;&gt; <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr.">RefCount</a> &amp;ref_count&lt;MyClass&gt;(const MyClass *c) {return c-&gt;ref_count;} template&lt;&gt; void destroy&lt;MyClass&gt;(const MyClass *c) {delete c;} </p>

</div>
</div>
<a class="anchor" id="acc591095a8e56d4d6f6587c66239fdb3"></a><!-- doxytag: member="Halide::Internal::ref_count&lt; IRNode &gt;" ref="acc591095a8e56d4d6f6587c66239fdb3" args="(const IRNode *n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; <a class="el" href="namespace_halide_1_1_internal.html#a9ff5beef3c5a4ec908d9c2bbe99a71f9">Halide::Internal::ref_count</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const IRNode *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_8h_source.html#l00054">54</a> of file <a class="el" href="_i_r_8h_source.html">IR.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7e3867f02d52edd32b4cfe38e5ee55a1"></a><!-- doxytag: member="Halide::Internal::destroy&lt; IRNode &gt;" ref="a7e3867f02d52edd32b4cfe38e5ee55a1" args="(const IRNode *n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="namespace_halide_1_1_internal.html#ada37ff426984f7459fe0bbe38b9e11f0">Halide::Internal::destroy</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const IRNode *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_8h_source.html#l00057">57</a> of file <a class="el" href="_i_r_8h_source.html">IR.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31dc49947eec58e14aab236c7b0182ee"></a><!-- doxytag: member="Halide::Internal::equal" ref="a31dc49947eec58e14aab236c7b0182ee" args="(Expr a, Expr b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#a31dc49947eec58e14aab236c7b0182ee">Halide::Internal::equal</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a> </p>

</div>
</div>
<a class="anchor" id="a4d404e95dced22ae673144c0351f186f"></a><!-- doxytag: member="Halide::Internal::equal" ref="a4d404e95dced22ae673144c0351f186f" args="(Stmt a, Stmt b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#a31dc49947eec58e14aab236c7b0182ee">Halide::Internal::equal</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a> </p>

</div>
</div>
<a class="anchor" id="a65590b80d11a0b92f74cf17d9fa5cf49"></a><!-- doxytag: member="Halide::Internal::deep_compare" ref="a65590b80d11a0b92f74cf17d9fa5cf49" args="(Expr a, Expr b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int <a class="el" href="namespace_halide_1_1_internal.html#a65590b80d11a0b92f74cf17d9fa5cf49">Halide::Internal::deep_compare</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a lexical ordering on IR nodes. </p>
<p>Returns -1 if the first expression is before the second, 0 if they're equal, and 1 if the first expression is after the second. </p>

<p>Referenced by <a class="el" href="_i_r_equality_8h_source.html#l00031">Halide::Internal::ExprDeepCompare::operator()()</a>, and <a class="el" href="_i_r_equality_8h_source.html#l00039">Halide::Internal::StmtDeepCompare::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a19c9545816a6a6e120b5681d20bf7055"></a><!-- doxytag: member="Halide::Internal::deep_compare" ref="a19c9545816a6a6e120b5681d20bf7055" args="(Stmt a, Stmt b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int <a class="el" href="namespace_halide_1_1_internal.html#a65590b80d11a0b92f74cf17d9fa5cf49">Halide::Internal::deep_compare</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes a lexical ordering on IR nodes. </p>
<p>Returns -1 if the first expression is before the second, 0 if they're equal, and 1 if the first expression is after the second. </p>

</div>
</div>
<a class="anchor" id="af22936be5f74cc50d73a4e478bd9271e"></a><!-- doxytag: member="Halide::Internal::expr_match" ref="af22936be5f74cc50d73a4e478bd9271e" args="(Expr pattern, Expr expr, std::vector&lt; Expr &gt; &amp;result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_halide_1_1_internal.html#af22936be5f74cc50d73a4e478bd9271e">Halide::Internal::expr_match</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example: </p>
<div class="fragment"><pre class="fragment"> Expr x = <span class="keyword">new</span> Variable(<a class="code" href="namespace_halide.html#acf59f500385c448b26d0d245f55b23f4" title="Constructing a signed integer type.">Int</a>(32), <span class="stringliteral">&quot;*&quot;</span>);
 match(x + x, 3 + (2*k), result)
</pre></div><p> should return true, and set result[0] to 3 and result[1] to 2*k. </p>

</div>
</div>
<a class="anchor" id="a1eed932bc0eb3a15edcb20795bfb8c2f"></a><!-- doxytag: member="Halide::Internal::expr_match_test" ref="a1eed932bc0eb3a15edcb20795bfb8c2f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a1eed932bc0eb3a15edcb20795bfb8c2f">Halide::Internal::expr_match_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab370d99a882a8163ae91d43b94d79d02"></a><!-- doxytag: member="Halide::Internal::is_const" ref="ab370d99a882a8163ae91d43b94d79d02" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#ab370d99a882a8163ae91d43b94d79d02">Halide::Internal::is_const</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="Cast a node from one type to another.">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node.">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same. </p>
<p>Doesn't do any constant folding. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00256">Halide::operator%()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00237">Halide::operator/()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00247">Halide::operator/=()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b709fdbc5a6944248187216b5df5b2e"></a><!-- doxytag: member="Halide::Internal::is_const" ref="a4b709fdbc5a6944248187216b5df5b2e" args="(Expr e, int v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#ab370d99a882a8163ae91d43b94d79d02">Halide::Internal::is_const</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="Cast a node from one type to another.">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;.">Broadcast</a> of the same. </p>

</div>
</div>
<a class="anchor" id="a68b76ccfb1d4e7cc35ff65f15f9b0077"></a><!-- doxytag: member="Halide::Internal::as_const_int" ref="a68b76ccfb1d4e7cc35ff65f15f9b0077" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const int* <a class="el" href="namespace_halide_1_1_internal.html#a68b76ccfb1d4e7cc35ff65f15f9b0077">Halide::Internal::as_const_int</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants.">IntImm</a>, return a pointer to its value. </p>
<p>Otherwise returns NULL. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00729">Halide::fast_pow()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00950">Halide::lerp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00697">Halide::pow()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00387">Halide::select()</a>.</p>

</div>
</div>
<a class="anchor" id="af2a9edb743eaf6d8074867314247a970"></a><!-- doxytag: member="Halide::Internal::as_const_float" ref="af2a9edb743eaf6d8074867314247a970" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const float* <a class="el" href="namespace_halide_1_1_internal.html#af2a9edb743eaf6d8074867314247a970">Halide::Internal::as_const_float</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants.">FloatImm</a>, return a pointer to its value. </p>
<p>Otherwise returns NULL. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00950">Halide::lerp()</a>.</p>

</div>
</div>
<a class="anchor" id="a2399da4e027488064c4d14a2469f9fc3"></a><!-- doxytag: member="Halide::Internal::is_const_power_of_two" ref="a2399da4e027488064c4d14a2469f9fc3" args="(Expr e, int *bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#a2399da4e027488064c4d14a2469f9fc3">Halide::Internal::is_const_power_of_two</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression a constant integer power of two. </p>
<p>Also returns log base two of the expression if it is. </p>

</div>
</div>
<a class="anchor" id="ad050aaa17987fa4cbb8fd4d41c952e04"></a><!-- doxytag: member="Halide::Internal::is_positive_const" ref="ad050aaa17987fa4cbb8fd4d41c952e04" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#ad050aaa17987fa4cbb8fd4d41c952e04">Halide::Internal::is_positive_const</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="acc39652dfc1d64fb82d02dc4064185d7"></a><!-- doxytag: member="Halide::Internal::is_negative_const" ref="acc39652dfc1d64fb82d02dc4064185d7" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#acc39652dfc1d64fb82d02dc4064185d7">Halide::Internal::is_negative_const</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="a1a521ef987e7964954b997e6dcc5e65b"></a><!-- doxytag: member="Halide::Internal::is_zero" ref="a1a521ef987e7964954b997e6dcc5e65b" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#a1a521ef987e7964954b997e6dcc5e65b">Halide::Internal::is_zero</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="a940b37091a8f16bf1e4a78db7764274e"></a><!-- doxytag: member="Halide::Internal::is_one" ref="a940b37091a8f16bf1e4a78db7764274e" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#a940b37091a8f16bf1e4a78db7764274e">Halide::Internal::is_one</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="abeed2f66190d11ee6e56e4089a1f441b"></a><!-- doxytag: member="Halide::Internal::is_two" ref="abeed2f66190d11ee6e56e4089a1f441b" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#abeed2f66190d11ee6e56e4089a1f441b">Halide::Internal::is_two</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="a225fbecd4560e77ea24cb16541fe6b15"></a><!-- doxytag: member="Halide::Internal::int_cast_constant" ref="a225fbecd4560e77ea24cb16541fe6b15" args="(Type t, int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int <a class="el" href="namespace_halide_1_1_internal.html#a225fbecd4560e77ea24cb16541fe6b15">Halide::Internal::int_cast_constant</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an integer value, cast it into a designated integer type and return the bits as int. </p>
<p>Unsigned types are returned as bits in the int and should be cast to unsigned int for comparison. int_cast_constant implements bit manipulations to wrap val into the value range of the <a class="el" href="struct_halide_1_1_type.html" title="Types in the halide type system.">Type</a> t. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, int_cast_constant(UInt(16), -1) returns 65535 int_cast_constant(Int(8), 128) returns -128 </p>

</div>
</div>
<a class="anchor" id="ab48739c460778f7af77999cfd251d5af"></a><!-- doxytag: member="Halide::Internal::make_const" ref="ab48739c460778f7af77999cfd251d5af" args="(Type t, int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#ab48739c460778f7af77999cfd251d5af">Halide::Internal::make_const</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a const of the given type. </p>

</div>
</div>
<a class="anchor" id="a1e258c84149c36aad7d93cced54cd173"></a><!-- doxytag: member="Halide::Internal::make_bool" ref="a1e258c84149c36aad7d93cced54cd173" args="(bool val, int width=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a1e258c84149c36aad7d93cced54cd173">Halide::Internal::make_bool</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a boolean constant from a C++ boolean value. </p>
<p>May also be a vector if width is given. It is not possible to coerce a C++ boolean to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> because if we provide such a path then char objects can ambiguously be converted to <a class="el" href="namespace_halide.html">Halide</a> <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> or to std::string. The problem is that C++ does not have a real bool type - it is in fact close enough to char that C++ does not know how to distinguish them. make_bool is the explicit coercion. </p>

</div>
</div>
<a class="anchor" id="a57fedf535d58f8900f8b7c00aa15ece8"></a><!-- doxytag: member="Halide::Internal::make_zero" ref="a57fedf535d58f8900f8b7c00aa15ece8" args="(Type t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a57fedf535d58f8900f8b7c00aa15ece8">Halide::Internal::make_zero</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the representation of zero in the given type. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00204">Halide::operator-()</a>.</p>

</div>
</div>
<a class="anchor" id="ace305dbdd7fed2cf9d5057d4c02067c9"></a><!-- doxytag: member="Halide::Internal::make_one" ref="ace305dbdd7fed2cf9d5057d4c02067c9" args="(Type t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#ace305dbdd7fed2cf9d5057d4c02067c9">Halide::Internal::make_one</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the representation of one in the given type. </p>

</div>
</div>
<a class="anchor" id="afc35f0dc3562ffb5bb777021679435e2"></a><!-- doxytag: member="Halide::Internal::make_two" ref="afc35f0dc3562ffb5bb777021679435e2" args="(Type t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#afc35f0dc3562ffb5bb777021679435e2">Halide::Internal::make_two</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the representation of two in the given type. </p>

</div>
</div>
<a class="anchor" id="a0f8e27a136a9facf0e97e6ac6bd71c23"></a><!-- doxytag: member="Halide::Internal::const_true" ref="a0f8e27a136a9facf0e97e6ac6bd71c23" args="(int width=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a0f8e27a136a9facf0e97e6ac6bd71c23">Halide::Internal::const_true</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the constant boolean true. </p>
<p>May also be a vector of trues, if a width argument is given. </p>

</div>
</div>
<a class="anchor" id="a6c5d4e90106e92aa21840547b6588eb3"></a><!-- doxytag: member="Halide::Internal::const_false" ref="a6c5d4e90106e92aa21840547b6588eb3" args="(int width=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a6c5d4e90106e92aa21840547b6588eb3">Halide::Internal::const_false</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the constant boolean false. </p>
<p>May also be a vector of falses, if a width argument is given. </p>

</div>
</div>
<a class="anchor" id="ab40a26aac941b763435e9915851cd073"></a><!-- doxytag: member="Halide::Internal::match_types" ref="ab40a26aac941b763435e9915851cd073" args="(Expr &amp;a, Expr &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types</a> </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Coerce the two expressions to have the same type, using C-style casting rules. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> the purposes of casting, a boolean type is UInt(1). We use the following procedure:</p>
<p>If the types already match, do nothing.</p>
<p>Then, if one type is a vector and the other is a scalar, the scalar is broadcast to match the vector width, and we continue.</p>
<p>Then, if one type is floating-point and the other is not, the non-float is cast to the floating-point type, and we're done.</p>
<p>Then, if neither is a float but one of the two is a constant, the constant is cast to match the non-const type and we're done. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, e has type UInt(8), then (e*32) also has type UInt(8), despite the overflow that may occur. Note that this also means that (e*(-1)) is positive, and is equivalent to (e*255) - i.e. the (-1) is cast to a UInt(8) before the multiplication.</p>
<p>Then, if both types are unsigned ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Then, if both types are signed ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Finally, if one type is an unsigned int and the other type is a signed int, both are cast to a signed int with the greater of the two bit-widths. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, matching an Int(8) with a UInt(16) results in an Int(16). </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00337">Halide::max()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00348">Halide::min()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00312">Halide::operator!=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00256">Halide::operator%()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00220">Halide::operator*()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00176">Halide::operator+()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00193">Halide::operator-()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00237">Halide::operator/()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00275">Halide::operator&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00860">Halide::operator&lt;&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00284">Halide::operator&lt;=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00303">Halide::operator==()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00266">Halide::operator&gt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00294">Halide::operator&gt;=()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00876">Halide::operator&gt;&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="af36627bf7242718b1c73214296dc9090"></a><!-- doxytag: member="Halide::Internal::halide_log" ref="af36627bf7242718b1c73214296dc9090" args="(Expr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#af36627bf7242718b1c73214296dc9090">Halide::Internal::halide_log</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespace_halide.html">Halide</a>'s vectorizable transcendentals. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00681">Halide::log()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00697">Halide::pow()</a>.</p>

</div>
</div>
<a class="anchor" id="a5688772a963296ea52d2bd9ac5913e79"></a><!-- doxytag: member="Halide::Internal::halide_exp" ref="a5688772a963296ea52d2bd9ac5913e79" args="(Expr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a5688772a963296ea52d2bd9ac5913e79">Halide::Internal::halide_exp</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespace_halide.html">Halide</a>'s vectorizable transcendentals. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00664">Halide::exp()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00697">Halide::pow()</a>.</p>

</div>
</div>
<a class="anchor" id="ac5890bd4a8aae2f1f6a2c43496d8ddae"></a><!-- doxytag: member="Halide::Internal::raise_to_integer_power" ref="ac5890bd4a8aae2f1f6a2c43496d8ddae" args="(Expr a, int b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#ac5890bd4a8aae2f1f6a2c43496d8ddae">Halide::Internal::raise_to_integer_power</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Raise an expression to an integer power by repeatedly multiplying it by itself. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00729">Halide::fast_pow()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00697">Halide::pow()</a>.</p>

</div>
</div>
<a class="anchor" id="aa67dad74ce8739ca7773f6032e51d5c6"></a><!-- doxytag: member="Halide::Internal::operator&lt;&lt;" ref="aa67dad74ce8739ca7773f6032e51d5c6" args="(std::ostream &amp;stream, const For::ForType &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const For::ForType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emit a halide for loop type (vectorized, serial, etc) in a human readable form. </p>

</div>
</div>
<a class="anchor" id="a2c00a579c3d86ae40920d5fc4ffe64cf"></a><!-- doxytag: member="Halide::Internal::lower_lerp" ref="a2c00a579c3d86ae40920d5fc4ffe64cf" args="(Expr zero_val, Expr one_val, Expr weight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="namespace_halide_1_1_internal.html#a2c00a579c3d86ae40920d5fc4ffe64cf">Halide::Internal::lower_lerp</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>zero_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>one_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build <a class="el" href="namespace_halide.html">Halide</a> IR that computes a lerp. </p>
<p>Use by codegen targets that don't have a native lerp. </p>

</div>
</div>
<a class="anchor" id="a95f0cfbb7653be4145fe4cedd9a15dfa"></a><!-- doxytag: member="Halide::Internal::lift_loop_invariants" ref="a95f0cfbb7653be4145fe4cedd9a15dfa" args="(Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a95f0cfbb7653be4145fe4cedd9a15dfa">Halide::Internal::lift_loop_invariants</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pull all let statements as far out as possible. </p>
<p>In particular, pull them outside of loops if they don't depend on the loop variable. </p>

</div>
</div>
<a class="anchor" id="a3d53906d81dae46b049456d5430abedd"></a><!-- doxytag: member="Halide::Internal::lower" ref="a3d53906d81dae46b049456d5430abedd" args="(Function f, const Target &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a3d53906d81dae46b049456d5430abedd">Halide::Internal::lower</a> </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a halide function with a schedule, create a statement that evaluates it. </p>
<p>Automatically pulls in all the functions f depends on. Some stages of lowering may be target-specific. </p>

</div>
</div>
<a class="anchor" id="a4d3bfe43201bab68cf4820993fe1469b"></a><!-- doxytag: member="Halide::Internal::lower_test" ref="a4d3bfe43201bab68cf4820993fe1469b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a4d3bfe43201bab68cf4820993fe1469b">Halide::Internal::lower_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7298e57b1434cccc072c45b6f5c6efef"></a><!-- doxytag: member="Halide::Internal::modulus_remainder" ref="a7298e57b1434cccc072c45b6f5c6efef" args="(Expr e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> <a class="el" href="namespace_halide_1_1_internal.html#a7298e57b1434cccc072c45b6f5c6efef">Halide::Internal::modulus_remainder</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> example, it is straight-forward to deduce that ((10*x + 2)*(6*y - 3) - 1) is congruent to five modulo six.</p>
<p>We get the most information when the modulus is large. E.g. if something is congruent to 208 modulo 384, then we also know it's congruent to 0 mod 8, and we can possibly use it as an index for an aligned load. If all else fails, we can just say that an integer is congruent to zero modulo one. </p>

</div>
</div>
<a class="anchor" id="a8489fb5b4449835f26313a57e856c4b3"></a><!-- doxytag: member="Halide::Internal::modulus_remainder" ref="a8489fb5b4449835f26313a57e856c4b3" args="(Expr e, const Scope&lt; ModulusRemainder &gt; &amp;scope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> <a class="el" href="namespace_halide_1_1_internal.html#a7298e57b1434cccc072c45b6f5c6efef">Halide::Internal::modulus_remainder</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; ModulusRemainder &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder: </p>

</div>
</div>
<a class="anchor" id="af210d0f6ae102d704259f49bb32adc2f"></a><!-- doxytag: member="Halide::Internal::reduce_expr_modulo" ref="af210d0f6ae102d704259f49bb32adc2f" args="(Expr e, int modulus, int *remainder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_halide_1_1_internal.html#af210d0f6ae102d704259f49bb32adc2f">Halide::Internal::reduce_expr_modulo</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>remainder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reduce an expression modulo some integer. </p>
<p>Returns true and assigns to remainder if an answer could be found. </p>

</div>
</div>
<a class="anchor" id="a789149daec96e933f8758f71f8474dd6"></a><!-- doxytag: member="Halide::Internal::modulus_remainder_test" ref="a789149daec96e933f8758f71f8474dd6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a789149daec96e933f8758f71f8474dd6">Halide::Internal::modulus_remainder_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a50891465f948d4f9b30b9253ce1640b1"></a><!-- doxytag: member="Halide::Internal::gcd" ref="a50891465f948d4f9b30b9253ce1640b1" args="(int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespace_halide_1_1_internal.html#a50891465f948d4f9b30b9253ce1640b1">Halide::Internal::gcd</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The greatest common divisor of two integers. </p>

</div>
</div>
<a class="anchor" id="ab56d2d1c54f988f23aa03ae70cdfd857"></a><!-- doxytag: member="Halide::Internal::lcm" ref="ab56d2d1c54f988f23aa03ae70cdfd857" args="(int, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespace_halide_1_1_internal.html#ab56d2d1c54f988f23aa03ae70cdfd857">Halide::Internal::lcm</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The least common multiple of two integers. </p>

</div>
</div>
<a class="anchor" id="a36620e2156363b215b17fae00eec44ea"></a><!-- doxytag: member="Halide::Internal::is_one_to_one" ref="a36620e2156363b215b17fae00eec44ea" args="(Expr expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_halide_1_1_internal.html#a36620e2156363b215b17fae00eec44ea">Halide::Internal::is_one_to_one</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Conservatively determine whether an integer expression is one-to-one in its variables. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop.">For</a> now this means it contains a single variable and its derivative is provably strictly positive or strictly negative. </p>

</div>
</div>
<a class="anchor" id="acd3b8d6aeed9a003fe228ad1aba7322f"></a><!-- doxytag: member="Halide::Internal::is_one_to_one_test" ref="acd3b8d6aeed9a003fe228ad1aba7322f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#acd3b8d6aeed9a003fe228ad1aba7322f">Halide::Internal::is_one_to_one_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ce66817377fbb1918bbe7510ab47b29"></a><!-- doxytag: member="Halide::Internal::check_call_arg_types" ref="a0ce66817377fbb1918bbe7510ab47b29" args="(const std::string &amp;name, std::vector&lt; Expr &gt; *args, int dims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a0ce66817377fbb1918bbe7510ab47b29">Halide::Internal::check_call_arg_types</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Expr &gt; *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate arguments to a call to a func, image or imageparam. </p>

</div>
</div>
<a class="anchor" id="a568a0554db6866ee8560c3f599bceadd"></a><!-- doxytag: member="Halide::Internal::inject_profiling" ref="a568a0554db6866ee8560c3f599bceadd" args="(Stmt, std::string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a568a0554db6866ee8560c3f599bceadd">Halide::Internal::inject_profiling</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement representing a halide pipeline, and (depending on the environment variable HL_PROFILE), insert high-resolution timing into the generated code; summaries of execution times and counts will be logged at the end. </p>
<p>Should be done before storage flattening, but after all bounds inference. Use util/HalideProf to analyze the output.</p>
<p>NOTE: this makes no effort to provide accurate or useful information when parallelization is scheduled; more work would need to be done to safely record data from multiple threads.</p>
<p>NOTE: this makes no effort to account for overhead from the profiling instructions inserted; profile-enabled runtimes will be slower, and inner loops will be more profoundly affected. </p>

</div>
</div>
<a class="anchor" id="ae828a911751c5115cb503d05afb1dcbe"></a><!-- doxytag: member="Halide::Internal::profiling_level" ref="ae828a911751c5115cb503d05afb1dcbe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespace_halide_1_1_internal.html#ae828a911751c5115cb503d05afb1dcbe">Halide::Internal::profiling_level</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current profiling level (by reading HL_PROFILE) </p>

</div>
</div>
<a class="anchor" id="add0c1d3ac79fd83cb609d37831253957"></a><!-- doxytag: member="Halide::Internal::qualify" ref="add0c1d3ac79fd83cb609d37831253957" args="(const std::string &amp;prefix, Expr value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#add0c1d3ac79fd83cb609d37831253957">Halide::Internal::qualify</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prefix all variable names in the given expression with the prefix string. </p>

</div>
</div>
<a class="anchor" id="a795f343747d7f716a33198907c3e7d25"></a><!-- doxytag: member="Halide::Internal::random_float" ref="a795f343747d7f716a33198907c3e7d25" args="(const std::vector&lt; Expr &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a795f343747d7f716a33198907c3e7d25">Halide::Internal::random_float</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a random floating-point number between zero and one that varies deterministically based on the input expressions. </p>

</div>
</div>
<a class="anchor" id="ae4e64539c6d89123f6200b919ec28fbb"></a><!-- doxytag: member="Halide::Internal::random_int" ref="ae4e64539c6d89123f6200b919ec28fbb" args="(const std::vector&lt; Expr &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#ae4e64539c6d89123f6200b919ec28fbb">Halide::Internal::random_int</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a random unsigned integer between zero and 2^32-1 that varies deterministically based on the input expressions (which must be integers). </p>

</div>
</div>
<a class="anchor" id="a0f875bf4d528885d68581fbd198bf356"></a><!-- doxytag: member="Halide::Internal::lower_random" ref="a0f875bf4d528885d68581fbd198bf356" args="(Expr e, const std::vector&lt; std::string &gt; &amp;free_vars, int tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a0f875bf4d528885d68581fbd198bf356">Halide::Internal::lower_random</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>free_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert calls to random() to IR generated by random_float and random_int. </p>
<p>Tags all calls with the variables in free_vars, and the integer given as the last argument. </p>

</div>
</div>
<a class="anchor" id="a445fa778b28abf135eb1b1d0c8389efc"></a><!-- doxytag: member="Halide::Internal::remove_trivial_for_loops" ref="a445fa778b28abf135eb1b1d0c8389efc" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a445fa778b28abf135eb1b1d0c8389efc">Halide::Internal::remove_trivial_for_loops</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert for loops of size 1 into <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node.">LetStmt</a> nodes, which allows for further simplification. </p>
<p>Done during a late stage of lowering. </p>

</div>
</div>
<a class="anchor" id="a078fe646230de310959c4506c76de02e"></a><!-- doxytag: member="Halide::Internal::remove_undef" ref="a078fe646230de310959c4506c76de02e" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a078fe646230de310959c4506c76de02e">Halide::Internal::remove_undef</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes stores that depend on undef values, and statements that only contain such stores. </p>

</div>
</div>
<a class="anchor" id="a4242a0b28a7409d2a2489a74795914ef"></a><!-- doxytag: member="Halide::Internal::operator&lt;&lt;" ref="a4242a0b28a7409d2a2489a74795914ef" args="(std::ostream &amp;stream, const Scope&lt; T &gt; &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_scope_8h_source.html#l00198">198</a> of file <a class="el" href="_scope_8h_source.html">Scope.h</a>.</p>

<p>References <a class="el" href="_scope_8h_source.html#l00137">Halide::Internal::Scope&lt; T &gt;::const_iterator::name()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7b681bba7782bb83ff3bfd6341fd5a9"></a><!-- doxytag: member="Halide::Internal::simplify" ref="ad7b681bba7782bb83ff3bfd6341fd5a9" args="(Stmt, bool remove_dead_lets=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#ad7b681bba7782bb83ff3bfd6341fd5a9">Halide::Internal::simplify</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_dead_lets</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc. </p>
<p>Simplifies across let statements, so must not be called on stmts with dangling or repeated variable names. </p>

</div>
</div>
<a class="anchor" id="a71eca1a06e6305effb6bc10941d397f0"></a><!-- doxytag: member="Halide::Internal::simplify" ref="a71eca1a06e6305effb6bc10941d397f0" args="(Expr, bool remove_dead_lets=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#ad7b681bba7782bb83ff3bfd6341fd5a9">Halide::Internal::simplify</a> </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_dead_lets</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc. </p>
<p>Simplifies across let statements, so must not be called on stmts with dangling or repeated variable names. </p>

</div>
</div>
<a class="anchor" id="a0faf83270a59e0cf2e3821be2a4666c2"></a><!-- doxytag: member="Halide::Internal::simplify_exprs" ref="a0faf83270a59e0cf2e3821be2a4666c2" args="(Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a0faf83270a59e0cf2e3821be2a4666c2">Halide::Internal::simplify_exprs</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Simplify expressions found in a statement, but don't simplify across different statements. </p>
<p>This is safe to perform at an earlier stage in lowering than full simplification of a stmt. </p>

</div>
</div>
<a class="anchor" id="a6cd3908859c82249a2c7f10158883a97"></a><!-- doxytag: member="Halide::Internal::mod_imp" ref="a6cd3908859c82249a2c7f10158883a97" args="(T a, T b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html">Halide</a>. </p>
<p>Use these implementations; do not use native C division or mod to simplify <a class="el" href="namespace_halide.html">Halide</a> expressions. </p>

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00034">34</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00049">Halide::Type::is_int()</a>.</p>

</div>
</div>
<a class="anchor" id="adff5495089b812474881ee939c4701c4"></a><!-- doxytag: member="Halide::Internal::mod_imp&lt; float &gt;" ref="adff5495089b812474881ee939c4701c4" args="(float a, float b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00043">43</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac9a60708c880da445554b8eeb778c034"></a><!-- doxytag: member="Halide::Internal::mod_imp&lt; double &gt;" ref="ac9a60708c880da445554b8eeb778c034" args="(double a, double b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00048">48</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00743">Halide::floor()</a>.</p>

</div>
</div>
<a class="anchor" id="a0442f9a0450f45683938a69ce0273974"></a><!-- doxytag: member="Halide::Internal::div_imp" ref="a0442f9a0450f45683938a69ce0273974" args="(T a, T b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00055">55</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00028">Halide::Type::bits</a>, and <a class="el" href="_type_8h_source.html#l00049">Halide::Type::is_int()</a>.</p>

</div>
</div>
<a class="anchor" id="a7feea16442755d0a73ec2de1b8889106"></a><!-- doxytag: member="Halide::Internal::simplify_test" ref="a7feea16442755d0a73ec2de1b8889106" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespace_halide_1_1_internal.html#a7feea16442755d0a73ec2de1b8889106">Halide::Internal::simplify_test</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8489422fe4da6e486b5fd7831aab8bfb"></a><!-- doxytag: member="Halide::Internal::skip_stages" ref="a8489422fe4da6e486b5fd7831aab8bfb" args="(Stmt s, const std::vector&lt; std::string &gt; &amp;order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a8489422fe4da6e486b5fd7831aab8bfb">Halide::Internal::skip_stages</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Avoid computing certain stages if we can infer a runtime condition to check that tells us they won't be used. </p>
<p>Does this by aanalyzing all reads of each buffer allocated, and inferring some condition that tells us if the reads occur. If the condition is non-trivial, inject ifs that guard the production. </p>

</div>
</div>
<a class="anchor" id="a07bde9012b280aad21a569ea008ed296"></a><!-- doxytag: member="Halide::Internal::sliding_window" ref="a07bde9012b280aad21a569ea008ed296" args="(Stmt s, const std::map&lt; std::string, Function &gt; &amp;env)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a07bde9012b280aad21a569ea008ed296">Halide::Internal::sliding_window</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform sliding window optimizations on a halide statement. </p>
<p>I.e. don't bother computing points in a function that have provably already been computed by a previous iteration. </p>

</div>
</div>
<a class="anchor" id="ab3d6d20f5581d4711c83a2b1755c2716"></a><!-- doxytag: member="Halide::Internal::specialize_clamped_ramps" ref="ab3d6d20f5581d4711c83a2b1755c2716" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#ab3d6d20f5581d4711c83a2b1755c2716">Halide::Internal::specialize_clamped_ramps</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;.">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer.">Load</a> nodes respectively. </p>

</div>
</div>
<a class="anchor" id="a36bbe2f07f16d251525ee4beaa68c102"></a><!-- doxytag: member="Halide::Internal::storage_flattening" ref="a36bbe2f07f16d251525ee4beaa68c102" args="(Stmt s, const std::map&lt; std::string, Function &gt; &amp;env)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a36bbe2f07f16d251525ee4beaa68c102">Halide::Internal::storage_flattening</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size.">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location.">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call.">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size.">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;.">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer.">Load</a> nodes respectively. </p>

</div>
</div>
<a class="anchor" id="a9eefd272612c586d9c3e4dba31d1c215"></a><!-- doxytag: member="Halide::Internal::storage_folding" ref="a9eefd272612c586d9c3e4dba31d1c215" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a9eefd272612c586d9c3e4dba31d1c215">Halide::Internal::storage_folding</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fold storage of functions if possible. </p>
<p>This means reducing one of the dimensions module something for the purpose of storage, if we can prove that this is safe to do. E.g consider:</p>
<div class="fragment"><pre class="fragment"> f(x) = ...
 g(x) = f(x-1) + f(x)
 f.store_root().compute_at(g, x);
</pre></div><p>We can store f as a circular buffer of size two, instead of allocating space for all of it. </p>

</div>
</div>
<a class="anchor" id="a9cec67b9b23c3f0047874cc432591ae6"></a><!-- doxytag: member="Halide::Internal::substitute" ref="a9cec67b9b23c3f0047874cc432591ae6" args="(std::string name, Expr replacement, Expr expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a9cec67b9b23c3f0047874cc432591ae6">Halide::Internal::substitute</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within expr. </p>
<p>This is a dangerous thing to do if variable names have not been uniquified. While it won't traverse inside let statements with the same name as the first argument, moving a piece of syntax around can change its meaning, because it can cross lets that redefine variable names that it includes references to. </p>

</div>
</div>
<a class="anchor" id="aa5f3a31a571b877aeff8804b204b78ec"></a><!-- doxytag: member="Halide::Internal::substitute" ref="aa5f3a31a571b877aeff8804b204b78ec" args="(std::string name, Expr replacement, Stmt stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a9cec67b9b23c3f0047874cc432591ae6">Halide::Internal::substitute</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within stmt. </p>

</div>
</div>
<a class="anchor" id="ac546c55fe301504146a0ea9e19a4ac00"></a><!-- doxytag: member="Halide::Internal::substitute" ref="ac546c55fe301504146a0ea9e19a4ac00" args="(const std::map&lt; std::string, Expr &gt; &amp;replacements, Expr expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a9cec67b9b23c3f0047874cc432591ae6">Halide::Internal::substitute</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Substitute variables with names in the map. </p>

</div>
</div>
<a class="anchor" id="a9d3e92b9c76f56e57b4590f89d6cd073"></a><!-- doxytag: member="Halide::Internal::substitute" ref="a9d3e92b9c76f56e57b4590f89d6cd073" args="(const std::map&lt; std::string, Expr &gt; &amp;replacements, Stmt stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a9cec67b9b23c3f0047874cc432591ae6">Halide::Internal::substitute</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Substitute variables with names in the map. </p>

</div>
</div>
<a class="anchor" id="a320fa7575718308bc5b1e7a1b6d42d31"></a><!-- doxytag: member="Halide::Internal::get_initial_module_for_target" ref="a320fa7575718308bc5b1e7a1b6d42d31" args="(Target, llvm::LLVMContext *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Module* <a class="el" href="namespace_halide_1_1_internal.html#a320fa7575718308bc5b1e7a1b6d42d31">Halide::Internal::get_initial_module_for_target</a> </td>
          <td>(</td>
          <td class="paramtype">Target&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an llvm module containing the support code for a given target. </p>

</div>
</div>
<a class="anchor" id="aa9f98b98cbded4d63028df71771ca835"></a><!-- doxytag: member="Halide::Internal::get_initial_module_for_ptx_device" ref="aa9f98b98cbded4d63028df71771ca835" args="(llvm::LLVMContext *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Module* <a class="el" href="namespace_halide_1_1_internal.html#aa9f98b98cbded4d63028df71771ca835">Halide::Internal::get_initial_module_for_ptx_device</a> </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an llvm module containing the support code for ptx device. </p>

</div>
</div>
<a class="anchor" id="a3cd3f1d683bcca49a2df7179d42245d0"></a><!-- doxytag: member="Halide::Internal::inject_tracing" ref="a3cd3f1d683bcca49a2df7179d42245d0" args="(Stmt, const std::map&lt; std::string, Function &gt; &amp;env, Function output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a3cd3f1d683bcca49a2df7179d42245d0">Halide::Internal::inject_tracing</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations. </p>
<p>Should be done before storage flattening, but after all bounds inference. </p>

</div>
</div>
<a class="anchor" id="a0b6c445013b15af0a32bd54f5bb6bdc3"></a><!-- doxytag: member="Halide::Internal::unify_duplicate_lets" ref="a0b6c445013b15af0a32bd54f5bb6bdc3" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#a0b6c445013b15af0a32bd54f5bb6bdc3">Halide::Internal::unify_duplicate_lets</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find let statements that all define the same value, and make later ones just reuse the symbol names of the earlier ones. </p>

</div>
</div>
<a class="anchor" id="abf197e316b7d0a6adb96c25976612c1b"></a><!-- doxytag: member="Halide::Internal::uniquify_variable_names" ref="abf197e316b7d0a6adb96c25976612c1b" args="(Stmt s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#abf197e316b7d0a6adb96c25976612c1b">Halide::Internal::uniquify_variable_names</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify a statement so that every internally-defined variable name is unique. </p>
<p>This lets later passes assume syntactic equivalence is semantic equivalence. </p>

</div>
</div>
<a class="anchor" id="adc1c49e552297672b3751ac988bf70c3"></a><!-- doxytag: member="Halide::Internal::unroll_loops" ref="adc1c49e552297672b3751ac988bf70c3" args="(Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#adc1c49e552297672b3751ac988bf70c3">Halide::Internal::unroll_loops</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement. </p>
<p>I.e. unroll the loop. </p>

</div>
</div>
<a class="anchor" id="a1581b658edf919ea8aae58ad09b4f829"></a><!-- doxytag: member="Halide::Internal::vec" ref="a1581b658edf919ea8aae58ad09b4f829" args="(T a)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a14">tutorial/lesson_08_scheduling_2.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_util_8h_source.html#l00050">50</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00369">Halide::abs()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00517">Halide::acos()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00605">Halide::acosh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00493">Halide::asin()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00581">Halide::asinh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00541">Halide::atan()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00553">Halide::atan2()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00629">Halide::atanh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00756">Halide::ceil()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00505">Halide::cos()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00593">Halide::cosh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01000">Halide::count_leading_zeros()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01008">Halide::count_trailing_zeros()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00664">Halide::exp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00743">Halide::floor()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00950">Halide::lerp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00681">Halide::log()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00799">Halide::operator&amp;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00860">Halide::operator&lt;&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00876">Halide::operator&gt;&gt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00833">Halide::operator^()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00816">Halide::operator|()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00848">Halide::operator~()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00992">Halide::popcount()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00697">Halide::pow()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00779">Halide::reinterpret()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00769">Halide::round()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00481">Halide::sin()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00569">Halide::sinh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00641">Halide::sqrt()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00529">Halide::tan()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00617">Halide::tanh()</a>.</p>

</div>
</div>
<a class="anchor" id="a60049819a1e4ee7971c624c18a26210a"></a><!-- doxytag: member="Halide::Internal::vec" ref="a60049819a1e4ee7971c624c18a26210a" args="(T a, T b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00057">57</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a57308fdf8df2d93ff56d7dc8d2f621b1"></a><!-- doxytag: member="Halide::Internal::vec" ref="a57308fdf8df2d93ff56d7dc8d2f621b1" args="(T a, T b, T c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00065">65</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a643930ad0d00b2138183abfb01ba7083"></a><!-- doxytag: member="Halide::Internal::vec" ref="a643930ad0d00b2138183abfb01ba7083" args="(T a, T b, T c, T d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00074">74</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a33cbb76cabe65d3b5fc27f6d4866ce0b"></a><!-- doxytag: member="Halide::Internal::vec" ref="a33cbb76cabe65d3b5fc27f6d4866ce0b" args="(T a, T b, T c, T d, T e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00084">84</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac29a0bceb82c876dc7b2d9d15ea0f5b7"></a><!-- doxytag: member="Halide::Internal::vec" ref="ac29a0bceb82c876dc7b2d9d15ea0f5b7" args="(T a, T b, T c, T d, T e, T f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00095">95</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6e0218a6965fff6add01901838ccef67"></a><!-- doxytag: member="Halide::Internal::vec" ref="a6e0218a6965fff6add01901838ccef67" args="(T a, T b, T c, T d, T e, T f, T g)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00107">107</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab96724ccfd5edca25ce01a24fce53a66"></a><!-- doxytag: member="Halide::Internal::vec" ref="ab96724ccfd5edca25ce01a24fce53a66" args="(T a, T b, T c, T d, T e, T f, T g, T h)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">Halide::Internal::vec</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build small vectors of up to 6 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00120">120</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0aeffeff26578021bc780e1506bfa448"></a><!-- doxytag: member="Halide::Internal::int_to_string" ref="a0aeffeff26578021bc780e1506bfa448" args="(int x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string <a class="el" href="namespace_halide_1_1_internal.html#a0aeffeff26578021bc780e1506bfa448">Halide::Internal::int_to_string</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert an integer to a string. </p>

</div>
</div>
<a class="anchor" id="a94816d6979fdadb6e206a5d0a668e008"></a><!-- doxytag: member="Halide::Internal::reinterpret_bits" ref="a94816d6979fdadb6e206a5d0a668e008" args="(const SrcType &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DstType , typename SrcType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DstType <a class="el" href="namespace_halide_1_1_internal.html#a94816d6979fdadb6e206a5d0a668e008">Halide::Internal::reinterpret_bits</a> </td>
          <td>(</td>
          <td class="paramtype">const SrcType &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An aggressive form of reinterpret cast used for correct type-punning. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00139">139</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="mini__string_8h.html#add55236e1a6168d059f1409762081d1a">memcpy()</a>.</p>

</div>
</div>
<a class="anchor" id="a2eb97978547d98141752de6b614195f4"></a><!-- doxytag: member="Halide::Internal::make_entity_name" ref="a2eb97978547d98141752de6b614195f4" args="(void *stack_ptr, const std::string &amp;type, char prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string <a class="el" href="namespace_halide_1_1_internal.html#a2eb97978547d98141752de6b614195f4">Halide::Internal::make_entity_name</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a unique name for an object based on the name of the stack variable passed in. </p>
<p>If introspection isn't working or there are no debug symbols, just uses unique_name with the given prefix. </p>

</div>
</div>
<a class="anchor" id="acd575ab182df12cc793dba4aa241c1a9"></a><!-- doxytag: member="Halide::Internal::unique_name" ref="acd575ab182df12cc793dba4aa241c1a9" args="(char prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name</a> </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a unique name starting with the given character. </p>
<p>It's unique relative to all other calls to unique_name done by this process. <a class="el" href="struct_halide_1_1_internal_1_1_not.html" title="Logical not - true if the expression false.">Not</a> thread-safe. </p>

<p>Referenced by <a class="el" href="_lambda_8h_source.html#l00017">Halide::lambda()</a>, and <a class="el" href="_var_8h_source.html#l00024">Halide::Var::Var()</a>.</p>

</div>
</div>
<a class="anchor" id="aafd40e47c06b4ccb5d2173528ae0523f"></a><!-- doxytag: member="Halide::Internal::unique_name" ref="aafd40e47c06b4ccb5d2173528ae0523f" args="(const std::string &amp;name, bool user=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string <a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">Halide::Internal::unique_name</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>user</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a unique name starting with the given string. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_not.html" title="Logical not - true if the expression false.">Not</a> thread-safe. </p>

</div>
</div>
<a class="anchor" id="aa7703083cfe592de68f37796533724ed"></a><!-- doxytag: member="Halide::Internal::starts_with" ref="aa7703083cfe592de68f37796533724ed" args="(const std::string &amp;str, const std::string &amp;prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#aa7703083cfe592de68f37796533724ed">Halide::Internal::starts_with</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the first string starts with the second string. </p>

<p>Referenced by <a class="el" href="_var_8h_source.html#l00128">Halide::Var::is_implicit()</a>, and <a class="el" href="_schedule_8h_source.html#l00047">Halide::Internal::LoopLevel::match()</a>.</p>

</div>
</div>
<a class="anchor" id="a230079281175545b9b90b2285106ab28"></a><!-- doxytag: member="Halide::Internal::ends_with" ref="a230079281175545b9b90b2285106ab28" args="(const std::string &amp;str, const std::string &amp;suffix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool <a class="el" href="namespace_halide_1_1_internal.html#a230079281175545b9b90b2285106ab28">Halide::Internal::ends_with</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test if the first string ends with the second string. </p>

<p>Referenced by <a class="el" href="_schedule_8h_source.html#l00047">Halide::Internal::LoopLevel::match()</a>.</p>

</div>
</div>
<a class="anchor" id="ac91d88c24b89bb17c7b69c671c723516"></a><!-- doxytag: member="Halide::Internal::base_name" ref="ac91d88c24b89bb17c7b69c671c723516" args="(const std::string &amp;name, char delim= '.')" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string <a class="el" href="namespace_halide_1_1_internal.html#ac91d88c24b89bb17c7b69c671c723516">Halide::Internal::base_name</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the final token of the name string using the given delimiter. </p>

</div>
</div>
<a class="anchor" id="abe70c3a9d0ecd59908b1837a11d01de0"></a><!-- doxytag: member="Halide::Internal::vectorize_loops" ref="abe70c3a9d0ecd59908b1837a11d01de0" args="(Stmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> <a class="el" href="namespace_halide_1_1_internal.html#abe70c3a9d0ecd59908b1837a11d01de0">Halide::Internal::vectorize_loops</a> </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors. </p>
<p>The loops in question must have constant extent. </p>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a>      </li>
      <li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a>      </li>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
