<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: Halide::Internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_halide_1_1_internal.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Internal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_generator_min_max"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_generator_min_max.html">GeneratorMinMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_integer_division"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_integer_division.html">IntegerDivision</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_introspection"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_introspection.html">Introspection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent the equivalent associative binary/unary operator of an associative <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>.  <a href="struct_halide_1_1_internal_1_1_associative_op.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the bounds of a region of arbitrary dimension.  <a href="struct_halide_1_1_internal_1_1_box.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_buffer_ptr.html">BufferPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A named reference-counted handle on a Halide::Buffer&lt;&gt;  <a href="class_halide_1_1_internal_1_1_buffer_ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to manage closures.  <a href="class_halide_1_1_internal_1_1_closure.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___a_r_m.html">CodeGen_ARM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits ARM code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___a_r_m.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___c.html">CodeGen_C</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class emits C++ code equivalent to a halide <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>.  <a href="class_halide_1_1_internal_1_1_code_gen___c.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_p_u___host.html">CodeGen_GPU_Host</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___g_p_u___host.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___hexagon.html">CodeGen_Hexagon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits Hexagon code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___hexagon.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html">CodeGen_LLVM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator abstract base class.  <a href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___metal___dev.html">CodeGen_Metal_Dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___m_i_p_s.html">CodeGen_MIPS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits mips code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___m_i_p_s.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___open_c_l___dev.html">CodeGen_OpenCL_Dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___open_g_l___dev.html">CodeGen_OpenGL_Dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l_base.html">CodeGen_GLSLBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class handles GLSL arithmetic, shared by <a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l.html" title="Compile one statement into GLSL. ">CodeGen_GLSL</a> and CodeGen_OpenGLCompute_C.  <a href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l_base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l.html">CodeGen_GLSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile one statement into GLSL.  <a href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___open_g_l_compute___dev.html">CodeGen_OpenGLCompute_Dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___p_na_cl.html">CodeGen_PNaCl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits pnacl bitcode from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___p_na_cl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits posix code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___posix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___power_p_c.html">CodeGen_PowerPC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits mips code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___power_p_c.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___p_t_x___dev.html">CodeGen_PTX_Dev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___p_t_x___dev.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___renderscript___dev.html">CodeGen_Renderscript_Dev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits Renderscript code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___renderscript___dev.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___x86.html">CodeGen_X86</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits x86 code from a given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___x86.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1debug.html">debug</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> optional debugging during codegen, use the debug class as follows:  <a href="struct_halide_1_1_internal_1_1debug.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition which can either represent a init or an update definition.  <a href="class_halide_1_1_internal_1_1_definition.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_device_argument.html">DeviceArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struct_halide_1_1_internal_1_1_device_argument.html" title="A DeviceArgument looks similar to an Halide::Argument, but has behavioral differences that make it sp...">DeviceArgument</a> looks similar to an <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function. ">Halide::Argument</a>, but has behavioral differences that make it specific to the GPU pipeline; the fact that neither is-a nor has-a <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function. ">Halide::Argument</a> is deliberate.  <a href="struct_halide_1_1_internal_1_1_device_argument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_host_closure.html">HostClosure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_halide_1_1_internal_1_1_closure.html" title="A helper class to manage closures. ">Closure</a> modified to inspect GPU-specific memory accesses, and produce a vector of <a class="el" href="struct_halide_1_1_internal_1_1_device_argument.html" title="A DeviceArgument looks similar to an Halide::Argument, but has behavioral differences that make it sp...">DeviceArgument</a> objects.  <a href="class_halide_1_1_internal_1_1_host_closure.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_error_report.html">ErrorReport</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base classes for a node in the <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> IR.  <a href="struct_halide_1_1_internal_1_1_i_r_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_stmt_node.html">BaseStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are split into expressions and statements.  <a href="struct_halide_1_1_internal_1_1_base_stmt_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for expression nodes.  <a href="struct_halide_1_1_internal_1_1_base_expr_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_node.html">ExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We use the "curiously recurring template pattern" to avoid duplicated code in the IR Nodes.  <a href="struct_halide_1_1_internal_1_1_expr_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt_node.html">StmtNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are passed around opaque handles to them.  <a href="struct_halide_1_1_internal_1_1_i_r_handle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html">IntImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer constants.  <a href="struct_halide_1_1_internal_1_1_int_imm.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html">UIntImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer constants.  <a href="struct_halide_1_1_internal_1_1_u_int_imm.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html">FloatImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point constants.  <a href="struct_halide_1_1_internal_1_1_float_imm.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html">StringImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String constants.  <a href="struct_halide_1_1_internal_1_1_string_imm.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a statement node.  <a href="struct_halide_1_1_internal_1_1_stmt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_expr_uses_vars.html">ExprUsesVars</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s internal representation of a function.  <a href="class_halide_1_1_internal_1_1_function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1select__type.html">select_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1select__type_3_01_first_01_4.html">select_type&lt; First &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_base.html">GeneratorParamBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_impl.html">GeneratorParamImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___target.html">GeneratorParam_Target</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___arithmetic.html">GeneratorParam_Arithmetic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___bool.html">GeneratorParam_Bool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___enum.html">GeneratorParam_Enum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param___type.html">GeneratorParam_Type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_base.html">GeneratorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_factory.html">GeneratorFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html">GeneratorRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to represent ranges of Exprs.  <a href="struct_halide_1_1_internal_1_1_interval.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a reference count to be used with <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html" title="Intrusive shared pointers have a reference count (a RefCount object) stored in the class itself...">IntrusivePtr</a>.  <a href="class_halide_1_1_internal_1_1_ref_count.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive shared pointers have a reference count (a <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> object) stored in the class itself.  <a href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual IR nodes begin here.  <a href="struct_halide_1_1_internal_1_1_cast.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of two expressions.  <a href="struct_halide_1_1_internal_1_1_add.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The difference of two expressions.  <a href="struct_halide_1_1_internal_1_1_sub.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The product of two expressions.  <a href="struct_halide_1_1_internal_1_1_mul.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ratio of two expressions.  <a href="struct_halide_1_1_internal_1_1_div.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of a / b.  <a href="struct_halide_1_1_internal_1_1_mod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lesser of two values.  <a href="struct_halide_1_1_internal_1_1_min.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater of two values.  <a href="struct_halide_1_1_internal_1_1_max.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression equal to the second.  <a href="struct_halide_1_1_internal_1_1_e_q.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression not equal to the second.  <a href="struct_halide_1_1_internal_1_1_n_e.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than the second.  <a href="struct_halide_1_1_internal_1_1_l_t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_l_e.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than the second.  <a href="struct_halide_1_1_internal_1_1_g_t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_g_e.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and - are both expressions true.  <a href="struct_halide_1_1_internal_1_1_and.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or - is at least one of the expression true.  <a href="struct_halide_1_1_internal_1_1_or.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_not.html">Not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical not - true if the expression false.  <a href="struct_halide_1_1_internal_1_1_not.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_select.html">Select</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ternary operator.  <a href="struct_halide_1_1_internal_1_1_select.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_load.html">Load</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer. ">Load</a> a value from a named buffer.  <a href="struct_halide_1_1_internal_1_1_load.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_ramp.html">Ramp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear ramp vector node.  <a href="struct_halide_1_1_internal_1_1_ramp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html">Broadcast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector with 'lanes' elements, in which every element is 'value'.  <a href="struct_halide_1_1_internal_1_1_broadcast.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let.html">Let</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A let expression, like you might find in a functional language.  <a href="struct_halide_1_1_internal_1_1_let.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html">LetStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The statement form of a let node.  <a href="struct_halide_1_1_internal_1_1_let_stmt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_assert_stmt.html">AssertStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the 'condition' is false, then evaluate and return the message, which should be a call to an error function.  <a href="struct_halide_1_1_internal_1_1_assert_stmt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_producer_consumer.html">ProducerConsumer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node is a helpful annotation to do with permissions.  <a href="struct_halide_1_1_internal_1_1_producer_consumer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_store.html">Store</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;. ">Store</a> a 'value' to the buffer called 'name' at a given 'index'.  <a href="struct_halide_1_1_internal_1_1_store.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_provide.html">Provide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines the value of a function at a multi-dimensional location.  <a href="struct_halide_1_1_internal_1_1_provide.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html">Allocate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a> a scratch area called with the given name, type, and size.  <a href="struct_halide_1_1_internal_1_1_allocate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_free.html">Free</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_free.html" title="Free the resources associated with the given buffer. ">Free</a> the resources associated with the given buffer.  <a href="struct_halide_1_1_internal_1_1_free.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-dimensional span.  <a href="struct_halide_1_1_internal_1_1_range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_realize.html">Realize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a> a multi-dimensional buffer of the given type and size.  <a href="struct_halide_1_1_internal_1_1_realize.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of statements to be executed in-order.  <a href="struct_halide_1_1_internal_1_1_block.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_if_then_else.html">IfThenElse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An if-then-else block.  <a href="struct_halide_1_1_internal_1_1_if_then_else.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html">Evaluate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect. ">Evaluate</a> and discard an expression, presumably because it has some side-effect.  <a href="struct_halide_1_1_internal_1_1_evaluate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function call.  <a href="struct_halide_1_1_internal_1_1_call.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A named variable.  <a href="struct_halide_1_1_internal_1_1_variable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_for.html">For</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A for loop.  <a href="struct_halide_1_1_internal_1_1_for.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_deep_compare.html">IRDeepCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compare struct suitable for use in std::map and std::set that computes a lexical ordering on IR nodes.  <a href="struct_halide_1_1_internal_1_1_i_r_deep_compare.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_compare_cache.html">IRCompareCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lossily track known equal exprs with a cache.  <a href="class_halide_1_1_internal_1_1_i_r_compare_cache.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_with_compare_cache.html">ExprWithCompareCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper about Exprs so that they can be deeply compared with a cache for known-equal subexpressions.  <a href="struct_halide_1_1_internal_1_1_expr_with_compare_cache.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for passes over the IR which modify it (e.g.  <a href="class_halide_1_1_internal_1_1_i_r_mutator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_graph_mutator.html">IRGraphMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutator that caches and reapplies previously-done mutations, so that it can handle graphs of IR that have not had CSE done to them.  <a href="class_halide_1_1_internal_1_1_i_r_graph_mutator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_printer.html">IRPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR. ">IRVisitor</a> that emits IR to the given output stream in a human readable form.  <a href="class_halide_1_1_internal_1_1_i_r_printer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that need to recursively walk over the IR.  <a href="class_halide_1_1_internal_1_1_i_r_visitor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html">IRGraphVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that walk recursively over the IR without visiting the same node twice.  <a href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_module.html">JITModule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_handlers.html">JITHandlers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_user_context.html">JITUserContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_j_i_t_shared_runtime.html">JITSharedRuntime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_lowered_argument.html">LoweredArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a> of an argument to a <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html" title="Definition of a lowered function. ">LoweredFunc</a>.  <a href="struct_halide_1_1_internal_1_1_lowered_argument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a> of a lowered function.  <a href="struct_halide_1_1_internal_1_1_lowered_func.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of modulus_remainder analysis.  <a href="struct_halide_1_1_internal_1_1_modulus_remainder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_object_instance_registry.html">ObjectInstanceRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a parameter to a halide pipeline.  <a href="class_halide_1_1_internal_1_1_parameter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html">ReductionVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single named dimension of a reduction domain.  <a href="struct_halide_1_1_internal_1_1_reduction_variable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle on a reduction domain, which is just a vector of <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html" title="A single named dimension of a reduction domain. ">ReductionVariable</a>.  <a href="class_halide_1_1_internal_1_1_reduction_domain.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_bound.html">Bound</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_storage_dim.html">StorageDim</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_prefetch.html">Prefetch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_schedule.html">Schedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A schedule for a single stage of a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> pipeline.  <a href="class_halide_1_1_internal_1_1_schedule.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_small_stack.html">SmallStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack which can store one item very efficiently.  <a href="class_halide_1_1_internal_1_1_small_stack.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A common pattern when traversing <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> IR is that you need to keep track of stuff when you find a <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language. ">Let</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node. ">LetStmt</a>, and that it should hide previous values with the same name until you leave the <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language. ">Let</a> or <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node. ">LetStmt</a> nodes This class helps with that.  <a href="class_halide_1_1_internal_1_1_scope.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_solver_result.html">SolverResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and.html">meta_and</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and_3_01_t1_00_01_args_8_8_8_4.html">meta_and&lt; T1, Args...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">all_are_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_temporary_file.html">TemporaryFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple utility class that creates a temporary file in its ctor and deletes that file in its dtor; this is useful for temporary files that you want to ensure are deleted when exiting a certain scope.  <a href="class_halide_1_1_internal_1_1_temporary_file.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaa0611a86047e2c583dd061a620dcc6e"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::pair<br class="typebreak"/>
&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a></td></tr>
<tr class="separator:aaa0611a86047e2c583dd061a620dcc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc03e0ba4be51afc995f76d6d309aca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aecc03e0ba4be51afc995f76d6d309aca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aecc03e0ba4be51afc995f76d6d309aca">GeneratorParamImplBase</a> = typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">Internal::select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">Internal::cond</a>&lt; std::is_same&lt; T, <a class="el" href="struct_halide_1_1_target.html">Target</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___target.html">Internal::GeneratorParam_Target</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">Internal::cond</a>&lt; std::is_same&lt; T, <a class="el" href="struct_halide_1_1_type.html">Type</a> &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___type.html">Internal::GeneratorParam_Type</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">Internal::cond</a>&lt; std::is_same&lt; T, bool &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___bool.html">Internal::GeneratorParam_Bool</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">Internal::cond</a>&lt; std::is_arithmetic&lt; T &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___arithmetic.html">Internal::GeneratorParam_Arithmetic</a>&lt; T &gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">Internal::cond</a>&lt; std::is_enum&lt; T &gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___enum.html">Internal::GeneratorParam_Enum</a>&lt; T &gt;&gt; &gt;::type</td></tr>
<tr class="separator:aecc03e0ba4be51afc995f76d6d309aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1b9521b6f1f513178f281d8f395335"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a></td></tr>
<tr class="memdesc:abd1b9521b6f1f513178f281d8f395335"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional box.  <a href="#abd1b9521b6f1f513178f281d8f395335">More...</a><br/></td></tr>
<tr class="separator:abd1b9521b6f1f513178f281d8f395335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db928fd19209689611a24deafa15b9c"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7db928fd19209689611a24deafa15b9c">halide_task</a> )(void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td></tr>
<tr class="separator:a7db928fd19209689611a24deafa15b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7114c2dcec2af79da28735c5b11c0916"><td class="memItemLeft" align="right" valign="top">typedef llvm::raw_pwrite_stream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">LLVMOStream</a></td></tr>
<tr class="separator:a7114c2dcec2af79da28735c5b11c0916"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8548315fd4d13ccebe45a8123369f7ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7ca">Direction</a> { <a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7caa19de5b94f7b83900d4b296d9fa491aec">Direction::Upper</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7caab75fcdd2d72d9e000beab48622402d93">Direction::Lower</a>
 }</td></tr>
<tr class="separator:a8548315fd4d13ccebe45a8123369f7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9e0b8e5376e2294d74ded8e7de9ef2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2">IRNodeType</a> { <br/>
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ad90896d6a515230ad67dfc865553e417">IRNodeType::IntImm</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a180c72f0a469e718cd8c2d23fb87ffb8">IRNodeType::UIntImm</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a42e91b555b80a7e354d5e43a9fc4be07">IRNodeType::FloatImm</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a771ef82b08c11e5688dcb0714a7bbc73">IRNodeType::StringImm</a>, 
<br/>
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a4cd9f3996d60790cd11c04f842ebc43c">IRNodeType::Cast</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a47c14840d8e15331fa420b9b2f757cd9">IRNodeType::Variable</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2aec211f7c20af43e742bf2570c3cb84f9">IRNodeType::Add</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ae80155eceb940c89e2de63ad05868db2">IRNodeType::Sub</a>, 
<br/>
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a62b6d55816cf737bfc6f42e60df1a3f2">IRNodeType::Mul</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a43d11850893d2fe84a1e618121c1cc0a">IRNodeType::Div</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a7aeb0277500c86e4aa6bd23f9a737942">IRNodeType::Mod</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a78d811e98514cd165dda532286610fd2">IRNodeType::Min</a>, 
<br/>
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a6a061313d22e51e0f25b7cd4dc065233">IRNodeType::Max</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a2dcbad7477fd40561e8b8198f173bd47">IRNodeType::EQ</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2adc33066c3993e0d50896e533fd692ce0">IRNodeType::NE</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ac562607189d77eb9dfb707464c1e7b0b">IRNodeType::LT</a>, 
<br/>
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2acfe6055d2e0503be378bb63449ec7ba6">IRNodeType::LE</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2acd6a9bd2a175104eed40f0d33a8b4020">IRNodeType::GT</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2af803729628adf4199f224c2a225038e9">IRNodeType::GE</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ac33315685a0cba3ce53be378b3c7874b">IRNodeType::And</a>, 
<br/>
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a3a2d5fe857d8f9541136a124c2edec6c">IRNodeType::Or</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2aa74c05d080620f087c4e523977230666">IRNodeType::Not</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ae0626222614bdee31951d84c64e5e9ff">IRNodeType::Select</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2af19dbf2edb3a0bd74b0524d960ff21eb">IRNodeType::Load</a>, 
<br/>
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a99b4c3afc6aaa3ab4de17c90455a55eb">IRNodeType::Ramp</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2abe55b6387170df0ca68f41225268e842">IRNodeType::Broadcast</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ac3755e61202abd74da5885d2e9c9160e">IRNodeType::Call</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2acae6404c4aecf46684930fe2a86676a6">IRNodeType::Let</a>, 
<br/>
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2aa7312a9d08c50e9dbc7043efe7b54df2">IRNodeType::LetStmt</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a592a4f2501f4145b888a956d28448742">IRNodeType::AssertStmt</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a2c20d259c8ce0541078629d15be803a0">IRNodeType::ProducerConsumer</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a39e61d57e9209611edd4f884e9e47c11">IRNodeType::For</a>, 
<br/>
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2afdb0c388de01d545017cdf9ccf00eb72">IRNodeType::Store</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2a2e5af173c7126a0e6f6bc996222386c7">IRNodeType::Provide</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ac9baacf6cca6c54626e594639081177f">IRNodeType::Allocate</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ab24ce0cd392a5b0b8dedc66c25213594">IRNodeType::Free</a>, 
<br/>
&#160;&#160;<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2acbe1377636dc5dc95b68ff96203249cc">IRNodeType::Realize</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ae1e4c8c9ccd9fc39c391da4bcd093fb2">IRNodeType::Block</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2aaff6933d8331eca27edc911467980c9c">IRNodeType::IfThenElse</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2ab086843368d1c92d0a86cbee76b20b6f">IRNodeType::Evaluate</a>
<br/>
 }</td></tr>
<tr class="memdesc:aee9e0b8e5376e2294d74ded8e7de9ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">All our IR node types get unique IDs for the purposes of RTTI.  <a href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2">More...</a><br/></td></tr>
<tr class="separator:aee9e0b8e5376e2294d74ded8e7de9ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8761f129e6554b9ea03de31bf066f1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> { <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1a5255d3daaa0a6276b844d61401e6f493">ForType::Serial</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1a98402eecfbcefc336954458a01752131">ForType::Parallel</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1a138bc087eaaaf426b54f9a466f0cc725">ForType::Vectorized</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1ae53597647de81f4cc9e098fc119ba0ac">ForType::Unrolled</a>
 }</td></tr>
<tr class="memdesc:a6a8761f129e6554b9ea03de31bf066f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing a type of loop traversal.  <a href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">More...</a><br/></td></tr>
<tr class="separator:a6a8761f129e6554b9ea03de31bf066f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc0c8c1adc38d2c5a80979948f0007c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> { <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007cacb17869fe51048b5a5c4c6106551a255">Monotonic::Constant</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007caf3ff61f20d0c8eedfa348b0298df5edd">Monotonic::Increasing</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007ca2e6a9b0375c021e8f650a5eb22012b5b">Monotonic::Decreasing</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007ca88183b946cc5f0e8c96b2e66e1c74a7e">Monotonic::Unknown</a>
 }</td></tr>
<tr class="memdesc:a7dc0c8c1adc38d2c5a80979948f0007c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown.  <a href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">More...</a><br/></td></tr>
<tr class="separator:a7dc0c8c1adc38d2c5a80979948f0007c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acdd1e32e936b40a5ae1a2a1ef41b64c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acdd1e32e936b40a5ae1a2a1ef41b64c0">add_image_checks</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;fb)</td></tr>
<tr class="memdesc:acdd1e32e936b40a5ae1a2a1ef41b64c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert checks to make sure a statement doesn't read out of bounds on inputs or outputs, and that the inputs and outputs conform to the format required (e.g.  <a href="#acdd1e32e936b40a5ae1a2a1ef41b64c0">More...</a><br/></td></tr>
<tr class="separator:acdd1e32e936b40a5ae1a2a1ef41b64c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd151298721810b82ac418d3810a0dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6bd151298721810b82ac418d3810a0dc">add_parameter_checks</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a6bd151298721810b82ac418d3810a0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert checks to make sure that all referenced parameters meet their constraints.  <a href="#a6bd151298721810b82ac418d3810a0dc">More...</a><br/></td></tr>
<tr class="separator:a6bd151298721810b82ac418d3810a0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b2cbb7a5ae40e05e1d3a05015349ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa5b2cbb7a5ae40e05e1d3a05015349ca">align_loads</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, int alignment)</td></tr>
<tr class="memdesc:aa5b2cbb7a5ae40e05e1d3a05015349ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to rewrite unaligned loads from buffers which are known to be aligned to instead load aligned vectors that cover the original load, and then slice the original load out of the aligned vectors.  <a href="#aa5b2cbb7a5ae40e05e1d3a05015349ca">More...</a><br/></td></tr>
<tr class="separator:aa5b2cbb7a5ae40e05e1d3a05015349ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410eac3ad68dfb697c5ee97100f2053f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a410eac3ad68dfb697c5ee97100f2053f">allocation_bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;func_bounds)</td></tr>
<tr class="memdesc:a410eac3ad68dfb697c5ee97100f2053f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a> nodes in terms of variables, and define values for those variables.  <a href="#a410eac3ad68dfb697c5ee97100f2053f">More...</a><br/></td></tr>
<tr class="separator:a410eac3ad68dfb697c5ee97100f2053f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822c743898c237d427555eea5c94129b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, std::vector<br class="typebreak"/>
&lt; <a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a822c743898c237d427555eea5c94129b">prove_associativity</a> (const std::string &amp;f, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; args, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; exprs)</td></tr>
<tr class="memdesc:a822c743898c237d427555eea5c94129b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an update definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> 'f', determine its equivalent associative binary/unary operator if there is any.  <a href="#a822c743898c237d427555eea5c94129b">More...</a><br/></td></tr>
<tr class="separator:a822c743898c237d427555eea5c94129b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca79da3cbafab805c5cd1f0c6ee81d15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aca79da3cbafab805c5cd1f0c6ee81d15">associativity_test</a> ()</td></tr>
<tr class="separator:aca79da3cbafab805c5cd1f0c6ee81d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f7e59492cfa4804a6dece2d867a5db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab7f7e59492cfa4804a6dece2d867a5db">bounds_of_expr_in_scope</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope, const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:ab7f7e59492cfa4804a6dece2d867a5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression.  <a href="#ab7f7e59492cfa4804a6dece2d867a5db">More...</a><br/></td></tr>
<tr class="separator:ab7f7e59492cfa4804a6dece2d867a5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f153e2f6ddfec8e6ca9d31b8d7acfc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0f153e2f6ddfec8e6ca9d31b8d7acfc9">find_constant_bound</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, <a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7ca">Direction</a> d)</td></tr>
<tr class="separator:a0f153e2f6ddfec8e6ca9d31b8d7acfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac2f62c0ee3ace8de2be57a9db369a3e4">merge_boxes</a> (<a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand box a to encompass box b.  <a href="#ac2f62c0ee3ace8de2be57a9db369a3e4">More...</a><br/></td></tr>
<tr class="separator:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9641dd947fdf6352ccd5e34548db35e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac9641dd947fdf6352ccd5e34548db35e">boxes_overlap</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:ac9641dd947fdf6352ccd5e34548db35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if box a could possibly overlap box b.  <a href="#ac9641dd947fdf6352ccd5e34548db35e">More...</a><br/></td></tr>
<tr class="separator:ac9641dd947fdf6352ccd5e34548db35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86d8a9b260b097d115182e4b8488f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af86d8a9b260b097d115182e4b8488f09">box_union</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:af86d8a9b260b097d115182e4b8488f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The union of two boxes.  <a href="#af86d8a9b260b097d115182e4b8488f09">More...</a><br/></td></tr>
<tr class="separator:af86d8a9b260b097d115182e4b8488f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c57c8cff1c0ff811a01724b58086bdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8c57c8cff1c0ff811a01724b58086bdc">box_intersection</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:a8c57c8cff1c0ff811a01724b58086bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intersection of two boxes.  <a href="#a8c57c8cff1c0ff811a01724b58086bdc">More...</a><br/></td></tr>
<tr class="separator:a8c57c8cff1c0ff811a01724b58086bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9198438916c78b87c90e665d665a18cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9198438916c78b87c90e665d665a18cd">box_contains</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="memdesc:a9198438916c78b87c90e665d665a18cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if box a provably contains box b.  <a href="#a9198438916c78b87c90e665d665a18cd">More...</a><br/></td></tr>
<tr class="separator:a9198438916c78b87c90e665d665a18cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b807d0d1524fb2f20b1533d05032c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0b807d0d1524fb2f20b1533d05032c02">compute_function_value_bounds</a> (const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a0b807d0d1524fb2f20b1533d05032c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum and minimum possible value for each function in an environment.  <a href="#a0b807d0d1524fb2f20b1533d05032c02">More...</a><br/></td></tr>
<tr class="separator:a0b807d0d1524fb2f20b1533d05032c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0ac02fb219b5b3b77f2930b2ef63a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abf0ac02fb219b5b3b77f2930b2ef63a2">bounds_test</a> ()</td></tr>
<tr class="separator:abf0ac02fb219b5b3b77f2930b2ef63a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571cac31938f53aa2e66671e187d9b9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a571cac31938f53aa2e66671e187d9b9f">bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::string &gt; &amp;<a class="el" href="namespace_halide_1_1_internal.html#ab7e4af61cd70924152b76870cd5fc361">realization_order</a>, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;environment, const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;func_bounds, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:a571cac31938f53aa2e66671e187d9b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds.  <a href="#a571cac31938f53aa2e66671e187d9b9f">More...</a><br/></td></tr>
<tr class="separator:a571cac31938f53aa2e66671e187d9b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1e270066706802bc3903a17703f173"><td class="memItemLeft" align="right" valign="top">llvm::StructType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1a1e270066706802bc3903a17703f173">build_closure_type</a> (const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;closure, llvm::StructType *<a class="el" href="structbuffer__t.html">buffer_t</a>, llvm::LLVMContext *context)</td></tr>
<tr class="memdesc:a1a1e270066706802bc3903a17703f173"><td class="mdescLeft">&#160;</td><td class="mdescRight">The llvm type of a struct containing all of the externally referenced state of a <a class="el" href="class_halide_1_1_internal_1_1_closure.html" title="A helper class to manage closures. ">Closure</a>.  <a href="#a1a1e270066706802bc3903a17703f173">More...</a><br/></td></tr>
<tr class="separator:a1a1e270066706802bc3903a17703f173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bb457246f10a99d7884697912d5542"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab9bb457246f10a99d7884697912d5542">pack_closure</a> (llvm::Type *type, llvm::Value *<a class="el" href="printer_8h.html#a961c13eb7fcda15b167b953cac1ab3ec">dst</a>, const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;closure, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; llvm::Value * &gt; &amp;src, llvm::StructType *<a class="el" href="structbuffer__t.html">buffer_t</a>, <a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt;&gt; *builder)</td></tr>
<tr class="memdesc:ab9bb457246f10a99d7884697912d5542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that builds a struct containing all the externally referenced state.  <a href="#ab9bb457246f10a99d7884697912d5542">More...</a><br/></td></tr>
<tr class="separator:ab9bb457246f10a99d7884697912d5542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa343f8851b8c07de8d1b9f964fc830c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa343f8851b8c07de8d1b9f964fc830c7">unpack_closure</a> (const <a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a> &amp;closure, <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; llvm::Value * &gt; &amp;<a class="el" href="printer_8h.html#a961c13eb7fcda15b167b953cac1ab3ec">dst</a>, llvm::Type *type, llvm::Value *src, <a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt;&gt; *builder)</td></tr>
<tr class="memdesc:aa343f8851b8c07de8d1b9f964fc830c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that unpacks a struct containing all the externally referenced state into a symbol table.  <a href="#aa343f8851b8c07de8d1b9f964fc830c7">More...</a><br/></td></tr>
<tr class="separator:aa343f8851b8c07de8d1b9f964fc830c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f10140e29131153c3be98d2899b090"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a71f10140e29131153c3be98d2899b090">llvm_type_of</a> (llvm::LLVMContext *context, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> t)</td></tr>
<tr class="memdesc:a71f10140e29131153c3be98d2899b090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the llvm type equivalent to a given halide type.  <a href="#a71f10140e29131153c3be98d2899b090">More...</a><br/></td></tr>
<tr class="separator:a71f10140e29131153c3be98d2899b090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adc60421b682a09ea4c4dcaaaa3e105e2">function_takes_user_context</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which built-in functions require a user-context first argument?  <a href="#adc60421b682a09ea4c4dcaaaa3e105e2">More...</a><br/></td></tr>
<tr class="separator:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa783278be5bae448cf01fec2df4a9a6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa783278be5bae448cf01fec2df4a9a6f">can_allocation_fit_on_stack</a> (<a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> size)</td></tr>
<tr class="memdesc:aa783278be5bae448cf01fec2df4a9a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a size (in bytes), return True if the allocation size can fit on the stack; otherwise, return False.  <a href="#aa783278be5bae448cf01fec2df4a9a6f">More...</a><br/></td></tr>
<tr class="separator:aa783278be5bae448cf01fec2df4a9a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4fa94b1f3a877eb3387824c09df826"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7b4fa94b1f3a877eb3387824c09df826">get_target_options</a> (const llvm::Module &amp;module, llvm::TargetOptions &amp;options, std::string &amp;mcpu, std::string &amp;mattrs)</td></tr>
<tr class="memdesc:a7b4fa94b1f3a877eb3387824c09df826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an llvm::Module, set llvm:TargetOptions, cpu and attr information.  <a href="#a7b4fa94b1f3a877eb3387824c09df826">More...</a><br/></td></tr>
<tr class="separator:a7b4fa94b1f3a877eb3387824c09df826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b16d175882e16f544bf4bf92ec931b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1b16d175882e16f544bf4bf92ec931b5">clone_target_options</a> (const llvm::Module &amp;from, llvm::Module &amp;to)</td></tr>
<tr class="memdesc:a1b16d175882e16f544bf4bf92ec931b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two llvm::Modules, clone target options from one to the other.  <a href="#a1b16d175882e16f544bf4bf92ec931b5">More...</a><br/></td></tr>
<tr class="separator:a1b16d175882e16f544bf4bf92ec931b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e20aff45028d266f854487159df341"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; llvm::TargetMachine &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af1e20aff45028d266f854487159df341">make_target_machine</a> (const llvm::Module &amp;module)</td></tr>
<tr class="memdesc:af1e20aff45028d266f854487159df341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an llvm::Module, get or create an llvm:TargetMachine.  <a href="#af1e20aff45028d266f854487159df341">More...</a><br/></td></tr>
<tr class="separator:af1e20aff45028d266f854487159df341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe55211c4dbc852f29c8e764360c670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abfe55211c4dbc852f29c8e764360c670">set_function_attributes_for_target</a> (llvm::Function *, <a class="el" href="struct_halide_1_1_target.html">Target</a>)</td></tr>
<tr class="memdesc:abfe55211c4dbc852f29c8e764360c670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the appropriate llvm <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> attributes given a <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#abfe55211c4dbc852f29c8e764360c670">More...</a><br/></td></tr>
<tr class="separator:abfe55211c4dbc852f29c8e764360c670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782f06d4de1f8dc9f230dd3c02ee93ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a782f06d4de1f8dc9f230dd3c02ee93ac">cplusplus_function_mangled_name</a> (const std::string &amp;name, const std::vector&lt; std::string &gt; &amp;namespaces, <a class="el" href="struct_halide_1_1_type.html">Type</a> return_type, const std::vector&lt; <a class="el" href="struct_halide_1_1_extern_func_argument.html">ExternFuncArgument</a> &gt; &amp;args, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:a782f06d4de1f8dc9f230dd3c02ee93ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mangled C++ name for a function.  <a href="#a782f06d4de1f8dc9f230dd3c02ee93ac">More...</a><br/></td></tr>
<tr class="separator:a782f06d4de1f8dc9f230dd3c02ee93ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b849065142ce8cb6303244c51a996b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a43b849065142ce8cb6303244c51a996b">cplusplus_mangle_test</a> ()</td></tr>
<tr class="separator:a43b849065142ce8cb6303244c51a996b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c69c01c5d35b1cd47354374d49bf28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a83c69c01c5d35b1cd47354374d49bf28">common_subexpression_elimination</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>)</td></tr>
<tr class="memdesc:a83c69c01c5d35b1cd47354374d49bf28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable.  <a href="#a83c69c01c5d35b1cd47354374d49bf28">More...</a><br/></td></tr>
<tr class="separator:a83c69c01c5d35b1cd47354374d49bf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd617bcfa0cf8b542eb38a8cca1f0614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abd617bcfa0cf8b542eb38a8cca1f0614">common_subexpression_elimination</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:abd617bcfa0cf8b542eb38a8cca1f0614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do common-subexpression-elimination on each expression in a statement.  <a href="#abd617bcfa0cf8b542eb38a8cca1f0614">More...</a><br/></td></tr>
<tr class="separator:abd617bcfa0cf8b542eb38a8cca1f0614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750967bfd0520280ceadbf9f15ffa3be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a750967bfd0520280ceadbf9f15ffa3be">cse_test</a> ()</td></tr>
<tr class="separator:a750967bfd0520280ceadbf9f15ffa3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f749a540acb9a7c148602c517e61e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a12f749a540acb9a7c148602c517e61e5">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:a12f749a540acb9a7c148602c517e61e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide statement on an output stream (such as std::cout) in a human-readable form.  <a href="#a12f749a540acb9a7c148602c517e61e5">More...</a><br/></td></tr>
<tr class="separator:a12f749a540acb9a7c148602c517e61e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915eea9584a02a02fa0ccd9dea859e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a915eea9584a02a02fa0ccd9dea859e87">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &amp;)</td></tr>
<tr class="separator:a915eea9584a02a02fa0ccd9dea859e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea2b563fa94726a65b596979b9d2f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaea2b563fa94726a65b596979b9d2f85">debug_to_file</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:aaea2b563fa94726a65b596979b9d2f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a> nodes still unlowered.  <a href="#aaea2b563fa94726a65b596979b9d2f85">More...</a><br/></td></tr>
<tr class="separator:aaea2b563fa94726a65b596979b9d2f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad946e0645ead551baee06d6c39e6552"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;, std::map<br class="typebreak"/>
&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aad946e0645ead551baee06d6c39e6552">deep_copy</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:aad946e0645ead551baee06d6c39e6552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create deep-copies of all Functions in 'env'.  <a href="#aad946e0645ead551baee06d6c39e6552">More...</a><br/></td></tr>
<tr class="separator:aad946e0645ead551baee06d6c39e6552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3886cd7a77937dd80231c35581b93be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af3886cd7a77937dd80231c35581b93be">extract_odd_lanes</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:af3886cd7a77937dd80231c35581b93be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the odd-numbered lanes in a vector.  <a href="#af3886cd7a77937dd80231c35581b93be">More...</a><br/></td></tr>
<tr class="separator:af3886cd7a77937dd80231c35581b93be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be6e8bc82582bb4ac055507907282c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8be6e8bc82582bb4ac055507907282c2">extract_even_lanes</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a8be6e8bc82582bb4ac055507907282c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the even-numbered lanes in a vector.  <a href="#a8be6e8bc82582bb4ac055507907282c2">More...</a><br/></td></tr>
<tr class="separator:a8be6e8bc82582bb4ac055507907282c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf56d49145d02ee1f675c8c838c8e9ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaf56d49145d02ee1f675c8c838c8e9ea">extract_lane</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> vec, int lane)</td></tr>
<tr class="memdesc:aaf56d49145d02ee1f675c8c838c8e9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the nth lane of a vector.  <a href="#aaf56d49145d02ee1f675c8c838c8e9ea">More...</a><br/></td></tr>
<tr class="separator:aaf56d49145d02ee1f675c8c838c8e9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1233a717a83d74121106b95245ce81a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac1233a717a83d74121106b95245ce81a">rewrite_interleavings</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:ac1233a717a83d74121106b95245ce81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic.  <a href="#ac1233a717a83d74121106b95245ce81a">More...</a><br/></td></tr>
<tr class="separator:ac1233a717a83d74121106b95245ce81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc21bfcfcc2b8feadd3612b4cd21e020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adc21bfcfcc2b8feadd3612b4cd21e020">deinterleave_vector_test</a> ()</td></tr>
<tr class="separator:adc21bfcfcc2b8feadd3612b4cd21e020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aedffca433bdfab639e4956779040e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5aedffca433bdfab639e4956779040e6">inject_early_frees</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a5aedffca433bdfab639e4956779040e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation.  <a href="#a5aedffca433bdfab639e4956779040e6">More...</a><br/></td></tr>
<tr class="separator:a5aedffca433bdfab639e4956779040e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3608cf83d3537cd1c519b046f34a51b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac3608cf83d3537cd1c519b046f34a51b">eliminated_bool_type</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> bool_type, <a class="el" href="struct_halide_1_1_type.html">Type</a> other_type)</td></tr>
<tr class="memdesc:ac3608cf83d3537cd1c519b046f34a51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a type is a boolean vector, find the type that it has been changed to by eliminate_bool_vectors.  <a href="#ac3608cf83d3537cd1c519b046f34a51b">More...</a><br/></td></tr>
<tr class="separator:ac3608cf83d3537cd1c519b046f34a51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc591095a8e56d4d6f6587c66239fdb3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:acc591095a8e56d4d6f6587c66239fdb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acc591095a8e56d4d6f6587c66239fdb3">ref_count&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *n)</td></tr>
<tr class="separator:acc591095a8e56d4d6f6587c66239fdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3867f02d52edd32b4cfe38e5ee55a1"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7e3867f02d52edd32b4cfe38e5ee55a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7e3867f02d52edd32b4cfe38e5ee55a1">destroy&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *n)</td></tr>
<tr class="separator:a7e3867f02d52edd32b4cfe38e5ee55a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15830092ee01286d279cdc991c1f252"><td class="memTemplParams" colspan="2">template&lt;typename StmtOrExpr &gt; </td></tr>
<tr class="memitem:af15830092ee01286d279cdc991c1f252"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af15830092ee01286d279cdc991c1f252">stmt_or_expr_uses_var</a> (StmtOrExpr e, const std::string &amp;v)</td></tr>
<tr class="memdesc:af15830092ee01286d279cdc991c1f252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a statement or expression references the given variable.  <a href="#af15830092ee01286d279cdc991c1f252">More...</a><br/></td></tr>
<tr class="separator:af15830092ee01286d279cdc991c1f252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29840c52385c687d17608300c94a0ab"><td class="memTemplParams" colspan="2">template&lt;typename StmtOrExpr , typename T &gt; </td></tr>
<tr class="memitem:af29840c52385c687d17608300c94a0ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af29840c52385c687d17608300c94a0ab">stmt_or_expr_uses_vars</a> (StmtOrExpr e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:af29840c52385c687d17608300c94a0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a statement or expression references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument.  <a href="#af29840c52385c687d17608300c94a0ab">More...</a><br/></td></tr>
<tr class="separator:af29840c52385c687d17608300c94a0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af239670eead776a941de1cb3f1a93202"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af239670eead776a941de1cb3f1a93202">expr_uses_var</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;v)</td></tr>
<tr class="memdesc:af239670eead776a941de1cb3f1a93202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an expression references the given variable.  <a href="#af239670eead776a941de1cb3f1a93202">More...</a><br/></td></tr>
<tr class="separator:af239670eead776a941de1cb3f1a93202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e764ec0fdfaddd0ec0e32af023f25f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2e764ec0fdfaddd0ec0e32af023f25f0">stmt_uses_var</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::string &amp;v)</td></tr>
<tr class="memdesc:a2e764ec0fdfaddd0ec0e32af023f25f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a statement references the given variable.  <a href="#a2e764ec0fdfaddd0ec0e32af023f25f0">More...</a><br/></td></tr>
<tr class="separator:a2e764ec0fdfaddd0ec0e32af023f25f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bc2cef7dff2305a29dc5512a7542da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9bc2cef7dff2305a29dc5512a7542da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af9bc2cef7dff2305a29dc5512a7542da">expr_uses_vars</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:af9bc2cef7dff2305a29dc5512a7542da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an expression references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument.  <a href="#af9bc2cef7dff2305a29dc5512a7542da">More...</a><br/></td></tr>
<tr class="separator:af9bc2cef7dff2305a29dc5512a7542da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fff0c011d19ecd028b4710291ffe18"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88fff0c011d19ecd028b4710291ffe18"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a88fff0c011d19ecd028b4710291ffe18">stmt_uses_vars</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a88fff0c011d19ecd028b4710291ffe18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a statement references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument.  <a href="#a88fff0c011d19ecd028b4710291ffe18">More...</a><br/></td></tr>
<tr class="separator:a88fff0c011d19ecd028b4710291ffe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b42e90ad180f1254cdd3be0ae7be89"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a16b42e90ad180f1254cdd3be0ae7be89">find_direct_calls</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:a16b42e90ad180f1254cdd3be0ae7be89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, including in update definitions, update index expressions, and <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> extents.  <a href="#a16b42e90ad180f1254cdd3be0ae7be89">More...</a><br/></td></tr>
<tr class="separator:a16b42e90ad180f1254cdd3be0ae7be89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770da2a7374eb2a8ac60f5c9d90b88ad"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a770da2a7374eb2a8ac60f5c9d90b88ad">find_transitive_calls</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:a770da2a7374eb2a8ac60f5c9d90b88ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, or indirectly in those functions' definitions, recursively.  <a href="#a770da2a7374eb2a8ac60f5c9d90b88ad">More...</a><br/></td></tr>
<tr class="separator:a770da2a7374eb2a8ac60f5c9d90b88ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b98bf6f8f3475caaa691d7884a31d45"><td class="memTemplParams" colspan="2">template&lt;typename Last &gt; </td></tr>
<tr class="memitem:a4b98bf6f8f3475caaa691d7884a31d45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b98bf6f8f3475caaa691d7884a31d45">check_types</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;t, int idx)</td></tr>
<tr class="separator:a4b98bf6f8f3475caaa691d7884a31d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec0560d55ceb7384483f00da38ad73f"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Rest&gt; </td></tr>
<tr class="memitem:abec0560d55ceb7384483f00da38ad73f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abec0560d55ceb7384483f00da38ad73f">check_types</a> (const <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> &amp;t, int idx)</td></tr>
<tr class="separator:abec0560d55ceb7384483f00da38ad73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bce2836846aa0286859b005b6aa015"><td class="memTemplParams" colspan="2">template&lt;typename Last &gt; </td></tr>
<tr class="memitem:a32bce2836846aa0286859b005b6aa015"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a32bce2836846aa0286859b005b6aa015">assign_results</a> (<a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;r, int idx, Last last)</td></tr>
<tr class="separator:a32bce2836846aa0286859b005b6aa015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc822256984ddc07c031b230ce2b8ae"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Rest&gt; </td></tr>
<tr class="memitem:acdc822256984ddc07c031b230ce2b8ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acdc822256984ddc07c031b230ce2b8ae">assign_results</a> (<a class="el" href="class_halide_1_1_realization.html">Realization</a> &amp;r, int idx, First first, Second second, Rest &amp;&amp;...rest)</td></tr>
<tr class="separator:acdc822256984ddc07c031b230ce2b8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9bfb55aa0058e51d72037fde785fb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1f9bfb55aa0058e51d72037fde785fb0">schedule_scalar</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> f)</td></tr>
<tr class="separator:a1f9bfb55aa0058e51d72037fde785fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c3eca91038227e115e5440d687c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a318c3eca91038227e115e5440d687c43">zero_gpu_loop_mins</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a318c3eca91038227e115e5440d687c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite all GPU loops to have a min of zero.  <a href="#a318c3eca91038227e115e5440d687c43">More...</a><br/></td></tr>
<tr class="separator:a318c3eca91038227e115e5440d687c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0081752824625e87b5e95bfae979499f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0081752824625e87b5e95bfae979499f">fuse_gpu_thread_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a0081752824625e87b5e95bfae979499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s GPGPU IR to the OpenCL/CUDA/Metal model.  <a href="#a0081752824625e87b5e95bfae979499f">More...</a><br/></td></tr>
<tr class="separator:a0081752824625e87b5e95bfae979499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a15fc4880c65ae27434a924540a07e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a56a15fc4880c65ae27434a924540a07e">fuzz_float_stores</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a56a15fc4880c65ae27434a924540a07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">On every store of a floating point value, mask off the least-significant-bit of the mantissa.  <a href="#a56a15fc4880c65ae27434a924540a07e">More...</a><br/></td></tr>
<tr class="separator:a56a15fc4880c65ae27434a924540a07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75ada54c5a74973e4d52adddf50ab9b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa75ada54c5a74973e4d52adddf50ab9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa75ada54c5a74973e4d52adddf50ab9b">enum_to_string</a> (const std::map&lt; std::string, T &gt; &amp;enum_map, const T &amp;t)</td></tr>
<tr class="separator:aa75ada54c5a74973e4d52adddf50ab9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e667cda683fba6cce2660ff2ffa48ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::map<br class="typebreak"/>
&lt; std::string, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1e667cda683fba6cce2660ff2ffa48ab">get_halide_type_enum_map</a> ()</td></tr>
<tr class="separator:a1e667cda683fba6cce2660ff2ffa48ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fce0241753e0d1cf50b4615b3d00430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2fce0241753e0d1cf50b4615b3d00430">generate_filter_main</a> (int argc, char **argv, std::ostream &amp;cerr)</td></tr>
<tr class="memdesc:a2fce0241753e0d1cf50b4615b3d00430"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal.html#a2fce0241753e0d1cf50b4615b3d00430" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a> is a convenient wrapper for <a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html#a387ce430f4c9f4366b6477d5625e12cb">GeneratorRegistry::create()</a> + compile_to_files(); it can be trivially wrapped by a "real" main() to produce a command-line utility for ahead-of-time filter compilation.  <a href="#a2fce0241753e0d1cf50b4615b3d00430">More...</a><br/></td></tr>
<tr class="separator:a2fce0241753e0d1cf50b4615b3d00430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386a29f838250d0c3bccc9bf6c2b3706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a386a29f838250d0c3bccc9bf6c2b3706">generator_test</a> ()</td></tr>
<tr class="separator:a386a29f838250d0c3bccc9bf6c2b3706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b403917d39534a2cbdd212efcb4bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a44b403917d39534a2cbdd212efcb4bbe">inject_hexagon_rpc</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;host_target)</td></tr>
<tr class="memdesc:a44b403917d39534a2cbdd212efcb4bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull loops marked with the Hexagon device API to a separate module, and call them through the Hexagon host runtime module.  <a href="#a44b403917d39534a2cbdd212efcb4bbe">More...</a><br/></td></tr>
<tr class="separator:a44b403917d39534a2cbdd212efcb4bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8e5b4d5e4aada5fffc99112a760917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7c8e5b4d5e4aada5fffc99112a760917">optimize_hexagon_shuffles</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, int lut_alignment)</td></tr>
<tr class="memdesc:a7c8e5b4d5e4aada5fffc99112a760917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace indirect and other loads with simple loads + vlut calls.  <a href="#a7c8e5b4d5e4aada5fffc99112a760917">More...</a><br/></td></tr>
<tr class="separator:a7c8e5b4d5e4aada5fffc99112a760917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a7fafb2febda78ab97d76bbc396510"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a40a7fafb2febda78ab97d76bbc396510">optimize_hexagon_instructions</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a40a7fafb2febda78ab97d76bbc396510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hexagon deinterleaves when performing widening operations, and interleaves when performing narrowing operations.  <a href="#a40a7fafb2febda78ab97d76bbc396510">More...</a><br/></td></tr>
<tr class="separator:a40a7fafb2febda78ab97d76bbc396510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a26bb3066dde7afbe33a1007992a22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a47a26bb3066dde7afbe33a1007992a22">call_extern_and_assert</a> (const std::string &amp;name, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="memdesc:a47a26bb3066dde7afbe33a1007992a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to call an extern function, and assert that it returns 0.  <a href="#a47a26bb3066dde7afbe33a1007992a22">More...</a><br/></td></tr>
<tr class="separator:a47a26bb3066dde7afbe33a1007992a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2f86eb8a14e51d81926be0688bb9d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0d2f86eb8a14e51d81926be0688bb9d0">inject_host_dev_buffer_copies</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a0d2f86eb8a14e51d81926be0688bb9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject calls to halide_device_malloc, halide_copy_to_device, and halide_copy_to_host as needed.  <a href="#a0d2f86eb8a14e51d81926be0688bb9d0">More...</a><br/></td></tr>
<tr class="separator:a0d2f86eb8a14e51d81926be0688bb9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0387cd8e369d8d328bd0dd420c3e1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5d0387cd8e369d8d328bd0dd420c3e1d">inject_image_intrinsics</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a5d0387cd8e369d8d328bd0dd420c3e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for kernel for loops and turn loads and stores inside the loops into image load and store intrinsics.  <a href="#a5d0387cd8e369d8d328bd0dd420c3e1d">More...</a><br/></td></tr>
<tr class="separator:a5d0387cd8e369d8d328bd0dd420c3e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94843d09c24cd65c12aa022e0ae3bb70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94843d09c24cd65c12aa022e0ae3bb70">inject_opengl_intrinsics</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a94843d09c24cd65c12aa022e0ae3bb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for kernel for loops and turn loads and stores inside the loops into OpenGL texture load and store intrinsics.  <a href="#a94843d09c24cd65c12aa022e0ae3bb70">More...</a><br/></td></tr>
<tr class="separator:a94843d09c24cd65c12aa022e0ae3bb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfd25a3f86e0f58d65302a4814e3415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aebfd25a3f86e0f58d65302a4814e3415">interval_test</a> ()</td></tr>
<tr class="separator:aebfd25a3f86e0f58d65302a4814e3415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1dc9a55f32a7813f8c76884b83d2e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9a1dc9a55f32a7813f8c76884b83d2e2">ir_equality_test</a> ()</td></tr>
<tr class="separator:a9a1dc9a55f32a7813f8c76884b83d2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2179b452c113777557e86873456174fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2179b452c113777557e86873456174fa">expr_match</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> pattern, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a2179b452c113777557e86873456174fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument.  <a href="#a2179b452c113777557e86873456174fa">More...</a><br/></td></tr>
<tr class="separator:a2179b452c113777557e86873456174fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a9c3dedcf234edd2dd3d4239d0116d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad6a9c3dedcf234edd2dd3d4239d0116d">expr_match</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> pattern, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:ad6a9c3dedcf234edd2dd3d4239d0116d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables are matched consistently.  <a href="#ad6a9c3dedcf234edd2dd3d4239d0116d">More...</a><br/></td></tr>
<tr class="separator:ad6a9c3dedcf234edd2dd3d4239d0116d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e9b6aa83c9f90ff87628d97d9666fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa4e9b6aa83c9f90ff87628d97d9666fd">expr_match_test</a> ()</td></tr>
<tr class="separator:aa4e9b6aa83c9f90ff87628d97d9666fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab370d99a882a8163ae91d43b94d79d02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab370d99a882a8163ae91d43b94d79d02">is_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:ab370d99a882a8163ae91d43b94d79d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants. ">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node. ">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same.  <a href="#ab370d99a882a8163ae91d43b94d79d02">More...</a><br/></td></tr>
<tr class="separator:ab370d99a882a8163ae91d43b94d79d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4c34df915e479f7a5308d13cfbed85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b4c34df915e479f7a5308d13cfbed85">is_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> v)</td></tr>
<tr class="memdesc:a4b4c34df915e479f7a5308d13cfbed85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same.  <a href="#a4b4c34df915e479f7a5308d13cfbed85">More...</a><br/></td></tr>
<tr class="separator:a4b4c34df915e479f7a5308d13cfbed85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feb76bb2b5ae05b49286f7bccaaecf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3feb76bb2b5ae05b49286f7bccaaecf7">as_const_int</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a3feb76bb2b5ae05b49286f7bccaaecf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, return a pointer to its value.  <a href="#a3feb76bb2b5ae05b49286f7bccaaecf7">More...</a><br/></td></tr>
<tr class="separator:a3feb76bb2b5ae05b49286f7bccaaecf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6318d9a64c365a0d891eedb97e2e8a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa6318d9a64c365a0d891eedb97e2e8a4">as_const_uint</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:aa6318d9a64c365a0d891eedb97e2e8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants. ">UIntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants. ">UIntImm</a>, return a pointer to its value.  <a href="#aa6318d9a64c365a0d891eedb97e2e8a4">More...</a><br/></td></tr>
<tr class="separator:aa6318d9a64c365a0d891eedb97e2e8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c789dcfe8f357c6ac50568feb04acfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0c789dcfe8f357c6ac50568feb04acfd">as_const_float</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a0c789dcfe8f357c6ac50568feb04acfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, return a pointer to its value.  <a href="#a0c789dcfe8f357c6ac50568feb04acfd">More...</a><br/></td></tr>
<tr class="separator:a0c789dcfe8f357c6ac50568feb04acfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154fb51a15d5c4b8ecf6f58f62ab9324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a154fb51a15d5c4b8ecf6f58f62ab9324">is_const_power_of_two_integer</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int *bits)</td></tr>
<tr class="memdesc:a154fb51a15d5c4b8ecf6f58f62ab9324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a constant integer power of two.  <a href="#a154fb51a15d5c4b8ecf6f58f62ab9324">More...</a><br/></td></tr>
<tr class="separator:a154fb51a15d5c4b8ecf6f58f62ab9324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad050aaa17987fa4cbb8fd4d41c952e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad050aaa17987fa4cbb8fd4d41c952e04">is_positive_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:ad050aaa17987fa4cbb8fd4d41c952e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression)  <a href="#ad050aaa17987fa4cbb8fd4d41c952e04">More...</a><br/></td></tr>
<tr class="separator:ad050aaa17987fa4cbb8fd4d41c952e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc39652dfc1d64fb82d02dc4064185d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acc39652dfc1d64fb82d02dc4064185d7">is_negative_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:acc39652dfc1d64fb82d02dc4064185d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression)  <a href="#acc39652dfc1d64fb82d02dc4064185d7">More...</a><br/></td></tr>
<tr class="separator:acc39652dfc1d64fb82d02dc4064185d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3da8f6192d557a4bd47cf244b79a9db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af3da8f6192d557a4bd47cf244b79a9db">is_negative_negatable_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:af3da8f6192d557a4bd47cf244b79a9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) and is its negative value representable.  <a href="#af3da8f6192d557a4bd47cf244b79a9db">More...</a><br/></td></tr>
<tr class="separator:af3da8f6192d557a4bd47cf244b79a9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51364d689b51fe9352cfb71e2a7df18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af51364d689b51fe9352cfb71e2a7df18">is_undef</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:af51364d689b51fe9352cfb71e2a7df18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an undef.  <a href="#af51364d689b51fe9352cfb71e2a7df18">More...</a><br/></td></tr>
<tr class="separator:af51364d689b51fe9352cfb71e2a7df18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a521ef987e7964954b997e6dcc5e65b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1a521ef987e7964954b997e6dcc5e65b">is_zero</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a1a521ef987e7964954b997e6dcc5e65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression)  <a href="#a1a521ef987e7964954b997e6dcc5e65b">More...</a><br/></td></tr>
<tr class="separator:a1a521ef987e7964954b997e6dcc5e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940b37091a8f16bf1e4a78db7764274e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a940b37091a8f16bf1e4a78db7764274e">is_one</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a940b37091a8f16bf1e4a78db7764274e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression)  <a href="#a940b37091a8f16bf1e4a78db7764274e">More...</a><br/></td></tr>
<tr class="separator:a940b37091a8f16bf1e4a78db7764274e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeed2f66190d11ee6e56e4089a1f441b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abeed2f66190d11ee6e56e4089a1f441b">is_two</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:abeed2f66190d11ee6e56e4089a1f441b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression)  <a href="#abeed2f66190d11ee6e56e4089a1f441b">More...</a><br/></td></tr>
<tr class="separator:abeed2f66190d11ee6e56e4089a1f441b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d7b687f4ac09ca9236cb1b8b82bb51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab2d7b687f4ac09ca9236cb1b8b82bb51">is_no_op</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:ab2d7b687f4ac09ca9236cb1b8b82bb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect. ">Evaluate</a> node of a constant)  <a href="#ab2d7b687f4ac09ca9236cb1b8b82bb51">More...</a><br/></td></tr>
<tr class="separator:ab2d7b687f4ac09ca9236cb1b8b82bb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f0a20e311c0982fb73a04c84a6bf3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a75f0a20e311c0982fb73a04c84a6bf3c">check_representable</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:a75f0a20e311c0982fb73a04c84a6bf3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a constant value can be correctly represented as the given type.  <a href="#a75f0a20e311c0982fb73a04c84a6bf3c">More...</a><br/></td></tr>
<tr class="separator:a75f0a20e311c0982fb73a04c84a6bf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ddf42fd8c32b453ea049bc176ea3a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a90ddf42fd8c32b453ea049bc176ea3a2">make_bool</a> (bool val, int lanes=1)</td></tr>
<tr class="memdesc:a90ddf42fd8c32b453ea049bc176ea3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean constant from a C++ boolean value.  <a href="#a90ddf42fd8c32b453ea049bc176ea3a2">More...</a><br/></td></tr>
<tr class="separator:a90ddf42fd8c32b453ea049bc176ea3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fedf535d58f8900f8b7c00aa15ece8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a57fedf535d58f8900f8b7c00aa15ece8">make_zero</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a57fedf535d58f8900f8b7c00aa15ece8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of zero in the given type.  <a href="#a57fedf535d58f8900f8b7c00aa15ece8">More...</a><br/></td></tr>
<tr class="separator:a57fedf535d58f8900f8b7c00aa15ece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ace305dbdd7fed2cf9d5057d4c02067c9">make_one</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of one in the given type.  <a href="#ace305dbdd7fed2cf9d5057d4c02067c9">More...</a><br/></td></tr>
<tr class="separator:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc35f0dc3562ffb5bb777021679435e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afc35f0dc3562ffb5bb777021679435e2">make_two</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:afc35f0dc3562ffb5bb777021679435e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of two in the given type.  <a href="#afc35f0dc3562ffb5bb777021679435e2">More...</a><br/></td></tr>
<tr class="separator:afc35f0dc3562ffb5bb777021679435e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baf8e1371967a473027d673c6d48286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7baf8e1371967a473027d673c6d48286">const_true</a> (int lanes=1)</td></tr>
<tr class="memdesc:a7baf8e1371967a473027d673c6d48286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean true.  <a href="#a7baf8e1371967a473027d673c6d48286">More...</a><br/></td></tr>
<tr class="separator:a7baf8e1371967a473027d673c6d48286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455bb5e473e0686b5b027a51228c1af4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a455bb5e473e0686b5b027a51228c1af4">const_false</a> (int lanes=1)</td></tr>
<tr class="memdesc:a455bb5e473e0686b5b027a51228c1af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean false.  <a href="#a455bb5e473e0686b5b027a51228c1af4">More...</a><br/></td></tr>
<tr class="separator:a455bb5e473e0686b5b027a51228c1af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c1bdedbb2a1cfb7aef147bf26998cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af2c1bdedbb2a1cfb7aef147bf26998cc">lossless_cast</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:af2c1bdedbb2a1cfb7aef147bf26998cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to cast an expression to a smaller type while provably not losing information.  <a href="#af2c1bdedbb2a1cfb7aef147bf26998cc">More...</a><br/></td></tr>
<tr class="separator:af2c1bdedbb2a1cfb7aef147bf26998cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40a26aac941b763435e9915851cd073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">match_types</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:ab40a26aac941b763435e9915851cd073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce the two expressions to have the same type, using C-style casting rules.  <a href="#ab40a26aac941b763435e9915851cd073">More...</a><br/></td></tr>
<tr class="separator:ab40a26aac941b763435e9915851cd073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff271995b6126896f73a7211f8a1ce06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aff271995b6126896f73a7211f8a1ce06">raise_to_integer_power</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:aff271995b6126896f73a7211f8a1ce06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise an expression to an integer power by repeatedly multiplying it by itself.  <a href="#aff271995b6126896f73a7211f8a1ce06">More...</a><br/></td></tr>
<tr class="separator:aff271995b6126896f73a7211f8a1ce06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc48fb3424e43b50b5bdc11731285f14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acc48fb3424e43b50b5bdc11731285f14">split_into_ands</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="struct_halide_1_1_internal_1_1cond.html">cond</a>, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:acc48fb3424e43b50b5bdc11731285f14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> a boolean condition into vector of ANDs.  <a href="#acc48fb3424e43b50b5bdc11731285f14">More...</a><br/></td></tr>
<tr class="separator:acc48fb3424e43b50b5bdc11731285f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b821cbe0e228fd5036e9fb1ed693184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7b821cbe0e228fd5036e9fb1ed693184">collect_print_args</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args)</td></tr>
<tr class="separator:a7b821cbe0e228fd5036e9fb1ed693184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa081b03ea688ae0e09ac4c5d77aff33b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa081b03ea688ae0e09ac4c5d77aff33b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa081b03ea688ae0e09ac4c5d77aff33b">collect_print_args</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args, const char *arg, Args &amp;&amp;...more_args)</td></tr>
<tr class="separator:aa081b03ea688ae0e09ac4c5d77aff33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6f133f6a6e341fe686cafbe3c520bc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6a6f133f6a6e341fe686cafbe3c520bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6a6f133f6a6e341fe686cafbe3c520bc">collect_print_args</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;args, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> arg, Args &amp;&amp;...more_args)</td></tr>
<tr class="separator:a6a6f133f6a6e341fe686cafbe3c520bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3a61c8b563a85ef94a175bcb35dee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abc3a61c8b563a85ef94a175bcb35dee2">memoize_tag_helper</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> result, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;cache_key_values)</td></tr>
<tr class="separator:abc3a61c8b563a85ef94a175bcb35dee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadeef8f93d8284eeb98f397cb1a8c7cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aadeef8f93d8284eeb98f397cb1a8c7cf">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> &amp;)</td></tr>
<tr class="memdesc:aadeef8f93d8284eeb98f397cb1a8c7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide for loop type (vectorized, serial, etc) in a human readable form.  <a href="#aadeef8f93d8284eeb98f397cb1a8c7cf">More...</a><br/></td></tr>
<tr class="separator:aadeef8f93d8284eeb98f397cb1a8c7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c00a579c3d86ae40920d5fc4ffe64cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2c00a579c3d86ae40920d5fc4ffe64cf">lower_lerp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> zero_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> one_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> weight)</td></tr>
<tr class="memdesc:a2c00a579c3d86ae40920d5fc4ffe64cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> IR that computes a lerp.  <a href="#a2c00a579c3d86ae40920d5fc4ffe64cf">More...</a><br/></td></tr>
<tr class="separator:a2c00a579c3d86ae40920d5fc4ffe64cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3866cf9bbadd5aed342a5a6e6ffa73"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d3866cf9bbadd5aed342a5a6e6ffa73"><td class="memTemplItemLeft" align="right" valign="top">T::value_type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d3866cf9bbadd5aed342a5a6e6ffa73">iterator_to_pointer</a> (T iter)</td></tr>
<tr class="separator:a3d3866cf9bbadd5aed342a5a6e6ffa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496ad11988df981c987a2557c3cd2d8c"><td class="memItemLeft" align="right" valign="top">llvm::Triple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a496ad11988df981c987a2557c3cd2d8c">get_triple_for_target</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:a496ad11988df981c987a2557c3cd2d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the llvm::Triple that corresponds to the given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a496ad11988df981c987a2557c3cd2d8c">More...</a><br/></td></tr>
<tr class="separator:a496ad11988df981c987a2557c3cd2d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b2ac324e660b73262abdb4b0643451"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a30b2ac324e660b73262abdb4b0643451">get_initial_module_for_target</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a>, llvm::LLVMContext *, bool for_shared_jit_runtime=false, bool just_gpu=false)</td></tr>
<tr class="memdesc:a30b2ac324e660b73262abdb4b0643451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for a given target.  <a href="#a30b2ac324e660b73262abdb4b0643451">More...</a><br/></td></tr>
<tr class="separator:a30b2ac324e660b73262abdb4b0643451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e77b70f4bfb715115d8c3a690b2faa0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9e77b70f4bfb715115d8c3a690b2faa0">get_initial_module_for_ptx_device</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a>, llvm::LLVMContext *c)</td></tr>
<tr class="memdesc:a9e77b70f4bfb715115d8c3a690b2faa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for ptx device.  <a href="#a9e77b70f4bfb715115d8c3a690b2faa0">More...</a><br/></td></tr>
<tr class="separator:a9e77b70f4bfb715115d8c3a690b2faa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabff7722c0ee5cf28db2fd08ca7d18b6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aabff7722c0ee5cf28db2fd08ca7d18b6">get_initial_module_for_renderscript_device</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a> target, llvm::LLVMContext *c)</td></tr>
<tr class="memdesc:aabff7722c0ee5cf28db2fd08ca7d18b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for renderscript.  <a href="#aabff7722c0ee5cf28db2fd08ca7d18b6">More...</a><br/></td></tr>
<tr class="separator:aabff7722c0ee5cf28db2fd08ca7d18b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc91c3863b2f3b6afe3902a717ff68b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1fc91c3863b2f3b6afe3902a717ff68b">loop_carry</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, int max_carried_values=8)</td></tr>
<tr class="memdesc:a1fc91c3863b2f3b6afe3902a717ff68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reuse loads done on previous loop iterations by stashing them in induction variables instead of redoing the load.  <a href="#a1fc91c3863b2f3b6afe3902a717ff68b">More...</a><br/></td></tr>
<tr class="separator:a1fc91c3863b2f3b6afe3902a717ff68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c16d0a33d7fdc862142297ce8f5134"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a78c16d0a33d7fdc862142297ce8f5134">lower</a> (std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; outputs, const std::string &amp;pipeline_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt; &amp;custom_passes=std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt;())</td></tr>
<tr class="memdesc:a78c16d0a33d7fdc862142297ce8f5134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a halide function with a schedule, create a statement that evaluates it.  <a href="#a78c16d0a33d7fdc862142297ce8f5134">More...</a><br/></td></tr>
<tr class="separator:a78c16d0a33d7fdc862142297ce8f5134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3bfe43201bab68cf4820993fe1469b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d3bfe43201bab68cf4820993fe1469b">lower_test</a> ()</td></tr>
<tr class="separator:a4d3bfe43201bab68cf4820993fe1469b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c220ffcd7afe63803179dc304438b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a09c220ffcd7afe63803179dc304438b6">define_matlab_wrapper</a> (llvm::Module *module, llvm::Function *pipeline_argv_wrapper, llvm::Function *metadata_getter)</td></tr>
<tr class="memdesc:a09c220ffcd7afe63803179dc304438b6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions. ">Add</a> a mexFunction wrapper definition to the module, calling the function with the name pipeline_name.  <a href="#a09c220ffcd7afe63803179dc304438b6">More...</a><br/></td></tr>
<tr class="separator:a09c220ffcd7afe63803179dc304438b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585e65b645868795c02e73c853404321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a585e65b645868795c02e73c853404321">inject_memoization</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::string &amp;name, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs)</td></tr>
<tr class="memdesc:a585e65b645868795c02e73c853404321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform pipeline calls for Funcs scheduled with memoize to do a lookup call to the runtime cache implementation, and if there is a miss, compute the results and call the runtime to store it back to the cache.  <a href="#a585e65b645868795c02e73c853404321">More...</a><br/></td></tr>
<tr class="separator:a585e65b645868795c02e73c853404321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb0d4310fbae915041f61f46dc96677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0cb0d4310fbae915041f61f46dc96677">rewrite_memoized_allocations</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a0cb0d4310fbae915041f61f46dc96677"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should be called after Storage Flattening has added Allocation IR nodes.  <a href="#a0cb0d4310fbae915041f61f46dc96677">More...</a><br/></td></tr>
<tr class="separator:a0cb0d4310fbae915041f61f46dc96677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7298e57b1434cccc072c45b6f5c6efef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7298e57b1434cccc072c45b6f5c6efef">modulus_remainder</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a7298e57b1434cccc072c45b6f5c6efef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant.  <a href="#a7298e57b1434cccc072c45b6f5c6efef">More...</a><br/></td></tr>
<tr class="separator:a7298e57b1434cccc072c45b6f5c6efef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ba7c6c7ec1ea5d6eafd713498a1062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a54ba7c6c7ec1ea5d6eafd713498a1062">modulus_remainder</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;scope)</td></tr>
<tr class="memdesc:a54ba7c6c7ec1ea5d6eafd713498a1062"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder:  <a href="#a54ba7c6c7ec1ea5d6eafd713498a1062">More...</a><br/></td></tr>
<tr class="separator:a54ba7c6c7ec1ea5d6eafd713498a1062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e2febe349b889e21aa91a10f7a6a0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a89e2febe349b889e21aa91a10f7a6a0f">modulus_remainder_test</a> ()</td></tr>
<tr class="separator:a89e2febe349b889e21aa91a10f7a6a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2243b7799ccb021a5dd49c4961834fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af2243b7799ccb021a5dd49c4961834fa">gcd</a> (int, int)</td></tr>
<tr class="memdesc:af2243b7799ccb021a5dd49c4961834fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greatest common divisor of two integers.  <a href="#af2243b7799ccb021a5dd49c4961834fa">More...</a><br/></td></tr>
<tr class="separator:af2243b7799ccb021a5dd49c4961834fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc78c709d77e443e9243cab48ed05929"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acc78c709d77e443e9243cab48ed05929">lcm</a> (int, int)</td></tr>
<tr class="memdesc:acc78c709d77e443e9243cab48ed05929"><td class="mdescLeft">&#160;</td><td class="mdescRight">The least common multiple of two integers.  <a href="#acc78c709d77e443e9243cab48ed05929">More...</a><br/></td></tr>
<tr class="separator:acc78c709d77e443e9243cab48ed05929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b5b805d410ace5fad604890402cce5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a37b5b805d410ace5fad604890402cce5">is_monotonic</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;var)</td></tr>
<tr class="separator:a37b5b805d410ace5fad604890402cce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3afe4c4d3960b627d7d98d1f207fa52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad3afe4c4d3960b627d7d98d1f207fa52">is_monotonic_test</a> ()</td></tr>
<tr class="separator:ad3afe4c4d3960b627d7d98d1f207fa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a87590be371b78913eaab20e563f335"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9a87590be371b78913eaab20e563f335">can_parallelize_rvar</a> (const std::string &amp;rvar, const std::string &amp;func, const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;r)</td></tr>
<tr class="memdesc:a9a87590be371b78913eaab20e563f335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> can prove that it is safe to parallelize an update definition across a specific variable.  <a href="#a9a87590be371b78913eaab20e563f335">More...</a><br/></td></tr>
<tr class="separator:a9a87590be371b78913eaab20e563f335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce66817377fbb1918bbe7510ab47b29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0ce66817377fbb1918bbe7510ab47b29">check_call_arg_types</a> (const std::string &amp;name, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; *args, int dims)</td></tr>
<tr class="memdesc:a0ce66817377fbb1918bbe7510ab47b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate arguments to a call to a func, image or imageparam.  <a href="#a0ce66817377fbb1918bbe7510ab47b29">More...</a><br/></td></tr>
<tr class="separator:a0ce66817377fbb1918bbe7510ab47b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe34fa32a730191953a42d96759d23f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acfe34fa32a730191953a42d96759d23f">partition_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:acfe34fa32a730191953a42d96759d23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions loop bodies into a prologue, a steady state, and an epilogue.  <a href="#acfe34fa32a730191953a42d96759d23f">More...</a><br/></td></tr>
<tr class="separator:acfe34fa32a730191953a42d96759d23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00dbff02860c1622c6e4d1fba8ac01e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a00dbff02860c1622c6e4d1fba8ac01e3">inject_prefetch</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="separator:a00dbff02860c1622c6e4d1fba8ac01e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e398566fc51e7921f17b3a438b8f95a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1e398566fc51e7921f17b3a438b8f95a">print_loop_nest</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs)</td></tr>
<tr class="memdesc:a1e398566fc51e7921f17b3a438b8f95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit some simple pseudocode that shows the structure of the loop nest specified by this pipeline's schedule, and the schedules of the functions it uses.  <a href="#a1e398566fc51e7921f17b3a438b8f95a">More...</a><br/></td></tr>
<tr class="separator:a1e398566fc51e7921f17b3a438b8f95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568a0554db6866ee8560c3f599bceadd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a568a0554db6866ee8560c3f599bceadd">inject_profiling</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, std::string)</td></tr>
<tr class="memdesc:a568a0554db6866ee8560c3f599bceadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline insert high-resolution timing into the generated code (via spawning a thread that acts as a sampling profiler); summaries of execution times and counts will be logged at the end.  <a href="#a568a0554db6866ee8560c3f599bceadd">More...</a><br/></td></tr>
<tr class="separator:a568a0554db6866ee8560c3f599bceadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0c1d3ac79fd83cb609d37831253957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#add0c1d3ac79fd83cb609d37831253957">qualify</a> (const std::string &amp;prefix, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value)</td></tr>
<tr class="memdesc:add0c1d3ac79fd83cb609d37831253957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix all variable names in the given expression with the prefix string.  <a href="#add0c1d3ac79fd83cb609d37831253957">More...</a><br/></td></tr>
<tr class="separator:add0c1d3ac79fd83cb609d37831253957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795f343747d7f716a33198907c3e7d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a795f343747d7f716a33198907c3e7d25">random_float</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a795f343747d7f716a33198907c3e7d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random floating-point number between zero and one that varies deterministically based on the input expressions.  <a href="#a795f343747d7f716a33198907c3e7d25">More...</a><br/></td></tr>
<tr class="separator:a795f343747d7f716a33198907c3e7d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e64539c6d89123f6200b919ec28fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae4e64539c6d89123f6200b919ec28fbb">random_int</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ae4e64539c6d89123f6200b919ec28fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random unsigned integer between zero and 2^32-1 that varies deterministically based on the input expressions (which must be integers or unsigned integers).  <a href="#ae4e64539c6d89123f6200b919ec28fbb">More...</a><br/></td></tr>
<tr class="separator:ae4e64539c6d89123f6200b919ec28fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f875bf4d528885d68581fbd198bf356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0f875bf4d528885d68581fbd198bf356">lower_random</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::vector&lt; std::string &gt; &amp;free_vars, int tag)</td></tr>
<tr class="memdesc:a0f875bf4d528885d68581fbd198bf356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert calls to random() to IR generated by random_float and random_int.  <a href="#a0f875bf4d528885d68581fbd198bf356">More...</a><br/></td></tr>
<tr class="separator:a0f875bf4d528885d68581fbd198bf356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e4af61cd70924152b76870cd5fc361"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab7e4af61cd70924152b76870cd5fc361">realization_order</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;output, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:ab7e4af61cd70924152b76870cd5fc361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bunch of functions that call each other, determine an order in which to do the scheduling.  <a href="#ab7e4af61cd70924152b76870cd5fc361">More...</a><br/></td></tr>
<tr class="separator:ab7e4af61cd70924152b76870cd5fc361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38933818f7fe63420bd293296d6c01cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a38933818f7fe63420bd293296d6c01cf">split_predicate_test</a> ()</td></tr>
<tr class="separator:a38933818f7fe63420bd293296d6c01cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8459c153113e252e4cf11fd16326b065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8459c153113e252e4cf11fd16326b065">remove_dead_allocations</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a8459c153113e252e4cf11fd16326b065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Allocate/Free pairs that are never loaded from or stored to, and remove them from the <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>.  <a href="#a8459c153113e252e4cf11fd16326b065">More...</a><br/></td></tr>
<tr class="separator:a8459c153113e252e4cf11fd16326b065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445fa778b28abf135eb1b1d0c8389efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a445fa778b28abf135eb1b1d0c8389efc">remove_trivial_for_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a445fa778b28abf135eb1b1d0c8389efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert for loops of size 1 into <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node. ">LetStmt</a> nodes, which allows for further simplification.  <a href="#a445fa778b28abf135eb1b1d0c8389efc">More...</a><br/></td></tr>
<tr class="separator:a445fa778b28abf135eb1b1d0c8389efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078fe646230de310959c4506c76de02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a078fe646230de310959c4506c76de02e">remove_undef</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a078fe646230de310959c4506c76de02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes stores that depend on undef values, and statements that only contain such stores.  <a href="#a078fe646230de310959c4506c76de02e">More...</a><br/></td></tr>
<tr class="separator:a078fe646230de310959c4506c76de02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec17a0e39d355b75d1d5d3c0ae10dea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aec17a0e39d355b75d1d5d3c0ae10dea0">schedule_functions</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target, bool &amp;any_memoized)</td></tr>
<tr class="memdesc:aec17a0e39d355b75d1d5d3c0ae10dea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build loop nests and inject <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> realizations at the appropriate places using the schedule.  <a href="#aec17a0e39d355b75d1d5d3c0ae10dea0">More...</a><br/></td></tr>
<tr class="separator:aec17a0e39d355b75d1d5d3c0ae10dea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4242a0b28a7409d2a2489a74795914ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4242a0b28a7409d2a2489a74795914ef"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4242a0b28a7409d2a2489a74795914ef">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:a4242a0b28a7409d2a2489a74795914ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6961bbda74000b883fc5759884e4a0b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6961bbda74000b883fc5759884e4a0b0">select_gpu_api</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, <a class="el" href="struct_halide_1_1_target.html">Target</a> t)</td></tr>
<tr class="memdesc:a6961bbda74000b883fc5759884e4a0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace for loops with GPU_Default device_api with an actual device API depending on what's enabled in the target.  <a href="#a6961bbda74000b883fc5759884e4a0b0">More...</a><br/></td></tr>
<tr class="separator:a6961bbda74000b883fc5759884e4a0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9bb398349140947e359eb3b1abc24c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9a9bb398349140947e359eb3b1abc24c">can_prove</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a9a9bb398349140947e359eb3b1abc24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A common use of the simplifier is to prove boolean expressions are true at compile time.  <a href="#a9a9bb398349140947e359eb3b1abc24c">More...</a><br/></td></tr>
<tr class="separator:a9a9bb398349140947e359eb3b1abc24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d8c444c776976f822644dc995d10ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a27d8c444c776976f822644dc995d10ca">simplify_exprs</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:a27d8c444c776976f822644dc995d10ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify expressions found in a statement, but don't simplify across different statements.  <a href="#a27d8c444c776976f822644dc995d10ca">More...</a><br/></td></tr>
<tr class="separator:a27d8c444c776976f822644dc995d10ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff5495089b812474881ee939c4701c4"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:adff5495089b812474881ee939c4701c4"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adff5495089b812474881ee939c4701c4">mod_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr class="separator:adff5495089b812474881ee939c4701c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a60708c880da445554b8eeb778c034"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac9a60708c880da445554b8eeb778c034"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac9a60708c880da445554b8eeb778c034">mod_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr class="separator:ac9a60708c880da445554b8eeb778c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13a82f37fe6336c154122f66d294523"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa13a82f37fe6336c154122f66d294523"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa13a82f37fe6336c154122f66d294523">div_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr class="separator:aa13a82f37fe6336c154122f66d294523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965c871f086a60fda2cc31e678d050a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3965c871f086a60fda2cc31e678d050a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3965c871f086a60fda2cc31e678d050a">div_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr class="separator:a3965c871f086a60fda2cc31e678d050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c952efe23378dcba6fcbd92055c213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a91c952efe23378dcba6fcbd92055c213">simplify_test</a> ()</td></tr>
<tr class="separator:a91c952efe23378dcba6fcbd92055c213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4259425c64a0a9b25760e1c38123c13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af4259425c64a0a9b25760e1c38123c13">simplify_specializations</a> (std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:af4259425c64a0a9b25760e1c38123c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to simplify the RHS/LHS of a function's definition based on its specializations.  <a href="#af4259425c64a0a9b25760e1c38123c13">More...</a><br/></td></tr>
<tr class="separator:af4259425c64a0a9b25760e1c38123c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8489422fe4da6e486b5fd7831aab8bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8489422fe4da6e486b5fd7831aab8bfb">skip_stages</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; std::string &gt; &amp;order)</td></tr>
<tr class="memdesc:a8489422fe4da6e486b5fd7831aab8bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Avoid computing certain stages if we can infer a runtime condition to check that tells us they won't be used.  <a href="#a8489422fe4da6e486b5fd7831aab8bfb">More...</a><br/></td></tr>
<tr class="separator:a8489422fe4da6e486b5fd7831aab8bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bde9012b280aad21a569ea008ed296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a07bde9012b280aad21a569ea008ed296">sliding_window</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a07bde9012b280aad21a569ea008ed296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sliding window optimizations on a halide statement.  <a href="#a07bde9012b280aad21a569ea008ed296">More...</a><br/></td></tr>
<tr class="separator:a07bde9012b280aad21a569ea008ed296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935e1b9f6b8c8aafaa7f7e28ae546c72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_solver_result.html">SolverResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a935e1b9f6b8c8aafaa7f7e28ae546c72">solve_expression</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;variable, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a935e1b9f6b8c8aafaa7f7e28ae546c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to collect all instances of a variable in an expression tree and place it as far to the left as possible, and as far up the tree as possible (i.e.  <a href="#a935e1b9f6b8c8aafaa7f7e28ae546c72">More...</a><br/></td></tr>
<tr class="separator:a935e1b9f6b8c8aafaa7f7e28ae546c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ea43af65052aca0edc723e047a7fcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae6ea43af65052aca0edc723e047a7fcb">solve_for_outer_interval</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c, const std::string &amp;variable)</td></tr>
<tr class="memdesc:ae6ea43af65052aca0edc723e047a7fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the smallest interval such that the condition is either true or false inside of it, but definitely false outside of it.  <a href="#ae6ea43af65052aca0edc723e047a7fcb">More...</a><br/></td></tr>
<tr class="separator:ae6ea43af65052aca0edc723e047a7fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e47b29745810786912857f328fc6b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a97e47b29745810786912857f328fc6b6">solve_for_inner_interval</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c, const std::string &amp;variable)</td></tr>
<tr class="memdesc:a97e47b29745810786912857f328fc6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the largest interval such that the condition is definitely true inside of it, and might be true or false outside of it.  <a href="#a97e47b29745810786912857f328fc6b6">More...</a><br/></td></tr>
<tr class="separator:a97e47b29745810786912857f328fc6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed16d941f9de01188d0d4cc265d4c6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abed16d941f9de01188d0d4cc265d4c6b">and_condition_over_domain</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> c, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;varying)</td></tr>
<tr class="memdesc:abed16d941f9de01188d0d4cc265d4c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a conditional that includes variables that vary over some domain, and convert it to a more conservative (less frequently true) condition that doesn't depend on those variables.  <a href="#abed16d941f9de01188d0d4cc265d4c6b">More...</a><br/></td></tr>
<tr class="separator:abed16d941f9de01188d0d4cc265d4c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff96a46ef180209a14610a2a5a1d74ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aff96a46ef180209a14610a2a5a1d74ba">solve_test</a> ()</td></tr>
<tr class="separator:aff96a46ef180209a14610a2a5a1d74ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18248db0e632551cd5b3376e6ade4365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a18248db0e632551cd5b3376e6ade4365">print_to_html</a> (std::string filename, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a18248db0e632551cd5b3376e6ade4365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump an HTML-formatted print of a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> to filename.  <a href="#a18248db0e632551cd5b3376e6ade4365">More...</a><br/></td></tr>
<tr class="separator:a18248db0e632551cd5b3376e6ade4365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8228323a26e73895bb0e3d3e1e78496"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae8228323a26e73895bb0e3d3e1e78496">print_to_html</a> (std::string filename, const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;m)</td></tr>
<tr class="memdesc:ae8228323a26e73895bb0e3d3e1e78496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump an HTML-formatted print of a <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to filename.  <a href="#ae8228323a26e73895bb0e3d3e1e78496">More...</a><br/></td></tr>
<tr class="separator:ae8228323a26e73895bb0e3d3e1e78496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cb6fe2cb6171bf79124c2c1b1e867f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac8cb6fe2cb6171bf79124c2c1b1e867f">storage_flattening</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:ac8cb6fe2cb6171bf79124c2c1b1e867f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location. ">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;. ">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer. ">Load</a> nodes respectively.  <a href="#ac8cb6fe2cb6171bf79124c2c1b1e867f">More...</a><br/></td></tr>
<tr class="separator:ac8cb6fe2cb6171bf79124c2c1b1e867f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003d25ab32344023873b630df8fc5719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a003d25ab32344023873b630df8fc5719">storage_folding</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a003d25ab32344023873b630df8fc5719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold storage of functions if possible.  <a href="#a003d25ab32344023873b630df8fc5719">More...</a><br/></td></tr>
<tr class="separator:a003d25ab32344023873b630df8fc5719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48710fd66a0823291cabe7451d91f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac48710fd66a0823291cabe7451d91f80">substitute</a> (std::string name, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr class="memdesc:ac48710fd66a0823291cabe7451d91f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within expr.  <a href="#ac48710fd66a0823291cabe7451d91f80">More...</a><br/></td></tr>
<tr class="separator:ac48710fd66a0823291cabe7451d91f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62310d71063459051000c4032c78d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad62310d71063459051000c4032c78d6b">substitute</a> (std::string name, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:ad62310d71063459051000c4032c78d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within stmt.  <a href="#ad62310d71063459051000c4032c78d6b">More...</a><br/></td></tr>
<tr class="separator:ad62310d71063459051000c4032c78d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c39fdac13dbbf178d4ae1680c7dbf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a75c39fdac13dbbf178d4ae1680c7dbf7">target_test</a> ()</td></tr>
<tr class="separator:a75c39fdac13dbbf178d4ae1680c7dbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaccc673e9c40dc5fb5742cdfd1ea37e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afaccc673e9c40dc5fb5742cdfd1ea37e">inject_tracing</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::string &amp;pipeline_name, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;outputs)</td></tr>
<tr class="memdesc:afaccc673e9c40dc5fb5742cdfd1ea37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations.  <a href="#afaccc673e9c40dc5fb5742cdfd1ea37e">More...</a><br/></td></tr>
<tr class="separator:afaccc673e9c40dc5fb5742cdfd1ea37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7de5466472c73e9b9510a19b536481a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae7de5466472c73e9b9510a19b536481a">trim_no_ops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:ae7de5466472c73e9b9510a19b536481a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate loop bounds to the region over which they actually do something.  <a href="#ae7de5466472c73e9b9510a19b536481a">More...</a><br/></td></tr>
<tr class="separator:ae7de5466472c73e9b9510a19b536481a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6c445013b15af0a32bd54f5bb6bdc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0b6c445013b15af0a32bd54f5bb6bdc3">unify_duplicate_lets</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a0b6c445013b15af0a32bd54f5bb6bdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find let statements that all define the same value, and make later ones just reuse the symbol names of the earlier ones.  <a href="#a0b6c445013b15af0a32bd54f5bb6bdc3">More...</a><br/></td></tr>
<tr class="separator:a0b6c445013b15af0a32bd54f5bb6bdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf197e316b7d0a6adb96c25976612c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abf197e316b7d0a6adb96c25976612c1b">uniquify_variable_names</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:abf197e316b7d0a6adb96c25976612c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a statement so that every internally-defined variable name is unique.  <a href="#abf197e316b7d0a6adb96c25976612c1b">More...</a><br/></td></tr>
<tr class="separator:abf197e316b7d0a6adb96c25976612c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1c49e552297672b3751ac988bf70c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adc1c49e552297672b3751ac988bf70c3">unroll_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:adc1c49e552297672b3751ac988bf70c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement.  <a href="#adc1c49e552297672b3751ac988bf70c3">More...</a><br/></td></tr>
<tr class="separator:adc1c49e552297672b3751ac988bf70c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplParams" colspan="2">template&lt;typename DstType , typename SrcType &gt; </td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplItemLeft" align="right" valign="top">DstType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94816d6979fdadb6e206a5d0a668e008">reinterpret_bits</a> (const SrcType &amp;src)</td></tr>
<tr class="memdesc:a94816d6979fdadb6e206a5d0a668e008"><td class="mdescLeft">&#160;</td><td class="mdescRight">An aggressive form of reinterpret cast used for correct type-punning.  <a href="#a94816d6979fdadb6e206a5d0a668e008">More...</a><br/></td></tr>
<tr class="separator:a94816d6979fdadb6e206a5d0a668e008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb97978547d98141752de6b614195f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2eb97978547d98141752de6b614195f4">make_entity_name</a> (void *stack_ptr, const std::string &amp;type, char prefix)</td></tr>
<tr class="memdesc:a2eb97978547d98141752de6b614195f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a unique name for an object based on the name of the stack variable passed in.  <a href="#a2eb97978547d98141752de6b614195f4">More...</a><br/></td></tr>
<tr class="separator:a2eb97978547d98141752de6b614195f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5c91808e78c03a99a02fb7b37d2c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3f5c91808e78c03a99a02fb7b37d2c02">get_env_variable</a> (char const *env_var_name, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> &amp;var_defined)</td></tr>
<tr class="memdesc:a3f5c91808e78c03a99a02fb7b37d2c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get value of an environment variable.  <a href="#a3f5c91808e78c03a99a02fb7b37d2c02">More...</a><br/></td></tr>
<tr class="separator:a3f5c91808e78c03a99a02fb7b37d2c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67ba715b9cc517c979f2f56f1236a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa67ba715b9cc517c979f2f56f1236a33">running_program_name</a> ()</td></tr>
<tr class="memdesc:aa67ba715b9cc517c979f2f56f1236a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the currently running executable.  <a href="#aa67ba715b9cc517c979f2f56f1236a33">More...</a><br/></td></tr>
<tr class="separator:aa67ba715b9cc517c979f2f56f1236a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7703083cfe592de68f37796533724ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa7703083cfe592de68f37796533724ed">starts_with</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:aa7703083cfe592de68f37796533724ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the first string starts with the second string.  <a href="#aa7703083cfe592de68f37796533724ed">More...</a><br/></td></tr>
<tr class="separator:aa7703083cfe592de68f37796533724ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230079281175545b9b90b2285106ab28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a230079281175545b9b90b2285106ab28">ends_with</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a230079281175545b9b90b2285106ab28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the first string ends with the second string.  <a href="#a230079281175545b9b90b2285106ab28">More...</a><br/></td></tr>
<tr class="separator:a230079281175545b9b90b2285106ab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba3d0dce3432d1af82c8548d40406c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acba3d0dce3432d1af82c8548d40406c5">replace_all</a> (const std::string &amp;str, const std::string &amp;find, const std::string &amp;replace)</td></tr>
<tr class="memdesc:acba3d0dce3432d1af82c8548d40406c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches of the second string in the first string with the last string.  <a href="#acba3d0dce3432d1af82c8548d40406c5">More...</a><br/></td></tr>
<tr class="separator:acba3d0dce3432d1af82c8548d40406c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc761896b3e6a38bddce45b6c0f8b15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aedc761896b3e6a38bddce45b6c0f8b15">split_string</a> (const std::string &amp;source, const std::string &amp;delim)</td></tr>
<tr class="memdesc:aedc761896b3e6a38bddce45b6c0f8b15"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> the source string using 'delim' as the divider.  <a href="#aedc761896b3e6a38bddce45b6c0f8b15">More...</a><br/></td></tr>
<tr class="separator:aedc761896b3e6a38bddce45b6c0f8b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaee1bb2b0dc659851899df7c12437ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:aaaee1bb2b0dc659851899df7c12437ba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaaee1bb2b0dc659851899df7c12437ba">fold_left</a> (const std::vector&lt; T &gt; &amp;vec, Fn f)</td></tr>
<tr class="memdesc:aaaee1bb2b0dc659851899df7c12437ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a left fold of a vector.  <a href="#aaaee1bb2b0dc659851899df7c12437ba">More...</a><br/></td></tr>
<tr class="separator:aaaee1bb2b0dc659851899df7c12437ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedfcf82469516f0f05eb5a4699f480a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Fn &gt; </td></tr>
<tr class="memitem:afedfcf82469516f0f05eb5a4699f480a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afedfcf82469516f0f05eb5a4699f480a">fold_right</a> (const std::vector&lt; T &gt; &amp;vec, Fn f)</td></tr>
<tr class="memdesc:afedfcf82469516f0f05eb5a4699f480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a right fold of a vector.  <a href="#afedfcf82469516f0f05eb5a4699f480a">More...</a><br/></td></tr>
<tr class="separator:afedfcf82469516f0f05eb5a4699f480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f0ecaee7837d40c1d42846617992fb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 &gt; </td></tr>
<tr class="memitem:aa0f0ecaee7837d40c1d42846617992fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa0f0ecaee7837d40c1d42846617992fb">collect_paired_args</a> (std::vector&lt; std::pair&lt; T1, T2 &gt;&gt; &amp;collected_args, const T3 &amp;a1, const T4 &amp;a2)</td></tr>
<tr class="separator:aa0f0ecaee7837d40c1d42846617992fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8060f18ae092b69122b0334f9e05f4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename... Args&gt; </td></tr>
<tr class="memitem:a0f8060f18ae092b69122b0334f9e05f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0f8060f18ae092b69122b0334f9e05f4">collect_paired_args</a> (std::vector&lt; std::pair&lt; T1, T2 &gt;&gt; &amp;collected_args, const T3 &amp;a1, const T4 &amp;a2, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a0f8060f18ae092b69122b0334f9e05f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93192a2ea0afe58664e69232595ae08e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a93192a2ea0afe58664e69232595ae08e">extract_namespaces</a> (const std::string &amp;name, std::vector&lt; std::string &gt; &amp;namespaces)</td></tr>
<tr class="memdesc:a93192a2ea0afe58664e69232595ae08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns base name and fills in namespaces, outermost one first in vector.  <a href="#a93192a2ea0afe58664e69232595ae08e">More...</a><br/></td></tr>
<tr class="separator:a93192a2ea0afe58664e69232595ae08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce725835e748b650a0836269a140615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afce725835e748b650a0836269a140615">file_make_temp</a> (const std::string &amp;prefix, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:afce725835e748b650a0836269a140615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary (but writable) directory; this is typically /tmp, but the specific location is not guaranteed.  <a href="#afce725835e748b650a0836269a140615">More...</a><br/></td></tr>
<tr class="separator:afce725835e748b650a0836269a140615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf1e96bff058c5a479b08c236cec689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1cf1e96bff058c5a479b08c236cec689">dir_make_temp</a> ()</td></tr>
<tr class="memdesc:a1cf1e96bff058c5a479b08c236cec689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique directory in an arbitrary (but writable) directory; this is typically somewhere inside /tmp, but the specific location is not guaranteed.  <a href="#a1cf1e96bff058c5a479b08c236cec689">More...</a><br/></td></tr>
<tr class="separator:a1cf1e96bff058c5a479b08c236cec689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518086fef4df79fd915e6489e3be703e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a518086fef4df79fd915e6489e3be703e">file_exists</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a518086fef4df79fd915e6489e3be703e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for access().  <a href="#a518086fef4df79fd915e6489e3be703e">More...</a><br/></td></tr>
<tr class="separator:a518086fef4df79fd915e6489e3be703e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0f0dfc46541dab4528baf664a63ea7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6b0f0dfc46541dab4528baf664a63ea7">file_unlink</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6b0f0dfc46541dab4528baf664a63ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for unlink().  <a href="#a6b0f0dfc46541dab4528baf664a63ea7">More...</a><br/></td></tr>
<tr class="separator:a6b0f0dfc46541dab4528baf664a63ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205a11ea75c89d6642c8476372e2f83d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a205a11ea75c89d6642c8476372e2f83d">dir_rmdir</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a205a11ea75c89d6642c8476372e2f83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for rmdir().  <a href="#a205a11ea75c89d6642c8476372e2f83d">More...</a><br/></td></tr>
<tr class="separator:a205a11ea75c89d6642c8476372e2f83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb54eb008076b8c9d945a770e24799af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acb54eb008076b8c9d945a770e24799af">file_stat</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:acb54eb008076b8c9d945a770e24799af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for stat().  <a href="#acb54eb008076b8c9d945a770e24799af">More...</a><br/></td></tr>
<tr class="separator:acb54eb008076b8c9d945a770e24799af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfef059a37f995f9434f836bdbc1edd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adcfef059a37f995f9434f836bdbc1edd">find_linear_expressions</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:adcfef059a37f995f9434f836bdbc1edd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal.html#adcfef059a37f995f9434f836bdbc1edd" title="find_linear_expressions(Stmt s) identifies expressions that may be moved out of the generated fragmen...">find_linear_expressions(Stmt s)</a> identifies expressions that may be moved out of the generated fragment shader into a varying attribute.  <a href="#adcfef059a37f995f9434f836bdbc1edd">More...</a><br/></td></tr>
<tr class="separator:adcfef059a37f995f9434f836bdbc1edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523c0d5dea7bfbd664e8506ebb7016de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a523c0d5dea7bfbd664e8506ebb7016de">setup_gpu_vertex_buffer</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a523c0d5dea7bfbd664e8506ebb7016de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a set of 2D mesh coordinates based on the behavior of varying attribute expressions contained within a GLSL scheduled for loop.  <a href="#a523c0d5dea7bfbd664e8506ebb7016de">More...</a><br/></td></tr>
<tr class="separator:a523c0d5dea7bfbd664e8506ebb7016de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe70c3a9d0ecd59908b1837a11d01de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abe70c3a9d0ecd59908b1837a11d01de0">vectorize_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:abe70c3a9d0ecd59908b1837a11d01de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors.  <a href="#abe70c3a9d0ecd59908b1837a11d01de0">More...</a><br/></td></tr>
<tr class="separator:abe70c3a9d0ecd59908b1837a11d01de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ba0a978ebdc5f1866290752bd76e6d"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a47ba0a978ebdc5f1866290752bd76e6d">wrap_func_calls</a> (const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a47ba0a978ebdc5f1866290752bd76e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace every call to wrapped Functions in the Functions' definitions with call to their wrapper functions.  <a href="#a47ba0a978ebdc5f1866290752bd76e6d">More...</a><br/></td></tr>
<tr class="separator:a47ba0a978ebdc5f1866290752bd76e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab68083f9769cbbf033176ba50f3709c9"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab68083f9769cbbf033176ba50f3709c9">boxes_required</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:ab68083f9769cbbf033176ba50f3709c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s to each function that occurs within a given statement or expression.  <a href="#ab68083f9769cbbf033176ba50f3709c9">More...</a><br/></td></tr>
<tr class="separator:ab68083f9769cbbf033176ba50f3709c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f12c0072dbbf9639829af1aedda4ea"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af1f12c0072dbbf9639829af1aedda4ea">boxes_required</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:af1f12c0072dbbf9639829af1aedda4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s to each function that occurs within a given statement or expression.  <a href="#af1f12c0072dbbf9639829af1aedda4ea">More...</a><br/></td></tr>
<tr class="separator:af1f12c0072dbbf9639829af1aedda4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aeaf945673dc90b8bdd2e79900b147954"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aeaf945673dc90b8bdd2e79900b147954">boxes_provided</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:aeaf945673dc90b8bdd2e79900b147954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression.  <a href="#aeaf945673dc90b8bdd2e79900b147954">More...</a><br/></td></tr>
<tr class="separator:aeaf945673dc90b8bdd2e79900b147954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c4633706bdb6855b69fb9146ee65ff"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae6c4633706bdb6855b69fb9146ee65ff">boxes_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:ae6c4633706bdb6855b69fb9146ee65ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression.  <a href="#ae6c4633706bdb6855b69fb9146ee65ff">More...</a><br/></td></tr>
<tr class="separator:ae6c4633706bdb6855b69fb9146ee65ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae5c5855f4212c1cb3880a8534b6f41b6"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae5c5855f4212c1cb3880a8534b6f41b6">boxes_touched</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:ae5c5855f4212c1cb3880a8534b6f41b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression.  <a href="#ae5c5855f4212c1cb3880a8534b6f41b6">More...</a><br/></td></tr>
<tr class="separator:ae5c5855f4212c1cb3880a8534b6f41b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbd14233932a8f658ac66d45e00d7fb"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0fbd14233932a8f658ac66d45e00d7fb">boxes_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a0fbd14233932a8f658ac66d45e00d7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression.  <a href="#a0fbd14233932a8f658ac66d45e00d7fb">More...</a><br/></td></tr>
<tr class="separator:a0fbd14233932a8f658ac66d45e00d7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a69980b5d1669ec54e78b7d393d8a7201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a69980b5d1669ec54e78b7d393d8a7201">box_required</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a69980b5d1669ec54e78b7d393d8a7201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a69980b5d1669ec54e78b7d393d8a7201">More...</a><br/></td></tr>
<tr class="separator:a69980b5d1669ec54e78b7d393d8a7201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6ad02cea8b0bacbb0b3c1f644af501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aea6ad02cea8b0bacbb0b3c1f644af501">box_required</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:aea6ad02cea8b0bacbb0b3c1f644af501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#aea6ad02cea8b0bacbb0b3c1f644af501">More...</a><br/></td></tr>
<tr class="separator:aea6ad02cea8b0bacbb0b3c1f644af501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0586fc0706c9a4d39f0ae5f9c7073c86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0586fc0706c9a4d39f0ae5f9c7073c86">box_provided</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a0586fc0706c9a4d39f0ae5f9c7073c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a0586fc0706c9a4d39f0ae5f9c7073c86">More...</a><br/></td></tr>
<tr class="separator:a0586fc0706c9a4d39f0ae5f9c7073c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4d7463fc7d96132bbe01768f967dd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9d4d7463fc7d96132bbe01768f967dd6">box_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a9d4d7463fc7d96132bbe01768f967dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a9d4d7463fc7d96132bbe01768f967dd6">More...</a><br/></td></tr>
<tr class="separator:a9d4d7463fc7d96132bbe01768f967dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa211ee508998ef25191d04fa45eb16c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa211ee508998ef25191d04fa45eb16c7">box_touched</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:aa211ee508998ef25191d04fa45eb16c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#aa211ee508998ef25191d04fa45eb16c7">More...</a><br/></td></tr>
<tr class="separator:aa211ee508998ef25191d04fa45eb16c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a819815a3d7f37a441a22c06689689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a35a819815a3d7f37a441a22c06689689">box_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a35a819815a3d7f37a441a22c06689689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a35a819815a3d7f37a441a22c06689689">More...</a><br/></td></tr>
<tr class="separator:a35a819815a3d7f37a441a22c06689689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab7a4f18b650b23e1e6ed980d1feebcf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab7a4f18b650b23e1e6ed980d1feebcf5">lower_euclidean_div</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ab7a4f18b650b23e1e6ed980d1feebcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero.  <a href="#ab7a4f18b650b23e1e6ed980d1feebcf5">More...</a><br/></td></tr>
<tr class="separator:ab7a4f18b650b23e1e6ed980d1feebcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81d78fd7f3115750e17167ebf0fe920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae81d78fd7f3115750e17167ebf0fe920">lower_euclidean_mod</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:ae81d78fd7f3115750e17167ebf0fe920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero.  <a href="#ae81d78fd7f3115750e17167ebf0fe920">More...</a><br/></td></tr>
<tr class="separator:ae81d78fd7f3115750e17167ebf0fe920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a70a9ad424415eeb1529413e529e17d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a70a9ad424415eeb1529413e529e17d83">eliminate_bool_vectors</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a70a9ad424415eeb1529413e529e17d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on.  <a href="#a70a9ad424415eeb1529413e529e17d83">More...</a><br/></td></tr>
<tr class="separator:a70a9ad424415eeb1529413e529e17d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad795b88cdb0e1c0c664ed94dd86642a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad795b88cdb0e1c0c664ed94dd86642a9">eliminate_bool_vectors</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> s)</td></tr>
<tr class="memdesc:ad795b88cdb0e1c0c664ed94dd86642a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on.  <a href="#ad795b88cdb0e1c0c664ed94dd86642a9">More...</a><br/></td></tr>
<tr class="separator:ad795b88cdb0e1c0c664ed94dd86642a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abfe3690b39dbad72494049eda6d89dcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abfe3690b39dbad72494049eda6d89dcf">native_deinterleave</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:abfe3690b39dbad72494049eda6d89dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate deinterleave or interleave operations, operating on groups of vectors at a time.  <a href="#abfe3690b39dbad72494049eda6d89dcf">More...</a><br/></td></tr>
<tr class="separator:abfe3690b39dbad72494049eda6d89dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd389a510a98d7e4cda77280a299345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6cd389a510a98d7e4cda77280a299345">native_interleave</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a6cd389a510a98d7e4cda77280a299345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate deinterleave or interleave operations, operating on groups of vectors at a time.  <a href="#a6cd389a510a98d7e4cda77280a299345">More...</a><br/></td></tr>
<tr class="separator:a6cd389a510a98d7e4cda77280a299345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc23c653c21c17cb6104565d4e9cae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afcc23c653c21c17cb6104565d4e9cae6">is_native_deinterleave</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:afcc23c653c21c17cb6104565d4e9cae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate deinterleave or interleave operations, operating on groups of vectors at a time.  <a href="#afcc23c653c21c17cb6104565d4e9cae6">More...</a><br/></td></tr>
<tr class="separator:afcc23c653c21c17cb6104565d4e9cae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6603e09402b55b5ab00239ab3c9e04bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6603e09402b55b5ab00239ab3c9e04bd">is_native_interleave</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> x)</td></tr>
<tr class="memdesc:a6603e09402b55b5ab00239ab3c9e04bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate deinterleave or interleave operations, operating on groups of vectors at a time.  <a href="#a6603e09402b55b5ab00239ab3c9e04bd">More...</a><br/></td></tr>
<tr class="separator:a6603e09402b55b5ab00239ab3c9e04bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a38c4753b75f784e928d24b5f085ed383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a38c4753b75f784e928d24b5f085ed383">inline_function</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>)</td></tr>
<tr class="memdesc:a38c4753b75f784e928d24b5f085ed383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a single named function, which must be pure.  <a href="#a38c4753b75f784e928d24b5f085ed383">More...</a><br/></td></tr>
<tr class="separator:a38c4753b75f784e928d24b5f085ed383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839846970613235cae5c8904a5fda794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a839846970613235cae5c8904a5fda794">inline_function</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>)</td></tr>
<tr class="memdesc:a839846970613235cae5c8904a5fda794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a single named function, which must be pure.  <a href="#a839846970613235cae5c8904a5fda794">More...</a><br/></td></tr>
<tr class="separator:a839846970613235cae5c8904a5fda794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9ff5beef3c5a4ec908d9c2bbe99a71f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ff5beef3c5a4ec908d9c2bbe99a71f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9ff5beef3c5a4ec908d9c2bbe99a71f9">ref_count</a> (const T *)</td></tr>
<tr class="memdesc:a9ff5beef3c5a4ec908d9c2bbe99a71f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here.  <a href="#a9ff5beef3c5a4ec908d9c2bbe99a71f9">More...</a><br/></td></tr>
<tr class="separator:a9ff5beef3c5a4ec908d9c2bbe99a71f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada37ff426984f7459fe0bbe38b9e11f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada37ff426984f7459fe0bbe38b9e11f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ada37ff426984f7459fe0bbe38b9e11f0">destroy</a> (const T *)</td></tr>
<tr class="memdesc:ada37ff426984f7459fe0bbe38b9e11f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here.  <a href="#ada37ff426984f7459fe0bbe38b9e11f0">More...</a><br/></td></tr>
<tr class="separator:ada37ff426984f7459fe0bbe38b9e11f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a31dc49947eec58e14aab236c7b0182ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a31dc49947eec58e14aab236c7b0182ee">equal</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a31dc49947eec58e14aab236c7b0182ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a31dc49947eec58e14aab236c7b0182ee">More...</a><br/></td></tr>
<tr class="separator:a31dc49947eec58e14aab236c7b0182ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d404e95dced22ae673144c0351f186f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d404e95dced22ae673144c0351f186f">equal</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> a, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> b)</td></tr>
<tr class="memdesc:a4d404e95dced22ae673144c0351f186f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a4d404e95dced22ae673144c0351f186f">More...</a><br/></td></tr>
<tr class="separator:a4d404e95dced22ae673144c0351f186f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa92b936aa610bfa43e2b0a158d700d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6fa92b936aa610bfa43e2b0a158d700d">graph_equal</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a6fa92b936aa610bfa43e2b0a158d700d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a6fa92b936aa610bfa43e2b0a158d700d">More...</a><br/></td></tr>
<tr class="separator:a6fa92b936aa610bfa43e2b0a158d700d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a990211f75bf579328387fa24a27b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a75a990211f75bf579328387fa24a27b3">graph_equal</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> a, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> b)</td></tr>
<tr class="memdesc:a75a990211f75bf579328387fa24a27b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a75a990211f75bf579328387fa24a27b3">More...</a><br/></td></tr>
<tr class="separator:a75a990211f75bf579328387fa24a27b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aff2e2c3b53edabca8089670422959e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:aff2e2c3b53edabca8089670422959e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#aff2e2c3b53edabca8089670422959e18">More...</a><br/></td></tr>
<tr class="separator:aff2e2c3b53edabca8089670422959e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4212797e9dcc4a1a3577c6e6475832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7e4212797e9dcc4a1a3577c6e6475832">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val)</td></tr>
<tr class="memdesc:a7e4212797e9dcc4a1a3577c6e6475832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a7e4212797e9dcc4a1a3577c6e6475832">More...</a><br/></td></tr>
<tr class="separator:a7e4212797e9dcc4a1a3577c6e6475832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ec777cbfe66e5a592adf1eea14ec64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab4ec777cbfe66e5a592adf1eea14ec64">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, double val)</td></tr>
<tr class="memdesc:ab4ec777cbfe66e5a592adf1eea14ec64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#ab4ec777cbfe66e5a592adf1eea14ec64">More...</a><br/></td></tr>
<tr class="separator:ab4ec777cbfe66e5a592adf1eea14ec64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaae8ca905f0ce9cde74cc0897a61c4e7">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> val)</td></tr>
<tr class="memdesc:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#aaae8ca905f0ce9cde74cc0897a61c4e7">More...</a><br/></td></tr>
<tr class="separator:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b64c00a450c92807011cdc02f8b29b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a70b64c00a450c92807011cdc02f8b29b">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> val)</td></tr>
<tr class="memdesc:a70b64c00a450c92807011cdc02f8b29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a70b64c00a450c92807011cdc02f8b29b">More...</a><br/></td></tr>
<tr class="separator:a70b64c00a450c92807011cdc02f8b29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df9ef655a78f9fb233fa0322525496c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4df9ef655a78f9fb233fa0322525496c">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#ac124c451b40871e78c16cb36581022ae">int16_t</a> val)</td></tr>
<tr class="memdesc:a4df9ef655a78f9fb233fa0322525496c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a4df9ef655a78f9fb233fa0322525496c">More...</a><br/></td></tr>
<tr class="separator:a4df9ef655a78f9fb233fa0322525496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af14e2dade91eb04482b4b5ffdfc920dd">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a> val)</td></tr>
<tr class="memdesc:af14e2dade91eb04482b4b5ffdfc920dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#af14e2dade91eb04482b4b5ffdfc920dd">More...</a><br/></td></tr>
<tr class="separator:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5231b80b8e1a7904cdd4fcac7b89a98d">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#acfd957407fbe865fe77f6fdf86818f5e">int8_t</a> val)</td></tr>
<tr class="memdesc:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a5231b80b8e1a7904cdd4fcac7b89a98d">More...</a><br/></td></tr>
<tr class="separator:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae9a1ece36d20a64a59c92bf7f8c4e9aa">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> val)</td></tr>
<tr class="memdesc:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#ae9a1ece36d20a64a59c92bf7f8c4e9aa">More...</a><br/></td></tr>
<tr class="separator:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#addbd965eccbcfc1f5b80eaa0607f698c">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, bool val)</td></tr>
<tr class="memdesc:addbd965eccbcfc1f5b80eaa0607f698c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#addbd965eccbcfc1f5b80eaa0607f698c">More...</a><br/></td></tr>
<tr class="separator:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90929bcfb18413ffd527152bb8580de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa90929bcfb18413ffd527152bb8580de">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, float val)</td></tr>
<tr class="memdesc:aa90929bcfb18413ffd527152bb8580de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#aa90929bcfb18413ffd527152bb8580de">More...</a><br/></td></tr>
<tr class="separator:aa90929bcfb18413ffd527152bb8580de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592ef00a06a1d8f017b48359099c16d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6592ef00a06a1d8f017b48359099c16d">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, <a class="el" href="struct_halide_1_1float16__t.html">float16_t</a> val)</td></tr>
<tr class="memdesc:a6592ef00a06a1d8f017b48359099c16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a6592ef00a06a1d8f017b48359099c16d">More...</a><br/></td></tr>
<tr class="separator:a6592ef00a06a1d8f017b48359099c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af36627bf7242718b1c73214296dc9090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af36627bf7242718b1c73214296dc9090">halide_log</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:af36627bf7242718b1c73214296dc9090"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals.  <a href="#af36627bf7242718b1c73214296dc9090">More...</a><br/></td></tr>
<tr class="separator:af36627bf7242718b1c73214296dc9090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5688772a963296ea52d2bd9ac5913e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5688772a963296ea52d2bd9ac5913e79">halide_exp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a5688772a963296ea52d2bd9ac5913e79"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals.  <a href="#a5688772a963296ea52d2bd9ac5913e79">More...</a><br/></td></tr>
<tr class="separator:a5688772a963296ea52d2bd9ac5913e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d36eef829f9c1e2d6aaf9218b2e0e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d36eef829f9c1e2d6aaf9218b2e0e66">halide_erf</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a3d36eef829f9c1e2d6aaf9218b2e0e66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals.  <a href="#a3d36eef829f9c1e2d6aaf9218b2e0e66">More...</a><br/></td></tr>
<tr class="separator:a3d36eef829f9c1e2d6aaf9218b2e0e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac074a908960c5cc4d53e4126869245d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac074a908960c5cc4d53e4126869245d1">reduce_expr_modulo</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int modulus, int *remainder)</td></tr>
<tr class="memdesc:ac074a908960c5cc4d53e4126869245d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an expression modulo some integer.  <a href="#ac074a908960c5cc4d53e4126869245d1">More...</a><br/></td></tr>
<tr class="separator:ac074a908960c5cc4d53e4126869245d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a8f7f1ebbdf53051f5403178c164e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a46a8f7f1ebbdf53051f5403178c164e5">reduce_expr_modulo</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int modulus, int *remainder, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;scope)</td></tr>
<tr class="memdesc:a46a8f7f1ebbdf53051f5403178c164e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an expression modulo some integer.  <a href="#a46a8f7f1ebbdf53051f5403178c164e5">More...</a><br/></td></tr>
<tr class="separator:a46a8f7f1ebbdf53051f5403178c164e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4b077780a2dcb6ed633f6f5d111046c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b077780a2dcb6ed633f6f5d111046c2">simplify</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, bool simplify_lets=true, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;bounds=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;alignment=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a4b077780a2dcb6ed633f6f5d111046c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc.  <a href="#a4b077780a2dcb6ed633f6f5d111046c2">More...</a><br/></td></tr>
<tr class="separator:a4b077780a2dcb6ed633f6f5d111046c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2006cf9a5d8bad4e7861a3a10168b1d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2006cf9a5d8bad4e7861a3a10168b1d6">simplify</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, bool simplify_lets=true, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;bounds=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;alignment=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a2006cf9a5d8bad4e7861a3a10168b1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc.  <a href="#a2006cf9a5d8bad4e7861a3a10168b1d6">More...</a><br/></td></tr>
<tr class="separator:a2006cf9a5d8bad4e7861a3a10168b1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6cd3908859c82249a2c7f10158883a97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cd3908859c82249a2c7f10158883a97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">mod_imp</a> (T a, T b)</td></tr>
<tr class="memdesc:a6cd3908859c82249a2c7f10158883a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>.  <a href="#a6cd3908859c82249a2c7f10158883a97">More...</a><br/></td></tr>
<tr class="separator:a6cd3908859c82249a2c7f10158883a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0442f9a0450f45683938a69ce0273974"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0442f9a0450f45683938a69ce0273974"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">div_imp</a> (T a, T b)</td></tr>
<tr class="memdesc:a0442f9a0450f45683938a69ce0273974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>.  <a href="#a0442f9a0450f45683938a69ce0273974">More...</a><br/></td></tr>
<tr class="separator:a0442f9a0450f45683938a69ce0273974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6daa7c8282e00d77d69713bd0ca4c73d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6daa7c8282e00d77d69713bd0ca4c73d">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr class="memdesc:a6daa7c8282e00d77d69713bd0ca4c73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with names in the map.  <a href="#a6daa7c8282e00d77d69713bd0ca4c73d">More...</a><br/></td></tr>
<tr class="separator:a6daa7c8282e00d77d69713bd0ca4c73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f67c2e11eb92dcfb534e01a4e431e29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6f67c2e11eb92dcfb534e01a4e431e29">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a6f67c2e11eb92dcfb534e01a4e431e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with names in the map.  <a href="#a6f67c2e11eb92dcfb534e01a4e431e29">More...</a><br/></td></tr>
<tr class="separator:a6f67c2e11eb92dcfb534e01a4e431e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9624281bd69638e2901f037e7d481dc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9624281bd69638e2901f037e7d481dc8">substitute</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> find, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr class="memdesc:a9624281bd69638e2901f037e7d481dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute expressions for other expressions.  <a href="#a9624281bd69638e2901f037e7d481dc8">More...</a><br/></td></tr>
<tr class="separator:a9624281bd69638e2901f037e7d481dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3066061a33cacb7f0c7ab0fc63eefe84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3066061a33cacb7f0c7ab0fc63eefe84">substitute</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> find, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a3066061a33cacb7f0c7ab0fc63eefe84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute expressions for other expressions.  <a href="#a3066061a33cacb7f0c7ab0fc63eefe84">More...</a><br/></td></tr>
<tr class="separator:a3066061a33cacb7f0c7ab0fc63eefe84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a82ec663fe98ff797570d624865d72390"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a82ec663fe98ff797570d624865d72390">graph_substitute</a> (std::string name, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr class="memdesc:a82ec663fe98ff797570d624865d72390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutions where the IR may be a general graph (and not just a DAG).  <a href="#a82ec663fe98ff797570d624865d72390">More...</a><br/></td></tr>
<tr class="separator:a82ec663fe98ff797570d624865d72390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c182d9900ff0e7e47da4949fc9f913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a87c182d9900ff0e7e47da4949fc9f913">graph_substitute</a> (std::string name, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a87c182d9900ff0e7e47da4949fc9f913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutions where the IR may be a general graph (and not just a DAG).  <a href="#a87c182d9900ff0e7e47da4949fc9f913">More...</a><br/></td></tr>
<tr class="separator:a87c182d9900ff0e7e47da4949fc9f913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f8abdf5154d9a9fa66e0e92842b650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a01f8abdf5154d9a9fa66e0e92842b650">graph_substitute</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> find, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr class="memdesc:a01f8abdf5154d9a9fa66e0e92842b650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutions where the IR may be a general graph (and not just a DAG).  <a href="#a01f8abdf5154d9a9fa66e0e92842b650">More...</a><br/></td></tr>
<tr class="separator:a01f8abdf5154d9a9fa66e0e92842b650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8009665b3c0e8441bb4a5dd27cfa8e3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8009665b3c0e8441bb4a5dd27cfa8e3b">graph_substitute</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> find, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a8009665b3c0e8441bb4a5dd27cfa8e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutions where the IR may be a general graph (and not just a DAG).  <a href="#a8009665b3c0e8441bb4a5dd27cfa8e3b">More...</a><br/></td></tr>
<tr class="separator:a8009665b3c0e8441bb4a5dd27cfa8e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0b8a52e8564fccbd77e9e133ea2fe45d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0b8a52e8564fccbd77e9e133ea2fe45d">substitute_in_all_lets</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr class="memdesc:a0b8a52e8564fccbd77e9e133ea2fe45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute in all let Exprs in a piece of IR.  <a href="#a0b8a52e8564fccbd77e9e133ea2fe45d">More...</a><br/></td></tr>
<tr class="separator:a0b8a52e8564fccbd77e9e133ea2fe45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab579b1fa582db455111a5083fa0c8708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab579b1fa582db455111a5083fa0c8708">substitute_in_all_lets</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:ab579b1fa582db455111a5083fa0c8708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute in all let Exprs in a piece of IR.  <a href="#ab579b1fa582db455111a5083fa0c8708">More...</a><br/></td></tr>
<tr class="separator:ab579b1fa582db455111a5083fa0c8708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acd575ab182df12cc793dba4aa241c1a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">unique_name</a> (char prefix)</td></tr>
<tr class="memdesc:acd575ab182df12cc793dba4aa241c1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given prefix.  <a href="#acd575ab182df12cc793dba4aa241c1a9">More...</a><br/></td></tr>
<tr class="separator:acd575ab182df12cc793dba4aa241c1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd494d26bfdb439727f5a9e8ecc48537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acd494d26bfdb439727f5a9e8ecc48537">unique_name</a> (const std::string &amp;prefix)</td></tr>
<tr class="memdesc:acd494d26bfdb439727f5a9e8ecc48537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given prefix.  <a href="#acd494d26bfdb439727f5a9e8ecc48537">More...</a><br/></td></tr>
<tr class="separator:acd494d26bfdb439727f5a9e8ecc48537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8cc678d669d07fdd15685b87e3b8b620"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8cc678d669d07fdd15685b87e3b8b620">add_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:a8cc678d669d07fdd15685b87e3b8b620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines to test if math would overflow for signed integers with the given number of bits.  <a href="#a8cc678d669d07fdd15685b87e3b8b620">More...</a><br/></td></tr>
<tr class="separator:a8cc678d669d07fdd15685b87e3b8b620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c64641e261b5596a2ab6d7da7f8ef8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a82c64641e261b5596a2ab6d7da7f8ef8">sub_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:a82c64641e261b5596a2ab6d7da7f8ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines to test if math would overflow for signed integers with the given number of bits.  <a href="#a82c64641e261b5596a2ab6d7da7f8ef8">More...</a><br/></td></tr>
<tr class="separator:a82c64641e261b5596a2ab6d7da7f8ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaa735c9ff93372dce25222fb551b67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9aaa735c9ff93372dce25222fb551b67">mul_would_overflow</a> (int bits, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:a9aaa735c9ff93372dce25222fb551b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines to test if math would overflow for signed integers with the given number of bits.  <a href="#a9aaa735c9ff93372dce25222fb551b67">More...</a><br/></td></tr>
<tr class="separator:a9aaa735c9ff93372dce25222fb551b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aaa0611a86047e2c583dd061a620dcc6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::pair&lt;std::string, int&gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">Halide::Internal::FuncValueBounds</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_bounds_8h_source.html#l00016">16</a> of file <a class="el" href="_bounds_8h_source.html">Bounds.h</a>.</p>

</div>
</div>
<a class="anchor" id="aecc03e0ba4be51afc995f76d6d309aca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#aecc03e0ba4be51afc995f76d6d309aca">Halide::Internal::GeneratorParamImplBase</a> = typedef typename <a class="el" href="struct_halide_1_1_internal_1_1select__type.html">Internal::select_type</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1cond.html">Internal::cond</a>&lt;std::is_same&lt;T, <a class="el" href="struct_halide_1_1_target.html">Target</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___target.html">Internal::GeneratorParam_Target</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">Internal::cond</a>&lt;std::is_same&lt;T, <a class="el" href="struct_halide_1_1_type.html">Type</a>&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___type.html">Internal::GeneratorParam_Type</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">Internal::cond</a>&lt;std::is_same&lt;T, bool&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___bool.html">Internal::GeneratorParam_Bool</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">Internal::cond</a>&lt;std::is_arithmetic&lt;T&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___arithmetic.html">Internal::GeneratorParam_Arithmetic</a>&lt;T&gt;&gt;, <a class="el" href="struct_halide_1_1_internal_1_1cond.html">Internal::cond</a>&lt;std::is_enum&lt;T&gt;::value, <a class="el" href="class_halide_1_1_internal_1_1_generator_param___enum.html">Internal::GeneratorParam_Enum</a>&lt;T&gt;&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_generator_8h_source.html#l00295">295</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a class="anchor" id="abd1b9521b6f1f513178f281d8f395335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Halide::Internal::Region</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A multi-dimensional box. </p>
<p>The outer product of the elements </p>

<p>Definition at line <a class="el" href="_i_r_8h_source.html#l00381">381</a> of file <a class="el" href="_i_r_8h_source.html">IR.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7db928fd19209689611a24deafa15b9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* Halide::Internal::halide_task)(void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_j_i_t_module_8h_source.html#l00141">141</a> of file <a class="el" href="_j_i_t_module_8h_source.html">JITModule.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7114c2dcec2af79da28735c5b11c0916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef llvm::raw_pwrite_stream <a class="el" href="namespace_halide_1_1_internal.html#a7114c2dcec2af79da28735c5b11c0916">Halide::Internal::LLVMOStream</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_l_l_v_m___output_8h_source.html#l00027">27</a> of file <a class="el" href="_l_l_v_m___output_8h_source.html">LLVM_Output.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a8548315fd4d13ccebe45a8123369f7ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a8548315fd4d13ccebe45a8123369f7ca">Halide::Internal::Direction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a8548315fd4d13ccebe45a8123369f7caa19de5b94f7b83900d4b296d9fa491aec"></a>Upper</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8548315fd4d13ccebe45a8123369f7caab75fcdd2d72d9e000beab48622402d93"></a>Lower</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_bounds_8h_source.html#l00038">38</a> of file <a class="el" href="_bounds_8h_source.html">Bounds.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#aee9e0b8e5376e2294d74ded8e7de9ef2">Halide::Internal::IRNodeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All our IR node types get unique IDs for the purposes of RTTI. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ad90896d6a515230ad67dfc865553e417"></a>IntImm</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a180c72f0a469e718cd8c2d23fb87ffb8"></a>UIntImm</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a42e91b555b80a7e354d5e43a9fc4be07"></a>FloatImm</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a771ef82b08c11e5688dcb0714a7bbc73"></a>StringImm</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a4cd9f3996d60790cd11c04f842ebc43c"></a>Cast</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a47c14840d8e15331fa420b9b2f757cd9"></a>Variable</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2aec211f7c20af43e742bf2570c3cb84f9"></a>Add</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ae80155eceb940c89e2de63ad05868db2"></a>Sub</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a43d11850893d2fe84a1e618121c1cc0a"></a>Div</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a7aeb0277500c86e4aa6bd23f9a737942"></a>Mod</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a78d811e98514cd165dda532286610fd2"></a>Min</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a6a061313d22e51e0f25b7cd4dc065233"></a>Max</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a2dcbad7477fd40561e8b8198f173bd47"></a>EQ</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2adc33066c3993e0d50896e533fd692ce0"></a>NE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ac562607189d77eb9dfb707464c1e7b0b"></a>LT</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2acfe6055d2e0503be378bb63449ec7ba6"></a>LE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2acd6a9bd2a175104eed40f0d33a8b4020"></a>GT</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2af803729628adf4199f224c2a225038e9"></a>GE</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ac33315685a0cba3ce53be378b3c7874b"></a>And</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a3a2d5fe857d8f9541136a124c2edec6c"></a>Or</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2aa74c05d080620f087c4e523977230666"></a>Not</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ae0626222614bdee31951d84c64e5e9ff"></a>Select</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2af19dbf2edb3a0bd74b0524d960ff21eb"></a>Load</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a99b4c3afc6aaa3ab4de17c90455a55eb"></a>Ramp</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2abe55b6387170df0ca68f41225268e842"></a>Broadcast</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ac3755e61202abd74da5885d2e9c9160e"></a>Call</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2acae6404c4aecf46684930fe2a86676a6"></a>Let</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2aa7312a9d08c50e9dbc7043efe7b54df2"></a>LetStmt</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a592a4f2501f4145b888a956d28448742"></a>AssertStmt</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a2c20d259c8ce0541078629d15be803a0"></a>ProducerConsumer</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a39e61d57e9209611edd4f884e9e47c11"></a>For</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2afdb0c388de01d545017cdf9ccf00eb72"></a>Store</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2a2e5af173c7126a0e6f6bc996222386c7"></a>Provide</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ac9baacf6cca6c54626e594639081177f"></a>Allocate</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ab24ce0cd392a5b0b8dedc66c25213594"></a>Free</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2acbe1377636dc5dc95b68ff96203249cc"></a>Realize</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ae1e4c8c9ccd9fc39c391da4bcd093fb2"></a>Block</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2aaff6933d8331eca27edc911467980c9c"></a>IfThenElse</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aee9e0b8e5376e2294d74ded8e7de9ef2ab086843368d1c92d0a86cbee76b20b6f"></a>Evaluate</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_expr_8h_source.html#l00024">24</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">Halide::Internal::ForType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing a type of loop traversal. </p>
<p>Used in schedules, and in the <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> loop IR node. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1a5255d3daaa0a6276b844d61401e6f493"></a>Serial</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1a98402eecfbcefc336954458a01752131"></a>Parallel</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1a138bc087eaaaf426b54f9a466f0cc725"></a>Vectorized</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1ae53597647de81f4cc9e098fc119ba0ac"></a>Unrolled</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_expr_8h_source.html#l00332">332</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7dc0c8c1adc38d2c5a80979948f0007c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Halide::Internal::Monotonic</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7dc0c8c1adc38d2c5a80979948f0007cacb17869fe51048b5a5c4c6106551a255"></a>Constant</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7dc0c8c1adc38d2c5a80979948f0007caf3ff61f20d0c8eedfa348b0298df5edd"></a>Increasing</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7dc0c8c1adc38d2c5a80979948f0007ca2e6a9b0375c021e8f650a5eb22012b5b"></a>Decreasing</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7dc0c8c1adc38d2c5a80979948f0007ca88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_monotonic_8h_source.html#l00018">18</a> of file <a class="el" href="_monotonic_8h_source.html">Monotonic.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acdd1e32e936b40a5ae1a2a1ef41b64c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::add_image_checks </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>fb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert checks to make sure a statement doesn't read out of bounds on inputs or outputs, and that the inputs and outputs conform to the format required (e.g. </p>
<p>stride.0 must be 1). </p>

</div>
</div>
<a class="anchor" id="a6bd151298721810b82ac418d3810a0dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::add_parameter_checks </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert checks to make sure that all referenced parameters meet their constraints. </p>

</div>
</div>
<a class="anchor" id="aa5b2cbb7a5ae40e05e1d3a05015349ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::align_loads </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to rewrite unaligned loads from buffers which are known to be aligned to instead load aligned vectors that cover the original load, and then slice the original load out of the aligned vectors. </p>

</div>
</div>
<a class="anchor" id="a410eac3ad68dfb697c5ee97100f2053f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::allocation_bounds_inference </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; std::string, int &gt;, Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a partially statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a> nodes in terms of variables, and define values for those variables. </p>

</div>
</div>
<a class="anchor" id="a822c743898c237d427555eea5c94129b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_associative_op.html">AssociativeOp</a>&gt; &gt; Halide::Internal::prove_associativity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Expr &gt;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Expr &gt;&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an update definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> 'f', determine its equivalent associative binary/unary operator if there is any. </p>
<p>The first boolean value of the returned pair indicates if the operation was successfuly proven as associative, and the second vector contains the list of AssociativeOps for each <a class="el" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs. ">Tuple</a> element in the update definition. If it fails to prove associativity, the second vector will be empty.</p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> instance, f(x) = min(f(x), g(r.x)) will return true and it will also return {{min(_x_0, _y_0), +inf, {_x_0, f(x)}, {_y_0, g(r.x)}}}, where the first <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> is the equivalent binary operator, the second <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> is identity of the binary operator, the third and the last pair contain the corresponding definition of each variable in the binary operator.</p>
<p>Note that even though f(x) = f(x) is associative, we'll treat it as non-associative since it doesn't really make any sense to do any associative reduction on that particular update definition. </p>

</div>
</div>
<a class="anchor" id="aca79da3cbafab805c5cd1f0c6ee81d15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::associativity_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7f7e59492cfa4804a6dece2d867a5db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::bounds_of_expr_in_scope </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_max.html" title="The greater of two values. ">Max</a> or min may be undefined expressions if the value is not bounded above or below. If the expression is a vector, also takes the bounds across the vector lanes and returns a scalar result.</p>
<p>This is for tasks such as deducing the region of a buffer loaded by a chunk of code. </p>

</div>
</div>
<a class="anchor" id="a0f153e2f6ddfec8e6ca9d31b8d7acfc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::find_constant_bound </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Direction&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2f62c0ee3ace8de2be57a9db369a3e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::merge_boxes </td>
          <td>(</td>
          <td class="paramtype">Box &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand box a to encompass box b. </p>

</div>
</div>
<a class="anchor" id="ac9641dd947fdf6352ccd5e34548db35e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::boxes_overlap </td>
          <td>(</td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if box a could possibly overlap box b. </p>

</div>
</div>
<a class="anchor" id="af86d8a9b260b097d115182e4b8488f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_union </td>
          <td>(</td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The union of two boxes. </p>

</div>
</div>
<a class="anchor" id="a8c57c8cff1c0ff811a01724b58086bdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_intersection </td>
          <td>(</td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The intersection of two boxes. </p>

</div>
</div>
<a class="anchor" id="a9198438916c78b87c90e665d665a18cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::box_contains </td>
          <td>(</td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if box a provably contains box b. </p>

</div>
</div>
<a class="anchor" id="ab68083f9769cbbf033176ba50f3709c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_required </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s to each function that occurs within a given statement or expression. </p>
<p>This is useful for figuring out what regions of things to evaluate. </p>

</div>
</div>
<a class="anchor" id="af1f12c0072dbbf9639829af1aedda4ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_required </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s to each function that occurs within a given statement or expression. </p>
<p>This is useful for figuring out what regions of things to evaluate. </p>

</div>
</div>
<a class="anchor" id="aeaf945673dc90b8bdd2e79900b147954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_provided </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="ae6c4633706bdb6855b69fb9146ee65ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_provided </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="ae5c5855f4212c1cb3880a8534b6f41b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_touched </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="a0fbd14233932a8f658ac66d45e00d7fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_touched </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="a69980b5d1669ec54e78b7d393d8a7201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_required </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="aea6ad02cea8b0bacbb0b3c1f644af501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_required </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a0586fc0706c9a4d39f0ae5f9c7073c86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_provided </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a9d4d7463fc7d96132bbe01768f967dd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_provided </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="aa211ee508998ef25191d04fa45eb16c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_touched </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a35a819815a3d7f37a441a22c06689689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_touched </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a0b807d0d1524fb2f20b1533d05032c02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> Halide::Internal::compute_function_value_bounds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum and minimum possible value for each function in an environment. </p>

</div>
</div>
<a class="anchor" id="abf0ac02fb219b5b3b77f2930b2ef63a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::bounds_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a571cac31938f53aa2e66671e187d9b9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::bounds_inference </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>realization_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>environment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; std::string, int &gt;, Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds. </p>

</div>
</div>
<a class="anchor" id="a1a1e270066706802bc3903a17703f173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::StructType* Halide::Internal::build_closure_type </td>
          <td>(</td>
          <td class="paramtype">const Closure &amp;&#160;</td>
          <td class="paramname"><em>closure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StructType *&#160;</td>
          <td class="paramname"><em>buffer_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The llvm type of a struct containing all of the externally referenced state of a <a class="el" href="class_halide_1_1_internal_1_1_closure.html" title="A helper class to manage closures. ">Closure</a>. </p>

</div>
</div>
<a class="anchor" id="ab9bb457246f10a99d7884697912d5542"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::pack_closure </td>
          <td>(</td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Closure &amp;&#160;</td>
          <td class="paramname"><em>closure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StructType *&#160;</td>
          <td class="paramname"><em>buffer_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt;&gt; *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that builds a struct containing all the externally referenced state. </p>
<p>Requires you to pass it a type and struct to fill in, a scope to retrieve the llvm values from and a builder to place the packing code. </p>

</div>
</div>
<a class="anchor" id="aa343f8851b8c07de8d1b9f964fc830c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::unpack_closure </td>
          <td>(</td>
          <td class="paramtype">const Closure &amp;&#160;</td>
          <td class="paramname"><em>closure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scope&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Type *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1_i_r_builder.html">llvm::IRBuilder</a>&lt;&gt; *&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that unpacks a struct containing all the externally referenced state into a symbol table. </p>
<p>Requires you to pass it a state struct type and value, a scope to fill, and a builder to place the unpacking code. </p>

</div>
</div>
<a class="anchor" id="a71f10140e29131153c3be98d2899b090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* Halide::Internal::llvm_type_of </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the llvm type equivalent to a given halide type. </p>

</div>
</div>
<a class="anchor" id="adc60421b682a09ea4c4dcaaaa3e105e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::function_takes_user_context </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Which built-in functions require a user-context first argument? </p>

</div>
</div>
<a class="anchor" id="aa783278be5bae448cf01fec2df4a9a6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::can_allocation_fit_on_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a size (in bytes), return True if the allocation size can fit on the stack; otherwise, return False. </p>
<p>This routine asserts if size is non-positive. </p>

</div>
</div>
<a class="anchor" id="ab7a4f18b650b23e1e6ed980d1feebcf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_euclidean_div </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero. </p>

</div>
</div>
<a class="anchor" id="ae81d78fd7f3115750e17167ebf0fe920"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_euclidean_mod </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Euclidean division/mod operation, define it in terms of div_round_to_zero or mod_round_to_zero. </p>

</div>
</div>
<a class="anchor" id="a7b4fa94b1f3a877eb3387824c09df826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::get_target_options </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::TargetOptions &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>mcpu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>mattrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an llvm::Module, set llvm:TargetOptions, cpu and attr information. </p>

</div>
</div>
<a class="anchor" id="a1b16d175882e16f544bf4bf92ec931b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::clone_target_options </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two llvm::Modules, clone target options from one to the other. </p>

</div>
</div>
<a class="anchor" id="af1e20aff45028d266f854487159df341"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::TargetMachine&gt; Halide::Internal::make_target_machine </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an llvm::Module, get or create an llvm:TargetMachine. </p>

</div>
</div>
<a class="anchor" id="abfe55211c4dbc852f29c8e764360c670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::set_function_attributes_for_target </td>
          <td>(</td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Target&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the appropriate llvm <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> attributes given a <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

</div>
</div>
<a class="anchor" id="a782f06d4de1f8dc9f230dd3c02ee93ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::cplusplus_function_mangled_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>return_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; ExternFuncArgument &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the mangled C++ name for a function. </p>
<p>The target parameter is used to decide on the C++ ABI/mangling style to use. </p>

</div>
</div>
<a class="anchor" id="a43b849065142ce8cb6303244c51a996b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::cplusplus_mangle_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a83c69c01c5d35b1cd47354374d49bf28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::common_subexpression_elimination </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable. </p>
<p>This is important to do within <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> (instead of punting to llvm), because exprs that come in from the front-end are small when considered as a graph, but combinatorially large when considered as a tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> an example of a such a case, see test/code_explosion.cpp </p>

</div>
</div>
<a class="anchor" id="abd617bcfa0cf8b542eb38a8cca1f0614"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::common_subexpression_elimination </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do common-subexpression-elimination on each expression in a statement. </p>
<p>Does not introduce let statements. </p>

</div>
</div>
<a class="anchor" id="a750967bfd0520280ceadbf9f15ffa3be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::cse_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a12f749a540acb9a7c148602c517e61e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Stmt &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide statement on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a915eea9584a02a02fa0ccd9dea859e87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LoweredFunc &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaea2b563fa94726a65b596979b9d2f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::debug_to_file </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a> nodes still unlowered. </p>
<p>If the corresponding functions have a debug_file set, then inject code that will dump the contents of those functions to a file after the realization. </p>

</div>
</div>
<a class="anchor" id="aad946e0645ead551baee06d6c39e6552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt;, std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; &gt; Halide::Internal::deep_copy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create deep-copies of all Functions in 'env'. </p>
<p>This returns a pair of the deep-copied versions of 'outputs' and 'env' </p>

</div>
</div>
<a class="anchor" id="af3886cd7a77937dd80231c35581b93be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_odd_lanes </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the odd-numbered lanes in a vector. </p>

</div>
</div>
<a class="anchor" id="a8be6e8bc82582bb4ac055507907282c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_even_lanes </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the even-numbered lanes in a vector. </p>

</div>
</div>
<a class="anchor" id="aaf56d49145d02ee1f675c8c838c8e9ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_lane </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the nth lane of a vector. </p>

</div>
</div>
<a class="anchor" id="ac1233a717a83d74121106b95245ce81a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::rewrite_interleavings </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic. </p>

</div>
</div>
<a class="anchor" id="adc21bfcfcc2b8feadd3612b4cd21e020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::deinterleave_vector_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5aedffca433bdfab639e4956779040e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_early_frees </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation. </p>
<p>Targets may use this to free buffers earlier than the close of their <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a> node. </p>

</div>
</div>
<a class="anchor" id="a70a9ad424415eeb1529413e529e17d83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::eliminate_bool_vectors </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, instead of select(i1x8, u16x8, u16x8), the target would prefer to see select(u16x8, u16x8, u16x8), where the first argument is a vector of integers representing a mask. This pass converts vectors of bools to vectors of integers to meet this requirement. This is done by injecting intrinsics to convert bools to architecture-specific masks, and using a select_mask instrinsic instead of a <a class="el" href="struct_halide_1_1_internal_1_1_select.html" title="A ternary operator. ">Select</a> node. Because the masks are architecture specific, they may not be stored or loaded. On Stores, the masks are converted to UInt(8) with a value of 0 or 1, which is our canonical in-memory representation of a bool. </p>

</div>
</div>
<a class="anchor" id="ad795b88cdb0e1c0c664ed94dd86642a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::eliminate_bool_vectors </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some targets treat vectors of bools as integers of the same type that the boolean operation is being used to operate on. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, instead of select(i1x8, u16x8, u16x8), the target would prefer to see select(u16x8, u16x8, u16x8), where the first argument is a vector of integers representing a mask. This pass converts vectors of bools to vectors of integers to meet this requirement. This is done by injecting intrinsics to convert bools to architecture-specific masks, and using a select_mask instrinsic instead of a <a class="el" href="struct_halide_1_1_internal_1_1_select.html" title="A ternary operator. ">Select</a> node. Because the masks are architecture specific, they may not be stored or loaded. On Stores, the masks are converted to UInt(8) with a value of 0 or 1, which is our canonical in-memory representation of a bool. </p>

</div>
</div>
<a class="anchor" id="ac3608cf83d3537cd1c519b046f34a51b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_type.html">Type</a> Halide::Internal::eliminated_bool_type </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>bool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>other_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a type is a boolean vector, find the type that it has been changed to by eliminate_bool_vectors. </p>

<p>Definition at line <a class="el" href="_eliminate_bool_vectors_8h_source.html#l00032">32</a> of file <a class="el" href="_eliminate_bool_vectors_8h_source.html">EliminateBoolVectors.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00302">Halide::Type::bits()</a>, <a class="el" href="_type_8h_source.html#l00264">Halide::Type::Int</a>, <a class="el" href="_type_8h_source.html#l00331">Halide::Type::is_vector()</a>, <a class="el" href="_type_8h_source.html#l00313">Halide::Type::with_bits()</a>, and <a class="el" href="_type_8h_source.html#l00308">Halide::Type::with_code()</a>.</p>

</div>
</div>
<a class="anchor" id="acc591095a8e56d4d6f6587c66239fdb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; <a class="el" href="namespace_halide_1_1_internal.html#a9ff5beef3c5a4ec908d9c2bbe99a71f9">Halide::Internal::ref_count</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const IRNode *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_expr_8h_source.html#l00094">94</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7e3867f02d52edd32b4cfe38e5ee55a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="namespace_halide_1_1_internal.html#ada37ff426984f7459fe0bbe38b9e11f0">Halide::Internal::destroy</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const IRNode *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_expr_8h_source.html#l00097">97</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a class="anchor" id="af15830092ee01286d279cdc991c1f252"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StmtOrExpr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_or_expr_uses_var </td>
          <td>(</td>
          <td class="paramtype">StmtOrExpr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a statement or expression references the given variable. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00038">38</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_scope_8h_source.html#l00142">Halide::Internal::Scope&lt; T &gt;::push()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00033">Halide::Internal::ExprUsesVars&lt; T &gt;::result</a>.</p>

<p>Referenced by <a class="el" href="_expr_uses_var_8h_source.html#l00059">expr_uses_var()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00064">stmt_uses_var()</a>.</p>

</div>
</div>
<a class="anchor" id="af29840c52385c687d17608300c94a0ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StmtOrExpr , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_or_expr_uses_vars </td>
          <td>(</td>
          <td class="paramtype">StmtOrExpr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>Scope&lt;Expr&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a statement or expression references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00051">51</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_expr_uses_var_8h_source.html#l00033">Halide::Internal::ExprUsesVars&lt; T &gt;::result</a>.</p>

<p>Referenced by <a class="el" href="_expr_uses_var_8h_source.html#l00073">expr_uses_vars()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00083">stmt_uses_vars()</a>.</p>

</div>
</div>
<a class="anchor" id="af239670eead776a941de1cb3f1a93202"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_uses_var </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if an expression references the given variable. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00059">59</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_expr_uses_var_8h_source.html#l00038">stmt_or_expr_uses_var()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e764ec0fdfaddd0ec0e32af023f25f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_uses_var </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a statement references the given variable. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00064">64</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_expr_uses_var_8h_source.html#l00038">stmt_or_expr_uses_var()</a>.</p>

</div>
</div>
<a class="anchor" id="af9bc2cef7dff2305a29dc5512a7542da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_uses_vars </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>Scope&lt;Expr&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if an expression references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00073">73</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_expr_uses_var_8h_source.html#l00051">stmt_or_expr_uses_vars()</a>.</p>

</div>
</div>
<a class="anchor" id="a88fff0c011d19ecd028b4710291ffe18"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::stmt_uses_vars </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>Scope&lt;Expr&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a statement references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00083">83</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_expr_uses_var_8h_source.html#l00051">stmt_or_expr_uses_vars()</a>.</p>

</div>
</div>
<a class="anchor" id="a16b42e90ad180f1254cdd3be0ae7be89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; Halide::Internal::find_direct_calls </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, including in update definitions, update index expressions, and <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> extents. </p>
<p>This map <em>does not</em> include the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, unless it is called recursively by itself. </p>

</div>
</div>
<a class="anchor" id="a770da2a7374eb2a8ac60f5c9d90b88ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; Halide::Internal::find_transitive_calls </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, or indirectly in those functions' definitions, recursively. </p>
<p>This map always <em>includes</em> the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f. </p>

</div>
</div>
<a class="anchor" id="a4b98bf6f8f3475caaa691d7884a31d45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Last &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_types </td>
          <td>(</td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l01847">1847</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="_error_8h_source.html#l00148">user_assert</a>.</p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01892">Halide::evaluate()</a>, and <a class="el" href="_func_8h_source.html#l01937">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a class="anchor" id="abec0560d55ceb7384483f00da38ad73f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_types </td>
          <td>(</td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l01856">1856</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00184">Halide::Runtime::Internal::t</a>.</p>

</div>
</div>
<a class="anchor" id="a32bce2836846aa0286859b005b6aa015"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Last &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assign_results </td>
          <td>(</td>
          <td class="paramtype">Realization &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l01862">1862</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01892">Halide::evaluate()</a>, and <a class="el" href="_func_8h_source.html#l01937">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a class="anchor" id="acdc822256984ddc07c031b230ce2b8ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::assign_results </td>
          <td>(</td>
          <td class="paramtype">Realization &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">First&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Second&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l01868">1868</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1f9bfb55aa0058e51d72037fde785fb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::schedule_scalar </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_func_8h_source.html#l01903">1903</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p>References <a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">Halide::get_jit_target_from_environment()</a>, <a class="el" href="class_halide_1_1_func.html#a2b1fe099bd3039ed95c724b24290aa9e">Halide::Func::gpu_single_thread()</a>, <a class="el" href="_target_8h_source.html#l00119">Halide::Target::has_feature()</a>, <a class="el" href="_target_8h_source.html#l00169">Halide::Target::has_gpu_feature()</a>, <a class="el" href="class_halide_1_1_func.html#a27e1ab719e115952fd57762e31664985">Halide::Func::hexagon()</a>, <a class="el" href="_target_8h_source.html#l00074">Halide::Target::HVX_128</a>, and <a class="el" href="_target_8h_source.html#l00073">Halide::Target::HVX_64</a>.</p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01921">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a class="anchor" id="a318c3eca91038227e115e5440d687c43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::zero_gpu_loop_mins </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite all GPU loops to have a min of zero. </p>

</div>
</div>
<a class="anchor" id="a0081752824625e87b5e95bfae979499f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::fuse_gpu_thread_loops </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s GPGPU IR to the OpenCL/CUDA/Metal model. </p>
<p>Within every loop over gpu block indices, fuse the inner loops over thread indices into a single loop (with predication to turn off threads). Also injects synchronization points as needed, and hoists allocations at the block level out into a single shared memory array. </p>

</div>
</div>
<a class="anchor" id="a56a15fc4880c65ae27434a924540a07e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::fuzz_float_stores </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>On every store of a floating point value, mask off the least-significant-bit of the mantissa. </p>
<p>We've found that whether or not this dramatically changes the output of a pipeline correlates very well with whether or not a pipeline will produce very different outputs on different architectures (e.g. with and without FMA). It's also a useful way to detect bad tests, such as those that expect exact floating point equality across platforms. </p>

</div>
</div>
<a class="anchor" id="aa75ada54c5a74973e4d52adddf50ab9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> std::string Halide::Internal::enum_to_string </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>enum_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_generator_8h_source.html#l00107">107</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

<p>References <a class="el" href="_error_8h_source.html#l00147">user_error</a>.</p>

<p>Referenced by <a class="el" href="_generator_8h_source.html#l00272">Halide::Internal::GeneratorParam_Enum&lt; T &gt;::to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e667cda683fba6cce2660ff2ffa48ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::map&lt;std::string, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&gt;&amp; Halide::Internal::get_halide_type_enum_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2fce0241753e0d1cf50b4615b3d00430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int Halide::Internal::generate_filter_main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>cerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal.html#a2fce0241753e0d1cf50b4615b3d00430" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a> is a convenient wrapper for <a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html#a387ce430f4c9f4366b6477d5625e12cb">GeneratorRegistry::create()</a> + compile_to_files(); it can be trivially wrapped by a "real" main() to produce a command-line utility for ahead-of-time filter compilation. </p>

</div>
</div>
<a class="anchor" id="a386a29f838250d0c3bccc9bf6c2b3706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::generator_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a44b403917d39534a2cbdd212efcb4bbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_hexagon_rpc </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>host_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pull loops marked with the Hexagon device API to a separate module, and call them through the Hexagon host runtime module. </p>

</div>
</div>
<a class="anchor" id="a7c8e5b4d5e4aada5fffc99112a760917"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::optimize_hexagon_shuffles </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lut_alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace indirect and other loads with simple loads + vlut calls. </p>

</div>
</div>
<a class="anchor" id="a40a7fafb2febda78ab97d76bbc396510"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::optimize_hexagon_instructions </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hexagon deinterleaves when performing widening operations, and interleaves when performing narrowing operations. </p>
<p>This pass rewrites widenings/narrowings to be explicit in the IR, and attempts to simplify away most of the interleaving/deinterleaving. </p>

</div>
</div>
<a class="anchor" id="abfe3690b39dbad72494049eda6d89dcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::native_deinterleave </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate deinterleave or interleave operations, operating on groups of vectors at a time. </p>

</div>
</div>
<a class="anchor" id="a6cd389a510a98d7e4cda77280a299345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::native_interleave </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate deinterleave or interleave operations, operating on groups of vectors at a time. </p>

</div>
</div>
<a class="anchor" id="afcc23c653c21c17cb6104565d4e9cae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_native_deinterleave </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate deinterleave or interleave operations, operating on groups of vectors at a time. </p>

</div>
</div>
<a class="anchor" id="a6603e09402b55b5ab00239ab3c9e04bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_native_interleave </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate deinterleave or interleave operations, operating on groups of vectors at a time. </p>

</div>
</div>
<a class="anchor" id="a47a26bb3066dde7afbe33a1007992a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::call_extern_and_assert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A helper function to call an extern function, and assert that it returns 0. </p>

</div>
</div>
<a class="anchor" id="a0d2f86eb8a14e51d81926be0688bb9d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_host_dev_buffer_copies </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject calls to halide_device_malloc, halide_copy_to_device, and halide_copy_to_host as needed. </p>

</div>
</div>
<a class="anchor" id="a5d0387cd8e369d8d328bd0dd420c3e1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_image_intrinsics </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for kernel for loops and turn loads and stores inside the loops into image load and store intrinsics. </p>

</div>
</div>
<a class="anchor" id="a94843d09c24cd65c12aa022e0ae3bb70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_opengl_intrinsics </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for kernel for loops and turn loads and stores inside the loops into OpenGL texture load and store intrinsics. </p>
<p>Should only be run when the OpenGL target is active. </p>

</div>
</div>
<a class="anchor" id="a38c4753b75f784e928d24b5f085ed383"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a single named function, which must be pure. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> a pure function to be inlined, it must not have any specializations (i.e. it can only have one values definition). </p>

</div>
</div>
<a class="anchor" id="a839846970613235cae5c8904a5fda794"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a single named function, which must be pure. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> a pure function to be inlined, it must not have any specializations (i.e. it can only have one values definition). </p>

</div>
</div>
<a class="anchor" id="aebfd25a3f86e0f58d65302a4814e3415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::interval_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ff5beef3c5a4ec908d9c2bbe99a71f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; Halide::Internal::ref_count </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here. </p>
<p>E.g. if you want to use IntrusivePtr&lt;MyClass&gt;, then you should define something like this in MyClass.cpp (assuming MyClass has a field: mutable <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> ref_count):</p>
<p>template&lt;&gt; <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> &amp;ref_count&lt;MyClass&gt;(const MyClass *c) {return c-&gt;ref_count;} template&lt;&gt; void destroy&lt;MyClass&gt;(const MyClass *c) {delete c;} </p>

</div>
</div>
<a class="anchor" id="ada37ff426984f7459fe0bbe38b9e11f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::destroy </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here. </p>
<p>E.g. if you want to use IntrusivePtr&lt;MyClass&gt;, then you should define something like this in MyClass.cpp (assuming MyClass has a field: mutable <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> ref_count):</p>
<p>template&lt;&gt; <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> &amp;ref_count&lt;MyClass&gt;(const MyClass *c) {return c-&gt;ref_count;} template&lt;&gt; void destroy&lt;MyClass&gt;(const MyClass *c) {delete c;} </p>

</div>
</div>
<a class="anchor" id="a31dc49947eec58e14aab236c7b0182ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a>. If you're comparing non-CSE'd Exprs, use graph_equal, which is safe for nasty graphs of IR nodes. </p>

</div>
</div>
<a class="anchor" id="a4d404e95dced22ae673144c0351f186f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a>. If you're comparing non-CSE'd Exprs, use graph_equal, which is safe for nasty graphs of IR nodes. </p>

</div>
</div>
<a class="anchor" id="a6fa92b936aa610bfa43e2b0a158d700d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::graph_equal </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a>. If you're comparing non-CSE'd Exprs, use graph_equal, which is safe for nasty graphs of IR nodes. </p>

</div>
</div>
<a class="anchor" id="a75a990211f75bf579328387fa24a27b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::graph_equal </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a>. If you're comparing non-CSE'd Exprs, use graph_equal, which is safe for nasty graphs of IR nodes. </p>

</div>
</div>
<a class="anchor" id="a9a1dc9a55f32a7813f8c76884b83d2e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::ir_equality_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2179b452c113777557e86873456174fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::expr_match </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument. </p>
<p>Wildcards require the types to match. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> the type bits and width, a 0 indicates "match anything". So an Int(8, 0) will match 8-bit integer vectors of any width (including scalars), and a UInt(0, 0) will match any unsigned integer type.</p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example: </p>
<div class="fragment"><div class="line">Expr x = <a class="code" href="struct_halide_1_1_internal_1_1_variable.html#aff3204ace57795ef312d3029c1f09aef">Variable::make</a>(<a class="code" href="namespace_halide.html#a70a0c034814a65d55bb848fe9c96653b">Int</a>(32), <span class="stringliteral">&quot;*&quot;</span>);</div>
<div class="line">match(x + x, 3 + (2*k), result)</div>
</div><!-- fragment --><p> should return true, and set result[0] to 3 and result[1] to 2*k. </p>

</div>
</div>
<a class="anchor" id="ad6a9c3dedcf234edd2dd3d4239d0116d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::expr_match </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the first expression have the same structure as the second? Variables are matched consistently. </p>
<p>The first time a variable is matched, it assumes the value of the matching part of the second expression. Subsequent matches must be equal to the first match.</p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example: </p>
<div class="fragment"><div class="line">Var x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line">match(x*(x + 1), <a class="code" href="namespace_halide_1_1_runtime_1_1_internal.html#a67dd017542dcaa40f1181f7806bd18af">a</a>*(<a class="code" href="namespace_halide_1_1_runtime_1_1_internal.html#a67dd017542dcaa40f1181f7806bd18af">a</a> + <a class="code" href="namespace_halide_1_1_runtime_1_1_internal.html#a220e62865cb92ff423d312a69f2213e6">b</a>), result)</div>
</div><!-- fragment --><p> should return true, and set result["x"] = a, and result["y"] = b. </p>

</div>
</div>
<a class="anchor" id="aa4e9b6aa83c9f90ff87628d97d9666fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::expr_match_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab370d99a882a8163ae91d43b94d79d02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_const </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants. ">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node. ">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same. </p>
<p>Doesn't do any constant folding. </p>

</div>
</div>
<a class="anchor" id="a4b4c34df915e479f7a5308d13cfbed85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_const </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same. </p>

</div>
</div>
<a class="anchor" id="a3feb76bb2b5ae05b49286f7bccaaecf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>* Halide::Internal::as_const_int </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, return a pointer to its value. </p>
<p>Otherwise returns nullptr. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00179">Halide::cast()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01275">Halide::fast_pow()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01599">Halide::lerp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01229">Halide::pow()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00784">Halide::select()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6318d9a64c365a0d891eedb97e2e8a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>* Halide::Internal::as_const_uint </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants. ">UIntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants. ">UIntImm</a>, return a pointer to its value. </p>
<p>Otherwise returns nullptr. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00179">Halide::cast()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c789dcfe8f357c6ac50568feb04acfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const double* Halide::Internal::as_const_float </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, return a pointer to its value. </p>
<p>Otherwise returns nullptr. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00179">Halide::cast()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01599">Halide::lerp()</a>.</p>

</div>
</div>
<a class="anchor" id="a154fb51a15d5c4b8ecf6f58f62ab9324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_const_power_of_two_integer </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a constant integer power of two. </p>
<p>Also returns log base two of the expression if it is. Only returns true for integer types. </p>

</div>
</div>
<a class="anchor" id="ad050aaa17987fa4cbb8fd4d41c952e04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_positive_const </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="acc39652dfc1d64fb82d02dc4064185d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_negative_const </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="af3da8f6192d557a4bd47cf244b79a9db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_negative_negatable_const </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) and is its negative value representable. </p>
<p>(This excludes the most negative value of the <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s type from inclusion. Intended to be used when the value will be negated as part of simplification.) </p>

</div>
</div>
<a class="anchor" id="af51364d689b51fe9352cfb71e2a7df18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_undef </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression an undef. </p>

</div>
</div>
<a class="anchor" id="a1a521ef987e7964954b997e6dcc5e65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_zero </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression) </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00378">Halide::operator%()</a>.</p>

</div>
</div>
<a class="anchor" id="a940b37091a8f16bf1e4a78db7764274e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_one </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression) </p>

<p>Referenced by <a class="el" href="_bounds_8h_source.html#l00062">Halide::Internal::Box::maybe_unused()</a>.</p>

</div>
</div>
<a class="anchor" id="abeed2f66190d11ee6e56e4089a1f441b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_two </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="ab2d7b687f4ac09ca9236cb1b8b82bb51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_no_op </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect. ">Evaluate</a> node of a constant) </p>

</div>
</div>
<a class="anchor" id="aff2e2c3b53edabca8089670422959e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00179">Halide::cast()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00083">make_const()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00646">Halide::max()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00680">Halide::min()</a>, <a class="el" href="_generator_8h_source.html#l00178">Halide::Internal::GeneratorParamImpl&lt; T &gt;::operator Expr()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00562">Halide::operator!=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00388">Halide::operator%()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00307">Halide::operator*()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00227">Halide::operator+()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00262">Halide::operator-()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00357">Halide::operator/()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00446">Halide::operator&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01497">Halide::operator&lt;&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00475">Halide::operator&lt;=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00533">Halide::operator==()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00417">Halide::operator&gt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00504">Halide::operator&gt;=()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01523">Halide::operator&gt;&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e4212797e9dcc4a1a3577c6e6475832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

</div>
</div>
<a class="anchor" id="ab4ec777cbfe66e5a592adf1eea14ec64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

</div>
</div>
<a class="anchor" id="aaae8ca905f0ce9cde74cc0897a61c4e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00083">83</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a70b64c00a450c92807011cdc02f8b29b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00084">84</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a4df9ef655a78f9fb233fa0322525496c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#ac124c451b40871e78c16cb36581022ae">int16_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00085">85</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="af14e2dade91eb04482b4b5ffdfc920dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00086">86</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a5231b80b8e1a7904cdd4fcac7b89a98d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#acfd957407fbe865fe77f6fdf86818f5e">int8_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00087">87</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9a1ece36d20a64a59c92bf7f8c4e9aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00088">88</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="addbd965eccbcfc1f5b80eaa0607f698c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00089">89</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="aa90929bcfb18413ffd527152bb8580de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00090">90</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a6592ef00a06a1d8f017b48359099c16d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float16_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an immediate of the given type from any numeric C++ type. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l00091">91</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">make_const()</a>.</p>

</div>
</div>
<a class="anchor" id="a75f0a20e311c0982fb73a04c84a6bf3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::check_representable </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a constant value can be correctly represented as the given type. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00646">Halide::max()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00680">Halide::min()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00562">Halide::operator!=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00388">Halide::operator%()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00307">Halide::operator*()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00227">Halide::operator+()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00262">Halide::operator-()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00357">Halide::operator/()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00446">Halide::operator&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01497">Halide::operator&lt;&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00475">Halide::operator&lt;=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00533">Halide::operator==()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00417">Halide::operator&gt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00504">Halide::operator&gt;=()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01523">Halide::operator&gt;&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a90ddf42fd8c32b453ea049bc176ea3a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_bool </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a boolean constant from a C++ boolean value. </p>
<p>May also be a vector if width is given. It is not possible to coerce a C++ boolean to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> because if we provide such a path then char objects can ambiguously be converted to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or to std::string. The problem is that C++ does not have a real bool type - it is in fact close enough to char that C++ does not know how to distinguish them. make_bool is the explicit coercion. </p>

</div>
</div>
<a class="anchor" id="a57fedf535d58f8900f8b7c00aa15ece8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_zero </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of zero in the given type. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00587">Halide::operator&amp;&amp;()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00282">Halide::operator-()</a>.</p>

</div>
</div>
<a class="anchor" id="ace305dbdd7fed2cf9d5057d4c02067c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_one </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of one in the given type. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00610">Halide::operator||()</a>.</p>

</div>
</div>
<a class="anchor" id="afc35f0dc3562ffb5bb777021679435e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_two </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of two in the given type. </p>

</div>
</div>
<a class="anchor" id="a7baf8e1371967a473027d673c6d48286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::const_true </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the constant boolean true. </p>
<p>May also be a vector of trues, if a lanes argument is given. </p>

</div>
</div>
<a class="anchor" id="a455bb5e473e0686b5b027a51228c1af4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::const_false </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the constant boolean false. </p>
<p>May also be a vector of falses, if a lanes argument is given. </p>

</div>
</div>
<a class="anchor" id="af2c1bdedbb2a1cfb7aef147bf26998cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lossless_cast </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to cast an expression to a smaller type while provably not losing information. </p>
<p>If it can't be done, return an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00731">Halide::clamp()</a>.</p>

</div>
</div>
<a class="anchor" id="ab40a26aac941b763435e9915851cd073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::match_types </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coerce the two expressions to have the same type, using C-style casting rules. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> the purposes of casting, a boolean type is UInt(1). We use the following procedure:</p>
<p>If the types already match, do nothing.</p>
<p>Then, if one type is a vector and the other is a scalar, the scalar is broadcast to match the vector width, and we continue.</p>
<p>Then, if one type is floating-point and the other is not, the non-float is cast to the floating-point type, and we're done.</p>
<p>Then, if both types are unsigned ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Then, if both types are signed ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Finally, if one type is an unsigned int and the other type is a signed int, both are cast to a signed int with the greater of the two bit-widths. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, matching an Int(8) with a UInt(16) results in an Int(16). </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00764">Halide::absd()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01667">Halide::div_round_to_zero()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00634">Halide::max()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00668">Halide::min()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01686">Halide::mod_round_to_zero()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00552">Halide::operator!=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00378">Halide::operator%()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00579">Halide::operator&amp;&amp;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00298">Halide::operator*()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00217">Halide::operator+()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00253">Halide::operator-()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00335">Halide::operator/()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00436">Halide::operator&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01490">Halide::operator&lt;&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00465">Halide::operator&lt;=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00523">Halide::operator==()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00407">Halide::operator&gt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00494">Halide::operator&gt;=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01516">Halide::operator&gt;&gt;()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00602">Halide::operator||()</a>.</p>

</div>
</div>
<a class="anchor" id="af36627bf7242718b1c73214296dc9090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_log </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals. </p>

</div>
</div>
<a class="anchor" id="a5688772a963296ea52d2bd9ac5913e79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_exp </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals. </p>

</div>
</div>
<a class="anchor" id="a3d36eef829f9c1e2d6aaf9218b2e0e66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_erf </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01254">Halide::erf()</a>.</p>

</div>
</div>
<a class="anchor" id="aff271995b6126896f73a7211f8a1ce06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::raise_to_integer_power </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise an expression to an integer power by repeatedly multiplying it by itself. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01275">Halide::fast_pow()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01229">Halide::pow()</a>.</p>

</div>
</div>
<a class="anchor" id="acc48fb3424e43b50b5bdc11731285f14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::split_into_ands </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> a boolean condition into vector of ANDs. </p>
<p>If 'cond' is undefined, return an empty vector. </p>

</div>
</div>
<a class="anchor" id="a7b821cbe0e228fd5036e9fb1ed693184"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::Internal::collect_print_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01777">1777</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01781">collect_print_args()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01801">Halide::print()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01814">Halide::print_when()</a>.</p>

</div>
</div>
<a class="anchor" id="aa081b03ea688ae0e09ac4c5d77aff33b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::Internal::collect_print_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>more_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01781">1781</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l01777">collect_print_args()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a6f133f6a6e341fe686cafbe3c520bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::Internal::collect_print_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>more_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01787">1787</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l01777">collect_print_args()</a>.</p>

</div>
</div>
<a class="anchor" id="abc3a61c8b563a85ef94a175bcb35dee2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::memoize_tag_helper </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache_key_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01884">Halide::memoize_tag()</a>.</p>

</div>
</div>
<a class="anchor" id="aadeef8f93d8284eeb98f397cb1a8c7cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide for loop type (vectorized, serial, etc) in a human readable form. </p>

</div>
</div>
<a class="anchor" id="a2c00a579c3d86ae40920d5fc4ffe64cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Internal::lower_lerp </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>zero_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>one_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> IR that computes a lerp. </p>
<p>Use by codegen targets that don't have a native lerp. </p>

</div>
</div>
<a class="anchor" id="a3d3866cf9bbadd5aed342a5a6e6ffa73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T::value_type* Halide::Internal::iterator_to_pointer </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_l_l_v_m___headers_8h_source.html#l00086">86</a> of file <a class="el" href="_l_l_v_m___headers_8h_source.html">LLVM_Headers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a496ad11988df981c987a2557c3cd2d8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Triple Halide::Internal::get_triple_for_target </td>
          <td>(</td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the llvm::Triple that corresponds to the given <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

</div>
</div>
<a class="anchor" id="a30b2ac324e660b73262abdb4b0643451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; Halide::Internal::get_initial_module_for_target </td>
          <td>(</td>
          <td class="paramtype">Target&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_shared_jit_runtime</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>just_gpu</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an llvm module containing the support code for a given target. </p>

</div>
</div>
<a class="anchor" id="a9e77b70f4bfb715115d8c3a690b2faa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; Halide::Internal::get_initial_module_for_ptx_device </td>
          <td>(</td>
          <td class="paramtype">Target&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an llvm module containing the support code for ptx device. </p>

</div>
</div>
<a class="anchor" id="aabff7722c0ee5cf28db2fd08ca7d18b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::Module&gt; Halide::Internal::get_initial_module_for_renderscript_device </td>
          <td>(</td>
          <td class="paramtype">Target&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an llvm module containing the support code for renderscript. </p>

</div>
</div>
<a class="anchor" id="a1fc91c3863b2f3b6afe3902a717ff68b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::loop_carry </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_carried_values</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reuse loads done on previous loop iterations by stashing them in induction variables instead of redoing the load. </p>
<p>Can be an optimization or pessimization depending on how good the L1 cache is on the architecture and how many memory issue slots there are. Currently only intended for Hexagon. </p>

</div>
</div>
<a class="anchor" id="a78c16d0a33d7fdc862142297ce8f5134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Function &gt;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pipeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IRMutator * &gt; &amp;&#160;</td>
          <td class="paramname"><em>custom_passes</em> = <code>std::vector&lt;&#160;IRMutator&#160;*&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a halide function with a schedule, create a statement that evaluates it. </p>
<p>Automatically pulls in all the functions f depends on. Some stages of lowering may be target-specific. </p>

</div>
</div>
<a class="anchor" id="a4d3bfe43201bab68cf4820993fe1469b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::lower_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a09c220ffcd7afe63803179dc304438b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> llvm::Function* Halide::Internal::define_matlab_wrapper </td>
          <td>(</td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>pipeline_argv_wrapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Function *&#160;</td>
          <td class="paramname"><em>metadata_getter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_add.html" title="The sum of two expressions. ">Add</a> a mexFunction wrapper definition to the module, calling the function with the name pipeline_name. </p>
<p>Returns the mexFunction definition. </p>

</div>
</div>
<a class="anchor" id="a585e65b645868795c02e73c853404321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_memoization </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform pipeline calls for Funcs scheduled with memoize to do a lookup call to the runtime cache implementation, and if there is a miss, compute the results and call the runtime to store it back to the cache. </p>
<p>Should leave non-memoized Funcs unchanged. </p>

</div>
</div>
<a class="anchor" id="a0cb0d4310fbae915041f61f46dc96677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::rewrite_memoized_allocations </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This should be called after Storage Flattening has added Allocation IR nodes. </p>
<p>It connects the memoization cache lookups to the Allocations so they point to the buffers from the memoization cache and those buffers are released when no longer used. Should not affect allocations for non-memoized Funcs. </p>

</div>
</div>
<a class="anchor" id="a7298e57b1434cccc072c45b6f5c6efef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::modulus_remainder </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, it is straight-forward to deduce that ((10*x + 2)*(6*y - 3) - 1) is congruent to five modulo six.</p>
<p>We get the most information when the modulus is large. E.g. if something is congruent to 208 modulo 384, then we also know it's congruent to 0 mod 8, and we can possibly use it as an index for an aligned load. If all else fails, we can just say that an integer is congruent to zero modulo one. </p>

</div>
</div>
<a class="anchor" id="a54ba7c6c7ec1ea5d6eafd713498a1062"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::modulus_remainder </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; ModulusRemainder &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder: </p>

</div>
</div>
<a class="anchor" id="ac074a908960c5cc4d53e4126869245d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::reduce_expr_modulo </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>remainder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce an expression modulo some integer. </p>
<p>Returns true and assigns to remainder if an answer could be found. </p>

</div>
</div>
<a class="anchor" id="a46a8f7f1ebbdf53051f5403178c164e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::reduce_expr_modulo </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>remainder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; ModulusRemainder &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce an expression modulo some integer. </p>
<p>Returns true and assigns to remainder if an answer could be found. </p>

</div>
</div>
<a class="anchor" id="a89e2febe349b889e21aa91a10f7a6a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::modulus_remainder_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af2243b7799ccb021a5dd49c4961834fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int Halide::Internal::gcd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The greatest common divisor of two integers. </p>

</div>
</div>
<a class="anchor" id="acc78c709d77e443e9243cab48ed05929"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int Halide::Internal::lcm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The least common multiple of two integers. </p>

</div>
</div>
<a class="anchor" id="a37b5b805d410ace5fad604890402cce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="namespace_halide_1_1_internal.html#a7dc0c8c1adc38d2c5a80979948f0007c">Monotonic</a> Halide::Internal::is_monotonic </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad3afe4c4d3960b627d7d98d1f207fa52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::is_monotonic_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a87590be371b78913eaab20e563f335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::can_parallelize_rvar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Definition &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> can prove that it is safe to parallelize an update definition across a specific variable. </p>
<p>If this returns true, it's definitely safe. If this returns false, it may still be safe, but <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> couldn't prove it. </p>

</div>
</div>
<a class="anchor" id="a0ce66817377fbb1918bbe7510ab47b29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_call_arg_types </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Expr &gt; *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate arguments to a call to a func, image or imageparam. </p>

</div>
</div>
<a class="anchor" id="acfe34fa32a730191953a42d96759d23f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::partition_loops </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions loop bodies into a prologue, a steady state, and an epilogue. </p>
<p>Finds the steady state by hunting for use of clamped ramps, or the 'likely' intrinsic. </p>

</div>
</div>
<a class="anchor" id="a00dbff02860c1622c6e4d1fba8ac01e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_prefetch </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e398566fc51e7921f17b3a438b8f95a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::print_loop_nest </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit some simple pseudocode that shows the structure of the loop nest specified by this pipeline's schedule, and the schedules of the functions it uses. </p>

</div>
</div>
<a class="anchor" id="a568a0554db6866ee8560c3f599bceadd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_profiling </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement representing a halide pipeline insert high-resolution timing into the generated code (via spawning a thread that acts as a sampling profiler); summaries of execution times and counts will be logged at the end. </p>
<p>Should be done before storage flattening, but after all bounds inference. </p>

</div>
</div>
<a class="anchor" id="add0c1d3ac79fd83cb609d37831253957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::qualify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefix all variable names in the given expression with the prefix string. </p>

</div>
</div>
<a class="anchor" id="a795f343747d7f716a33198907c3e7d25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::random_float </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random floating-point number between zero and one that varies deterministically based on the input expressions. </p>

</div>
</div>
<a class="anchor" id="ae4e64539c6d89123f6200b919ec28fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::random_int </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random unsigned integer between zero and 2^32-1 that varies deterministically based on the input expressions (which must be integers or unsigned integers). </p>

</div>
</div>
<a class="anchor" id="a0f875bf4d528885d68581fbd198bf356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_random </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>free_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert calls to random() to IR generated by random_float and random_int. </p>
<p>Tags all calls with the variables in free_vars, and the integer given as the last argument. </p>

</div>
</div>
<a class="anchor" id="ab7e4af61cd70924152b76870cd5fc361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Halide::Internal::realization_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bunch of functions that call each other, determine an order in which to do the scheduling. </p>
<p>This in turn influences the order in which stages are computed when there's no strict dependency between them. Currently just some arbitrary depth-first traversal of the call graph. </p>

</div>
</div>
<a class="anchor" id="a38933818f7fe63420bd293296d6c01cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::split_predicate_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8459c153113e252e4cf11fd16326b065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_dead_allocations </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Allocate/Free pairs that are never loaded from or stored to, and remove them from the <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>. </p>
<p>This doesn't touch Realize/Call nodes and so must be called after storage_flattening. </p>

</div>
</div>
<a class="anchor" id="a445fa778b28abf135eb1b1d0c8389efc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_trivial_for_loops </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert for loops of size 1 into <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node. ">LetStmt</a> nodes, which allows for further simplification. </p>
<p>Done during a late stage of lowering. </p>

</div>
</div>
<a class="anchor" id="a078fe646230de310959c4506c76de02e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_undef </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes stores that depend on undef values, and statements that only contain such stores. </p>

</div>
</div>
<a class="anchor" id="aec17a0e39d355b75d1d5d3c0ae10dea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::schedule_functions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>any_memoized</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build loop nests and inject <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> realizations at the appropriate places using the schedule. </p>
<p>Returns a flag indicating whether memoization passes need to be run. </p>

</div>
</div>
<a class="anchor" id="a4242a0b28a7409d2a2489a74795914ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_scope_8h_source.html#l00242">242</a> of file <a class="el" href="_scope_8h_source.html">Scope.h</a>.</p>

<p>References <a class="el" href="_scope_8h_source.html#l00176">Halide::Internal::Scope&lt; T &gt;::const_iterator::name()</a>.</p>

</div>
</div>
<a class="anchor" id="a6961bbda74000b883fc5759884e4a0b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::select_gpu_api </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Target&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace for loops with GPU_Default device_api with an actual device API depending on what's enabled in the target. </p>
<p>Choose the first of the following: opencl, cuda, openglcompute, renderscript, opengl </p>

</div>
</div>
<a class="anchor" id="a4b077780a2dcb6ed633f6f5d111046c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::simplify </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify_lets</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; ModulusRemainder &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>Scope&lt;&#160;ModulusRemainder&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc. </p>
<p>Simplifies across let statements, so must not be called on stmts with dangling or repeated variable names. </p>

</div>
</div>
<a class="anchor" id="a2006cf9a5d8bad4e7861a3a10168b1d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::simplify </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify_lets</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; ModulusRemainder &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>Scope&lt;&#160;ModulusRemainder&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc. </p>
<p>Simplifies across let statements, so must not be called on stmts with dangling or repeated variable names. </p>

</div>
</div>
<a class="anchor" id="a9a9bb398349140947e359eb3b1abc24c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::can_prove </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A common use of the simplifier is to prove boolean expressions are true at compile time. </p>
<p>Equivalent to is_one(simplify(e)) </p>

</div>
</div>
<a class="anchor" id="a27d8c444c776976f822644dc995d10ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::simplify_exprs </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify expressions found in a statement, but don't simplify across different statements. </p>
<p>This is safe to perform at an earlier stage in lowering than full simplification of a stmt. </p>

</div>
</div>
<a class="anchor" id="a6cd3908859c82249a2c7f10158883a97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::mod_imp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>. </p>
<p>Use these implementations; do not use native C division or mod to simplify <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> expressions. <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> division and modulo satisify the Euclidean definition of division for integers a and b:</p>
<p>/code (a/b)*b + ab = a 0 &lt;= ab &lt; |b| /endcode </p>

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00054">54</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00747">Halide::abs()</a>, <a class="el" href="runtime__internal_8h_source.html#l00186">Halide::Runtime::Internal::b</a>, <a class="el" href="_type_8h_source.html#l00341">Halide::Type::is_int()</a>, and <a class="el" href="runtime__internal_8h_source.html#l00184">Halide::Runtime::Internal::t</a>.</p>

</div>
</div>
<a class="anchor" id="a0442f9a0450f45683938a69ce0273974"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::div_imp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>. </p>
<p>Use these implementations; do not use native C division or mod to simplify <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> expressions. <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> division and modulo satisify the Euclidean definition of division for integers a and b:</p>
<p>/code (a/b)*b + ab = a 0 &lt;= ab &lt; |b| /endcode </p>

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00066">66</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00186">Halide::Runtime::Internal::b</a>, <a class="el" href="_type_8h_source.html#l00302">Halide::Type::bits()</a>, <a class="el" href="_type_8h_source.html#l00341">Halide::Type::is_int()</a>, and <a class="el" href="runtime__internal_8h_source.html#l00184">Halide::Runtime::Internal::t</a>.</p>

</div>
</div>
<a class="anchor" id="adff5495089b812474881ee939c4701c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00081">81</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00185">Halide::Runtime::Internal::a</a>, and <a class="el" href="runtime__internal_8h_source.html#l00186">Halide::Runtime::Internal::b</a>.</p>

</div>
</div>
<a class="anchor" id="ac9a60708c880da445554b8eeb778c034"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00086">86</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00185">Halide::Runtime::Internal::a</a>, <a class="el" href="runtime__internal_8h_source.html#l00186">Halide::Runtime::Internal::b</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01305">Halide::floor()</a>.</p>

</div>
</div>
<a class="anchor" id="aa13a82f37fe6336c154122f66d294523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00091">91</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00185">Halide::Runtime::Internal::a</a>, and <a class="el" href="runtime__internal_8h_source.html#l00186">Halide::Runtime::Internal::b</a>.</p>

</div>
</div>
<a class="anchor" id="a3965c871f086a60fda2cc31e678d050a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00094">94</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00185">Halide::Runtime::Internal::a</a>, and <a class="el" href="runtime__internal_8h_source.html#l00186">Halide::Runtime::Internal::b</a>.</p>

</div>
</div>
<a class="anchor" id="a91c952efe23378dcba6fcbd92055c213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::simplify_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af4259425c64a0a9b25760e1c38123c13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::simplify_specializations </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to simplify the RHS/LHS of a function's definition based on its specializations. </p>

</div>
</div>
<a class="anchor" id="a8489422fe4da6e486b5fd7831aab8bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::skip_stages </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Avoid computing certain stages if we can infer a runtime condition to check that tells us they won't be used. </p>
<p>Does this by analyzing all reads of each buffer allocated, and inferring some condition that tells us if the reads occur. If the condition is non-trivial, inject ifs that guard the production. </p>

</div>
</div>
<a class="anchor" id="a07bde9012b280aad21a569ea008ed296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::sliding_window </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform sliding window optimizations on a halide statement. </p>
<p>I.e. don't bother computing points in a function that have provably already been computed by a previous iteration. </p>

</div>
</div>
<a class="anchor" id="a935e1b9f6b8c8aafaa7f7e28ae546c72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_solver_result.html">SolverResult</a> Halide::Internal::solve_expression </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Expr&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to collect all instances of a variable in an expression tree and place it as far to the left as possible, and as far up the tree as possible (i.e. </p>
<p>outside most parentheses). If the expression is an equality or comparison, this 'solves' the equation. Returns a pair of <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> and bool. The <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> is the mutated expression, and the bool indicates whether there is a single instance of the variable in the result. If it is false, the expression has only been partially solved, and there are still multiple instances of the variable. </p>

</div>
</div>
<a class="anchor" id="ae6ea43af65052aca0edc723e047a7fcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::solve_for_outer_interval </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the smallest interval such that the condition is either true or false inside of it, but definitely false outside of it. </p>
<p>Never returns undefined Exprs, instead it uses variables called "pos_inf" and "neg_inf" to represent positive and negative infinity. </p>

</div>
</div>
<a class="anchor" id="a97e47b29745810786912857f328fc6b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::solve_for_inner_interval </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the largest interval such that the condition is definitely true inside of it, and might be true or false outside of it. </p>

</div>
</div>
<a class="anchor" id="abed16d941f9de01188d0d4cc265d4c6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::and_condition_over_domain </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>varying</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a conditional that includes variables that vary over some domain, and convert it to a more conservative (less frequently true) condition that doesn't depend on those variables. </p>
<p>Formally, the output expr implies the input expr.</p>
<p>The condition may be a vector condition, in which case we also 'and' over the vector lanes, and return a scalar result. </p>

</div>
</div>
<a class="anchor" id="aff96a46ef180209a14610a2a5a1d74ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::solve_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a18248db0e632551cd5b3376e6ade4365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::print_to_html </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump an HTML-formatted print of a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> to filename. </p>

</div>
</div>
<a class="anchor" id="ae8228323a26e73895bb0e3d3e1e78496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::print_to_html </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump an HTML-formatted print of a <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to filename. </p>

</div>
</div>
<a class="anchor" id="ac8cb6fe2cb6171bf79124c2c1b1e867f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::storage_flattening </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location. ">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;. ">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer. ">Load</a> nodes respectively. </p>

</div>
</div>
<a class="anchor" id="a003d25ab32344023873b630df8fc5719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::storage_folding </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold storage of functions if possible. </p>
<p>This means reducing one of the dimensions module something for the purpose of storage, if we can prove that this is safe to do. E.g consider:</p>
<div class="fragment"><div class="line">f(x) = ...</div>
<div class="line">g(x) = f(x-1) + f(x)</div>
<div class="line">f.store_root().compute_at(g, x);</div>
</div><!-- fragment --><p>We can store f as a circular buffer of size two, instead of allocating space for all of it. </p>

</div>
</div>
<a class="anchor" id="ac48710fd66a0823291cabe7451d91f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within expr. </p>
<p>This is a dangerous thing to do if variable names have not been uniquified. While it won't traverse inside let statements with the same name as the first argument, moving a piece of syntax around can change its meaning, because it can cross lets that redefine variable names that it includes references to. </p>

</div>
</div>
<a class="anchor" id="ad62310d71063459051000c4032c78d6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within stmt. </p>

</div>
</div>
<a class="anchor" id="a6daa7c8282e00d77d69713bd0ca4c73d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with names in the map. </p>

</div>
</div>
<a class="anchor" id="a6f67c2e11eb92dcfb534e01a4e431e29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with names in the map. </p>

</div>
</div>
<a class="anchor" id="a9624281bd69638e2901f037e7d481dc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute expressions for other expressions. </p>

</div>
</div>
<a class="anchor" id="a3066061a33cacb7f0c7ab0fc63eefe84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute expressions for other expressions. </p>

</div>
</div>
<a class="anchor" id="a82ec663fe98ff797570d624865d72390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutions where the IR may be a general graph (and not just a DAG). </p>

</div>
</div>
<a class="anchor" id="a87c182d9900ff0e7e47da4949fc9f913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutions where the IR may be a general graph (and not just a DAG). </p>

</div>
</div>
<a class="anchor" id="a01f8abdf5154d9a9fa66e0e92842b650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutions where the IR may be a general graph (and not just a DAG). </p>

</div>
</div>
<a class="anchor" id="a8009665b3c0e8441bb4a5dd27cfa8e3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::graph_substitute </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutions where the IR may be a general graph (and not just a DAG). </p>

</div>
</div>
<a class="anchor" id="a0b8a52e8564fccbd77e9e133ea2fe45d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute_in_all_lets </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute in all let Exprs in a piece of IR. </p>
<p>Doesn't substitute in let stmts, as this may change the meaning of the IR (e.g. by moving a load after a store). Produces graphs of IR, so don't use non-graph-aware visitors or mutators on it until you've CSE'd the result. </p>

</div>
</div>
<a class="anchor" id="ab579b1fa582db455111a5083fa0c8708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute_in_all_lets </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute in all let Exprs in a piece of IR. </p>
<p>Doesn't substitute in let stmts, as this may change the meaning of the IR (e.g. by moving a load after a store). Produces graphs of IR, so don't use non-graph-aware visitors or mutators on it until you've CSE'd the result. </p>

</div>
</div>
<a class="anchor" id="a75c39fdac13dbbf178d4ae1680c7dbf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::target_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afaccc673e9c40dc5fb5742cdfd1ea37e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_tracing </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pipeline_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations. </p>
<p>Should be done before storage flattening, but after all bounds inference. </p>

</div>
</div>
<a class="anchor" id="ae7de5466472c73e9b9510a19b536481a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::trim_no_ops </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate loop bounds to the region over which they actually do something. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> examples see test/correctness/trim_no_ops.cpp </p>

</div>
</div>
<a class="anchor" id="a0b6c445013b15af0a32bd54f5bb6bdc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unify_duplicate_lets </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find let statements that all define the same value, and make later ones just reuse the symbol names of the earlier ones. </p>

</div>
</div>
<a class="anchor" id="abf197e316b7d0a6adb96c25976612c1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::uniquify_variable_names </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify a statement so that every internally-defined variable name is unique. </p>
<p>This lets later passes assume syntactic equivalence is semantic equivalence. </p>

</div>
</div>
<a class="anchor" id="adc1c49e552297672b3751ac988bf70c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unroll_loops </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement. </p>
<p>I.e. unroll the loop. </p>

</div>
</div>
<a class="anchor" id="a94816d6979fdadb6e206a5d0a668e008"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DstType , typename SrcType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DstType Halide::Internal::reinterpret_bits </td>
          <td>(</td>
          <td class="paramtype">const SrcType &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An aggressive form of reinterpret cast used for correct type-punning. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00049">49</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="printer_8h_source.html#l00030">dst</a>, and <a class="el" href="runtime__internal_8h.html#add55236e1a6168d059f1409762081d1a">memcpy()</a>.</p>

</div>
</div>
<a class="anchor" id="a2eb97978547d98141752de6b614195f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::make_entity_name </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a unique name for an object based on the name of the stack variable passed in. </p>
<p>If introspection isn't working or there are no debug symbols, just uses unique_name with the given prefix. </p>

</div>
</div>
<a class="anchor" id="a3f5c91808e78c03a99a02fb7b37d2c02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::get_env_variable </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>env_var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>var_defined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get value of an environment variable. </p>
<p>Returns its value is defined in the environment. Input: env_var_name. Output: var_defined. Sets to true var_defined if the environment var is defined; false otherwise. </p>

<p>Referenced by <a class="el" href="_debug_8h_source.html#l00052">Halide::Internal::debug::debug()</a>.</p>

</div>
</div>
<a class="anchor" id="aa67ba715b9cc517c979f2f56f1236a33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::running_program_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the currently running executable. </p>
<p>Platform-specific. If program name cannot be retrieved, function returns an empty string. </p>

</div>
</div>
<a class="anchor" id="acd575ab182df12cc793dba4aa241c1a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::unique_name </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a unique name starting with the given prefix. </p>
<p>It's unique relative to all other strings returned by unique_name in this process.</p>
<p>The single-character version always appends a numeric suffix to the character.</p>
<p>The string version will either return the input as-is (with high probability on the first time it is called with that input), or replace any existing '$' characters with underscores, then add a '$' sign and a numeric suffix to it.</p>
<p>Note that unique_name('f') therefore differs from unique_name("f"). The former returns something like f123, and the latter returns either f or f$123. </p>

<p>Referenced by <a class="el" href="_lambda_8h_source.html#l00017">Halide::lambda()</a>.</p>

</div>
</div>
<a class="anchor" id="acd494d26bfdb439727f5a9e8ecc48537"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::unique_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a unique name starting with the given prefix. </p>
<p>It's unique relative to all other strings returned by unique_name in this process.</p>
<p>The single-character version always appends a numeric suffix to the character.</p>
<p>The string version will either return the input as-is (with high probability on the first time it is called with that input), or replace any existing '$' characters with underscores, then add a '$' sign and a numeric suffix to it.</p>
<p>Note that unique_name('f') therefore differs from unique_name("f"). The former returns something like f123, and the latter returns either f or f$123. </p>

</div>
</div>
<a class="anchor" id="aa7703083cfe592de68f37796533724ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the first string starts with the second string. </p>

</div>
</div>
<a class="anchor" id="a230079281175545b9b90b2285106ab28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the first string ends with the second string. </p>

</div>
</div>
<a class="anchor" id="acba3d0dce3432d1af82c8548d40406c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all matches of the second string in the first string with the last string. </p>

</div>
</div>
<a class="anchor" id="aedc761896b3e6a38bddce45b6c0f8b15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;std::string&gt; Halide::Internal::split_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> the source string using 'delim' as the divider. </p>

</div>
</div>
<a class="anchor" id="aaaee1bb2b0dc659851899df7c12437ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::fold_left </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a left fold of a vector. </p>
<p>Returns a default-constructed vector element if the vector is empty. Similar to std::accumulate but with a less clunky syntax. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00108">108</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="afedfcf82469516f0f05eb5a4699f480a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::fold_right </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a right fold of a vector. </p>
<p>Returns a default-constructed vector element if the vector is empty. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00123">123</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa0f0ecaee7837d40c1d42846617992fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::Internal::collect_paired_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T1, T2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>collected_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00136">136</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00142">collect_paired_args()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00113">Halide::BoundaryConditions::constant_exterior()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00222">Halide::BoundaryConditions::mirror_image()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00259">Halide::BoundaryConditions::mirror_interior()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00154">Halide::BoundaryConditions::repeat_edge()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00188">Halide::BoundaryConditions::repeat_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a0f8060f18ae092b69122b0334f9e05f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::Internal::collect_paired_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T1, T2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>collected_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4 &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00142">142</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00136">collect_paired_args()</a>.</p>

</div>
</div>
<a class="anchor" id="a93192a2ea0afe58664e69232595ae08e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Internal::extract_namespaces </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns base name and fills in namespaces, outermost one first in vector. </p>

</div>
</div>
<a class="anchor" id="afce725835e748b650a0836269a140615"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::file_make_temp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary (but writable) directory; this is typically /tmp, but the specific location is not guaranteed. </p>
<p>(Note that the exact form of the file name may vary; in particular, the suffix may be ignored on Windows.) The file is created (but not opened), thus this can be called from different threads (or processes, e.g. when building with parallel make) without risking collision. Note that if this file is used as a temporary file, the caller is responsibly for deleting it. Neither the prefix nor suffix may contain a directory separator. </p>

</div>
</div>
<a class="anchor" id="a1cf1e96bff058c5a479b08c236cec689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::dir_make_temp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a unique directory in an arbitrary (but writable) directory; this is typically somewhere inside /tmp, but the specific location is not guaranteed. </p>
<p>The directory will be empty (i.e., this will never return /tmp itself, but rather a new directory inside /tmp). The caller is responsible for removing the directory after use. </p>

</div>
</div>
<a class="anchor" id="a518086fef4df79fd915e6489e3be703e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for access(). </p>
<p>Asserts upon error. </p>

</div>
</div>
<a class="anchor" id="a6b0f0dfc46541dab4528baf664a63ea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::file_unlink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for unlink(). </p>
<p>Asserts upon error. </p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00211">Halide::Internal::TemporaryFile::~TemporaryFile()</a>.</p>

</div>
</div>
<a class="anchor" id="a205a11ea75c89d6642c8476372e2f83d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::dir_rmdir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for rmdir(). </p>
<p>Asserts upon error. </p>

</div>
</div>
<a class="anchor" id="acb54eb008076b8c9d945a770e24799af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_file_stat.html">FileStat</a> Halide::Internal::file_stat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper for stat(). </p>
<p>Asserts upon error. </p>

</div>
</div>
<a class="anchor" id="a8cc678d669d07fdd15685b87e3b8b620"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::add_would_overflow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routines to test if math would overflow for signed integers with the given number of bits. </p>

</div>
</div>
<a class="anchor" id="a82c64641e261b5596a2ab6d7da7f8ef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::sub_would_overflow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routines to test if math would overflow for signed integers with the given number of bits. </p>

</div>
</div>
<a class="anchor" id="a9aaa735c9ff93372dce25222fb551b67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::mul_would_overflow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routines to test if math would overflow for signed integers with the given number of bits. </p>

</div>
</div>
<a class="anchor" id="adcfef059a37f995f9434f836bdbc1edd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::find_linear_expressions </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal.html#adcfef059a37f995f9434f836bdbc1edd" title="find_linear_expressions(Stmt s) identifies expressions that may be moved out of the generated fragmen...">find_linear_expressions(Stmt s)</a> identifies expressions that may be moved out of the generated fragment shader into a varying attribute. </p>
<p>These expressions are tagged by wrapping them in a glsl_varying intrinsic </p>

</div>
</div>
<a class="anchor" id="a523c0d5dea7bfbd664e8506ebb7016de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::setup_gpu_vertex_buffer </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a set of 2D mesh coordinates based on the behavior of varying attribute expressions contained within a GLSL scheduled for loop. </p>
<p>This method is called during lowering to extract varying attribute expressions and generate code to evalue them at each mesh vertex location. The operation is performed on the host before the draw call to invoke the shader </p>

</div>
</div>
<a class="anchor" id="abe70c3a9d0ecd59908b1837a11d01de0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::vectorize_loops </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors. </p>
<p>The loops in question must have constant extent. </p>

</div>
</div>
<a class="anchor" id="a47ba0a978ebdc5f1866290752bd76e6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; Halide::Internal::wrap_func_calls </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace every call to wrapped Functions in the Functions' definitions with call to their wrapper functions. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
