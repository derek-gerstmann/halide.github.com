<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: Halide::Internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_halide_1_1_internal.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Internal Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A struct used to detect if a type is a pointer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_integer_division"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_integer_division.html">IntegerDivision</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_introspection"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_introspection.html">Introspection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the bounds of a region of arbitrary dimension.  <a href="struct_halide_1_1_internal_1_1_box.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___a_r_m.html">CodeGen_ARM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits ARM code from a given <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___a_r_m.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___c.html">CodeGen_C</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class emits C++ code equivalent to a halide <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>.  <a href="class_halide_1_1_internal_1_1_code_gen___c.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_p_u___argument.html">GPU_Argument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struct_halide_1_1_internal_1_1_g_p_u___argument.html" title="A GPU_Argument looks similar to an Halide::Argument, but has behavioral differences that make it spec...">GPU_Argument</a> looks similar to an <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function. ">Halide::Argument</a>, but has behavioral differences that make it specific to the GPU pipeline; the fact that neither is-a nor has-a <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function. ">Halide::Argument</a> is deliberate.  <a href="struct_halide_1_1_internal_1_1_g_p_u___argument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html">CodeGen_GPU_Dev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> stmt.  <a href="struct_halide_1_1_internal_1_1_code_gen___g_p_u___dev.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_p_u___host.html">CodeGen_GPU_Host</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___g_p_u___host.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_closure.html">Closure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to manage closures.  <a href="class_halide_1_1_internal_1_1_closure.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html">CodeGen_LLVM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator abstract base class.  <a href="class_halide_1_1_internal_1_1_code_gen___l_l_v_m.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___m_i_p_s.html">CodeGen_MIPS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits mips code from a given <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___m_i_p_s.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___open_c_l___dev.html">CodeGen_OpenCL_Dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___open_g_l___dev.html">CodeGen_OpenGL_Dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l.html">CodeGen_GLSL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile one statement into GLSL.  <a href="class_halide_1_1_internal_1_1_code_gen___g_l_s_l.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___p_na_cl.html">CodeGen_PNaCl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits pnacl bitcode from a given <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___p_na_cl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___posix.html">CodeGen_Posix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits posix code from a given <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___posix.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___p_t_x___dev.html">CodeGen_PTX_Dev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits GPU code from a given <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___p_t_x___dev.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_code_gen___x86.html">CodeGen_X86</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A code generator that emits x86 code from a given <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> stmt.  <a href="class_halide_1_1_internal_1_1_code_gen___x86.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1debug.html">debug</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> optional debugging during codegen, use the debug class as follows:  <a href="struct_halide_1_1_internal_1_1debug.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_error_report.html">ErrorReport</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_node_type.html">IRNodeType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a type of IR node (e.g.  <a href="struct_halide_1_1_internal_1_1_i_r_node_type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base classes for a node in the <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> IR.  <a href="struct_halide_1_1_internal_1_1_i_r_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_stmt_node.html">BaseStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are split into expressions and statements.  <a href="struct_halide_1_1_internal_1_1_base_stmt_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_base_expr_node.html">BaseExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for expression nodes.  <a href="struct_halide_1_1_internal_1_1_base_expr_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_node.html">ExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We use the "curiously recurring template pattern" to avoid duplicated code in the IR Nodes.  <a href="struct_halide_1_1_internal_1_1_expr_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt_node.html">StmtNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_handle.html">IRHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IR nodes are passed around opaque handles to them.  <a href="struct_halide_1_1_internal_1_1_i_r_handle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html">IntImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer constants.  <a href="struct_halide_1_1_internal_1_1_int_imm.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html">FloatImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point constants.  <a href="struct_halide_1_1_internal_1_1_float_imm.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html">StringImm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String constants.  <a href="struct_halide_1_1_internal_1_1_string_imm.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a statement node.  <a href="struct_halide_1_1_internal_1_1_stmt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_expr_uses_vars.html">ExprUsesVars</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_update_definition.html">UpdateDefinition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_function_contents.html">FunctionContents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s internal representation of a function.  <a href="class_halide_1_1_internal_1_1_function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_param_base.html">GeneratorParamBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_base.html">GeneratorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_factory.html">GeneratorFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html">GeneratorRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a reference count to be used with <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html" title="Intrusive shared pointers have a reference count (a RefCount object) stored in the class itself...">IntrusivePtr</a>.  <a href="class_halide_1_1_internal_1_1_ref_count.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive shared pointers have a reference count (a <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> object) stored in the class itself.  <a href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual IR nodes begin here.  <a href="struct_halide_1_1_internal_1_1_cast.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_add.html">Add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of two expressions.  <a href="struct_halide_1_1_internal_1_1_add.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_sub.html">Sub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The difference of two expressions.  <a href="struct_halide_1_1_internal_1_1_sub.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mul.html">Mul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The product of two expressions.  <a href="struct_halide_1_1_internal_1_1_mul.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_div.html">Div</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ratio of two expressions.  <a href="struct_halide_1_1_internal_1_1_div.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_mod.html">Mod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of a / b.  <a href="struct_halide_1_1_internal_1_1_mod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_min.html">Min</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lesser of two values.  <a href="struct_halide_1_1_internal_1_1_min.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_max.html">Max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greater of two values.  <a href="struct_halide_1_1_internal_1_1_max.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_e_q.html">EQ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression equal to the second.  <a href="struct_halide_1_1_internal_1_1_e_q.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_n_e.html">NE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression not equal to the second.  <a href="struct_halide_1_1_internal_1_1_n_e.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_t.html">LT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than the second.  <a href="struct_halide_1_1_internal_1_1_l_t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_l_e.html">LE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression less than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_l_e.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_t.html">GT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than the second.  <a href="struct_halide_1_1_internal_1_1_g_t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_g_e.html">GE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the first expression greater than or equal to the second.  <a href="struct_halide_1_1_internal_1_1_g_e.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_and.html">And</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and - are both expressions true.  <a href="struct_halide_1_1_internal_1_1_and.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_or.html">Or</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or - is at least one of the expression true.  <a href="struct_halide_1_1_internal_1_1_or.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_not.html">Not</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical not - true if the expression false.  <a href="struct_halide_1_1_internal_1_1_not.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_select.html">Select</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ternary operator.  <a href="struct_halide_1_1_internal_1_1_select.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_load.html">Load</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer. ">Load</a> a value from a named buffer.  <a href="struct_halide_1_1_internal_1_1_load.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_ramp.html">Ramp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear ramp vector node.  <a href="struct_halide_1_1_internal_1_1_ramp.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html">Broadcast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector with 'width' elements, in which every element is 'value'.  <a href="struct_halide_1_1_internal_1_1_broadcast.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let.html">Let</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A let expression, like you might find in a functional language.  <a href="struct_halide_1_1_internal_1_1_let.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html">LetStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The statement form of a let node.  <a href="struct_halide_1_1_internal_1_1_let_stmt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_assert_stmt.html">AssertStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the 'condition' is false, then evaluate and return the message, which should be a call to an error function.  <a href="struct_halide_1_1_internal_1_1_assert_stmt.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_pipeline.html">Pipeline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node is a helpful annotation to do with permissions.  <a href="struct_halide_1_1_internal_1_1_pipeline.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_store.html">Store</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;. ">Store</a> a 'value' to the buffer called 'name' at a given 'index'.  <a href="struct_halide_1_1_internal_1_1_store.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_provide.html">Provide</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines the value of a function at a multi-dimensional location.  <a href="struct_halide_1_1_internal_1_1_provide.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html">Allocate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a> a scratch area called with the given name, type, and size.  <a href="struct_halide_1_1_internal_1_1_allocate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_free.html">Free</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_free.html" title="Free the resources associated with the given buffer. ">Free</a> the resources associated with the given buffer.  <a href="struct_halide_1_1_internal_1_1_free.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single-dimensional span.  <a href="struct_halide_1_1_internal_1_1_range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_realize.html">Realize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a> a multi-dimensional buffer of the given type and size.  <a href="struct_halide_1_1_internal_1_1_realize.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of statements to be executed in-order.  <a href="struct_halide_1_1_internal_1_1_block.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_if_then_else.html">IfThenElse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An if-then-else block.  <a href="struct_halide_1_1_internal_1_1_if_then_else.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html">Evaluate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect. ">Evaluate</a> and discard an expression, presumably because it has some side-effect.  <a href="struct_halide_1_1_internal_1_1_evaluate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_call.html">Call</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function call.  <a href="struct_halide_1_1_internal_1_1_call.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A named variable.  <a href="struct_halide_1_1_internal_1_1_variable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_for.html">For</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A for loop.  <a href="struct_halide_1_1_internal_1_1_for.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_deep_compare.html">IRDeepCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compare struct suitable for use in std::map and std::set that computes a lexical ordering on IR nodes.  <a href="struct_halide_1_1_internal_1_1_i_r_deep_compare.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_compare_cache.html">IRCompareCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lossily track known equal exprs with a cache.  <a href="class_halide_1_1_internal_1_1_i_r_compare_cache.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_expr_with_compare_cache.html">ExprWithCompareCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper about Exprs so that they can be deeply compared with a cache for known-equal subexpressions.  <a href="struct_halide_1_1_internal_1_1_expr_with_compare_cache.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for passes over the IR which modify it (e.g.  <a href="class_halide_1_1_internal_1_1_i_r_mutator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_printer.html">IRPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR. ">IRVisitor</a> that emits IR to the given output stream in a human readable form.  <a href="class_halide_1_1_internal_1_1_i_r_printer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that need to recursively walk over the IR.  <a href="class_halide_1_1_internal_1_1_i_r_visitor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html">IRGraphVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms that walk recursively over the IR without visiting the same node twice.  <a href="class_halide_1_1_internal_1_1_i_r_graph_visitor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_module.html">JITModule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_handlers.html">JITHandlers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_user_context.html">JITUserContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_j_i_t_shared_runtime.html">JITSharedRuntime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a lowered function.  <a href="struct_halide_1_1_internal_1_1_lowered_func.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result of modulus_remainder analysis.  <a href="struct_halide_1_1_internal_1_1_modulus_remainder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_object_instance_registry.html">ObjectInstanceRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1not__a__pointer.html">not_a_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1not__a__pointer_3_01_t_01_5_01_4.html">not_a_pointer&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle to a parameter to a halide pipeline.  <a href="class_halide_1_1_internal_1_1_parameter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html">ReductionVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single named dimension of a reduction domain.  <a href="struct_halide_1_1_internal_1_1_reduction_variable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_reduction_domain_contents.html">ReductionDomainContents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted handle on a reduction domain, which is just a vector of <a class="el" href="struct_halide_1_1_internal_1_1_reduction_variable.html" title="A single named dimension of a reduction domain. ">ReductionVariable</a>.  <a href="class_halide_1_1_internal_1_1_reduction_domain.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_loop_level.html">LoopLevel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a site in a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> statement at the top of the body of a particular for loop.  <a href="struct_halide_1_1_internal_1_1_loop_level.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_dim.html">Dim</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_bound.html">Bound</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_schedule.html">Schedule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A schedule for a single stage of a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> pipeline.  <a href="class_halide_1_1_internal_1_1_schedule.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_small_stack.html">SmallStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack which can store one item very efficiently.  <a href="class_halide_1_1_internal_1_1_small_stack.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A common pattern when traversing <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> IR is that you need to keep track of stuff when you find a <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language. ">Let</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node. ">LetStmt</a>, and that it should hide previous values with the same name until you leave the <a class="el" href="struct_halide_1_1_internal_1_1_let.html" title="A let expression, like you might find in a functional language. ">Let</a> or <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node. ">LetStmt</a> nodes This class helps with that.  <a href="class_halide_1_1_internal_1_1_scope.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and.html">meta_and</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1meta__and_3_01_t1_00_01_args_8_8_8_4.html">meta_and&lt; T1, Args...&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">all_are_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aaa0611a86047e2c583dd061a620dcc6e"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::pair<br class="typebreak"/>
&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a></td></tr>
<tr class="separator:aaa0611a86047e2c583dd061a620dcc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08852c0c8674ceba4ec8739d799256c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab08852c0c8674ceba4ec8739d799256c">GeneratorParamValues</a> = std::map&lt; std::string, std::string &gt;</td></tr>
<tr class="separator:ab08852c0c8674ceba4ec8739d799256c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1b9521b6f1f513178f281d8f395335"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Region</a></td></tr>
<tr class="memdesc:abd1b9521b6f1f513178f281d8f395335"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional box.  <a href="#abd1b9521b6f1f513178f281d8f395335">More...</a><br/></td></tr>
<tr class="separator:abd1b9521b6f1f513178f281d8f395335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db928fd19209689611a24deafa15b9c"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7db928fd19209689611a24deafa15b9c">halide_task</a> )(void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td></tr>
<tr class="separator:a7db928fd19209689611a24deafa15b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694232f7607c49b94dcb6f7b08099fec"><td class="memItemLeft" align="right" valign="top">typedef llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a694232f7607c49b94dcb6f7b08099fec">LLVMMDNodeArgumentType</a></td></tr>
<tr class="separator:a694232f7607c49b94dcb6f7b08099fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6d77bcd7bf9bfb0b3f5e66010d9ff3ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">MonotonicResult</a> { <a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3eaad87898a017f26e62737125de2b4a9335">Constant</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa6d17c1a787b2f3a7331fde1759083637">MonotonicIncreasing</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa799183e45407f014ab370a9b4bcd2dc3">MonotonicDecreasing</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa33f442ca80fb5f8ce55a5becac9a30cf">Unknown</a>
 }</td></tr>
<tr class="memdesc:a6d77bcd7bf9bfb0b3f5e66010d9ff3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown.  <a href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">More...</a><br/></td></tr>
<tr class="separator:a6d77bcd7bf9bfb0b3f5e66010d9ff3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8761f129e6554b9ea03de31bf066f1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> { <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1a5255d3daaa0a6276b844d61401e6f493">ForType::Serial</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1a98402eecfbcefc336954458a01752131">ForType::Parallel</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1a138bc087eaaaf426b54f9a466f0cc725">ForType::Vectorized</a>, 
<a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1ae53597647de81f4cc9e098fc119ba0ac">ForType::Unrolled</a>
 }</td></tr>
<tr class="memdesc:a6a8761f129e6554b9ea03de31bf066f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing a type of loop traversal.  <a href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">More...</a><br/></td></tr>
<tr class="separator:a6a8761f129e6554b9ea03de31bf066f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a410eac3ad68dfb697c5ee97100f2053f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a410eac3ad68dfb697c5ee97100f2053f">allocation_bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;func_bounds)</td></tr>
<tr class="memdesc:a410eac3ad68dfb697c5ee97100f2053f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a> nodes in terms of variables, and define values for those variables.  <a href="#a410eac3ad68dfb697c5ee97100f2053f">More...</a><br/></td></tr>
<tr class="separator:a410eac3ad68dfb697c5ee97100f2053f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad216f1f9fcd53fd56ba2a55b172a3669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad216f1f9fcd53fd56ba2a55b172a3669">flatten_blocks</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="separator:ad216f1f9fcd53fd56ba2a55b172a3669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f7e59492cfa4804a6dece2d867a5db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab7f7e59492cfa4804a6dece2d867a5db">bounds_of_expr_in_scope</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope, const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:ab7f7e59492cfa4804a6dece2d867a5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression.  <a href="#ab7f7e59492cfa4804a6dece2d867a5db">More...</a><br/></td></tr>
<tr class="separator:ab7f7e59492cfa4804a6dece2d867a5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac2f62c0ee3ace8de2be57a9db369a3e4">merge_boxes</a> (<a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="separator:ac2f62c0ee3ace8de2be57a9db369a3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9641dd947fdf6352ccd5e34548db35e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac9641dd947fdf6352ccd5e34548db35e">boxes_overlap</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;a, const <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &amp;b)</td></tr>
<tr class="separator:ac9641dd947fdf6352ccd5e34548db35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b807d0d1524fb2f20b1533d05032c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0b807d0d1524fb2f20b1533d05032c02">compute_function_value_bounds</a> (const std::vector&lt; std::string &gt; &amp;order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a0b807d0d1524fb2f20b1533d05032c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum and minimum possible value for each function in an environment.  <a href="#a0b807d0d1524fb2f20b1533d05032c02">More...</a><br/></td></tr>
<tr class="separator:a0b807d0d1524fb2f20b1533d05032c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439ef9127bf30f5e2a67963eb8db0323"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a439ef9127bf30f5e2a67963eb8db0323">bounds_test</a> ()</td></tr>
<tr class="separator:a439ef9127bf30f5e2a67963eb8db0323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f57a77cbbb8e2e2e7212a75a470fec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9f57a77cbbb8e2e2e7212a75a470fec7">bounds_inference</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::vector&lt; std::string &gt; &amp;realization_order, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;environment, const std::map&lt; std::pair&lt; std::string, int &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;func_bounds)</td></tr>
<tr class="memdesc:a9f57a77cbbb8e2e2e7212a75a470fec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds.  <a href="#a9f57a77cbbb8e2e2e7212a75a470fec7">More...</a><br/></td></tr>
<tr class="separator:a9f57a77cbbb8e2e2e7212a75a470fec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f10140e29131153c3be98d2899b090"><td class="memItemLeft" align="right" valign="top">llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a71f10140e29131153c3be98d2899b090">llvm_type_of</a> (llvm::LLVMContext *context, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> t)</td></tr>
<tr class="memdesc:a71f10140e29131153c3be98d2899b090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the llvm type equivalent to a given halide type.  <a href="#a71f10140e29131153c3be98d2899b090">More...</a><br/></td></tr>
<tr class="separator:a71f10140e29131153c3be98d2899b090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dec1d917db83734b33d5a208e9ca973"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8dec1d917db83734b33d5a208e9ca973">constant_allocation_size</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;extents, const std::string &amp;name, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &amp;size)</td></tr>
<tr class="memdesc:a8dec1d917db83734b33d5a208e9ca973"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to check if a list of extents are all constants, and if so verify the total size is less than 2^31 - 1.  <a href="#a8dec1d917db83734b33d5a208e9ca973">More...</a><br/></td></tr>
<tr class="separator:a8dec1d917db83734b33d5a208e9ca973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adc60421b682a09ea4c4dcaaaa3e105e2">function_takes_user_context</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which built-in functions require a user-context first argument?  <a href="#adc60421b682a09ea4c4dcaaaa3e105e2">More...</a><br/></td></tr>
<tr class="separator:adc60421b682a09ea4c4dcaaaa3e105e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c69c01c5d35b1cd47354374d49bf28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a83c69c01c5d35b1cd47354374d49bf28">common_subexpression_elimination</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>)</td></tr>
<tr class="memdesc:a83c69c01c5d35b1cd47354374d49bf28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable.  <a href="#a83c69c01c5d35b1cd47354374d49bf28">More...</a><br/></td></tr>
<tr class="separator:a83c69c01c5d35b1cd47354374d49bf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd617bcfa0cf8b542eb38a8cca1f0614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abd617bcfa0cf8b542eb38a8cca1f0614">common_subexpression_elimination</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:abd617bcfa0cf8b542eb38a8cca1f0614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do common-subexpression-elimination on each expression in a statement.  <a href="#abd617bcfa0cf8b542eb38a8cca1f0614">More...</a><br/></td></tr>
<tr class="separator:abd617bcfa0cf8b542eb38a8cca1f0614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750967bfd0520280ceadbf9f15ffa3be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a750967bfd0520280ceadbf9f15ffa3be">cse_test</a> ()</td></tr>
<tr class="separator:a750967bfd0520280ceadbf9f15ffa3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f749a540acb9a7c148602c517e61e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a12f749a540acb9a7c148602c517e61e5">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> &amp;)</td></tr>
<tr class="memdesc:a12f749a540acb9a7c148602c517e61e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide statement on an output stream (such as std::cout) in a human-readable form.  <a href="#a12f749a540acb9a7c148602c517e61e5">More...</a><br/></td></tr>
<tr class="separator:a12f749a540acb9a7c148602c517e61e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915eea9584a02a02fa0ccd9dea859e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a915eea9584a02a02fa0ccd9dea859e87">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="struct_halide_1_1_internal_1_1_lowered_func.html">LoweredFunc</a> &amp;)</td></tr>
<tr class="separator:a915eea9584a02a02fa0ccd9dea859e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0694c89a8349199080a71443202acd43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0694c89a8349199080a71443202acd43">debug_to_file</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string output, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a0694c89a8349199080a71443202acd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a> nodes still unlowered.  <a href="#a0694c89a8349199080a71443202acd43">More...</a><br/></td></tr>
<tr class="separator:a0694c89a8349199080a71443202acd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3886cd7a77937dd80231c35581b93be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af3886cd7a77937dd80231c35581b93be">extract_odd_lanes</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:af3886cd7a77937dd80231c35581b93be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the odd-numbered lanes in a vector.  <a href="#af3886cd7a77937dd80231c35581b93be">More...</a><br/></td></tr>
<tr class="separator:af3886cd7a77937dd80231c35581b93be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be6e8bc82582bb4ac055507907282c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8be6e8bc82582bb4ac055507907282c2">extract_even_lanes</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a8be6e8bc82582bb4ac055507907282c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the even-numbered lanes in a vector.  <a href="#a8be6e8bc82582bb4ac055507907282c2">More...</a><br/></td></tr>
<tr class="separator:a8be6e8bc82582bb4ac055507907282c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf56d49145d02ee1f675c8c838c8e9ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaf56d49145d02ee1f675c8c838c8e9ea">extract_lane</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">vec</a>, int lane)</td></tr>
<tr class="memdesc:aaf56d49145d02ee1f675c8c838c8e9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the nth lane of a vector.  <a href="#aaf56d49145d02ee1f675c8c838c8e9ea">More...</a><br/></td></tr>
<tr class="separator:aaf56d49145d02ee1f675c8c838c8e9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1233a717a83d74121106b95245ce81a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac1233a717a83d74121106b95245ce81a">rewrite_interleavings</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:ac1233a717a83d74121106b95245ce81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic.  <a href="#ac1233a717a83d74121106b95245ce81a">More...</a><br/></td></tr>
<tr class="separator:ac1233a717a83d74121106b95245ce81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc21bfcfcc2b8feadd3612b4cd21e020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adc21bfcfcc2b8feadd3612b4cd21e020">deinterleave_vector_test</a> ()</td></tr>
<tr class="separator:adc21bfcfcc2b8feadd3612b4cd21e020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534a3b8f52a0441dbb0fb7ab2aed3341"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a534a3b8f52a0441dbb0fb7ab2aed3341">finite_difference</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, const std::string &amp;var)</td></tr>
<tr class="memdesc:a534a3b8f52a0441dbb0fb7ab2aed3341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the analytic derivative of the expression with respect to the variable.  <a href="#a534a3b8f52a0441dbb0fb7ab2aed3341">More...</a><br/></td></tr>
<tr class="separator:a534a3b8f52a0441dbb0fb7ab2aed3341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ad39c95e126e3cdfe7ce5a72fa5f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">MonotonicResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af7ad39c95e126e3cdfe7ce5a72fa5f51">is_monotonic</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;var)</td></tr>
<tr class="separator:af7ad39c95e126e3cdfe7ce5a72fa5f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aedffca433bdfab639e4956779040e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5aedffca433bdfab639e4956779040e6">inject_early_frees</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a5aedffca433bdfab639e4956779040e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation.  <a href="#a5aedffca433bdfab639e4956779040e6">More...</a><br/></td></tr>
<tr class="separator:a5aedffca433bdfab639e4956779040e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc591095a8e56d4d6f6587c66239fdb3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:acc591095a8e56d4d6f6587c66239fdb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acc591095a8e56d4d6f6587c66239fdb3">ref_count&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *n)</td></tr>
<tr class="separator:acc591095a8e56d4d6f6587c66239fdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3867f02d52edd32b4cfe38e5ee55a1"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7e3867f02d52edd32b4cfe38e5ee55a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7e3867f02d52edd32b4cfe38e5ee55a1">destroy&lt; IRNode &gt;</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> *n)</td></tr>
<tr class="separator:a7e3867f02d52edd32b4cfe38e5ee55a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065c314ae66ddc429dd6ca70c7e467cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a065c314ae66ddc429dd6ca70c7e467cd">expr_uses_var</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;v)</td></tr>
<tr class="memdesc:a065c314ae66ddc429dd6ca70c7e467cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an expression references the given variable.  <a href="#a065c314ae66ddc429dd6ca70c7e467cd">More...</a><br/></td></tr>
<tr class="separator:a065c314ae66ddc429dd6ca70c7e467cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87be577ac94d5606198abf285d79aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab87be577ac94d5606198abf285d79aa8">expr_uses_var</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s)</td></tr>
<tr class="memdesc:ab87be577ac94d5606198abf285d79aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an expression references the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument.  <a href="#ab87be577ac94d5606198abf285d79aa8">More...</a><br/></td></tr>
<tr class="separator:ab87be577ac94d5606198abf285d79aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34564f47418b03522be982314215830"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab34564f47418b03522be982314215830"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab34564f47418b03522be982314215830">expr_uses_vars</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ab34564f47418b03522be982314215830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an expression references any of the variables in a scope.  <a href="#ab34564f47418b03522be982314215830">More...</a><br/></td></tr>
<tr class="separator:ab34564f47418b03522be982314215830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6683c44bf832d3e38e495c04485eab2c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6683c44bf832d3e38e495c04485eab2c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6683c44bf832d3e38e495c04485eab2c">expr_uses_vars</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;v, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;s)</td></tr>
<tr class="memdesc:a6683c44bf832d3e38e495c04485eab2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if an expression references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument.  <a href="#a6683c44bf832d3e38e495c04485eab2c">More...</a><br/></td></tr>
<tr class="separator:a6683c44bf832d3e38e495c04485eab2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b42e90ad180f1254cdd3be0ae7be89"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a16b42e90ad180f1254cdd3be0ae7be89">find_direct_calls</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:a16b42e90ad180f1254cdd3be0ae7be89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, including in update definitions, update index expressions, and <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> extents.  <a href="#a16b42e90ad180f1254cdd3be0ae7be89">More...</a><br/></td></tr>
<tr class="separator:a16b42e90ad180f1254cdd3be0ae7be89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770da2a7374eb2a8ac60f5c9d90b88ad"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a770da2a7374eb2a8ac60f5c9d90b88ad">find_transitive_calls</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f)</td></tr>
<tr class="memdesc:a770da2a7374eb2a8ac60f5c9d90b88ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, or indirectly in those functions' definitions, recursively.  <a href="#a770da2a7374eb2a8ac60f5c9d90b88ad">More...</a><br/></td></tr>
<tr class="separator:a770da2a7374eb2a8ac60f5c9d90b88ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c3eca91038227e115e5440d687c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a318c3eca91038227e115e5440d687c43">zero_gpu_loop_mins</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a318c3eca91038227e115e5440d687c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite all GPU loops to have a min of zero.  <a href="#a318c3eca91038227e115e5440d687c43">More...</a><br/></td></tr>
<tr class="separator:a318c3eca91038227e115e5440d687c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0081752824625e87b5e95bfae979499f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0081752824625e87b5e95bfae979499f">fuse_gpu_thread_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a0081752824625e87b5e95bfae979499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s GPGPU IR to the OpenCL/CUDA model.  <a href="#a0081752824625e87b5e95bfae979499f">More...</a><br/></td></tr>
<tr class="separator:a0081752824625e87b5e95bfae979499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e667cda683fba6cce2660ff2ffa48ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::map<br class="typebreak"/>
&lt; std::string, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1e667cda683fba6cce2660ff2ffa48ab">get_halide_type_enum_map</a> ()</td></tr>
<tr class="separator:a1e667cda683fba6cce2660ff2ffa48ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fce0241753e0d1cf50b4615b3d00430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2fce0241753e0d1cf50b4615b3d00430">generate_filter_main</a> (int argc, char **argv, std::ostream &amp;cerr)</td></tr>
<tr class="memdesc:a2fce0241753e0d1cf50b4615b3d00430"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal.html#a2fce0241753e0d1cf50b4615b3d00430" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a> is a convenient wrapper for <a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html#a21aef07a57064b18d7ad2bb80224b31f">GeneratorRegistry::create()</a> + compile_to_files(); it can be trivially wrapped by a "real" main() to produce a command-line utility for ahead-of-time filter compilation.  <a href="#a2fce0241753e0d1cf50b4615b3d00430">More...</a><br/></td></tr>
<tr class="separator:a2fce0241753e0d1cf50b4615b3d00430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa15ced2f13142e6c4b5e5f4649aa15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9fa15ced2f13142e6c4b5e5f4649aa15">inject_host_dev_buffer_copies</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t)</td></tr>
<tr class="memdesc:a9fa15ced2f13142e6c4b5e5f4649aa15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject calls to halide_device_malloc, halide_copy_to_device, and halide_copy_to_host as needed.  <a href="#a9fa15ced2f13142e6c4b5e5f4649aa15">More...</a><br/></td></tr>
<tr class="separator:a9fa15ced2f13142e6c4b5e5f4649aa15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fcc88dde228e4f70a90d4848ddb773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a70fcc88dde228e4f70a90d4848ddb773">inject_dev_frees</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a70fcc88dde228e4f70a90d4848ddb773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject calls to halide_dev_free as needed.  <a href="#a70fcc88dde228e4f70a90d4848ddb773">More...</a><br/></td></tr>
<tr class="separator:a70fcc88dde228e4f70a90d4848ddb773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785a0f3f270d94a0c7b3d96da2eebe85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a785a0f3f270d94a0c7b3d96da2eebe85">inject_image_intrinsics</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a785a0f3f270d94a0c7b3d96da2eebe85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for kernel for loops and turn loads and stores inside the loops into coordinate-based load and store intrinsics.  <a href="#a785a0f3f270d94a0c7b3d96da2eebe85">More...</a><br/></td></tr>
<tr class="separator:a785a0f3f270d94a0c7b3d96da2eebe85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94843d09c24cd65c12aa022e0ae3bb70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94843d09c24cd65c12aa022e0ae3bb70">inject_opengl_intrinsics</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a94843d09c24cd65c12aa022e0ae3bb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for kernel for loops and turn loads and stores inside the loops into OpenGL texture load and store intrinsics.  <a href="#a94843d09c24cd65c12aa022e0ae3bb70">More...</a><br/></td></tr>
<tr class="separator:a94843d09c24cd65c12aa022e0ae3bb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1dc9a55f32a7813f8c76884b83d2e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9a1dc9a55f32a7813f8c76884b83d2e2">ir_equality_test</a> ()</td></tr>
<tr class="separator:a9a1dc9a55f32a7813f8c76884b83d2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22936be5f74cc50d73a4e478bd9271e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af22936be5f74cc50d73a4e478bd9271e">expr_match</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> pattern, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:af22936be5f74cc50d73a4e478bd9271e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument.  <a href="#af22936be5f74cc50d73a4e478bd9271e">More...</a><br/></td></tr>
<tr class="separator:af22936be5f74cc50d73a4e478bd9271e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cc40f5fe9cc4d0ba0bf37b5550ad01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a90cc40f5fe9cc4d0ba0bf37b5550ad01">expr_match</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> pattern, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr, std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:a90cc40f5fe9cc4d0ba0bf37b5550ad01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables are matched consistently.  <a href="#a90cc40f5fe9cc4d0ba0bf37b5550ad01">More...</a><br/></td></tr>
<tr class="separator:a90cc40f5fe9cc4d0ba0bf37b5550ad01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eed932bc0eb3a15edcb20795bfb8c2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1eed932bc0eb3a15edcb20795bfb8c2f">expr_match_test</a> ()</td></tr>
<tr class="separator:a1eed932bc0eb3a15edcb20795bfb8c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab370d99a882a8163ae91d43b94d79d02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab370d99a882a8163ae91d43b94d79d02">is_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:ab370d99a882a8163ae91d43b94d79d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants. ">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node. ">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same.  <a href="#ab370d99a882a8163ae91d43b94d79d02">More...</a><br/></td></tr>
<tr class="separator:ab370d99a882a8163ae91d43b94d79d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b709fdbc5a6944248187216b5df5b2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b709fdbc5a6944248187216b5df5b2e">is_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int v)</td></tr>
<tr class="memdesc:a4b709fdbc5a6944248187216b5df5b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same.  <a href="#a4b709fdbc5a6944248187216b5df5b2e">More...</a><br/></td></tr>
<tr class="separator:a4b709fdbc5a6944248187216b5df5b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b76ccfb1d4e7cc35ff65f15f9b0077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a68b76ccfb1d4e7cc35ff65f15f9b0077">as_const_int</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a68b76ccfb1d4e7cc35ff65f15f9b0077"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, return a pointer to its value.  <a href="#a68b76ccfb1d4e7cc35ff65f15f9b0077">More...</a><br/></td></tr>
<tr class="separator:a68b76ccfb1d4e7cc35ff65f15f9b0077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a9edb743eaf6d8074867314247a970"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af2a9edb743eaf6d8074867314247a970">as_const_float</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:af2a9edb743eaf6d8074867314247a970"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, return a pointer to its value.  <a href="#af2a9edb743eaf6d8074867314247a970">More...</a><br/></td></tr>
<tr class="separator:af2a9edb743eaf6d8074867314247a970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2399da4e027488064c4d14a2469f9fc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2399da4e027488064c4d14a2469f9fc3">is_const_power_of_two</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int *bits)</td></tr>
<tr class="memdesc:a2399da4e027488064c4d14a2469f9fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a constant integer power of two.  <a href="#a2399da4e027488064c4d14a2469f9fc3">More...</a><br/></td></tr>
<tr class="separator:a2399da4e027488064c4d14a2469f9fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad050aaa17987fa4cbb8fd4d41c952e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad050aaa17987fa4cbb8fd4d41c952e04">is_positive_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:ad050aaa17987fa4cbb8fd4d41c952e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression)  <a href="#ad050aaa17987fa4cbb8fd4d41c952e04">More...</a><br/></td></tr>
<tr class="separator:ad050aaa17987fa4cbb8fd4d41c952e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc39652dfc1d64fb82d02dc4064185d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acc39652dfc1d64fb82d02dc4064185d7">is_negative_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:acc39652dfc1d64fb82d02dc4064185d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression)  <a href="#acc39652dfc1d64fb82d02dc4064185d7">More...</a><br/></td></tr>
<tr class="separator:acc39652dfc1d64fb82d02dc4064185d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3da8f6192d557a4bd47cf244b79a9db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af3da8f6192d557a4bd47cf244b79a9db">is_negative_negatable_const</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:af3da8f6192d557a4bd47cf244b79a9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) and is its negative value representable.  <a href="#af3da8f6192d557a4bd47cf244b79a9db">More...</a><br/></td></tr>
<tr class="separator:af3da8f6192d557a4bd47cf244b79a9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a521ef987e7964954b997e6dcc5e65b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1a521ef987e7964954b997e6dcc5e65b">is_zero</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a1a521ef987e7964954b997e6dcc5e65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression)  <a href="#a1a521ef987e7964954b997e6dcc5e65b">More...</a><br/></td></tr>
<tr class="separator:a1a521ef987e7964954b997e6dcc5e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940b37091a8f16bf1e4a78db7764274e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a940b37091a8f16bf1e4a78db7764274e">is_one</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a940b37091a8f16bf1e4a78db7764274e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression)  <a href="#a940b37091a8f16bf1e4a78db7764274e">More...</a><br/></td></tr>
<tr class="separator:a940b37091a8f16bf1e4a78db7764274e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeed2f66190d11ee6e56e4089a1f441b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abeed2f66190d11ee6e56e4089a1f441b">is_two</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:abeed2f66190d11ee6e56e4089a1f441b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression)  <a href="#abeed2f66190d11ee6e56e4089a1f441b">More...</a><br/></td></tr>
<tr class="separator:abeed2f66190d11ee6e56e4089a1f441b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d7b687f4ac09ca9236cb1b8b82bb51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab2d7b687f4ac09ca9236cb1b8b82bb51">is_no_op</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:ab2d7b687f4ac09ca9236cb1b8b82bb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect. ">Evaluate</a> node of a constant)  <a href="#ab2d7b687f4ac09ca9236cb1b8b82bb51">More...</a><br/></td></tr>
<tr class="separator:ab2d7b687f4ac09ca9236cb1b8b82bb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225fbecd4560e77ea24cb16541fe6b15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a225fbecd4560e77ea24cb16541fe6b15">int_cast_constant</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, int val)</td></tr>
<tr class="memdesc:a225fbecd4560e77ea24cb16541fe6b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an integer value, cast it into a designated integer type and return the bits as int.  <a href="#a225fbecd4560e77ea24cb16541fe6b15">More...</a><br/></td></tr>
<tr class="separator:a225fbecd4560e77ea24cb16541fe6b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48739c460778f7af77999cfd251d5af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab48739c460778f7af77999cfd251d5af">make_const</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t, int val)</td></tr>
<tr class="memdesc:ab48739c460778f7af77999cfd251d5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const of the given type.  <a href="#ab48739c460778f7af77999cfd251d5af">More...</a><br/></td></tr>
<tr class="separator:ab48739c460778f7af77999cfd251d5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e258c84149c36aad7d93cced54cd173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1e258c84149c36aad7d93cced54cd173">make_bool</a> (bool val, int width=1)</td></tr>
<tr class="memdesc:a1e258c84149c36aad7d93cced54cd173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean constant from a C++ boolean value.  <a href="#a1e258c84149c36aad7d93cced54cd173">More...</a><br/></td></tr>
<tr class="separator:a1e258c84149c36aad7d93cced54cd173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fedf535d58f8900f8b7c00aa15ece8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a57fedf535d58f8900f8b7c00aa15ece8">make_zero</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:a57fedf535d58f8900f8b7c00aa15ece8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of zero in the given type.  <a href="#a57fedf535d58f8900f8b7c00aa15ece8">More...</a><br/></td></tr>
<tr class="separator:a57fedf535d58f8900f8b7c00aa15ece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ace305dbdd7fed2cf9d5057d4c02067c9">make_one</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of one in the given type.  <a href="#ace305dbdd7fed2cf9d5057d4c02067c9">More...</a><br/></td></tr>
<tr class="separator:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc35f0dc3562ffb5bb777021679435e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afc35f0dc3562ffb5bb777021679435e2">make_two</a> (<a class="el" href="struct_halide_1_1_type.html">Type</a> t)</td></tr>
<tr class="memdesc:afc35f0dc3562ffb5bb777021679435e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of two in the given type.  <a href="#afc35f0dc3562ffb5bb777021679435e2">More...</a><br/></td></tr>
<tr class="separator:afc35f0dc3562ffb5bb777021679435e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8e27a136a9facf0e97e6ac6bd71c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0f8e27a136a9facf0e97e6ac6bd71c23">const_true</a> (int width=1)</td></tr>
<tr class="memdesc:a0f8e27a136a9facf0e97e6ac6bd71c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean true.  <a href="#a0f8e27a136a9facf0e97e6ac6bd71c23">More...</a><br/></td></tr>
<tr class="separator:a0f8e27a136a9facf0e97e6ac6bd71c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5d4e90106e92aa21840547b6588eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6c5d4e90106e92aa21840547b6588eb3">const_false</a> (int width=1)</td></tr>
<tr class="memdesc:a6c5d4e90106e92aa21840547b6588eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean false.  <a href="#a6c5d4e90106e92aa21840547b6588eb3">More...</a><br/></td></tr>
<tr class="separator:a6c5d4e90106e92aa21840547b6588eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40a26aac941b763435e9915851cd073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">match_types</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;b)</td></tr>
<tr class="memdesc:ab40a26aac941b763435e9915851cd073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce the two expressions to have the same type, using C-style casting rules.  <a href="#ab40a26aac941b763435e9915851cd073">More...</a><br/></td></tr>
<tr class="separator:ab40a26aac941b763435e9915851cd073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5890bd4a8aae2f1f6a2c43496d8ddae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac5890bd4a8aae2f1f6a2c43496d8ddae">raise_to_integer_power</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, int b)</td></tr>
<tr class="memdesc:ac5890bd4a8aae2f1f6a2c43496d8ddae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise an expression to an integer power by repeatedly multiplying it by itself.  <a href="#ac5890bd4a8aae2f1f6a2c43496d8ddae">More...</a><br/></td></tr>
<tr class="separator:ac5890bd4a8aae2f1f6a2c43496d8ddae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f84a0040711a023783268f1213caa3e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f84a0040711a023783268f1213caa3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8f84a0040711a023783268f1213caa3e">scalar_to_constant_expr</a> (T value)</td></tr>
<tr class="memdesc:a8f84a0040711a023783268f1213caa3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a scalar constant, return an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that represents it.  <a href="#a8f84a0040711a023783268f1213caa3e">More...</a><br/></td></tr>
<tr class="separator:a8f84a0040711a023783268f1213caa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40117c4a26ac5f612f075a99b5c87207"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a40117c4a26ac5f612f075a99b5c87207"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a40117c4a26ac5f612f075a99b5c87207">scalar_to_constant_expr</a> (float f32)</td></tr>
<tr class="separator:a40117c4a26ac5f612f075a99b5c87207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c1973a3b52e6908d939810844d8405"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab5c1973a3b52e6908d939810844d8405"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab5c1973a3b52e6908d939810844d8405">scalar_to_constant_expr</a> (double f64)</td></tr>
<tr class="separator:ab5c1973a3b52e6908d939810844d8405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14a81e0ff39d55ece7cc41600486337"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac14a81e0ff39d55ece7cc41600486337"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac14a81e0ff39d55ece7cc41600486337">scalar_to_constant_expr</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> i)</td></tr>
<tr class="separator:ac14a81e0ff39d55ece7cc41600486337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7e626d2cf8d0e105f2d7e9b80b5d70"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3b7e626d2cf8d0e105f2d7e9b80b5d70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3b7e626d2cf8d0e105f2d7e9b80b5d70">scalar_to_constant_expr</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> u)</td></tr>
<tr class="separator:a3b7e626d2cf8d0e105f2d7e9b80b5d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69be35df1689b43027589dad39bb47da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69be35df1689b43027589dad39bb47da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a69be35df1689b43027589dad39bb47da">scalar_from_constant_expr</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, T *value)</td></tr>
<tr class="memdesc:a69be35df1689b43027589dad39bb47da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> produced by scalar_to_constant_expr&lt;T&gt;, extract the constant value of type T and return true.  <a href="#a69be35df1689b43027589dad39bb47da">More...</a><br/></td></tr>
<tr class="separator:a69be35df1689b43027589dad39bb47da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cfea8acb4f311a9365e26a8f7de08f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a10cfea8acb4f311a9365e26a8f7de08f">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">ForType</a> &amp;)</td></tr>
<tr class="memdesc:a10cfea8acb4f311a9365e26a8f7de08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a halide for loop type (vectorized, serial, etc) in a human readable form.  <a href="#a10cfea8acb4f311a9365e26a8f7de08f">More...</a><br/></td></tr>
<tr class="separator:a10cfea8acb4f311a9365e26a8f7de08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c00a579c3d86ae40920d5fc4ffe64cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2c00a579c3d86ae40920d5fc4ffe64cf">lower_lerp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> zero_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> one_val, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> weight)</td></tr>
<tr class="memdesc:a2c00a579c3d86ae40920d5fc4ffe64cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> IR that computes a lerp.  <a href="#a2c00a579c3d86ae40920d5fc4ffe64cf">More...</a><br/></td></tr>
<tr class="separator:a2c00a579c3d86ae40920d5fc4ffe64cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de53dea62d6fa723dbb862fab8c5630"><td class="memItemLeft" align="right" valign="top">llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0de53dea62d6fa723dbb862fab8c5630">value_as_metadata_type</a> (llvm::Value *val)</td></tr>
<tr class="separator:a0de53dea62d6fa723dbb862fab8c5630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cf32e5a054a8b3c42884529527b89f"><td class="memItemLeft" align="right" valign="top">llvm::Module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a55cf32e5a054a8b3c42884529527b89f">get_initial_module_for_target</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a>, llvm::LLVMContext *, bool for_shared_jit_runtime=false, bool just_gpu=false)</td></tr>
<tr class="memdesc:a55cf32e5a054a8b3c42884529527b89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for a given target.  <a href="#a55cf32e5a054a8b3c42884529527b89f">More...</a><br/></td></tr>
<tr class="separator:a55cf32e5a054a8b3c42884529527b89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae550b1911283d65000a7abb81fdc3c14"><td class="memItemLeft" align="right" valign="top">llvm::Module *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae550b1911283d65000a7abb81fdc3c14">get_initial_module_for_ptx_device</a> (<a class="el" href="struct_halide_1_1_target.html">Target</a>, llvm::LLVMContext *c)</td></tr>
<tr class="memdesc:ae550b1911283d65000a7abb81fdc3c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an llvm module containing the support code for ptx device.  <a href="#ae550b1911283d65000a7abb81fdc3c14">More...</a><br/></td></tr>
<tr class="separator:ae550b1911283d65000a7abb81fdc3c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a115487cd9954063dd4e55e37394af2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6a115487cd9954063dd4e55e37394af2">lower</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;t, const std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt; &amp;custom_passes=std::vector&lt; <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> * &gt;())</td></tr>
<tr class="memdesc:a6a115487cd9954063dd4e55e37394af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a halide function with a schedule, create a statement that evaluates it.  <a href="#a6a115487cd9954063dd4e55e37394af2">More...</a><br/></td></tr>
<tr class="separator:a6a115487cd9954063dd4e55e37394af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3bfe43201bab68cf4820993fe1469b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d3bfe43201bab68cf4820993fe1469b">lower_test</a> ()</td></tr>
<tr class="separator:a4d3bfe43201bab68cf4820993fe1469b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01c2c3e306a2adba68958572c573d86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab01c2c3e306a2adba68958572c573d86">inject_memoization</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, const std::string &amp;name)</td></tr>
<tr class="memdesc:ab01c2c3e306a2adba68958572c573d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform pipeline calls for Funcs scheduled with memoize to do a lookup call to the runtime cache implementation, and if there is a miss, compute the results and call the runtime to store it back to the cache.  <a href="#ab01c2c3e306a2adba68958572c573d86">More...</a><br/></td></tr>
<tr class="separator:ab01c2c3e306a2adba68958572c573d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7298e57b1434cccc072c45b6f5c6efef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7298e57b1434cccc072c45b6f5c6efef">modulus_remainder</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e)</td></tr>
<tr class="memdesc:a7298e57b1434cccc072c45b6f5c6efef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant.  <a href="#a7298e57b1434cccc072c45b6f5c6efef">More...</a><br/></td></tr>
<tr class="separator:a7298e57b1434cccc072c45b6f5c6efef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8489fb5b4449835f26313a57e856c4b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8489fb5b4449835f26313a57e856c4b3">modulus_remainder</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;scope)</td></tr>
<tr class="memdesc:a8489fb5b4449835f26313a57e856c4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder:  <a href="#a8489fb5b4449835f26313a57e856c4b3">More...</a><br/></td></tr>
<tr class="separator:a8489fb5b4449835f26313a57e856c4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af210d0f6ae102d704259f49bb32adc2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af210d0f6ae102d704259f49bb32adc2f">reduce_expr_modulo</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, int modulus, int *remainder)</td></tr>
<tr class="memdesc:af210d0f6ae102d704259f49bb32adc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce an expression modulo some integer.  <a href="#af210d0f6ae102d704259f49bb32adc2f">More...</a><br/></td></tr>
<tr class="separator:af210d0f6ae102d704259f49bb32adc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789149daec96e933f8758f71f8474dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a789149daec96e933f8758f71f8474dd6">modulus_remainder_test</a> ()</td></tr>
<tr class="separator:a789149daec96e933f8758f71f8474dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50891465f948d4f9b30b9253ce1640b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a50891465f948d4f9b30b9253ce1640b1">gcd</a> (int, int)</td></tr>
<tr class="memdesc:a50891465f948d4f9b30b9253ce1640b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The greatest common divisor of two integers.  <a href="#a50891465f948d4f9b30b9253ce1640b1">More...</a><br/></td></tr>
<tr class="separator:a50891465f948d4f9b30b9253ce1640b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56d2d1c54f988f23aa03ae70cdfd857"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab56d2d1c54f988f23aa03ae70cdfd857">lcm</a> (int, int)</td></tr>
<tr class="memdesc:ab56d2d1c54f988f23aa03ae70cdfd857"><td class="mdescLeft">&#160;</td><td class="mdescRight">The least common multiple of two integers.  <a href="#ab56d2d1c54f988f23aa03ae70cdfd857">More...</a><br/></td></tr>
<tr class="separator:ab56d2d1c54f988f23aa03ae70cdfd857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36620e2156363b215b17fae00eec44ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a36620e2156363b215b17fae00eec44ea">is_one_to_one</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr class="memdesc:a36620e2156363b215b17fae00eec44ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conservatively determine whether an integer expression is one-to-one in its variables.  <a href="#a36620e2156363b215b17fae00eec44ea">More...</a><br/></td></tr>
<tr class="separator:a36620e2156363b215b17fae00eec44ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3b8d6aeed9a003fe228ad1aba7322f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acd3b8d6aeed9a003fe228ad1aba7322f">is_one_to_one_test</a> ()</td></tr>
<tr class="separator:acd3b8d6aeed9a003fe228ad1aba7322f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913e6ea61edf88f4ccdb3672b488e6d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a913e6ea61edf88f4ccdb3672b488e6d4">can_parallelize_rvar</a> (const std::string &amp;rvar, const std::string &amp;func, const <a class="el" href="struct_halide_1_1_internal_1_1_update_definition.html">UpdateDefinition</a> &amp;r)</td></tr>
<tr class="memdesc:a913e6ea61edf88f4ccdb3672b488e6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> can prove that it is safe to parallelize an update definition across a specific variable.  <a href="#a913e6ea61edf88f4ccdb3672b488e6d4">More...</a><br/></td></tr>
<tr class="separator:a913e6ea61edf88f4ccdb3672b488e6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce66817377fbb1918bbe7510ab47b29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0ce66817377fbb1918bbe7510ab47b29">check_call_arg_types</a> (const std::string &amp;name, std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; *args, int dims)</td></tr>
<tr class="memdesc:a0ce66817377fbb1918bbe7510ab47b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate arguments to a call to a func, image or imageparam.  <a href="#a0ce66817377fbb1918bbe7510ab47b29">More...</a><br/></td></tr>
<tr class="separator:a0ce66817377fbb1918bbe7510ab47b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe34fa32a730191953a42d96759d23f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acfe34fa32a730191953a42d96759d23f">partition_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:acfe34fa32a730191953a42d96759d23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions loop bodies into a prologue, a steady state, and an epilogue.  <a href="#acfe34fa32a730191953a42d96759d23f">More...</a><br/></td></tr>
<tr class="separator:acfe34fa32a730191953a42d96759d23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568a0554db6866ee8560c3f599bceadd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a568a0554db6866ee8560c3f599bceadd">inject_profiling</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, std::string)</td></tr>
<tr class="memdesc:a568a0554db6866ee8560c3f599bceadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline, and (depending on the environment variable HL_PROFILE), insert high-resolution timing into the generated code; summaries of execution times and counts will be logged at the end.  <a href="#a568a0554db6866ee8560c3f599bceadd">More...</a><br/></td></tr>
<tr class="separator:a568a0554db6866ee8560c3f599bceadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae828a911751c5115cb503d05afb1dcbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae828a911751c5115cb503d05afb1dcbe">profiling_level</a> ()</td></tr>
<tr class="memdesc:ae828a911751c5115cb503d05afb1dcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current profiling level (by reading HL_PROFILE)  <a href="#ae828a911751c5115cb503d05afb1dcbe">More...</a><br/></td></tr>
<tr class="separator:ae828a911751c5115cb503d05afb1dcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0c1d3ac79fd83cb609d37831253957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#add0c1d3ac79fd83cb609d37831253957">qualify</a> (const std::string &amp;prefix, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value)</td></tr>
<tr class="memdesc:add0c1d3ac79fd83cb609d37831253957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix all variable names in the given expression with the prefix string.  <a href="#add0c1d3ac79fd83cb609d37831253957">More...</a><br/></td></tr>
<tr class="separator:add0c1d3ac79fd83cb609d37831253957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795f343747d7f716a33198907c3e7d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a795f343747d7f716a33198907c3e7d25">random_float</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:a795f343747d7f716a33198907c3e7d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random floating-point number between zero and one that varies deterministically based on the input expressions.  <a href="#a795f343747d7f716a33198907c3e7d25">More...</a><br/></td></tr>
<tr class="separator:a795f343747d7f716a33198907c3e7d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e64539c6d89123f6200b919ec28fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae4e64539c6d89123f6200b919ec28fbb">random_int</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;)</td></tr>
<tr class="memdesc:ae4e64539c6d89123f6200b919ec28fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random unsigned integer between zero and 2^32-1 that varies deterministically based on the input expressions (which must be integers).  <a href="#ae4e64539c6d89123f6200b919ec28fbb">More...</a><br/></td></tr>
<tr class="separator:ae4e64539c6d89123f6200b919ec28fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f875bf4d528885d68581fbd198bf356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0f875bf4d528885d68581fbd198bf356">lower_random</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::vector&lt; std::string &gt; &amp;free_vars, int tag)</td></tr>
<tr class="memdesc:a0f875bf4d528885d68581fbd198bf356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert calls to random() to IR generated by random_float and random_int.  <a href="#a0f875bf4d528885d68581fbd198bf356">More...</a><br/></td></tr>
<tr class="separator:a0f875bf4d528885d68581fbd198bf356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8459c153113e252e4cf11fd16326b065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8459c153113e252e4cf11fd16326b065">remove_dead_allocations</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a8459c153113e252e4cf11fd16326b065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Allocate/Free pairs that are never loaded from or stored to, and remove them from the <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>.  <a href="#a8459c153113e252e4cf11fd16326b065">More...</a><br/></td></tr>
<tr class="separator:a8459c153113e252e4cf11fd16326b065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445fa778b28abf135eb1b1d0c8389efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a445fa778b28abf135eb1b1d0c8389efc">remove_trivial_for_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a445fa778b28abf135eb1b1d0c8389efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert for loops of size 1 into <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node. ">LetStmt</a> nodes, which allows for further simplification.  <a href="#a445fa778b28abf135eb1b1d0c8389efc">More...</a><br/></td></tr>
<tr class="separator:a445fa778b28abf135eb1b1d0c8389efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078fe646230de310959c4506c76de02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a078fe646230de310959c4506c76de02e">remove_undef</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a078fe646230de310959c4506c76de02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes stores that depend on undef values, and statements that only contain such stores.  <a href="#a078fe646230de310959c4506c76de02e">More...</a><br/></td></tr>
<tr class="separator:a078fe646230de310959c4506c76de02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4242a0b28a7409d2a2489a74795914ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4242a0b28a7409d2a2489a74795914ef"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4242a0b28a7409d2a2489a74795914ef">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="separator:a4242a0b28a7409d2a2489a74795914ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d8c444c776976f822644dc995d10ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a27d8c444c776976f822644dc995d10ca">simplify_exprs</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:a27d8c444c776976f822644dc995d10ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify expressions found in a statement, but don't simplify across different statements.  <a href="#a27d8c444c776976f822644dc995d10ca">More...</a><br/></td></tr>
<tr class="separator:a27d8c444c776976f822644dc995d10ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff5495089b812474881ee939c4701c4"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:adff5495089b812474881ee939c4701c4"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adff5495089b812474881ee939c4701c4">mod_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr class="separator:adff5495089b812474881ee939c4701c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a60708c880da445554b8eeb778c034"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac9a60708c880da445554b8eeb778c034"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac9a60708c880da445554b8eeb778c034">mod_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr class="separator:ac9a60708c880da445554b8eeb778c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13a82f37fe6336c154122f66d294523"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa13a82f37fe6336c154122f66d294523"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa13a82f37fe6336c154122f66d294523">div_imp&lt; float &gt;</a> (float a, float b)</td></tr>
<tr class="separator:aa13a82f37fe6336c154122f66d294523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965c871f086a60fda2cc31e678d050a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3965c871f086a60fda2cc31e678d050a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3965c871f086a60fda2cc31e678d050a">div_imp&lt; double &gt;</a> (double a, double b)</td></tr>
<tr class="separator:a3965c871f086a60fda2cc31e678d050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c952efe23378dcba6fcbd92055c213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a91c952efe23378dcba6fcbd92055c213">simplify_test</a> ()</td></tr>
<tr class="separator:a91c952efe23378dcba6fcbd92055c213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8489422fe4da6e486b5fd7831aab8bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8489422fe4da6e486b5fd7831aab8bfb">skip_stages</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::vector&lt; std::string &gt; &amp;order)</td></tr>
<tr class="memdesc:a8489422fe4da6e486b5fd7831aab8bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Avoid computing certain stages if we can infer a runtime condition to check that tells us they won't be used.  <a href="#a8489422fe4da6e486b5fd7831aab8bfb">More...</a><br/></td></tr>
<tr class="separator:a8489422fe4da6e486b5fd7831aab8bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bde9012b280aad21a569ea008ed296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a07bde9012b280aad21a569ea008ed296">sliding_window</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a07bde9012b280aad21a569ea008ed296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform sliding window optimizations on a halide statement.  <a href="#a07bde9012b280aad21a569ea008ed296">More...</a><br/></td></tr>
<tr class="separator:a07bde9012b280aad21a569ea008ed296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862cc0c54124576f8b14550c1154f971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a862cc0c54124576f8b14550c1154f971">solve_expression</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const std::string &amp;variable, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a862cc0c54124576f8b14550c1154f971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to collect all instances of a variable in an expression tree and place it as far to the left as possible, and as far up the tree as possible (i.e.  <a href="#a862cc0c54124576f8b14550c1154f971">More...</a><br/></td></tr>
<tr class="separator:a862cc0c54124576f8b14550c1154f971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff96a46ef180209a14610a2a5a1d74ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aff96a46ef180209a14610a2a5a1d74ba">solve_test</a> ()</td></tr>
<tr class="separator:aff96a46ef180209a14610a2a5a1d74ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18248db0e632551cd5b3376e6ade4365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a18248db0e632551cd5b3376e6ade4365">print_to_html</a> (std::string filename, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a18248db0e632551cd5b3376e6ade4365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump an HTML-formatted print of a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> to filename.  <a href="#a18248db0e632551cd5b3376e6ade4365">More...</a><br/></td></tr>
<tr class="separator:a18248db0e632551cd5b3376e6ade4365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8228323a26e73895bb0e3d3e1e78496"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae8228323a26e73895bb0e3d3e1e78496">print_to_html</a> (std::string filename, const <a class="el" href="class_halide_1_1_module.html">Module</a> &amp;m)</td></tr>
<tr class="memdesc:ae8228323a26e73895bb0e3d3e1e78496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump an HTML-formatted print of a <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to filename.  <a href="#ae8228323a26e73895bb0e3d3e1e78496">More...</a><br/></td></tr>
<tr class="separator:ae8228323a26e73895bb0e3d3e1e78496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac482fc1e5a48a0e5c3320e80d597657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aac482fc1e5a48a0e5c3320e80d597657">storage_flattening</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const std::string &amp;output, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:aac482fc1e5a48a0e5c3320e80d597657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location. ">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;. ">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer. ">Load</a> nodes respectively.  <a href="#aac482fc1e5a48a0e5c3320e80d597657">More...</a><br/></td></tr>
<tr class="separator:aac482fc1e5a48a0e5c3320e80d597657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eefd272612c586d9c3e4dba31d1c215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9eefd272612c586d9c3e4dba31d1c215">storage_folding</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a9eefd272612c586d9c3e4dba31d1c215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold storage of functions if possible.  <a href="#a9eefd272612c586d9c3e4dba31d1c215">More...</a><br/></td></tr>
<tr class="separator:a9eefd272612c586d9c3e4dba31d1c215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48710fd66a0823291cabe7451d91f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac48710fd66a0823291cabe7451d91f80">substitute</a> (std::string name, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr class="memdesc:ac48710fd66a0823291cabe7451d91f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within expr.  <a href="#ac48710fd66a0823291cabe7451d91f80">More...</a><br/></td></tr>
<tr class="separator:ac48710fd66a0823291cabe7451d91f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62310d71063459051000c4032c78d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad62310d71063459051000c4032c78d6b">substitute</a> (std::string name, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:ad62310d71063459051000c4032c78d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with the given name with the replacement expression within stmt.  <a href="#ad62310d71063459051000c4032c78d6b">More...</a><br/></td></tr>
<tr class="separator:ad62310d71063459051000c4032c78d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd3f1d683bcca49a2df7179d42245d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3cd3f1d683bcca49a2df7179d42245d0">inject_tracing</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, const std::map&lt; std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> &gt; &amp;env, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> output)</td></tr>
<tr class="memdesc:a3cd3f1d683bcca49a2df7179d42245d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations.  <a href="#a3cd3f1d683bcca49a2df7179d42245d0">More...</a><br/></td></tr>
<tr class="separator:a3cd3f1d683bcca49a2df7179d42245d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6c445013b15af0a32bd54f5bb6bdc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0b6c445013b15af0a32bd54f5bb6bdc3">unify_duplicate_lets</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a0b6c445013b15af0a32bd54f5bb6bdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find let statements that all define the same value, and make later ones just reuse the symbol names of the earlier ones.  <a href="#a0b6c445013b15af0a32bd54f5bb6bdc3">More...</a><br/></td></tr>
<tr class="separator:a0b6c445013b15af0a32bd54f5bb6bdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf197e316b7d0a6adb96c25976612c1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abf197e316b7d0a6adb96c25976612c1b">uniquify_variable_names</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:abf197e316b7d0a6adb96c25976612c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a statement so that every internally-defined variable name is unique.  <a href="#abf197e316b7d0a6adb96c25976612c1b">More...</a><br/></td></tr>
<tr class="separator:abf197e316b7d0a6adb96c25976612c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1c49e552297672b3751ac988bf70c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adc1c49e552297672b3751ac988bf70c3">unroll_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:adc1c49e552297672b3751ac988bf70c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement.  <a href="#adc1c49e552297672b3751ac988bf70c3">More...</a><br/></td></tr>
<tr class="separator:adc1c49e552297672b3751ac988bf70c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aeffeff26578021bc780e1506bfa448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0aeffeff26578021bc780e1506bfa448">int_to_string</a> (int x)</td></tr>
<tr class="memdesc:a0aeffeff26578021bc780e1506bfa448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer to a string.  <a href="#a0aeffeff26578021bc780e1506bfa448">More...</a><br/></td></tr>
<tr class="separator:a0aeffeff26578021bc780e1506bfa448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplParams" colspan="2">template&lt;typename DstType , typename SrcType &gt; </td></tr>
<tr class="memitem:a94816d6979fdadb6e206a5d0a668e008"><td class="memTemplItemLeft" align="right" valign="top">DstType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a94816d6979fdadb6e206a5d0a668e008">reinterpret_bits</a> (const SrcType &amp;src)</td></tr>
<tr class="memdesc:a94816d6979fdadb6e206a5d0a668e008"><td class="mdescLeft">&#160;</td><td class="mdescRight">An aggressive form of reinterpret cast used for correct type-punning.  <a href="#a94816d6979fdadb6e206a5d0a668e008">More...</a><br/></td></tr>
<tr class="separator:a94816d6979fdadb6e206a5d0a668e008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb97978547d98141752de6b614195f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2eb97978547d98141752de6b614195f4">make_entity_name</a> (void *stack_ptr, const std::string &amp;type, char prefix)</td></tr>
<tr class="memdesc:a2eb97978547d98141752de6b614195f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a unique name for an object based on the name of the stack variable passed in.  <a href="#a2eb97978547d98141752de6b614195f4">More...</a><br/></td></tr>
<tr class="separator:a2eb97978547d98141752de6b614195f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd575ab182df12cc793dba4aa241c1a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acd575ab182df12cc793dba4aa241c1a9">unique_name</a> (char prefix)</td></tr>
<tr class="memdesc:acd575ab182df12cc793dba4aa241c1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given character.  <a href="#acd575ab182df12cc793dba4aa241c1a9">More...</a><br/></td></tr>
<tr class="separator:acd575ab182df12cc793dba4aa241c1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd40e47c06b4ccb5d2173528ae0523f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aafd40e47c06b4ccb5d2173528ae0523f">unique_name</a> (const std::string &amp;name, bool user=true)</td></tr>
<tr class="memdesc:aafd40e47c06b4ccb5d2173528ae0523f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a unique name starting with the given string.  <a href="#aafd40e47c06b4ccb5d2173528ae0523f">More...</a><br/></td></tr>
<tr class="separator:aafd40e47c06b4ccb5d2173528ae0523f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7703083cfe592de68f37796533724ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa7703083cfe592de68f37796533724ed">starts_with</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:aa7703083cfe592de68f37796533724ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the first string starts with the second string.  <a href="#aa7703083cfe592de68f37796533724ed">More...</a><br/></td></tr>
<tr class="separator:aa7703083cfe592de68f37796533724ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230079281175545b9b90b2285106ab28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a230079281175545b9b90b2285106ab28">ends_with</a> (const std::string &amp;str, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a230079281175545b9b90b2285106ab28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the first string ends with the second string.  <a href="#a230079281175545b9b90b2285106ab28">More...</a><br/></td></tr>
<tr class="separator:a230079281175545b9b90b2285106ab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323b05ce69829cea65348efc21923625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a323b05ce69829cea65348efc21923625">replace_all</a> (std::string &amp;str, const std::string &amp;find, const std::string &amp;replace)</td></tr>
<tr class="memdesc:a323b05ce69829cea65348efc21923625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all matches of the second string in the first string with the last string.  <a href="#a323b05ce69829cea65348efc21923625">More...</a><br/></td></tr>
<tr class="separator:a323b05ce69829cea65348efc21923625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91d88c24b89bb17c7b69c671c723516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac91d88c24b89bb17c7b69c671c723516">base_name</a> (const std::string &amp;name, char delim= '.')</td></tr>
<tr class="memdesc:ac91d88c24b89bb17c7b69c671c723516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the final token of the name string using the given delimiter.  <a href="#ac91d88c24b89bb17c7b69c671c723516">More...</a><br/></td></tr>
<tr class="separator:ac91d88c24b89bb17c7b69c671c723516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc761896b3e6a38bddce45b6c0f8b15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aedc761896b3e6a38bddce45b6c0f8b15">split_string</a> (const std::string &amp;source, const std::string &amp;delim)</td></tr>
<tr class="memdesc:aedc761896b3e6a38bddce45b6c0f8b15"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> the source string using 'delim' as the divider.  <a href="#aedc761896b3e6a38bddce45b6c0f8b15">More...</a><br/></td></tr>
<tr class="separator:aedc761896b3e6a38bddce45b6c0f8b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacabf4d4e1d92f8059e6c3ce90b06368"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aacabf4d4e1d92f8059e6c3ce90b06368"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aacabf4d4e1d92f8059e6c3ce90b06368">collect_args</a> (std::vector&lt; T &gt; &amp;collected_args)</td></tr>
<tr class="separator:aacabf4d4e1d92f8059e6c3ce90b06368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a5d4585e8974633558071b65ccead7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a11a5d4585e8974633558071b65ccead7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a11a5d4585e8974633558071b65ccead7">collect_args</a> (std::vector&lt; T &gt; &amp;collected_args, T2 arg)</td></tr>
<tr class="separator:a11a5d4585e8974633558071b65ccead7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4859b8bc2993517cfdc270931b4d8d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 , typename... Args&gt; </td></tr>
<tr class="memitem:afb4859b8bc2993517cfdc270931b4d8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afb4859b8bc2993517cfdc270931b4d8d">collect_args</a> (std::vector&lt; T &gt; &amp;collected_args, T2 arg, Args...args)</td></tr>
<tr class="separator:afb4859b8bc2993517cfdc270931b4d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3edc6396d4157000cf0b27bec127c20"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 &gt; </td></tr>
<tr class="memitem:aa3edc6396d4157000cf0b27bec127c20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa3edc6396d4157000cf0b27bec127c20">collect_paired_args</a> (std::vector&lt; std::pair&lt; T1, T2 &gt;&gt; &amp;collected_args, T3 a1, T4 a2)</td></tr>
<tr class="separator:aa3edc6396d4157000cf0b27bec127c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b69555853e1ada3402c97304481c821"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename... Args&gt; </td></tr>
<tr class="memitem:a4b69555853e1ada3402c97304481c821"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b69555853e1ada3402c97304481c821">collect_paired_args</a> (std::vector&lt; std::pair&lt; T1, T2 &gt;&gt; &amp;collected_args, T3 a1, T4 a2, Args...args)</td></tr>
<tr class="separator:a4b69555853e1ada3402c97304481c821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfef059a37f995f9434f836bdbc1edd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#adcfef059a37f995f9434f836bdbc1edd">find_linear_expressions</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:adcfef059a37f995f9434f836bdbc1edd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide_1_1_internal.html#adcfef059a37f995f9434f836bdbc1edd" title="find_linear_expressions(Stmt s) identifies expressions that may be moved out of the generated fragmen...">find_linear_expressions(Stmt s)</a> identifies expressions that may be moved out of the generated fragment shader into a varying attribute.  <a href="#adcfef059a37f995f9434f836bdbc1edd">More...</a><br/></td></tr>
<tr class="separator:adcfef059a37f995f9434f836bdbc1edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523c0d5dea7bfbd664e8506ebb7016de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a523c0d5dea7bfbd664e8506ebb7016de">setup_gpu_vertex_buffer</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s)</td></tr>
<tr class="memdesc:a523c0d5dea7bfbd664e8506ebb7016de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a set of 2D mesh coordinates based on the behavior of varying attribute expressions contained within a GLSL scheduled for loop.  <a href="#a523c0d5dea7bfbd664e8506ebb7016de">More...</a><br/></td></tr>
<tr class="separator:a523c0d5dea7bfbd664e8506ebb7016de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe70c3a9d0ecd59908b1837a11d01de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abe70c3a9d0ecd59908b1837a11d01de0">vectorize_loops</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>)</td></tr>
<tr class="memdesc:abe70c3a9d0ecd59908b1837a11d01de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors.  <a href="#abe70c3a9d0ecd59908b1837a11d01de0">More...</a><br/></td></tr>
<tr class="separator:abe70c3a9d0ecd59908b1837a11d01de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab68083f9769cbbf033176ba50f3709c9"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab68083f9769cbbf033176ba50f3709c9">boxes_required</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:ab68083f9769cbbf033176ba50f3709c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s to each function that occurs within a given statement or expression.  <a href="#ab68083f9769cbbf033176ba50f3709c9">More...</a><br/></td></tr>
<tr class="separator:ab68083f9769cbbf033176ba50f3709c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f12c0072dbbf9639829af1aedda4ea"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af1f12c0072dbbf9639829af1aedda4ea">boxes_required</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:af1f12c0072dbbf9639829af1aedda4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s to each function that occurs within a given statement or expression.  <a href="#af1f12c0072dbbf9639829af1aedda4ea">More...</a><br/></td></tr>
<tr class="separator:af1f12c0072dbbf9639829af1aedda4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aeaf945673dc90b8bdd2e79900b147954"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aeaf945673dc90b8bdd2e79900b147954">boxes_provided</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:aeaf945673dc90b8bdd2e79900b147954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression.  <a href="#aeaf945673dc90b8bdd2e79900b147954">More...</a><br/></td></tr>
<tr class="separator:aeaf945673dc90b8bdd2e79900b147954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c4633706bdb6855b69fb9146ee65ff"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae6c4633706bdb6855b69fb9146ee65ff">boxes_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:ae6c4633706bdb6855b69fb9146ee65ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression.  <a href="#ae6c4633706bdb6855b69fb9146ee65ff">More...</a><br/></td></tr>
<tr class="separator:ae6c4633706bdb6855b69fb9146ee65ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae5c5855f4212c1cb3880a8534b6f41b6"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae5c5855f4212c1cb3880a8534b6f41b6">boxes_touched</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:ae5c5855f4212c1cb3880a8534b6f41b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression.  <a href="#ae5c5855f4212c1cb3880a8534b6f41b6">More...</a><br/></td></tr>
<tr class="separator:ae5c5855f4212c1cb3880a8534b6f41b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbd14233932a8f658ac66d45e00d7fb"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0fbd14233932a8f658ac66d45e00d7fb">boxes_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a0fbd14233932a8f658ac66d45e00d7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression.  <a href="#a0fbd14233932a8f658ac66d45e00d7fb">More...</a><br/></td></tr>
<tr class="separator:a0fbd14233932a8f658ac66d45e00d7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a69980b5d1669ec54e78b7d393d8a7201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a69980b5d1669ec54e78b7d393d8a7201">box_required</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a69980b5d1669ec54e78b7d393d8a7201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a69980b5d1669ec54e78b7d393d8a7201">More...</a><br/></td></tr>
<tr class="separator:a69980b5d1669ec54e78b7d393d8a7201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6ad02cea8b0bacbb0b3c1f644af501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aea6ad02cea8b0bacbb0b3c1f644af501">box_required</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:aea6ad02cea8b0bacbb0b3c1f644af501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#aea6ad02cea8b0bacbb0b3c1f644af501">More...</a><br/></td></tr>
<tr class="separator:aea6ad02cea8b0bacbb0b3c1f644af501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0586fc0706c9a4d39f0ae5f9c7073c86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0586fc0706c9a4d39f0ae5f9c7073c86">box_provided</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a0586fc0706c9a4d39f0ae5f9c7073c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a0586fc0706c9a4d39f0ae5f9c7073c86">More...</a><br/></td></tr>
<tr class="separator:a0586fc0706c9a4d39f0ae5f9c7073c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4d7463fc7d96132bbe01768f967dd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9d4d7463fc7d96132bbe01768f967dd6">box_provided</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a9d4d7463fc7d96132bbe01768f967dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a9d4d7463fc7d96132bbe01768f967dd6">More...</a><br/></td></tr>
<tr class="separator:a9d4d7463fc7d96132bbe01768f967dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa211ee508998ef25191d04fa45eb16c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa211ee508998ef25191d04fa45eb16c7">box_touched</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> e, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:aa211ee508998ef25191d04fa45eb16c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#aa211ee508998ef25191d04fa45eb16c7">More...</a><br/></td></tr>
<tr class="separator:aa211ee508998ef25191d04fa45eb16c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a819815a3d7f37a441a22c06689689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a35a819815a3d7f37a441a22c06689689">box_touched</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, std::string fn, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;scope=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> &amp;func_bounds=<a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a>())</td></tr>
<tr class="memdesc:a35a819815a3d7f37a441a22c06689689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of the above that are only concerned with a single function.  <a href="#a35a819815a3d7f37a441a22c06689689">More...</a><br/></td></tr>
<tr class="separator:a35a819815a3d7f37a441a22c06689689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a67ce3fefc01a50b8f513aac7c5749e31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a67ce3fefc01a50b8f513aac7c5749e31">human_readable_stmt</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, <a class="el" href="class_halide_1_1_buffer.html">Buffer</a> <a class="el" href="runtime__internal_8h.html#a820af5182fa2b758297c9db1af6b2256">buf</a>)</td></tr>
<tr class="memdesc:a67ce3fefc01a50b8f513aac7c5749e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> simplified using a concrete size of the output, and other optional values for parameters.  <a href="#a67ce3fefc01a50b8f513aac7c5749e31">More...</a><br/></td></tr>
<tr class="separator:a67ce3fefc01a50b8f513aac7c5749e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568395264b5729435f7f8a68313c4620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a568395264b5729435f7f8a68313c4620">human_readable_stmt</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a> f, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> s, <a class="el" href="class_halide_1_1_buffer.html">Buffer</a> <a class="el" href="runtime__internal_8h.html#a820af5182fa2b758297c9db1af6b2256">buf</a>, std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; additional_replacements)</td></tr>
<tr class="memdesc:a568395264b5729435f7f8a68313c4620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> simplified using a concrete size of the output, and other optional values for parameters.  <a href="#a568395264b5729435f7f8a68313c4620">More...</a><br/></td></tr>
<tr class="separator:a568395264b5729435f7f8a68313c4620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a38c4753b75f784e928d24b5f085ed383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a38c4753b75f784e928d24b5f085ed383">inline_function</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>)</td></tr>
<tr class="memdesc:a38c4753b75f784e928d24b5f085ed383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a single named function, which must be pure.  <a href="#a38c4753b75f784e928d24b5f085ed383">More...</a><br/></td></tr>
<tr class="separator:a38c4753b75f784e928d24b5f085ed383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839846970613235cae5c8904a5fda794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a839846970613235cae5c8904a5fda794">inline_function</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>)</td></tr>
<tr class="memdesc:a839846970613235cae5c8904a5fda794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline a single named function, which must be pure.  <a href="#a839846970613235cae5c8904a5fda794">More...</a><br/></td></tr>
<tr class="separator:a839846970613235cae5c8904a5fda794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9ff5beef3c5a4ec908d9c2bbe99a71f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ff5beef3c5a4ec908d9c2bbe99a71f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9ff5beef3c5a4ec908d9c2bbe99a71f9">ref_count</a> (const T *)</td></tr>
<tr class="memdesc:a9ff5beef3c5a4ec908d9c2bbe99a71f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here.  <a href="#a9ff5beef3c5a4ec908d9c2bbe99a71f9">More...</a><br/></td></tr>
<tr class="separator:a9ff5beef3c5a4ec908d9c2bbe99a71f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada37ff426984f7459fe0bbe38b9e11f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada37ff426984f7459fe0bbe38b9e11f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ada37ff426984f7459fe0bbe38b9e11f0">destroy</a> (const T *)</td></tr>
<tr class="memdesc:ada37ff426984f7459fe0bbe38b9e11f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here.  <a href="#ada37ff426984f7459fe0bbe38b9e11f0">More...</a><br/></td></tr>
<tr class="separator:ada37ff426984f7459fe0bbe38b9e11f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a31dc49947eec58e14aab236c7b0182ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a31dc49947eec58e14aab236c7b0182ee">equal</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> b)</td></tr>
<tr class="memdesc:a31dc49947eec58e14aab236c7b0182ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a31dc49947eec58e14aab236c7b0182ee">More...</a><br/></td></tr>
<tr class="separator:a31dc49947eec58e14aab236c7b0182ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d404e95dced22ae673144c0351f186f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4d404e95dced22ae673144c0351f186f">equal</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> a, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> b)</td></tr>
<tr class="memdesc:a4d404e95dced22ae673144c0351f186f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare IR nodes for equality of value.  <a href="#a4d404e95dced22ae673144c0351f186f">More...</a><br/></td></tr>
<tr class="separator:a4d404e95dced22ae673144c0351f186f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af36627bf7242718b1c73214296dc9090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af36627bf7242718b1c73214296dc9090">halide_log</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:af36627bf7242718b1c73214296dc9090"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s vectorizable transcendentals.  <a href="#af36627bf7242718b1c73214296dc9090">More...</a><br/></td></tr>
<tr class="separator:af36627bf7242718b1c73214296dc9090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5688772a963296ea52d2bd9ac5913e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5688772a963296ea52d2bd9ac5913e79">halide_exp</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a5688772a963296ea52d2bd9ac5913e79"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s vectorizable transcendentals.  <a href="#a5688772a963296ea52d2bd9ac5913e79">More...</a><br/></td></tr>
<tr class="separator:a5688772a963296ea52d2bd9ac5913e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d36eef829f9c1e2d6aaf9218b2e0e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d36eef829f9c1e2d6aaf9218b2e0e66">halide_erf</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> a)</td></tr>
<tr class="memdesc:a3d36eef829f9c1e2d6aaf9218b2e0e66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s vectorizable transcendentals.  <a href="#a3d36eef829f9c1e2d6aaf9218b2e0e66">More...</a><br/></td></tr>
<tr class="separator:a3d36eef829f9c1e2d6aaf9218b2e0e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4b077780a2dcb6ed633f6f5d111046c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b077780a2dcb6ed633f6f5d111046c2">simplify</a> (<a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>, bool simplify_lets=true, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;bounds=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;alignment=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a4b077780a2dcb6ed633f6f5d111046c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc.  <a href="#a4b077780a2dcb6ed633f6f5d111046c2">More...</a><br/></td></tr>
<tr class="separator:a4b077780a2dcb6ed633f6f5d111046c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2006cf9a5d8bad4e7861a3a10168b1d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a2006cf9a5d8bad4e7861a3a10168b1d6">simplify</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a>, bool simplify_lets=true, const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt; &amp;bounds=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> &gt;::empty_scope(), const <a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt; &amp;alignment=<a class="el" href="class_halide_1_1_internal_1_1_scope.html">Scope</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> &gt;::empty_scope())</td></tr>
<tr class="memdesc:a2006cf9a5d8bad4e7861a3a10168b1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc.  <a href="#a2006cf9a5d8bad4e7861a3a10168b1d6">More...</a><br/></td></tr>
<tr class="separator:a2006cf9a5d8bad4e7861a3a10168b1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6cd3908859c82249a2c7f10158883a97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6cd3908859c82249a2c7f10158883a97"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">mod_imp</a> (T a, T b)</td></tr>
<tr class="memdesc:a6cd3908859c82249a2c7f10158883a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>.  <a href="#a6cd3908859c82249a2c7f10158883a97">More...</a><br/></td></tr>
<tr class="separator:a6cd3908859c82249a2c7f10158883a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0442f9a0450f45683938a69ce0273974"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0442f9a0450f45683938a69ce0273974"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">div_imp</a> (T a, T b)</td></tr>
<tr class="memdesc:a0442f9a0450f45683938a69ce0273974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>.  <a href="#a0442f9a0450f45683938a69ce0273974">More...</a><br/></td></tr>
<tr class="separator:a0442f9a0450f45683938a69ce0273974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6daa7c8282e00d77d69713bd0ca4c73d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6daa7c8282e00d77d69713bd0ca4c73d">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr class="memdesc:a6daa7c8282e00d77d69713bd0ca4c73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with names in the map.  <a href="#a6daa7c8282e00d77d69713bd0ca4c73d">More...</a><br/></td></tr>
<tr class="separator:a6daa7c8282e00d77d69713bd0ca4c73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f67c2e11eb92dcfb534e01a4e431e29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6f67c2e11eb92dcfb534e01a4e431e29">substitute</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;replacements, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a6f67c2e11eb92dcfb534e01a4e431e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute variables with names in the map.  <a href="#a6f67c2e11eb92dcfb534e01a4e431e29">More...</a><br/></td></tr>
<tr class="separator:a6f67c2e11eb92dcfb534e01a4e431e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9624281bd69638e2901f037e7d481dc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9624281bd69638e2901f037e7d481dc8">substitute</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> find, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> expr)</td></tr>
<tr class="memdesc:a9624281bd69638e2901f037e7d481dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute expressions for other expressions.  <a href="#a9624281bd69638e2901f037e7d481dc8">More...</a><br/></td></tr>
<tr class="separator:a9624281bd69638e2901f037e7d481dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3066061a33cacb7f0c7ab0fc63eefe84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3066061a33cacb7f0c7ab0fc63eefe84">substitute</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> find, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> replacement, <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a3066061a33cacb7f0c7ab0fc63eefe84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute expressions for other expressions.  <a href="#a3066061a33cacb7f0c7ab0fc63eefe84">More...</a><br/></td></tr>
<tr class="separator:a3066061a33cacb7f0c7ab0fc63eefe84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1581b658edf919ea8aae58ad09b4f829"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1581b658edf919ea8aae58ad09b4f829"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">vec</a> (T a)</td></tr>
<tr class="memdesc:a1581b658edf919ea8aae58ad09b4f829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 10 elements.  <a href="#a1581b658edf919ea8aae58ad09b4f829">More...</a><br/></td></tr>
<tr class="separator:a1581b658edf919ea8aae58ad09b4f829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60049819a1e4ee7971c624c18a26210a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60049819a1e4ee7971c624c18a26210a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a60049819a1e4ee7971c624c18a26210a">vec</a> (T a, T b)</td></tr>
<tr class="memdesc:a60049819a1e4ee7971c624c18a26210a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 10 elements.  <a href="#a60049819a1e4ee7971c624c18a26210a">More...</a><br/></td></tr>
<tr class="separator:a60049819a1e4ee7971c624c18a26210a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57308fdf8df2d93ff56d7dc8d2f621b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57308fdf8df2d93ff56d7dc8d2f621b1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a57308fdf8df2d93ff56d7dc8d2f621b1">vec</a> (T a, T b, T c)</td></tr>
<tr class="memdesc:a57308fdf8df2d93ff56d7dc8d2f621b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 10 elements.  <a href="#a57308fdf8df2d93ff56d7dc8d2f621b1">More...</a><br/></td></tr>
<tr class="separator:a57308fdf8df2d93ff56d7dc8d2f621b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643930ad0d00b2138183abfb01ba7083"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a643930ad0d00b2138183abfb01ba7083"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a643930ad0d00b2138183abfb01ba7083">vec</a> (T a, T b, T c, T d)</td></tr>
<tr class="memdesc:a643930ad0d00b2138183abfb01ba7083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 10 elements.  <a href="#a643930ad0d00b2138183abfb01ba7083">More...</a><br/></td></tr>
<tr class="separator:a643930ad0d00b2138183abfb01ba7083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cbb76cabe65d3b5fc27f6d4866ce0b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33cbb76cabe65d3b5fc27f6d4866ce0b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a33cbb76cabe65d3b5fc27f6d4866ce0b">vec</a> (T a, T b, T c, T d, T e)</td></tr>
<tr class="memdesc:a33cbb76cabe65d3b5fc27f6d4866ce0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 10 elements.  <a href="#a33cbb76cabe65d3b5fc27f6d4866ce0b">More...</a><br/></td></tr>
<tr class="separator:a33cbb76cabe65d3b5fc27f6d4866ce0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29a0bceb82c876dc7b2d9d15ea0f5b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac29a0bceb82c876dc7b2d9d15ea0f5b7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac29a0bceb82c876dc7b2d9d15ea0f5b7">vec</a> (T a, T b, T c, T d, T e, T f)</td></tr>
<tr class="memdesc:ac29a0bceb82c876dc7b2d9d15ea0f5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 10 elements.  <a href="#ac29a0bceb82c876dc7b2d9d15ea0f5b7">More...</a><br/></td></tr>
<tr class="separator:ac29a0bceb82c876dc7b2d9d15ea0f5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0218a6965fff6add01901838ccef67"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e0218a6965fff6add01901838ccef67"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6e0218a6965fff6add01901838ccef67">vec</a> (T a, T b, T c, T d, T e, T f, T g)</td></tr>
<tr class="memdesc:a6e0218a6965fff6add01901838ccef67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 10 elements.  <a href="#a6e0218a6965fff6add01901838ccef67">More...</a><br/></td></tr>
<tr class="separator:a6e0218a6965fff6add01901838ccef67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96724ccfd5edca25ce01a24fce53a66"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab96724ccfd5edca25ce01a24fce53a66"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab96724ccfd5edca25ce01a24fce53a66">vec</a> (T a, T b, T c, T d, T e, T f, T g, T h)</td></tr>
<tr class="memdesc:ab96724ccfd5edca25ce01a24fce53a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 10 elements.  <a href="#ab96724ccfd5edca25ce01a24fce53a66">More...</a><br/></td></tr>
<tr class="separator:ab96724ccfd5edca25ce01a24fce53a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb695b3df9ba1978cbf747fc24128f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4cb695b3df9ba1978cbf747fc24128f3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4cb695b3df9ba1978cbf747fc24128f3">vec</a> (T a, T b, T c, T d, T e, T f, T g, T h, T i)</td></tr>
<tr class="memdesc:a4cb695b3df9ba1978cbf747fc24128f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 10 elements.  <a href="#a4cb695b3df9ba1978cbf747fc24128f3">More...</a><br/></td></tr>
<tr class="separator:a4cb695b3df9ba1978cbf747fc24128f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ab30e2bb69186df1728035d83c9b3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2ab30e2bb69186df1728035d83c9b3a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa2ab30e2bb69186df1728035d83c9b3a">vec</a> (T a, T b, T c, T d, T e, T f, T g, T h, T i, T j)</td></tr>
<tr class="memdesc:aa2ab30e2bb69186df1728035d83c9b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build small vectors of up to 10 elements.  <a href="#aa2ab30e2bb69186df1728035d83c9b3a">More...</a><br/></td></tr>
<tr class="separator:aa2ab30e2bb69186df1728035d83c9b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A struct used to detect if a type is a pointer. </p>
<p>If it's not a pointer, then <a class="el" href="struct_halide_1_1_internal_1_1not__a__pointer.html#a83007de3b5f843f71e03f2cc8d58775a">not_a_pointer&lt;T&gt;::type</a> is T. If it is a pointer, then <a class="el" href="struct_halide_1_1_internal_1_1not__a__pointer.html#a83007de3b5f843f71e03f2cc8d58775a">not_a_pointer&lt;T&gt;::type</a> is some internal hidden type that no overload should trigger on. TODO: with C++11 this can be written more cleanly. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aaa0611a86047e2c583dd061a620dcc6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::pair&lt;std::string, int&gt;, <a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">Halide::Internal::FuncValueBounds</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_bounds_8h_source.html#l00023">23</a> of file <a class="el" href="_bounds_8h_source.html">Bounds.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab08852c0c8674ceba4ec8739d799256c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_halide_1_1_internal.html#ab08852c0c8674ceba4ec8739d799256c">Halide::Internal::GeneratorParamValues</a> = typedef std::map&lt;std::string, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_generator_8h_source.html#l00364">364</a> of file <a class="el" href="_generator_8h_source.html">Generator.h</a>.</p>

</div>
</div>
<a class="anchor" id="abd1b9521b6f1f513178f281d8f395335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_range.html">Range</a>&gt; <a class="el" href="namespace_halide_1_1_internal.html#abd1b9521b6f1f513178f281d8f395335">Halide::Internal::Region</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A multi-dimensional box. </p>
<p>The outer product of the elements </p>

<p>Definition at line <a class="el" href="_i_r_8h_source.html#l00299">299</a> of file <a class="el" href="_i_r_8h_source.html">IR.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7db928fd19209689611a24deafa15b9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* Halide::Internal::halide_task)(void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_j_i_t_module_8h_source.html#l00092">92</a> of file <a class="el" href="_j_i_t_module_8h_source.html">JITModule.h</a>.</p>

</div>
</div>
<a class="anchor" id="a694232f7607c49b94dcb6f7b08099fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef llvm::Value* <a class="el" href="namespace_halide_1_1_internal.html#a694232f7607c49b94dcb6f7b08099fec">Halide::Internal::LLVMMDNodeArgumentType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_l_l_v_m___headers_8h_source.html#l00100">100</a> of file <a class="el" href="_l_l_v_m___headers_8h_source.html">LLVM_Headers.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">Halide::Internal::MonotonicResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect whether an expression is monotonic increasing in a variable, decreasing, or unknown. </p>
<p>Returns -1, 0, or 1 for decreasing, unknown, and increasing. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaad87898a017f26e62737125de2b4a9335"></a>Constant</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa6d17c1a787b2f3a7331fde1759083637"></a>MonotonicIncreasing</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa799183e45407f014ab370a9b4bcd2dc3"></a>MonotonicDecreasing</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6d77bcd7bf9bfb0b3f5e66010d9ff3eaa33f442ca80fb5f8ce55a5becac9a30cf"></a>Unknown</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_derivative_8h_source.html#l00040">40</a> of file <a class="el" href="_derivative_8h_source.html">Derivative.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_halide_1_1_internal.html#a6a8761f129e6554b9ea03de31bf066f1">Halide::Internal::ForType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing a type of loop traversal. </p>
<p>Used in schedules, and in the <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> loop IR node. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1a5255d3daaa0a6276b844d61401e6f493"></a>Serial</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1a98402eecfbcefc336954458a01752131"></a>Parallel</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1a138bc087eaaaf426b54f9a466f0cc725"></a>Vectorized</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6a8761f129e6554b9ea03de31bf066f1ae53597647de81f4cc9e098fc119ba0ac"></a>Unrolled</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_expr_8h_source.html#l00236">236</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a410eac3ad68dfb697c5ee97100f2053f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::allocation_bounds_inference </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; std::string, int &gt;, Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a partially statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a> nodes in terms of variables, and define values for those variables. </p>

</div>
</div>
<a class="anchor" id="ad216f1f9fcd53fd56ba2a55b172a3669"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::flatten_blocks </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7f7e59492cfa4804a6dece2d867a5db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_interval.html">Interval</a> Halide::Internal::bounds_of_expr_in_scope </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an expression in some variables, and a map from those variables to their bounds (in the form of (minimum possible value, maximum possible value)), compute two expressions that give the minimum possible value and the maximum possible value of this expression. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_max.html" title="The greater of two values. ">Max</a> or min may be undefined expressions if the value is not bounded above or below.</p>
<p>This is for tasks such as deducing the region of a buffer loaded by a chunk of code. </p>

</div>
</div>
<a class="anchor" id="ac2f62c0ee3ace8de2be57a9db369a3e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::merge_boxes </td>
          <td>(</td>
          <td class="paramtype">Box &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9641dd947fdf6352ccd5e34548db35e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::boxes_overlap </td>
          <td>(</td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Box &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab68083f9769cbbf033176ba50f3709c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_required </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s to each function that occurs within a given statement or expression. </p>
<p>This is useful for figuring out what regions of things to evaluate. </p>

</div>
</div>
<a class="anchor" id="af1f12c0072dbbf9639829af1aedda4ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_required </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s to each function that occurs within a given statement or expression. </p>
<p>This is useful for figuring out what regions of things to evaluate. </p>

</div>
</div>
<a class="anchor" id="aeaf945673dc90b8bdd2e79900b147954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_provided </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="ae6c4633706bdb6855b69fb9146ee65ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_provided </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="ae5c5855f4212c1cb3880a8534b6f41b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_touched </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="a0fbd14233932a8f658ac66d45e00d7fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a>&gt; Halide::Internal::boxes_touched </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rectangular domains large enough to cover all the '<a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a>'s and 'Provides's to each function that occurs within a given statement or expression. </p>

</div>
</div>
<a class="anchor" id="a69980b5d1669ec54e78b7d393d8a7201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_required </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="aea6ad02cea8b0bacbb0b3c1f644af501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_required </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a0586fc0706c9a4d39f0ae5f9c7073c86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_provided </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a9d4d7463fc7d96132bbe01768f967dd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_provided </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="aa211ee508998ef25191d04fa45eb16c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_touched </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a35a819815a3d7f37a441a22c06689689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_box.html">Box</a> Halide::Internal::box_touched </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FuncValueBounds &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em> = <code>FuncValueBounds()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of the above that are only concerned with a single function. </p>

</div>
</div>
<a class="anchor" id="a0b807d0d1524fb2f20b1533d05032c02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#aaa0611a86047e2c583dd061a620dcc6e">FuncValueBounds</a> Halide::Internal::compute_function_value_bounds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum and minimum possible value for each function in an environment. </p>

</div>
</div>
<a class="anchor" id="a439ef9127bf30f5e2a67963eb8db0323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::bounds_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9f57a77cbbb8e2e2e7212a75a470fec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::bounds_inference </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>realization_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>environment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::pair&lt; std::string, int &gt;, Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>func_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a partially lowered statement that includes symbolic representations of the bounds over which things should be realized, and inject expressions defining those bounds. </p>

</div>
</div>
<a class="anchor" id="a71f10140e29131153c3be98d2899b090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Type* Halide::Internal::llvm_type_of </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the llvm type equivalent to a given halide type. </p>

</div>
</div>
<a class="anchor" id="a8dec1d917db83734b33d5a208e9ca973"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::constant_allocation_size </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine to check if a list of extents are all constants, and if so verify the total size is less than 2^31 - 1. </p>
<p>If the result is constant, but overflows, this routine asserts. The name parameter is used in the assertion message. </p>

</div>
</div>
<a class="anchor" id="adc60421b682a09ea4c4dcaaaa3e105e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::function_takes_user_context </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Which built-in functions require a user-context first argument? </p>

</div>
</div>
<a class="anchor" id="a83c69c01c5d35b1cd47354374d49bf28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::common_subexpression_elimination </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace each common sub-expression in the argument with a variable, and wrap the resulting expr in a let statement giving a value to that variable. </p>
<p>This is important to do within <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> (instead of punting to llvm), because exprs that come in from the front-end are small when considered as a graph, but combinatorially large when considered as a tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> an example of a such a case, see test/code_explosion.cpp </p>

</div>
</div>
<a class="anchor" id="abd617bcfa0cf8b542eb38a8cca1f0614"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::common_subexpression_elimination </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do common-subexpression-elimination on each expression in a statement. </p>
<p>Does not introduce let statements. </p>

</div>
</div>
<a class="anchor" id="a750967bfd0520280ceadbf9f15ffa3be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::cse_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a12f749a540acb9a7c148602c517e61e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream &amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Stmt &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide statement on an output stream (such as std::cout) in a human-readable form. </p>

</div>
</div>
<a class="anchor" id="a915eea9584a02a02fa0ccd9dea859e87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LoweredFunc &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0694c89a8349199080a71443202acd43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::debug_to_file </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a statement with <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a> nodes still unlowered. </p>
<p>If the corresponding functions have a debug_file set, then inject code that will dump the contents of those functions to a file after the realization. </p>

</div>
</div>
<a class="anchor" id="af3886cd7a77937dd80231c35581b93be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_odd_lanes </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the odd-numbered lanes in a vector. </p>

</div>
</div>
<a class="anchor" id="a8be6e8bc82582bb4ac055507907282c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_even_lanes </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the even-numbered lanes in a vector. </p>

</div>
</div>
<a class="anchor" id="aaf56d49145d02ee1f675c8c838c8e9ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::extract_lane </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the nth lane of a vector. </p>

</div>
</div>
<a class="anchor" id="ac1233a717a83d74121106b95245ce81a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::rewrite_interleavings </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look through a statement for expressions of the form select(ramp % 2 == 0, a, b) and replace them with calls to an interleave intrinsic. </p>

</div>
</div>
<a class="anchor" id="adc21bfcfcc2b8feadd3612b4cd21e020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::deinterleave_vector_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a534a3b8f52a0441dbb0fb7ab2aed3341"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::finite_difference </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the analytic derivative of the expression with respect to the variable. </p>
<p>May returned an undefined <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> if it's non-differentiable. Compute the finite difference version of the derivative: expr(var+1) - expr(var). The reason to do this as a derivative, instead of just explicitly constructing expr(var+1) - expr(var), is so that we don't have to do so much simplification later. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, the finite-difference derivative of 2*x is trivially 2, whereas 2*(x+1) - 2*x may or may not simplify down to 2, depending on the quality of our simplification routine.</p>
<p>Most rules for the finite difference and the true derivative are the same. The quotient and product rules are not. </p>

</div>
</div>
<a class="anchor" id="af7ad39c95e126e3cdfe7ce5a72fa5f51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_internal.html#a6d77bcd7bf9bfb0b3f5e66010d9ff3ea">MonotonicResult</a> Halide::Internal::is_monotonic </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5aedffca433bdfab639e4956779040e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_early_frees </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with allocations and inject markers (of the form of calls to "mark buffer dead") after the last use of each allocation. </p>
<p>Targets may use this to free buffers earlier than the close of their <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a> node. </p>

</div>
</div>
<a class="anchor" id="acc591095a8e56d4d6f6587c66239fdb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; <a class="el" href="namespace_halide_1_1_internal.html#a9ff5beef3c5a4ec908d9c2bbe99a71f9">Halide::Internal::ref_count</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const IRNode *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_expr_8h_source.html#l00052">52</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7e3867f02d52edd32b4cfe38e5ee55a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void <a class="el" href="namespace_halide_1_1_internal.html#ada37ff426984f7459fe0bbe38b9e11f0">Halide::Internal::destroy</a>&lt; <a class="el" href="struct_halide_1_1_internal_1_1_i_r_node.html">IRNode</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const IRNode *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_expr_8h_source.html#l00055">55</a> of file <a class="el" href="_expr_8h_source.html">Expr.h</a>.</p>

</div>
</div>
<a class="anchor" id="a065c314ae66ddc429dd6ca70c7e467cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::expr_uses_var </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if an expression references the given variable. </p>

</div>
</div>
<a class="anchor" id="ab87be577ac94d5606198abf285d79aa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::expr_uses_var </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if an expression references the given variable, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument. </p>

</div>
</div>
<a class="anchor" id="ab34564f47418b03522be982314215830"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_uses_vars </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if an expression references any of the variables in a scope. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00046">46</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_expr_8h_source.html#l00108">Halide::Internal::IRHandle::accept()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00041">Halide::Internal::ExprUsesVars&lt; T &gt;::result</a>.</p>

</div>
</div>
<a class="anchor" id="a6683c44bf832d3e38e495c04485eab2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_uses_vars </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if an expression references any of the variables in a scope, additionally considering variables bound to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s in the scope provided in the final argument. </p>

<p>Definition at line <a class="el" href="_expr_uses_var_8h_source.html#l00056">56</a> of file <a class="el" href="_expr_uses_var_8h_source.html">ExprUsesVar.h</a>.</p>

<p>References <a class="el" href="_expr_8h_source.html#l00108">Halide::Internal::IRHandle::accept()</a>, and <a class="el" href="_expr_uses_var_8h_source.html#l00041">Halide::Internal::ExprUsesVars&lt; T &gt;::result</a>.</p>

</div>
</div>
<a class="anchor" id="a16b42e90ad180f1254cdd3be0ae7be89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; Halide::Internal::find_direct_calls </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, including in update definitions, update index expressions, and <a class="el" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate. ">RDom</a> extents. </p>
<p>This map <em>does not</em> include the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, unless it is called recursively by itself. </p>

</div>
</div>
<a class="anchor" id="a770da2a7374eb2a8ac60f5c9d90b88ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="class_halide_1_1_internal_1_1_function.html">Function</a>&gt; Halide::Internal::find_transitive_calls </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a map from name to <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition object for all <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> functions called directly in the definition of the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f, or indirectly in those functions' definitions, recursively. </p>
<p>This map always <em>includes</em> the <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> f. </p>

</div>
</div>
<a class="anchor" id="a318c3eca91038227e115e5440d687c43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::zero_gpu_loop_mins </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite all GPU loops to have a min of zero. </p>

</div>
</div>
<a class="anchor" id="a0081752824625e87b5e95bfae979499f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::fuse_gpu_thread_loops </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s GPGPU IR to the OpenCL/CUDA model. </p>
<p>Within every loop over gpu block indices, fuse the inner loops over thread indices into a single loop (with predication to turn off threads). Also injects synchronization points as needed, and hoists allocations at the block level out into a single shared memory array. </p>

</div>
</div>
<a class="anchor" id="a1e667cda683fba6cce2660ff2ffa48ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::map&lt;std::string, <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&gt;&amp; Halide::Internal::get_halide_type_enum_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2fce0241753e0d1cf50b4615b3d00430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int Halide::Internal::generate_filter_main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>cerr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal.html#a2fce0241753e0d1cf50b4615b3d00430" title="generate_filter_main() is a convenient wrapper for GeneratorRegistry::create() + compile_to_files(); ...">generate_filter_main()</a> is a convenient wrapper for <a class="el" href="class_halide_1_1_internal_1_1_generator_registry.html#a21aef07a57064b18d7ad2bb80224b31f">GeneratorRegistry::create()</a> + compile_to_files(); it can be trivially wrapped by a "real" main() to produce a command-line utility for ahead-of-time filter compilation. </p>

</div>
</div>
<a class="anchor" id="a67ce3fefc01a50b8f513aac7c5749e31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::human_readable_stmt </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> simplified using a concrete size of the output, and other optional values for parameters. </p>

</div>
</div>
<a class="anchor" id="a568395264b5729435f7f8a68313c4620"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::human_readable_stmt </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Buffer&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, Expr &gt;&#160;</td>
          <td class="paramname"><em>additional_replacements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> simplified using a concrete size of the output, and other optional values for parameters. </p>

</div>
</div>
<a class="anchor" id="a9fa15ced2f13142e6c4b5e5f4649aa15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_host_dev_buffer_copies </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject calls to halide_device_malloc, halide_copy_to_device, and halide_copy_to_host as needed. </p>

</div>
</div>
<a class="anchor" id="a70fcc88dde228e4f70a90d4848ddb773"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_dev_frees </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject calls to halide_dev_free as needed. </p>

</div>
</div>
<a class="anchor" id="a785a0f3f270d94a0c7b3d96da2eebe85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_image_intrinsics </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for kernel for loops and turn loads and stores inside the loops into coordinate-based load and store intrinsics. </p>

</div>
</div>
<a class="anchor" id="a94843d09c24cd65c12aa022e0ae3bb70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_opengl_intrinsics </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for kernel for loops and turn loads and stores inside the loops into OpenGL texture load and store intrinsics. </p>
<p>Should only be run when the OpenGL target is active. </p>

</div>
</div>
<a class="anchor" id="a38c4753b75f784e928d24b5f085ed383"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a single named function, which must be pure. </p>

</div>
</div>
<a class="anchor" id="a839846970613235cae5c8904a5fda794"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::inline_function </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline a single named function, which must be pure. </p>

</div>
</div>
<a class="anchor" id="a9ff5beef3c5a4ec908d9c2bbe99a71f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html">RefCount</a>&amp; Halide::Internal::ref_count </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here. </p>
<p>E.g. if you want to use IntrusivePtr&lt;MyClass&gt;, then you should define something like this in MyClass.cpp (assuming MyClass has a field: mutable <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> ref_count):</p>
<p>template&lt;&gt; <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> &amp;ref_count&lt;MyClass&gt;(const MyClass *c) {return c-&gt;ref_count;} template&lt;&gt; void destroy&lt;MyClass&gt;(const MyClass *c) {delete c;} </p>

</div>
</div>
<a class="anchor" id="ada37ff426984f7459fe0bbe38b9e11f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::destroy </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Because in this header we don't yet know how client classes store their <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> (and we don't want to depend on the declarations of the client classes), any class that you want to hold onto via one of these must provide implementations of ref_count and destroy, which we forward-declare here. </p>
<p>E.g. if you want to use IntrusivePtr&lt;MyClass&gt;, then you should define something like this in MyClass.cpp (assuming MyClass has a field: mutable <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> ref_count):</p>
<p>template&lt;&gt; <a class="el" href="class_halide_1_1_internal_1_1_ref_count.html" title="A class representing a reference count to be used with IntrusivePtr. ">RefCount</a> &amp;ref_count&lt;MyClass&gt;(const MyClass *c) {return c-&gt;ref_count;} template&lt;&gt; void destroy&lt;MyClass&gt;(const MyClass *c) {delete c;} </p>

</div>
</div>
<a class="anchor" id="a31dc49947eec58e14aab236c7b0182ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a> </p>

</div>
</div>
<a class="anchor" id="a4d404e95dced22ae673144c0351f186f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::equal </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare IR nodes for equality of value. </p>
<p>Traverses entire IR tree. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> equality of reference, use <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html#a28f359d50f802aea35c2cc7075219ecd">Expr::same_as</a> </p>

</div>
</div>
<a class="anchor" id="a9a1dc9a55f32a7813f8c76884b83d2e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::ir_equality_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af22936be5f74cc50d73a4e478bd9271e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_match </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument. </p>
<p>Wildcards require the types to match. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> the type bits and width, a -1 indicates "match anything". So an Int(8, -1) will match 8-bit integer vectors of any width (including scalars), and a UInt(-1, -1) will match any unsigned integer type.</p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example: </p>
<div class="fragment"><div class="line">Expr x = <a class="code" href="struct_halide_1_1_internal_1_1_variable.html#aff3204ace57795ef312d3029c1f09aef">Variable::make</a>(<a class="code" href="namespace_halide.html#acf59f500385c448b26d0d245f55b23f4">Int</a>(32), <span class="stringliteral">&quot;*&quot;</span>);</div>
<div class="line">match(x + x, 3 + (2*k), result)</div>
</div><!-- fragment --><p> should return true, and set result[0] to 3 and result[1] to 2*k. </p>

</div>
</div>
<a class="anchor" id="a90cc40f5fe9cc4d0ba0bf37b5550ad01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::expr_match </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the first expression have the same structure as the second? Variables are matched consistently. </p>
<p>The first time a variable is matched, it assumes the value of the matching part of the second expression. Subsequent matches must be equal to the first match.</p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example: </p>
<div class="fragment"><div class="line">Var x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line">match(x*(x + 1), a*(a + b), result)</div>
</div><!-- fragment --><p> should return true, and set result["x"] = a, and result["y"] = b. </p>

</div>
</div>
<a class="anchor" id="a1eed932bc0eb3a15edcb20795bfb8c2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::expr_match_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab370d99a882a8163ae91d43b94d79d02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_const </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants. ">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node. ">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same. </p>
<p>Doesn't do any constant folding. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00269">Halide::operator%()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00250">Halide::operator/()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00260">Halide::operator/=()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b709fdbc5a6944248187216b5df5b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_const </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same. </p>

</div>
</div>
<a class="anchor" id="a68b76ccfb1d4e7cc35ff65f15f9b0077"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const int* Halide::Internal::as_const_int </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, return a pointer to its value. </p>
<p>Otherwise returns NULL. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00843">Halide::fast_pow()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01119">Halide::lerp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00802">Halide::pow()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00425">Halide::select()</a>.</p>

</div>
</div>
<a class="anchor" id="af2a9edb743eaf6d8074867314247a970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const float* Halide::Internal::as_const_float </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, return a pointer to its value. </p>
<p>Otherwise returns NULL. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l01119">Halide::lerp()</a>.</p>

</div>
</div>
<a class="anchor" id="a2399da4e027488064c4d14a2469f9fc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_const_power_of_two </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a constant integer power of two. </p>
<p>Also returns log base two of the expression if it is. </p>

</div>
</div>
<a class="anchor" id="ad050aaa17987fa4cbb8fd4d41c952e04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_positive_const </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="acc39652dfc1d64fb82d02dc4064185d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_negative_const </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="af3da8f6192d557a4bd47cf244b79a9db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_negative_negatable_const </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) and is its negative value representable. </p>
<p>(This excludes the most negative value of the <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>'s type from inclusion. Intended to be used when the value will be negated as part of simplification.) </p>

</div>
</div>
<a class="anchor" id="a1a521ef987e7964954b997e6dcc5e65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_zero </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="a940b37091a8f16bf1e4a78db7764274e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_one </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression) </p>

<p>Referenced by <a class="el" href="_bounds_8h_source.html#l00060">Halide::Internal::Box::maybe_unused()</a>.</p>

</div>
</div>
<a class="anchor" id="abeed2f66190d11ee6e56e4089a1f441b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_two </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression) </p>

</div>
</div>
<a class="anchor" id="ab2d7b687f4ac09ca9236cb1b8b82bb51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::is_no_op </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect. ">Evaluate</a> node of a constant) </p>

</div>
</div>
<a class="anchor" id="a225fbecd4560e77ea24cb16541fe6b15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int Halide::Internal::int_cast_constant </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an integer value, cast it into a designated integer type and return the bits as int. </p>
<p>Unsigned types are returned as bits in the int and should be cast to unsigned int for comparison. int_cast_constant implements bit manipulations to wrap val into the value range of the <a class="el" href="struct_halide_1_1_type.html" title="Types in the halide type system. ">Type</a> t. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, int_cast_constant(UInt(16), -1) returns 65535 int_cast_constant(Int(8), 128) returns -128 </p>

</div>
</div>
<a class="anchor" id="ab48739c460778f7af77999cfd251d5af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_const </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a const of the given type. </p>

</div>
</div>
<a class="anchor" id="a1e258c84149c36aad7d93cced54cd173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_bool </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a boolean constant from a C++ boolean value. </p>
<p>May also be a vector if width is given. It is not possible to coerce a C++ boolean to <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> because if we provide such a path then char objects can ambiguously be converted to <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> or to std::string. The problem is that C++ does not have a real bool type - it is in fact close enough to char that C++ does not know how to distinguish them. make_bool is the explicit coercion. </p>

</div>
</div>
<a class="anchor" id="a57fedf535d58f8900f8b7c00aa15ece8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_zero </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of zero in the given type. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00217">Halide::operator-()</a>.</p>

</div>
</div>
<a class="anchor" id="ace305dbdd7fed2cf9d5057d4c02067c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_one </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of one in the given type. </p>

</div>
</div>
<a class="anchor" id="afc35f0dc3562ffb5bb777021679435e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::make_two </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the representation of two in the given type. </p>

</div>
</div>
<a class="anchor" id="a0f8e27a136a9facf0e97e6ac6bd71c23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::const_true </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the constant boolean true. </p>
<p>May also be a vector of trues, if a width argument is given. </p>

</div>
</div>
<a class="anchor" id="a6c5d4e90106e92aa21840547b6588eb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::const_false </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the constant boolean false. </p>
<p>May also be a vector of falses, if a width argument is given. </p>

</div>
</div>
<a class="anchor" id="ab40a26aac941b763435e9915851cd073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::match_types </td>
          <td>(</td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coerce the two expressions to have the same type, using C-style casting rules. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> the purposes of casting, a boolean type is UInt(1). We use the following procedure:</p>
<p>If the types already match, do nothing.</p>
<p>Then, if one type is a vector and the other is a scalar, the scalar is broadcast to match the vector width, and we continue.</p>
<p>Then, if one type is floating-point and the other is not, the non-float is cast to the floating-point type, and we're done.</p>
<p>Then, if neither is a float but one of the two is a constant, the constant is cast to match the non-const type and we're done. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, e has type UInt(8), then (e*32) also has type UInt(8), despite the overflow that may occur. Note that this also means that (e*(-1)) is positive, and is equivalent to (e*255) - i.e. the (-1) is cast to a UInt(8) before the multiplication.</p>
<p>Then, if both types are unsigned ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Then, if both types are signed ints, the one with fewer bits is cast to match the one with more bits and we're done.</p>
<p>Finally, if one type is an unsigned int and the other type is a signed int, both are cast to a signed int with the greater of the two bit-widths. <a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, matching an Int(8) with a UInt(16) results in an Int(16). </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00401">Halide::absd()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00350">Halide::max()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00361">Halide::min()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00325">Halide::operator!=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00269">Halide::operator%()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00233">Halide::operator*()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00189">Halide::operator+()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00206">Halide::operator-()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00250">Halide::operator/()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00288">Halide::operator&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01029">Halide::operator&lt;&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00297">Halide::operator&lt;=()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00316">Halide::operator==()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00279">Halide::operator&gt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00307">Halide::operator&gt;=()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l01045">Halide::operator&gt;&gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="af36627bf7242718b1c73214296dc9090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_log </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s vectorizable transcendentals. </p>

</div>
</div>
<a class="anchor" id="a5688772a963296ea52d2bd9ac5913e79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_exp </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s vectorizable transcendentals. </p>

</div>
</div>
<a class="anchor" id="a3d36eef829f9c1e2d6aaf9218b2e0e66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::halide_erf </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s vectorizable transcendentals. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00822">Halide::erf()</a>.</p>

</div>
</div>
<a class="anchor" id="ac5890bd4a8aae2f1f6a2c43496d8ddae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::raise_to_integer_power </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raise an expression to an integer power by repeatedly multiplying it by itself. </p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00843">Halide::fast_pow()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00802">Halide::pow()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f84a0040711a023783268f1213caa3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::scalar_to_constant_expr </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a scalar constant, return an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that represents it. </p>
<p>This will usually be a simple <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a> or <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, with the exception of 64-bit values, which are stored as wrappers to simple <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a> expressions.</p>
<p>Note that in all cases, <a class="el" href="struct_halide_1_1_expr.html#a095f7fe04aa7c2a2acbc2dc4597a505c" title="Get the type of this expression node. ">Expr.type</a> == <a class="el" href="namespace_halide.html#a230bbc98235cdeaea250aa9ab19f3312" title="Construct the halide equivalent of a C type. ">type_of&lt;T&gt;()</a>. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01434">1434</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00157">Halide::cast()</a>.</p>

</div>
</div>
<a class="anchor" id="a40117c4a26ac5f612f075a99b5c87207"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::scalar_to_constant_expr </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01440">1440</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00157">Halide::cast()</a>, and <a class="el" href="_type_8h_source.html#l00134">Halide::Float()</a>.</p>

</div>
</div>
<a class="anchor" id="ab5c1973a3b52e6908d939810844d8405"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::scalar_to_constant_expr </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01446">1446</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00134">Halide::Float()</a>, <a class="el" href="_i_r_8h_source.html#l00348">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::make_float64</a>, and <a class="el" href="_util_8h_source.html#l00051">vec()</a>.</p>

</div>
</div>
<a class="anchor" id="ac14a81e0ff39d55ece7cc41600486337"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::scalar_to_constant_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01456">1456</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00116">Halide::Int()</a>, <a class="el" href="_i_r_8h_source.html#l00348">Halide::Internal::Call::Intrinsic</a>, <a class="el" href="struct_halide_1_1_internal_1_1_call.html#a5341db5809642f196a844ea65ca6bb4b">Halide::Internal::Call::make()</a>, <a class="el" href="_i_r_8h_source.html#l00358">Halide::Internal::Call::make_int64</a>, and <a class="el" href="_util_8h_source.html#l00051">vec()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b7e626d2cf8d0e105f2d7e9b80b5d70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::scalar_to_constant_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01463">1463</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00157">Halide::cast()</a>, and <a class="el" href="_type_8h_source.html#l00125">Halide::UInt()</a>.</p>

</div>
</div>
<a class="anchor" id="a69be35df1689b43027589dad39bb47da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::scalar_from_constant_expr </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> produced by scalar_to_constant_expr&lt;T&gt;, extract the constant value of type T and return true. </p>
<p>If the constant value cannot be converted to type T, return false.</p>
<p>In general, ScalarFromExpr&lt;T&gt;(ScalarToExpr&lt;T&gt;(v)) -&gt; (v, true) for all scalar type T, with the notable exception of T == float64, which will return true but possibly lose precision.</p>
<p>This function exists primarily to allow for code that needs to extract the default/min/max values in a <a class="el" href="class_halide_1_1_internal_1_1_parameter.html" title="A reference-counted handle to a parameter to a halide pipeline. ">Parameter</a> (e.g. to write metadata for a compiled <a class="el" href="class_halide_1_1_generator.html">Generator</a>); it is not intended to be a general <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> evaluator, and should not be used as one. </p>

<p>Definition at line <a class="el" href="_i_r_operator_8h_source.html#l01569">1569</a> of file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>

<p>References <a class="el" href="_expr_8h_source.html#l00120">Halide::Internal::IRHandle::as()</a>, <a class="el" href="_intrusive_ptr_8h_source.html#l00110">Halide::Internal::IntrusivePtr&lt; T &gt;::defined()</a>, and <a class="el" href="_expr_8h_source.html#l00208">Halide::Expr::type()</a>.</p>

</div>
</div>
<a class="anchor" id="a10cfea8acb4f311a9365e26a8f7de08f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a halide for loop type (vectorized, serial, etc) in a human readable form. </p>

</div>
</div>
<a class="anchor" id="a2c00a579c3d86ae40920d5fc4ffe64cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Internal::lower_lerp </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>zero_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>one_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> IR that computes a lerp. </p>
<p>Use by codegen targets that don't have a native lerp. </p>

</div>
</div>
<a class="anchor" id="a0de53dea62d6fa723dbb862fab8c5630"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Value* Halide::Internal::value_as_metadata_type </td>
          <td>(</td>
          <td class="paramtype">llvm::Value *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_l_l_v_m___headers_8h_source.html#l00101">101</a> of file <a class="el" href="_l_l_v_m___headers_8h_source.html">LLVM_Headers.h</a>.</p>

</div>
</div>
<a class="anchor" id="a55cf32e5a054a8b3c42884529527b89f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Module* Halide::Internal::get_initial_module_for_target </td>
          <td>(</td>
          <td class="paramtype">Target&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_shared_jit_runtime</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>just_gpu</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an llvm module containing the support code for a given target. </p>

</div>
</div>
<a class="anchor" id="ae550b1911283d65000a7abb81fdc3c14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Module* Halide::Internal::get_initial_module_for_ptx_device </td>
          <td>(</td>
          <td class="paramtype">Target&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an llvm module containing the support code for ptx device. </p>

</div>
</div>
<a class="anchor" id="a6a115487cd9954063dd4e55e37394af2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::lower </td>
          <td>(</td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Target &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; IRMutator * &gt; &amp;&#160;</td>
          <td class="paramname"><em>custom_passes</em> = <code>std::vector&lt;&#160;IRMutator&#160;*&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a halide function with a schedule, create a statement that evaluates it. </p>
<p>Automatically pulls in all the functions f depends on. Some stages of lowering may be target-specific. </p>

</div>
</div>
<a class="anchor" id="a4d3bfe43201bab68cf4820993fe1469b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::lower_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab01c2c3e306a2adba68958572c573d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_memoization </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform pipeline calls for Funcs scheduled with memoize to do a lookup call to the runtime cache implementation, and if there is a miss, compute the results and call the runtime to store it back to the cache. </p>
<p>Should leave non-memoized Funcs unchanged. </p>

</div>
</div>
<a class="anchor" id="a7298e57b1434cccc072c45b6f5c6efef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::modulus_remainder </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> things like alignment analysis, often it's helpful to know if an integer expression is some multiple of a constant plus some other constant. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> example, it is straight-forward to deduce that ((10*x + 2)*(6*y - 3) - 1) is congruent to five modulo six.</p>
<p>We get the most information when the modulus is large. E.g. if something is congruent to 208 modulo 384, then we also know it's congruent to 0 mod 8, and we can possibly use it as an index for an aligned load. If all else fails, we can just say that an integer is congruent to zero modulo one. </p>

</div>
</div>
<a class="anchor" id="a8489fb5b4449835f26313a57e856c4b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_modulus_remainder.html">ModulusRemainder</a> Halide::Internal::modulus_remainder </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; ModulusRemainder &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If we have alignment information about external variables, we can let the analysis know about that using this version of modulus_remainder: </p>

</div>
</div>
<a class="anchor" id="af210d0f6ae102d704259f49bb32adc2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::reduce_expr_modulo </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>modulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>remainder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce an expression modulo some integer. </p>
<p>Returns true and assigns to remainder if an answer could be found. </p>

</div>
</div>
<a class="anchor" id="a789149daec96e933f8758f71f8474dd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::modulus_remainder_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a50891465f948d4f9b30b9253ce1640b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::gcd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The greatest common divisor of two integers. </p>

</div>
</div>
<a class="anchor" id="ab56d2d1c54f988f23aa03ae70cdfd857"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::lcm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The least common multiple of two integers. </p>

</div>
</div>
<a class="anchor" id="a36620e2156363b215b17fae00eec44ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::is_one_to_one </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conservatively determine whether an integer expression is one-to-one in its variables. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_for.html" title="A for loop. ">For</a> now this means it contains a single variable and its derivative is provably strictly positive or strictly negative. </p>

</div>
</div>
<a class="anchor" id="acd3b8d6aeed9a003fe228ad1aba7322f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::is_one_to_one_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a913e6ea61edf88f4ccdb3672b488e6d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::can_parallelize_rvar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UpdateDefinition &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> can prove that it is safe to parallelize an update definition across a specific variable. </p>
<p>If this returns true, it's definitely safe. If this returns false, it may still be safe, but <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> couldn't prove it. </p>

</div>
</div>
<a class="anchor" id="a0ce66817377fbb1918bbe7510ab47b29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::check_call_arg_types </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Expr &gt; *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate arguments to a call to a func, image or imageparam. </p>

</div>
</div>
<a class="anchor" id="acfe34fa32a730191953a42d96759d23f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::partition_loops </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions loop bodies into a prologue, a steady state, and an epilogue. </p>
<p>Finds the steady state by hunting for use of clamped ramps, or the 'likely' intrinsic. </p>

</div>
</div>
<a class="anchor" id="a568a0554db6866ee8560c3f599bceadd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_profiling </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement representing a halide pipeline, and (depending on the environment variable HL_PROFILE), insert high-resolution timing into the generated code; summaries of execution times and counts will be logged at the end. </p>
<p>Should be done before storage flattening, but after all bounds inference. Use util/HalideProf to analyze the output.</p>
<p>NOTE: this makes no effort to provide accurate or useful information when parallelization is scheduled; more work would need to be done to safely record data from multiple threads.</p>
<p>NOTE: this makes no effort to account for overhead from the profiling instructions inserted; profile-enabled runtimes will be slower, and inner loops will be more profoundly affected. </p>

</div>
</div>
<a class="anchor" id="ae828a911751c5115cb503d05afb1dcbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Internal::profiling_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current profiling level (by reading HL_PROFILE) </p>

</div>
</div>
<a class="anchor" id="add0c1d3ac79fd83cb609d37831253957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::qualify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prefix all variable names in the given expression with the prefix string. </p>

</div>
</div>
<a class="anchor" id="a795f343747d7f716a33198907c3e7d25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::random_float </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random floating-point number between zero and one that varies deterministically based on the input expressions. </p>

</div>
</div>
<a class="anchor" id="ae4e64539c6d89123f6200b919ec28fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::random_int </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a random unsigned integer between zero and 2^32-1 that varies deterministically based on the input expressions (which must be integers). </p>

</div>
</div>
<a class="anchor" id="a0f875bf4d528885d68581fbd198bf356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::lower_random </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>free_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert calls to random() to IR generated by random_float and random_int. </p>
<p>Tags all calls with the variables in free_vars, and the integer given as the last argument. </p>

</div>
</div>
<a class="anchor" id="a8459c153113e252e4cf11fd16326b065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_dead_allocations </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Allocate/Free pairs that are never loaded from or stored to, and remove them from the <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>. </p>
<p>This doesn't touch Realize/Call nodes and so must be called after storage_flattening. </p>

</div>
</div>
<a class="anchor" id="a445fa778b28abf135eb1b1d0c8389efc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_trivial_for_loops </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert for loops of size 1 into <a class="el" href="struct_halide_1_1_internal_1_1_let_stmt.html" title="The statement form of a let node. ">LetStmt</a> nodes, which allows for further simplification. </p>
<p>Done during a late stage of lowering. </p>

</div>
</div>
<a class="anchor" id="a078fe646230de310959c4506c76de02e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::remove_undef </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes stores that depend on undef values, and statements that only contain such stores. </p>

</div>
</div>
<a class="anchor" id="a4242a0b28a7409d2a2489a74795914ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Halide::Internal::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_scope_8h_source.html#l00238">238</a> of file <a class="el" href="_scope_8h_source.html">Scope.h</a>.</p>

<p>References <a class="el" href="_scope_8h_source.html#l00172">Halide::Internal::Scope&lt; T &gt;::const_iterator::name()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b077780a2dcb6ed633f6f5d111046c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::simplify </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify_lets</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; ModulusRemainder &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>Scope&lt;&#160;ModulusRemainder&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc. </p>
<p>Simplifies across let statements, so must not be called on stmts with dangling or repeated variable names. </p>

</div>
</div>
<a class="anchor" id="a2006cf9a5d8bad4e7861a3a10168b1d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::simplify </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify_lets</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em> = <code>Scope&lt;&#160;Interval&#160;&gt;::empty_scope()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; ModulusRemainder &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>Scope&lt;&#160;ModulusRemainder&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a a wide range of simplifications to expressions and statements, including constant folding, substituting in trivial values, arithmetic rearranging, etc. </p>
<p>Simplifies across let statements, so must not be called on stmts with dangling or repeated variable names. </p>

</div>
</div>
<a class="anchor" id="a27d8c444c776976f822644dc995d10ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::simplify_exprs </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify expressions found in a statement, but don't simplify across different statements. </p>
<p>This is safe to perform at an earlier stage in lowering than full simplification of a stmt. </p>

</div>
</div>
<a class="anchor" id="a6cd3908859c82249a2c7f10158883a97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::mod_imp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>. </p>
<p>Use these implementations; do not use native C division or mod to simplify <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> expressions. <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> division and modulo satisify the Euclidean definition of division for integers a and b:</p>
<p>/code (a/b)*b + ab = a 0 &lt;= ab &lt; |b| /endcode </p>

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00049">49</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00382">Halide::abs()</a>, and <a class="el" href="_type_8h_source.html#l00071">Halide::Type::is_int()</a>.</p>

</div>
</div>
<a class="anchor" id="a0442f9a0450f45683938a69ce0273974"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Halide::Internal::div_imp </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementations of division and mod that are specific to <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>. </p>
<p>Use these implementations; do not use native C division or mod to simplify <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> expressions. <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> division and modulo satisify the Euclidean definition of division for integers a and b:</p>
<p>/code (a/b)*b + ab = a 0 &lt;= ab &lt; |b| /endcode </p>

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00061">61</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00036">Halide::Type::bits</a>, and <a class="el" href="_type_8h_source.html#l00071">Halide::Type::is_int()</a>.</p>

</div>
</div>
<a class="anchor" id="adff5495089b812474881ee939c4701c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00076">76</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac9a60708c880da445554b8eeb778c034"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespace_halide_1_1_internal.html#a6cd3908859c82249a2c7f10158883a97">Halide::Internal::mod_imp</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00081">81</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

<p>References <a class="el" href="_i_r_operator_8h_source.html#l00873">Halide::floor()</a>.</p>

</div>
</div>
<a class="anchor" id="aa13a82f37fe6336c154122f66d294523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00086">86</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3965c871f086a60fda2cc31e678d050a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespace_halide_1_1_internal.html#a0442f9a0450f45683938a69ce0273974">Halide::Internal::div_imp</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_simplify_8h_source.html#l00089">89</a> of file <a class="el" href="_simplify_8h_source.html">Simplify.h</a>.</p>

</div>
</div>
<a class="anchor" id="a91c952efe23378dcba6fcbd92055c213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::simplify_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8489422fe4da6e486b5fd7831aab8bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::skip_stages </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Avoid computing certain stages if we can infer a runtime condition to check that tells us they won't be used. </p>
<p>Does this by aanalyzing all reads of each buffer allocated, and inferring some condition that tells us if the reads occur. If the condition is non-trivial, inject ifs that guard the production. </p>

</div>
</div>
<a class="anchor" id="a07bde9012b280aad21a569ea008ed296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::sliding_window </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform sliding window optimizations on a halide statement. </p>
<p>I.e. don't bother computing points in a function that have provably already been computed by a previous iteration. </p>

</div>
</div>
<a class="anchor" id="a862cc0c54124576f8b14550c1154f971"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::solve_expression </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scope&lt; Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>scope</em> = <code>Scope&lt;&#160;Expr&#160;&gt;::empty_scope()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to collect all instances of a variable in an expression tree and place it as far to the left as possible, and as far up the tree as possible (i.e. </p>
<p>outside most parentheses). If the expression is an equality or comparison, this 'solves' the equation. Returns an undefined expression on failure. </p>

</div>
</div>
<a class="anchor" id="aff96a46ef180209a14610a2a5a1d74ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::solve_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a18248db0e632551cd5b3376e6ade4365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::print_to_html </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump an HTML-formatted print of a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a> to filename. </p>

</div>
</div>
<a class="anchor" id="ae8228323a26e73895bb0e3d3e1e78496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::print_to_html </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Module &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump an HTML-formatted print of a <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> to filename. </p>

</div>
</div>
<a class="anchor" id="aac482fc1e5a48a0e5c3320e80d597657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::storage_flattening </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with multi-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_realize.html" title="Allocate a multi-dimensional buffer of the given type and size. ">Realize</a>, <a class="el" href="struct_halide_1_1_internal_1_1_provide.html" title="This defines the value of a function at a multi-dimensional location. ">Provide</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_call.html" title="A function call. ">Call</a> nodes, and turn it into a statement with single-dimensional <a class="el" href="struct_halide_1_1_internal_1_1_allocate.html" title="Allocate a scratch area called with the given name, type, and size. ">Allocate</a>, <a class="el" href="struct_halide_1_1_internal_1_1_store.html" title="Store a &#39;value&#39; to the buffer called &#39;name&#39; at a given &#39;index&#39;. ">Store</a>, and <a class="el" href="struct_halide_1_1_internal_1_1_load.html" title="Load a value from a named buffer. ">Load</a> nodes respectively. </p>

</div>
</div>
<a class="anchor" id="a9eefd272612c586d9c3e4dba31d1c215"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::storage_folding </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold storage of functions if possible. </p>
<p>This means reducing one of the dimensions module something for the purpose of storage, if we can prove that this is safe to do. E.g consider:</p>
<div class="fragment"><div class="line">f(x) = ...</div>
<div class="line">g(x) = f(x-1) + f(x)</div>
<div class="line">f.store_root().compute_at(g, x);</div>
</div><!-- fragment --><p>We can store f as a circular buffer of size two, instead of allocating space for all of it. </p>

</div>
</div>
<a class="anchor" id="ac48710fd66a0823291cabe7451d91f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within expr. </p>
<p>This is a dangerous thing to do if variable names have not been uniquified. While it won't traverse inside let statements with the same name as the first argument, moving a piece of syntax around can change its meaning, because it can cross lets that redefine variable names that it includes references to. </p>

</div>
</div>
<a class="anchor" id="ad62310d71063459051000c4032c78d6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with the given name with the replacement expression within stmt. </p>

</div>
</div>
<a class="anchor" id="a6daa7c8282e00d77d69713bd0ca4c73d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with names in the map. </p>

</div>
</div>
<a class="anchor" id="a6f67c2e11eb92dcfb534e01a4e431e29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, Expr &gt; &amp;&#160;</td>
          <td class="paramname"><em>replacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute variables with names in the map. </p>

</div>
</div>
<a class="anchor" id="a9624281bd69638e2901f037e7d481dc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute expressions for other expressions. </p>

</div>
</div>
<a class="anchor" id="a3066061a33cacb7f0c7ab0fc63eefe84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::substitute </td>
          <td>(</td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>stmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute expressions for other expressions. </p>

</div>
</div>
<a class="anchor" id="a3cd3f1d683bcca49a2df7179d42245d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::inject_tracing </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, Function &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Function&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement representing a halide pipeline, inject calls to tracing functions at interesting points, such as allocations. </p>
<p>Should be done before storage flattening, but after all bounds inference. </p>

</div>
</div>
<a class="anchor" id="a0b6c445013b15af0a32bd54f5bb6bdc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unify_duplicate_lets </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find let statements that all define the same value, and make later ones just reuse the symbol names of the earlier ones. </p>

</div>
</div>
<a class="anchor" id="abf197e316b7d0a6adb96c25976612c1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::uniquify_variable_names </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify a statement so that every internally-defined variable name is unique. </p>
<p>This lets later passes assume syntactic equivalence is semantic equivalence. </p>

</div>
</div>
<a class="anchor" id="adc1c49e552297672b3751ac988bf70c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::unroll_loops </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for loops marked for unrolling, and convert each into several copies of the innermost statement. </p>
<p>I.e. unroll the loop. </p>

</div>
</div>
<a class="anchor" id="a1581b658edf919ea8aae58ad09b4f829"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Halide::Internal::vec </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build small vectors of up to 10 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#a14">tutorial/lesson_08_scheduling_2.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_util_8h_source.html#l00051">51</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_i_r_operator_8h_source.html#l00382">Halide::abs()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00401">Halide::absd()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00624">Halide::acos()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00712">Halide::acosh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00600">Halide::asin()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00688">Halide::asinh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00648">Halide::atan()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00660">Halide::atan2()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00736">Halide::atanh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00887">Halide::ceil()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00612">Halide::cos()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00700">Halide::cosh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01169">Halide::count_leading_zeros()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01177">Halide::count_trailing_zeros()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00771">Halide::exp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00856">Halide::fast_inverse()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00864">Halide::fast_inverse_sqrt()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00873">Halide::floor()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00927">Halide::is_nan()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01119">Halide::lerp()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00787">Halide::log()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00968">Halide::operator&amp;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01029">Halide::operator&lt;&lt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01045">Halide::operator&gt;&gt;()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01002">Halide::operator^()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00985">Halide::operator|()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01017">Halide::operator~()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01161">Halide::popcount()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00802">Halide::pow()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00948">Halide::reinterpret()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00902">Halide::round()</a>, <a class="el" href="_i_r_operator_8h_source.html#l01446">scalar_to_constant_expr()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00588">Halide::sin()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00676">Halide::sinh()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00748">Halide::sqrt()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00636">Halide::tan()</a>, <a class="el" href="_i_r_operator_8h_source.html#l00724">Halide::tanh()</a>, and <a class="el" href="_i_r_operator_8h_source.html#l00915">Halide::trunc()</a>.</p>

</div>
</div>
<a class="anchor" id="a60049819a1e4ee7971c624c18a26210a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Halide::Internal::vec </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build small vectors of up to 10 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00058">58</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a57308fdf8df2d93ff56d7dc8d2f621b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Halide::Internal::vec </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build small vectors of up to 10 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00066">66</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a643930ad0d00b2138183abfb01ba7083"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Halide::Internal::vec </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build small vectors of up to 10 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00075">75</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a33cbb76cabe65d3b5fc27f6d4866ce0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Halide::Internal::vec </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build small vectors of up to 10 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00085">85</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac29a0bceb82c876dc7b2d9d15ea0f5b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Halide::Internal::vec </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build small vectors of up to 10 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00096">96</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6e0218a6965fff6add01901838ccef67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Halide::Internal::vec </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build small vectors of up to 10 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00108">108</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab96724ccfd5edca25ce01a24fce53a66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Halide::Internal::vec </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build small vectors of up to 10 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00121">121</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4cb695b3df9ba1978cbf747fc24128f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Halide::Internal::vec </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build small vectors of up to 10 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00135">135</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa2ab30e2bb69186df1728035d83c9b3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Halide::Internal::vec </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build small vectors of up to 10 elements. </p>
<p>If we used C++11 and had vector initializers, this would not be necessary, but we don't want to rely on C++11 support. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00150">150</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0aeffeff26578021bc780e1506bfa448"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::int_to_string </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an integer to a string. </p>

</div>
</div>
<a class="anchor" id="a94816d6979fdadb6e206a5d0a668e008"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DstType , typename SrcType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DstType Halide::Internal::reinterpret_bits </td>
          <td>(</td>
          <td class="paramtype">const SrcType &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An aggressive form of reinterpret cast used for correct type-punning. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00171">171</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h_source.html#l00117">dst</a>, and <a class="el" href="runtime__internal_8h.html#add55236e1a6168d059f1409762081d1a">memcpy()</a>.</p>

</div>
</div>
<a class="anchor" id="a2eb97978547d98141752de6b614195f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::make_entity_name </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a unique name for an object based on the name of the stack variable passed in. </p>
<p>If introspection isn't working or there are no debug symbols, just uses unique_name with the given prefix. </p>

</div>
</div>
<a class="anchor" id="acd575ab182df12cc793dba4aa241c1a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::unique_name </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a unique name starting with the given character. </p>
<p>It's unique relative to all other calls to unique_name done by this process. <a class="el" href="struct_halide_1_1_internal_1_1_not.html" title="Logical not - true if the expression false. ">Not</a> thread-safe. </p>

<p>Referenced by <a class="el" href="_lambda_8h_source.html#l00017">Halide::lambda()</a>, <a class="el" href="_r_dom_8h_source.html#l00035">Halide::RVar::RVar()</a>, and <a class="el" href="_var_8h_source.html#l00024">Halide::Var::Var()</a>.</p>

</div>
</div>
<a class="anchor" id="aafd40e47c06b4ccb5d2173528ae0523f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::unique_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>user</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a unique name starting with the given string. </p>
<p><a class="el" href="struct_halide_1_1_internal_1_1_not.html" title="Logical not - true if the expression false. ">Not</a> thread-safe. </p>

</div>
</div>
<a class="anchor" id="aa7703083cfe592de68f37796533724ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the first string starts with the second string. </p>

<p>Referenced by <a class="el" href="_var_8h_source.html#l00129">Halide::Var::is_implicit()</a>, and <a class="el" href="_schedule_8h_source.html#l00047">Halide::Internal::LoopLevel::match()</a>.</p>

</div>
</div>
<a class="anchor" id="a230079281175545b9b90b2285106ab28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the first string ends with the second string. </p>

<p>Referenced by <a class="el" href="_schedule_8h_source.html#l00047">Halide::Internal::LoopLevel::match()</a>.</p>

</div>
</div>
<a class="anchor" id="a323b05ce69829cea65348efc21923625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all matches of the second string in the first string with the last string. </p>

</div>
</div>
<a class="anchor" id="ac91d88c24b89bb17c7b69c671c723516"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Internal::base_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em> = <code>'.'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the final token of the name string using the given delimiter. </p>

</div>
</div>
<a class="anchor" id="aedc761896b3e6a38bddce45b6c0f8b15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;std::string&gt; Halide::Internal::split_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> the source string using 'delim' as the divider. </p>

</div>
</div>
<a class="anchor" id="aacabf4d4e1d92f8059e6c3ce90b06368"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::Internal::collect_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>collected_args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00208">208</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00218">collect_args()</a>, <a class="el" href="_func_8h_source.html#l00952">Halide::Func::operator()()</a>, <a class="el" href="_func_8h_source.html#l00083">Halide::Stage::reorder()</a>, <a class="el" href="_func_8h_source.html#l01061">Halide::Func::reorder()</a>, and <a class="el" href="_func_8h_source.html#l01380">Halide::Func::reorder_storage()</a>.</p>

</div>
</div>
<a class="anchor" id="a11a5d4585e8974633558071b65ccead7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::Internal::collect_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>collected_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00212">212</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

</div>
</div>
<a class="anchor" id="afb4859b8bc2993517cfdc270931b4d8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::Internal::collect_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>collected_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00218">218</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00208">collect_args()</a>.</p>

</div>
</div>
<a class="anchor" id="aa3edc6396d4157000cf0b27bec127c20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::Internal::collect_paired_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T1, T2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>collected_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T3&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T4&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00225">225</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_util_8h_source.html#l00231">collect_paired_args()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00104">Halide::BoundaryConditions::constant_exterior()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00199">Halide::BoundaryConditions::mirror_image()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00233">Halide::BoundaryConditions::mirror_interior()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00137">Halide::BoundaryConditions::repeat_edge()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00168">Halide::BoundaryConditions::repeat_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b69555853e1ada3402c97304481c821"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::Internal::collect_paired_args </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T1, T2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>collected_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T3&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T4&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_util_8h_source.html#l00231">231</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>References <a class="el" href="_util_8h_source.html#l00225">collect_paired_args()</a>.</p>

</div>
</div>
<a class="anchor" id="adcfef059a37f995f9434f836bdbc1edd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::find_linear_expressions </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide_1_1_internal.html#adcfef059a37f995f9434f836bdbc1edd" title="find_linear_expressions(Stmt s) identifies expressions that may be moved out of the generated fragmen...">find_linear_expressions(Stmt s)</a> identifies expressions that may be moved out of the generated fragment shader into a varying attribute. </p>
<p>These expressions are tagged by wrapping them in a glsl_varying intrinsic </p>

</div>
</div>
<a class="anchor" id="a523c0d5dea7bfbd664e8506ebb7016de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::setup_gpu_vertex_buffer </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a set of 2D mesh coordinates based on the behavior of varying attribute expressions contained within a GLSL scheduled for loop. </p>
<p>This method is called during lowering to extract varying attribute expressions and generate code to evalue them at each mesh vertex location. The operation is performed on the host before the draw call to invoke the shader </p>

</div>
</div>
<a class="anchor" id="abe70c3a9d0ecd59908b1837a11d01de0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_internal_1_1_stmt.html">Stmt</a> Halide::Internal::vectorize_loops </td>
          <td>(</td>
          <td class="paramtype">Stmt&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a statement with for loops marked for vectorization, and turn them into single statements that operate on vectors. </p>
<p>The loops in question must have constant extent. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
