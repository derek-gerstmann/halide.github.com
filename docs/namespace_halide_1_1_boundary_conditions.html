<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Halide: Halide::BoundaryConditions Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('namespace_halide_1_1_boundary_conditions.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">Halide::BoundaryConditions Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace to hold functions for imposing boundary conditions on <a class="el" href="namespace_halide.html">Halide</a> Funcs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html">Internal</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">constant_exterior</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;source, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt; &amp;bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a8e9c2da541218897745d9e9c0cddc8b5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a512a3c08519c723659107821c61a0e8e">constant_exterior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a512a3c08519c723659107821c61a0e8e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a3494490c65e4c166ad8c8ac2448826b6">constant_exterior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a3494490c65e4c166ad8c8ac2448826b6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a72fcf28c5f020f3c4a7243da08229fee">constant_exterior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a72fcf28c5f020f3c4a7243da08229fee"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a98e4ccc1fc43f95a2429bddcd135af93">constant_exterior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a98e4ccc1fc43f95a2429bddcd135af93"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a0ed2c1c99a56efdf55e743ffee0a944e">constant_exterior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a0ed2c1c99a56efdf55e743ffee0a944e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a21f73b3931776fae35272b5ecb81d334">constant_exterior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a21f73b3931776fae35272b5ecb81d334"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2902d989503f56800196282a956f2d2a">constant_exterior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a2902d989503f56800196282a956f2d2a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">repeat_edge</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;source, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt; &amp;bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#a2432026c4f3e024c2f0082e700bef4f2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#aa5497265a7aa443a6ba8bb6f8843ec57">repeat_edge</a> (T func_like)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#aa5497265a7aa443a6ba8bb6f8843ec57"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#afffb3729f3334a6d64c2c2441ee20dd8">repeat_edge</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#afffb3729f3334a6d64c2c2441ee20dd8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a528e3317346e9a642014614e9ca2d3f1">repeat_edge</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#a528e3317346e9a642014614e9ca2d3f1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a7c3e4c6bf9cbac6ddd7256a3b44aebfb">repeat_edge</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#a7c3e4c6bf9cbac6ddd7256a3b44aebfb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a69c4ae257ac89aa24d57b7ecea607f49">repeat_edge</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#a69c4ae257ac89aa24d57b7ecea607f49"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9eaa40a7033f44978af8f317fb9e26c6">repeat_edge</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#a9eaa40a7033f44978af8f317fb9e26c6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#adb99ec97e80ae6479c91214c71fe44f9">repeat_edge</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#adb99ec97e80ae6479c91214c71fe44f9"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">repeat_image</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;source, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt; &amp;bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a8472a03bc5d5b544c259c928270481e4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a21dacea6046923b92ce184a68549b535">repeat_image</a> (T func_like)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a21dacea6046923b92ce184a68549b535"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad5c6c95b4a8479ddcf5135eae5811408">repeat_image</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#ad5c6c95b4a8479ddcf5135eae5811408"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#af340aa63c121d7d13690d04c2c43fa64">repeat_image</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#af340aa63c121d7d13690d04c2c43fa64"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a6a610ed59bbf566f756120db995c7fb8">repeat_image</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a6a610ed59bbf566f756120db995c7fb8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a47459c33ac4f55bd21a9fc054ec4f1cc">repeat_image</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a47459c33ac4f55bd21a9fc054ec4f1cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2c078e41888357be879f3511cb02cf3a">repeat_image</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a2c078e41888357be879f3511cb02cf3a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#adfef8f9357c1c5e71c77d34f95b2fbb8">repeat_image</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#adfef8f9357c1c5e71c77d34f95b2fbb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">mirror_image</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;source, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt; &amp;bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same.  <a href="#a9d0cea1519a98d7983d754323250bd95"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a90210f3878ff4e84f37e1a1d201ce7c0">mirror_image</a> (T func_like)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a90210f3878ff4e84f37e1a1d201ce7c0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a20f3907b2141da518dde88b5ce0360e7">mirror_image</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a20f3907b2141da518dde88b5ce0360e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9648de004485df3fef0d79d985d3c5e3">mirror_image</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a9648de004485df3fef0d79d985d3c5e3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a121810c4055788c61755d3cd5c459e63">mirror_image</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a121810c4055788c61755d3cd5c459e63"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#abcd833d8d10bc20e8c37966b28a4a264">mirror_image</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#abcd833d8d10bc20e8c37966b28a4a264"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a717316832fe3f3f4ed651d40286dd8ef">mirror_image</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a717316832fe3f3f4ed651d40286dd8ef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ab9c62a0e12724ce941fc4dfccbe4eb36">mirror_image</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#ab9c62a0e12724ce941fc4dfccbe4eb36"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">mirror_interior</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;source, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &gt; &amp;bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a090e3e8b50a162f92777f19b84e5b453"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a6f7e2ad1955724feb83bbaec99363b91">mirror_interior</a> (T func_like)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a6f7e2ad1955724feb83bbaec99363b91"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a35d63ccb1eaca9eb2119d455994fc027">mirror_interior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a35d63ccb1eaca9eb2119d455994fc027"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a4c34c03095c23274ef88a9c6901e535e">mirror_interior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a4c34c03095c23274ef88a9c6901e535e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a06572fdbca0463371ff4989383e00c62">mirror_interior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a06572fdbca0463371ff4989383e00c62"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a28341dfe322cdab5da3a2b9466f865b0">mirror_interior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a28341dfe322cdab5da3a2b9466f865b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a7585f628b4a0cb88edbc9712c1ed119f">mirror_interior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a7585f628b4a0cb88edbc9712c1ed119f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ae925984131df74f183b82a44ef1ca1e3">mirror_interior</a> (T func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent0, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent1, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent2, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent3, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent4, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> min5, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> extent5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#ae925984131df74f183b82a44ef1ca1e3"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>namespace to hold functions for imposing boundary conditions on <a class="el" href="namespace_halide.html">Halide</a> Funcs. </p>
<p>All functions in this namespace transform a source <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> to a result <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> where the result produces the values of the source within a given region and a different set of values outside the given region. A region is an N dimensional box specified by mins and extents.</p>
<p>Three areas are defined: The image is the entire set of values in the region. The edge is the set of pixels in the image but adjacent to coordinates that are not The interior is the image minus the edge (and is undefined if the extent of any region is 1 or less).</p>
<p>If the source <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> has more dimensions than are specified, the extra ones are unmodified.</p>
<p>Numerous options for specifing the outside area are provided, including replacement with an expression, repeating the edge samples, mirroring over the edge, and repeating or mirroring the entire image.</p>
<p>TODO: Add support for passing Image&lt;T&gt; and <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, and possibly other types directly to this functions. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8e9c2da541218897745d9e9c0cddc8b5"></a><!-- doxytag: member="Halide::BoundaryConditions::constant_exterior" ref="a8e9c2da541218897745d9e9c0cddc8b5" args="(const Func &amp;source, Expr value, const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;bounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">Halide::BoundaryConditions::constant_exterior</a> </td>
          <td>(</td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.) </p>

<p>Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00098">constant_exterior()</a>.</p>

</div>
</div>
<a class="anchor" id="a512a3c08519c723659107821c61a0e8e"></a><!-- doxytag: member="Halide::BoundaryConditions::constant_exterior" ref="a512a3c08519c723659107821c61a0e8e" args="(T func_like, Expr value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">Halide::BoundaryConditions::constant_exterior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00098">98</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">constant_exterior()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>.</p>

</div>
</div>
<a class="anchor" id="a3494490c65e4c166ad8c8ac2448826b6"></a><!-- doxytag: member="Halide::BoundaryConditions::constant_exterior" ref="a3494490c65e4c166ad8c8ac2448826b6" args="(T func_like, Expr value, Expr min0, Expr extent0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">Halide::BoundaryConditions::constant_exterior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00117">117</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">constant_exterior()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>.</p>

</div>
</div>
<a class="anchor" id="a72fcf28c5f020f3c4a7243da08229fee"></a><!-- doxytag: member="Halide::BoundaryConditions::constant_exterior" ref="a72fcf28c5f020f3c4a7243da08229fee" args="(T func_like, Expr value, Expr min0, Expr extent0, Expr min1, Expr extent1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">Halide::BoundaryConditions::constant_exterior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00125">125</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">constant_exterior()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>.</p>

</div>
</div>
<a class="anchor" id="a98e4ccc1fc43f95a2429bddcd135af93"></a><!-- doxytag: member="Halide::BoundaryConditions::constant_exterior" ref="a98e4ccc1fc43f95a2429bddcd135af93" args="(T func_like, Expr value, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">Halide::BoundaryConditions::constant_exterior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00135">135</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">constant_exterior()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ed2c1c99a56efdf55e743ffee0a944e"></a><!-- doxytag: member="Halide::BoundaryConditions::constant_exterior" ref="a0ed2c1c99a56efdf55e743ffee0a944e" args="(T func_like, Expr value, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">Halide::BoundaryConditions::constant_exterior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00147">147</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">constant_exterior()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>.</p>

</div>
</div>
<a class="anchor" id="a21f73b3931776fae35272b5ecb81d334"></a><!-- doxytag: member="Halide::BoundaryConditions::constant_exterior" ref="a21f73b3931776fae35272b5ecb81d334" args="(T func_like, Expr value, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">Halide::BoundaryConditions::constant_exterior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00161">161</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">constant_exterior()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>.</p>

</div>
</div>
<a class="anchor" id="a2902d989503f56800196282a956f2d2a"></a><!-- doxytag: member="Halide::BoundaryConditions::constant_exterior" ref="a2902d989503f56800196282a956f2d2a" args="(T func_like, Expr value, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4, Expr min5, Expr extent5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">Halide::BoundaryConditions::constant_exterior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00177">177</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">constant_exterior()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>.</p>

</div>
</div>
<a class="anchor" id="a2432026c4f3e024c2f0082e700bef4f2"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_edge" ref="a2432026c4f3e024c2f0082e700bef4f2" args="(const Func &amp;source, const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;bounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">Halide::BoundaryConditions::repeat_edge</a> </td>
          <td>(</td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_EDGE.) </p>

<p>Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00210">repeat_edge()</a>.</p>

</div>
</div>
<a class="anchor" id="aa5497265a7aa443a6ba8bb6f8843ec57"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_edge" ref="aa5497265a7aa443a6ba8bb6f8843ec57" args="(T func_like)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">Halide::BoundaryConditions::repeat_edge</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_EDGE.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00210">210</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">repeat_edge()</a>.</p>

</div>
</div>
<a class="anchor" id="afffb3729f3334a6d64c2c2441ee20dd8"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_edge" ref="afffb3729f3334a6d64c2c2441ee20dd8" args="(T func_like, Expr min0, Expr extent0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">Halide::BoundaryConditions::repeat_edge</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_EDGE.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00229">229</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">repeat_edge()</a>.</p>

</div>
</div>
<a class="anchor" id="a528e3317346e9a642014614e9ca2d3f1"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_edge" ref="a528e3317346e9a642014614e9ca2d3f1" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">Halide::BoundaryConditions::repeat_edge</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_EDGE.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00237">237</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">repeat_edge()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c3e4c6bf9cbac6ddd7256a3b44aebfb"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_edge" ref="a7c3e4c6bf9cbac6ddd7256a3b44aebfb" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">Halide::BoundaryConditions::repeat_edge</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_EDGE.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00247">247</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">repeat_edge()</a>.</p>

</div>
</div>
<a class="anchor" id="a69c4ae257ac89aa24d57b7ecea607f49"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_edge" ref="a69c4ae257ac89aa24d57b7ecea607f49" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">Halide::BoundaryConditions::repeat_edge</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_EDGE.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00259">259</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">repeat_edge()</a>.</p>

</div>
</div>
<a class="anchor" id="a9eaa40a7033f44978af8f317fb9e26c6"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_edge" ref="a9eaa40a7033f44978af8f317fb9e26c6" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">Halide::BoundaryConditions::repeat_edge</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_EDGE.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00273">273</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">repeat_edge()</a>.</p>

</div>
</div>
<a class="anchor" id="adb99ec97e80ae6479c91214c71fe44f9"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_edge" ref="adb99ec97e80ae6479c91214c71fe44f9" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4, Expr min5, Expr extent5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">Halide::BoundaryConditions::repeat_edge</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_EDGE.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00289">289</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">repeat_edge()</a>.</p>

</div>
</div>
<a class="anchor" id="a8472a03bc5d5b544c259c928270481e4"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_image" ref="a8472a03bc5d5b544c259c928270481e4" args="(const Func &amp;source, const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;bounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">Halide::BoundaryConditions::repeat_image</a> </td>
          <td>(</td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00322">repeat_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a21dacea6046923b92ce184a68549b535"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_image" ref="a21dacea6046923b92ce184a68549b535" args="(T func_like)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">Halide::BoundaryConditions::repeat_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00322">322</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">repeat_image()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5c6c95b4a8479ddcf5135eae5811408"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_image" ref="ad5c6c95b4a8479ddcf5135eae5811408" args="(T func_like, Expr min0, Expr extent0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">Halide::BoundaryConditions::repeat_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00340">340</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">repeat_image()</a>.</p>

</div>
</div>
<a class="anchor" id="af340aa63c121d7d13690d04c2c43fa64"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_image" ref="af340aa63c121d7d13690d04c2c43fa64" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">Halide::BoundaryConditions::repeat_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00348">348</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">repeat_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a610ed59bbf566f756120db995c7fb8"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_image" ref="a6a610ed59bbf566f756120db995c7fb8" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">Halide::BoundaryConditions::repeat_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00358">358</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">repeat_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a47459c33ac4f55bd21a9fc054ec4f1cc"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_image" ref="a47459c33ac4f55bd21a9fc054ec4f1cc" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">Halide::BoundaryConditions::repeat_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00370">370</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">repeat_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c078e41888357be879f3511cb02cf3a"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_image" ref="a2c078e41888357be879f3511cb02cf3a" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">Halide::BoundaryConditions::repeat_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00384">384</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">repeat_image()</a>.</p>

</div>
</div>
<a class="anchor" id="adfef8f9357c1c5e71c77d34f95b2fbb8"></a><!-- doxytag: member="Halide::BoundaryConditions::repeat_image" ref="adfef8f9357c1c5e71c77d34f95b2fbb8" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4, Expr min5, Expr extent5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">Halide::BoundaryConditions::repeat_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00400">400</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">repeat_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d0cea1519a98d7983d754323250bd95"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_image" ref="a9d0cea1519a98d7983d754323250bd95" args="(const Func &amp;source, const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;bounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">Halide::BoundaryConditions::mirror_image</a> </td>
          <td>(</td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_MIRRORED_REPEAT.) </p>

<p>Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00433">mirror_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a90210f3878ff4e84f37e1a1d201ce7c0"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_image" ref="a90210f3878ff4e84f37e1a1d201ce7c0" args="(T func_like)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">Halide::BoundaryConditions::mirror_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00433">433</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">mirror_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a20f3907b2141da518dde88b5ce0360e7"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_image" ref="a20f3907b2141da518dde88b5ce0360e7" args="(T func_like, Expr min0, Expr extent0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">Halide::BoundaryConditions::mirror_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00451">451</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">mirror_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a9648de004485df3fef0d79d985d3c5e3"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_image" ref="a9648de004485df3fef0d79d985d3c5e3" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">Halide::BoundaryConditions::mirror_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00459">459</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">mirror_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a121810c4055788c61755d3cd5c459e63"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_image" ref="a121810c4055788c61755d3cd5c459e63" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">Halide::BoundaryConditions::mirror_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00469">469</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">mirror_image()</a>.</p>

</div>
</div>
<a class="anchor" id="abcd833d8d10bc20e8c37966b28a4a264"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_image" ref="abcd833d8d10bc20e8c37966b28a4a264" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">Halide::BoundaryConditions::mirror_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00481">481</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">mirror_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a717316832fe3f3f4ed651d40286dd8ef"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_image" ref="a717316832fe3f3f4ed651d40286dd8ef" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">Halide::BoundaryConditions::mirror_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00495">495</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">mirror_image()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9c62a0e12724ce941fc4dfccbe4eb36"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_image" ref="ab9c62a0e12724ce941fc4dfccbe4eb36" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4, Expr min5, Expr extent5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">Halide::BoundaryConditions::mirror_image</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00511">511</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">mirror_image()</a>.</p>

</div>
</div>
<a class="anchor" id="a090e3e8b50a162f92777f19b84e5b453"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_interior" ref="a090e3e8b50a162f92777f19b84e5b453" args="(const Func &amp;source, const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;bounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">Halide::BoundaryConditions::mirror_interior</a> </td>
          <td>(</td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges. </p>
<p>This produces an error if any extent is 1 or less. (TODO: check this.)</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(I do not believe there is a direct GL_TEXTURE_WRAP_* equivalent for this.) </p>

<p>Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00547">mirror_interior()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f7e2ad1955724feb83bbaec99363b91"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_interior" ref="a6f7e2ad1955724feb83bbaec99363b91" args="(T func_like)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">Halide::BoundaryConditions::mirror_interior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges. </p>
<p>This produces an error if any extent is 1 or less. (TODO: check this.)</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(I do not believe there is a direct GL_TEXTURE_WRAP_* equivalent for this.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00547">547</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">mirror_interior()</a>.</p>

</div>
</div>
<a class="anchor" id="a35d63ccb1eaca9eb2119d455994fc027"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_interior" ref="a35d63ccb1eaca9eb2119d455994fc027" args="(T func_like, Expr min0, Expr extent0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">Halide::BoundaryConditions::mirror_interior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges. </p>
<p>This produces an error if any extent is 1 or less. (TODO: check this.)</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(I do not believe there is a direct GL_TEXTURE_WRAP_* equivalent for this.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00565">565</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">mirror_interior()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c34c03095c23274ef88a9c6901e535e"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_interior" ref="a4c34c03095c23274ef88a9c6901e535e" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">Halide::BoundaryConditions::mirror_interior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges. </p>
<p>This produces an error if any extent is 1 or less. (TODO: check this.)</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(I do not believe there is a direct GL_TEXTURE_WRAP_* equivalent for this.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00573">573</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">mirror_interior()</a>.</p>

</div>
</div>
<a class="anchor" id="a06572fdbca0463371ff4989383e00c62"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_interior" ref="a06572fdbca0463371ff4989383e00c62" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">Halide::BoundaryConditions::mirror_interior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges. </p>
<p>This produces an error if any extent is 1 or less. (TODO: check this.)</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(I do not believe there is a direct GL_TEXTURE_WRAP_* equivalent for this.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00583">583</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">mirror_interior()</a>.</p>

</div>
</div>
<a class="anchor" id="a28341dfe322cdab5da3a2b9466f865b0"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_interior" ref="a28341dfe322cdab5da3a2b9466f865b0" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">Halide::BoundaryConditions::mirror_interior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges. </p>
<p>This produces an error if any extent is 1 or less. (TODO: check this.)</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(I do not believe there is a direct GL_TEXTURE_WRAP_* equivalent for this.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00595">595</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">mirror_interior()</a>.</p>

</div>
</div>
<a class="anchor" id="a7585f628b4a0cb88edbc9712c1ed119f"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_interior" ref="a7585f628b4a0cb88edbc9712c1ed119f" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">Halide::BoundaryConditions::mirror_interior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges. </p>
<p>This produces an error if any extent is 1 or less. (TODO: check this.)</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(I do not believe there is a direct GL_TEXTURE_WRAP_* equivalent for this.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00609">609</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">mirror_interior()</a>.</p>

</div>
</div>
<a class="anchor" id="ae925984131df74f183b82a44ef1ca1e3"></a><!-- doxytag: member="Halide::BoundaryConditions::mirror_interior" ref="ae925984131df74f183b82a44ef1ca1e3" args="(T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4, Expr min5, Expr extent5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">Halide::BoundaryConditions::mirror_interior</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>min5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Expr&#160;</td>
          <td class="paramname"><em>extent5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges. </p>
<p>This produces an error if any extent is 1 or less. (TODO: check this.)</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline.">ImageParam</a>, Image&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(I do not believe there is a direct GL_TEXTURE_WRAP_* equivalent for this.) </p>

<p>Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00625">625</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p>References <a class="el" href="_boundary_conditions_8h_source.html#l00064">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">mirror_interior()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a>      </li>
      <li class="navelem"><a class="el" href="namespace_halide_1_1_boundary_conditions.html">BoundaryConditions</a>      </li>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
