<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::BoundaryConditions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_halide_1_1_boundary_conditions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">Halide::BoundaryConditions Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace to hold functions for imposing boundary conditions on <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Funcs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide_1_1_boundary_conditions_1_1_internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html">Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad65753e2ba404adf3c8a1615fa67e7e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad65753e2ba404adf3c8a1615fa67e7e5">constant_exterior</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;source, <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> value, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:ad65753e2ba404adf3c8a1615fa67e7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#ad65753e2ba404adf3c8a1615fa67e7e5">More...</a><br /></td></tr>
<tr class="separator:ad65753e2ba404adf3c8a1615fa67e7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067b81624cdf509eb1f14f9485c77014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a067b81624cdf509eb1f14f9485c77014">constant_exterior</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;source, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:a067b81624cdf509eb1f14f9485c77014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a067b81624cdf509eb1f14f9485c77014">More...</a><br /></td></tr>
<tr class="separator:a067b81624cdf509eb1f14f9485c77014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403721f48e0e86d288acb9fb63bf880c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a403721f48e0e86d288acb9fb63bf880c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a403721f48e0e86d288acb9fb63bf880c">constant_exterior</a> (const T &amp;func_like, <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> value)</td></tr>
<tr class="memdesc:a403721f48e0e86d288acb9fb63bf880c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a403721f48e0e86d288acb9fb63bf880c">More...</a><br /></td></tr>
<tr class="separator:a403721f48e0e86d288acb9fb63bf880c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3c0a9315fa44215e05b12e1489ad99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d3c0a9315fa44215e05b12e1489ad99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a5d3c0a9315fa44215e05b12e1489ad99">constant_exterior</a> (const T &amp;func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value)</td></tr>
<tr class="memdesc:a5d3c0a9315fa44215e05b12e1489ad99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a5d3c0a9315fa44215e05b12e1489ad99">More...</a><br /></td></tr>
<tr class="separator:a5d3c0a9315fa44215e05b12e1489ad99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56c305fef05526a323c3c3496e79b5c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa56c305fef05526a323c3c3496e79b5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#aa56c305fef05526a323c3c3496e79b5c">constant_exterior</a> (const T &amp;func_like, <a class="el" href="class_halide_1_1_tuple.html">Tuple</a> value, Bounds &amp;&amp;... bounds)</td></tr>
<tr class="memdesc:aa56c305fef05526a323c3c3496e79b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#aa56c305fef05526a323c3c3496e79b5c">More...</a><br /></td></tr>
<tr class="separator:aa56c305fef05526a323c3c3496e79b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f9553b8d3e4a705ba55ac5a503d774"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae9f9553b8d3e4a705ba55ac5a503d774"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ae9f9553b8d3e4a705ba55ac5a503d774">constant_exterior</a> (const T &amp;func_like, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> value, Bounds &amp;&amp;... bounds)</td></tr>
<tr class="memdesc:ae9f9553b8d3e4a705ba55ac5a503d774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#ae9f9553b8d3e4a705ba55ac5a503d774">More...</a><br /></td></tr>
<tr class="separator:ae9f9553b8d3e4a705ba55ac5a503d774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a773e2cba15577ec6ed683208b4556375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a773e2cba15577ec6ed683208b4556375">repeat_edge</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;source, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:a773e2cba15577ec6ed683208b4556375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#a773e2cba15577ec6ed683208b4556375">More...</a><br /></td></tr>
<tr class="separator:a773e2cba15577ec6ed683208b4556375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af552f8e2d722e1248cf4d0a8027a81df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af552f8e2d722e1248cf4d0a8027a81df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#af552f8e2d722e1248cf4d0a8027a81df">repeat_edge</a> (const T &amp;func_like)</td></tr>
<tr class="memdesc:af552f8e2d722e1248cf4d0a8027a81df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#af552f8e2d722e1248cf4d0a8027a81df">More...</a><br /></td></tr>
<tr class="separator:af552f8e2d722e1248cf4d0a8027a81df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad6282e286f854f7d71a34746bec3c9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:acad6282e286f854f7d71a34746bec3c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#acad6282e286f854f7d71a34746bec3c9">repeat_edge</a> (const T &amp;func_like, Bounds &amp;&amp;... bounds)</td></tr>
<tr class="memdesc:acad6282e286f854f7d71a34746bec3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#acad6282e286f854f7d71a34746bec3c9">More...</a><br /></td></tr>
<tr class="separator:acad6282e286f854f7d71a34746bec3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6b1961595eb14c04860d6e67819104a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a6b1961595eb14c04860d6e67819104a6">repeat_image</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;source, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:a6b1961595eb14c04860d6e67819104a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a6b1961595eb14c04860d6e67819104a6">More...</a><br /></td></tr>
<tr class="separator:a6b1961595eb14c04860d6e67819104a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c53aee37e3c73c1b57f69a3ee17a29e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c53aee37e3c73c1b57f69a3ee17a29e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8c53aee37e3c73c1b57f69a3ee17a29e">repeat_image</a> (const T &amp;func_like)</td></tr>
<tr class="memdesc:a8c53aee37e3c73c1b57f69a3ee17a29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a8c53aee37e3c73c1b57f69a3ee17a29e">More...</a><br /></td></tr>
<tr class="separator:a8c53aee37e3c73c1b57f69a3ee17a29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7695077ee4e64ac565a3bcb49b1c3c72"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7695077ee4e64ac565a3bcb49b1c3c72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a7695077ee4e64ac565a3bcb49b1c3c72">repeat_image</a> (const T &amp;func_like, Bounds &amp;&amp;... bounds)</td></tr>
<tr class="memdesc:a7695077ee4e64ac565a3bcb49b1c3c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a7695077ee4e64ac565a3bcb49b1c3c72">More...</a><br /></td></tr>
<tr class="separator:a7695077ee4e64ac565a3bcb49b1c3c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c0fc9d62f74de85e5e9e5690d97018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a02c0fc9d62f74de85e5e9e5690d97018">mirror_image</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;source, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:a02c0fc9d62f74de85e5e9e5690d97018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same.  <a href="#a02c0fc9d62f74de85e5e9e5690d97018">More...</a><br /></td></tr>
<tr class="separator:a02c0fc9d62f74de85e5e9e5690d97018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add16db9977891439ac354596aa8208dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add16db9977891439ac354596aa8208dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#add16db9977891439ac354596aa8208dc">mirror_image</a> (const T &amp;func_like)</td></tr>
<tr class="memdesc:add16db9977891439ac354596aa8208dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#add16db9977891439ac354596aa8208dc">More...</a><br /></td></tr>
<tr class="separator:add16db9977891439ac354596aa8208dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfad9a52f73c4990e164768e0fd40be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7bfad9a52f73c4990e164768e0fd40be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a7bfad9a52f73c4990e164768e0fd40be">mirror_image</a> (const T &amp;func_like, Bounds &amp;&amp;... bounds)</td></tr>
<tr class="memdesc:a7bfad9a52f73c4990e164768e0fd40be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a7bfad9a52f73c4990e164768e0fd40be">More...</a><br /></td></tr>
<tr class="separator:a7bfad9a52f73c4990e164768e0fd40be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad5eac859bc8e6c92efc8312c615482a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad5eac859bc8e6c92efc8312c615482a2">mirror_interior</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;source, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:ad5eac859bc8e6c92efc8312c615482a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#ad5eac859bc8e6c92efc8312c615482a2">More...</a><br /></td></tr>
<tr class="separator:ad5eac859bc8e6c92efc8312c615482a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0141a01322201a6c9ef2bd93c39aa6bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0141a01322201a6c9ef2bd93c39aa6bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a0141a01322201a6c9ef2bd93c39aa6bd">mirror_interior</a> (const T &amp;func_like)</td></tr>
<tr class="memdesc:a0141a01322201a6c9ef2bd93c39aa6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a0141a01322201a6c9ef2bd93c39aa6bd">More...</a><br /></td></tr>
<tr class="separator:a0141a01322201a6c9ef2bd93c39aa6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab572a64d9edf13a6b4e30e81755ecbfd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab572a64d9edf13a6b4e30e81755ecbfd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ab572a64d9edf13a6b4e30e81755ecbfd">mirror_interior</a> (const T &amp;func_like, Bounds &amp;&amp;... bounds)</td></tr>
<tr class="memdesc:ab572a64d9edf13a6b4e30e81755ecbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#ab572a64d9edf13a6b4e30e81755ecbfd">More...</a><br /></td></tr>
<tr class="separator:ab572a64d9edf13a6b4e30e81755ecbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace to hold functions for imposing boundary conditions on <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Funcs. </p>
<p>All functions in this namespace transform a source <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> to a result <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> where the result produces the values of the source within a given region and a different set of values outside the given region. A region is an N dimensional box specified by mins and extents.</p>
<p>Three areas are defined: The image is the entire set of values in the region. The edge is the set of pixels in the image but adjacent to coordinates that are not The interior is the image minus the edge (and is undefined if the extent of any region is 1 or less).</p>
<p>If the source <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> has more dimensions than are specified, the extra ones are unmodified. Additionally, passing an undefined (default constructed) '<a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a>' for the min and extent of a dimension will keep that dimension unmodified.</p>
<p>Numerous options for specifing the outside area are provided, including replacement with an expression, repeating the edge samples, mirroring over the edge, and repeating or mirroring the entire image.</p>
<p>Using these functions to express your boundary conditions is highly recommended for correctness and performance. Some of these are hard to get right. The versions here are both understood by bounds inference, and also judiciously use the 'likely' intrinsic to minimize runtime overhead. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ad65753e2ba404adf3c8a1615fa67e7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65753e2ba404adf3c8a1615fa67e7e5">&#9670;&nbsp;</a></span>constant_exterior() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::constant_exterior </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object. Note that objects are taken by mutable ref. Pipelines capture Buffers via mutable refs, because running a pipeline might alter the <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer. ">Buffer</a> metadata (e.g. device allocation state).</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="reference">Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00092">constant_exterior()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00061">Halide::BoundaryConditions::Internal::func_like_to_func()</a>.</p>

</div>
</div>
<a id="a067b81624cdf509eb1f14f9485c77014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067b81624cdf509eb1f14f9485c77014">&#9670;&nbsp;</a></span>constant_exterior() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::constant_exterior </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object. Note that objects are taken by mutable ref. Pipelines capture Buffers via mutable refs, because running a pipeline might alter the <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer. ">Buffer</a> metadata (e.g. device allocation state).</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

</div>
</div>
<a id="a403721f48e0e86d288acb9fb63bf880c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403721f48e0e86d288acb9fb63bf880c">&#9670;&nbsp;</a></span>constant_exterior() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::constant_exterior </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object. Note that objects are taken by mutable ref. Pipelines capture Buffers via mutable refs, because running a pipeline might alter the <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer. ">Buffer</a> metadata (e.g. device allocation state).</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00092">92</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad65753e2ba404adf3c8a1615fa67e7e5">constant_exterior()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00056">Halide::BoundaryConditions::Internal::func_like_to_func()</a>.</p>

</div>
</div>
<a id="a5d3c0a9315fa44215e05b12e1489ad99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3c0a9315fa44215e05b12e1489ad99">&#9670;&nbsp;</a></span>constant_exterior() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::constant_exterior </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object. Note that objects are taken by mutable ref. Pipelines capture Buffers via mutable refs, because running a pipeline might alter the <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer. ">Buffer</a> metadata (e.g. device allocation state).</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00101">101</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad65753e2ba404adf3c8a1615fa67e7e5">constant_exterior()</a>.</p>

</div>
</div>
<a id="aa56c305fef05526a323c3c3496e79b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56c305fef05526a323c3c3496e79b5c">&#9670;&nbsp;</a></span>constant_exterior() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::constant_exterior </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_tuple.html">Tuple</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bounds &amp;&amp;...&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object. Note that objects are taken by mutable ref. Pipelines capture Buffers via mutable refs, because running a pipeline might alter the <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer. ">Buffer</a> metadata (e.g. device allocation state).</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00107">107</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00184">Halide::Internal::collect_paired_args()</a>, <a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad65753e2ba404adf3c8a1615fa67e7e5">constant_exterior()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00056">Halide::BoundaryConditions::Internal::func_like_to_func()</a>.</p>

</div>
</div>
<a id="ae9f9553b8d3e4a705ba55ac5a503d774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f9553b8d3e4a705ba55ac5a503d774">&#9670;&nbsp;</a></span>constant_exterior() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::constant_exterior </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bounds &amp;&amp;...&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a boundary condition such that a given expression is returned everywhere outside the boundary. </p>
<p>Generally the expression will be a constant, though the code currently allows accessing the arguments of source.</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object. Note that objects are taken by mutable ref. Pipelines capture Buffers via mutable refs, because running a pipeline might alter the <a class="el" href="class_halide_1_1_buffer.html" title="A Halide::Buffer is a named shared reference to a Halide::Runtime::Buffer. ">Buffer</a> metadata (e.g. device allocation state).</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER and putting value in the border of the texture.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00115">115</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad65753e2ba404adf3c8a1615fa67e7e5">constant_exterior()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a773e2cba15577ec6ed683208b4556375">repeat_edge()</a>.</p>

</div>
</div>
<a id="a773e2cba15577ec6ed683208b4556375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773e2cba15577ec6ed683208b4556375">&#9670;&nbsp;</a></span>repeat_edge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::repeat_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_EDGE.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a13">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00115">constant_exterior()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00138">repeat_edge()</a>.</p>

</div>
</div>
<a id="af552f8e2d722e1248cf4d0a8027a81df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af552f8e2d722e1248cf4d0a8027a81df">&#9670;&nbsp;</a></span>repeat_edge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::repeat_edge </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>func_like</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_EDGE.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00138">138</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">References <a class="el" href="_boundary_conditions_8h_source.html#l00056">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a773e2cba15577ec6ed683208b4556375">repeat_edge()</a>.</p>

</div>
</div>
<a id="acad6282e286f854f7d71a34746bec3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad6282e286f854f7d71a34746bec3c9">&#9670;&nbsp;</a></span>repeat_edge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::repeat_edge </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bounds &amp;&amp;...&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_EDGE.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00150">150</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00184">Halide::Internal::collect_paired_args()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00056">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a773e2cba15577ec6ed683208b4556375">repeat_edge()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a6b1961595eb14c04860d6e67819104a6">repeat_image()</a>.</p>

</div>
</div>
<a id="a6b1961595eb14c04860d6e67819104a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1961595eb14c04860d6e67819104a6">&#9670;&nbsp;</a></span>repeat_image() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::repeat_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="reference">Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00150">repeat_edge()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00174">repeat_image()</a>.</p>

</div>
</div>
<a id="a8c53aee37e3c73c1b57f69a3ee17a29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c53aee37e3c73c1b57f69a3ee17a29e">&#9670;&nbsp;</a></span>repeat_image() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::repeat_image </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>func_like</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00174">174</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">References <a class="el" href="_boundary_conditions_8h_source.html#l00056">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a6b1961595eb14c04860d6e67819104a6">repeat_image()</a>.</p>

</div>
</div>
<a id="a7695077ee4e64ac565a3bcb49b1c3c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7695077ee4e64ac565a3bcb49b1c3c72">&#9670;&nbsp;</a></span>repeat_image() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::repeat_image </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bounds &amp;&amp;...&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00185">185</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00184">Halide::Internal::collect_paired_args()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00056">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a02c0fc9d62f74de85e5e9e5690d97018">mirror_image()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a6b1961595eb14c04860d6e67819104a6">repeat_image()</a>.</p>

</div>
</div>
<a id="a02c0fc9d62f74de85e5e9e5690d97018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c0fc9d62f74de85e5e9e5690d97018">&#9670;&nbsp;</a></span>mirror_image() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::mirror_image </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_MIRRORED_REPEAT.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="reference">Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00209">mirror_image()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00185">repeat_image()</a>.</p>

</div>
</div>
<a id="add16db9977891439ac354596aa8208dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add16db9977891439ac354596aa8208dc">&#9670;&nbsp;</a></span>mirror_image() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::mirror_image </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>func_like</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00209">209</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">References <a class="el" href="_boundary_conditions_8h_source.html#l00056">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a02c0fc9d62f74de85e5e9e5690d97018">mirror_image()</a>.</p>

</div>
</div>
<a id="a7bfad9a52f73c4990e164768e0fd40be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfad9a52f73c4990e164768e0fd40be">&#9670;&nbsp;</a></span>mirror_image() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::mirror_image </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bounds &amp;&amp;...&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other. </p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(This is similar to setting GL_TEXTURE_WRAP_* to GL_REPEAT.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00220">220</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00184">Halide::Internal::collect_paired_args()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00056">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, <a class="el" href="namespace_halide_1_1_boundary_conditions.html#a02c0fc9d62f74de85e5e9e5690d97018">mirror_image()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad5eac859bc8e6c92efc8312c615482a2">mirror_interior()</a>.</p>

</div>
</div>
<a id="ad5eac859bc8e6c92efc8312c615482a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5eac859bc8e6c92efc8312c615482a2">&#9670;&nbsp;</a></span>mirror_interior() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::mirror_interior </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a>, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges. </p>
<p>This produces an error if any extent is 1 or less. (TODO: check this.)</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(I do not believe there is a direct GL_TEXTURE_WRAP_* equivalent for this.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="reference">Referenced by <a class="el" href="_boundary_conditions_8h_source.html#l00220">mirror_image()</a>, and <a class="el" href="_boundary_conditions_8h_source.html#l00247">mirror_interior()</a>.</p>

</div>
</div>
<a id="a0141a01322201a6c9ef2bd93c39aa6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0141a01322201a6c9ef2bd93c39aa6bd">&#9670;&nbsp;</a></span>mirror_interior() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::mirror_interior </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>func_like</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges. </p>
<p>This produces an error if any extent is 1 or less. (TODO: check this.)</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(I do not believe there is a direct GL_TEXTURE_WRAP_* equivalent for this.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00247">247</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">References <a class="el" href="_boundary_conditions_8h_source.html#l00056">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad5eac859bc8e6c92efc8312c615482a2">mirror_interior()</a>.</p>

</div>
</div>
<a id="ab572a64d9edf13a6b4e30e81755ecbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab572a64d9edf13a6b4e30e81755ecbfd">&#9670;&nbsp;</a></span>mirror_interior() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> <a class="el" href="class_halide_1_1_func.html">Func</a> Halide::BoundaryConditions::mirror_interior </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>func_like</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bounds &amp;&amp;...&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges. </p>
<p>This produces an error if any extent is 1 or less. (TODO: check this.)</p>
<p>An <a class="el" href="class_halide_1_1_image_param.html" title="An Image parameter to a halide pipeline. ">ImageParam</a>, Buffer&lt;T&gt;, or similar can be passed instead of a <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. If this is done and no bounds are given, the boundaries will be taken from the min and extent methods of the passed object.</p>
<p>(I do not believe there is a direct GL_TEXTURE_WRAP_* equivalent for this.)</p>
<p>You may pass undefined Exprs for dimensions that you do not wish to bound. </p>

<p class="definition">Definition at line <a class="el" href="_boundary_conditions_8h_source.html#l00258">258</a> of file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00184">Halide::Internal::collect_paired_args()</a>, <a class="el" href="_boundary_conditions_8h_source.html#l00056">Halide::BoundaryConditions::Internal::func_like_to_func()</a>, and <a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad5eac859bc8e6c92efc8312c615482a2">mirror_interior()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_boundary_conditions.html">BoundaryConditions</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
