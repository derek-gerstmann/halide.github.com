<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Halide: HalideRuntime.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_halide_runtime_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HalideRuntime.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Set a custom malloc and free for halide to use.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
</div>
<p><a href="_halide_runtime_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__mutex.html">halide_mutex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These are allocated statically inside the runtime, hence the fixed size.  <a href="structhalide__mutex.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__trace__event.html">halide_trace_event</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ac87d020eed3438306b57d1eec5de0364">halide_assert</a>(user_context, cond)&#160;&#160;&#160;if (!(cond)) <a class="el" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8">halide_error</a>(user_context, #cond);</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro that calls halide_error if the supplied condition is false.  <a href="#ac87d020eed3438306b57d1eec5de0364"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7c">halide_trace_event_code</a> { <br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7ca2cbd3048c959f6d8def944097d8e21c9">halide_trace_load</a> =  0, 
<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7ca57b32d087e0862bd6ba748ce7743a851">halide_trace_store</a> =  1, 
<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7cad8657c19f6b2b9cc79fa3a438f39687b">halide_trace_begin_realization</a> =  2, 
<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7cacb0bdc3e4044609ab7fae05b921595ab">halide_trace_end_realization</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7cac4047c93cd032261e8373e38944bf7a1">halide_trace_produce</a> =  4, 
<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7ca19c97ad2b3f68b3393eba6e48f8f828d">halide_trace_update</a> =  5, 
<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7ca0dac17982d8ef6c404f94e5b7dd4de54">halide_trace_consume</a> =  6, 
<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7cac98849a734841652345dc3d37660c136">halide_trace_end_consume</a> =  7
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aea37ca2e04077132c617c02780e352e7">halide_printf</a> (void *user_context, const char *,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_printf to catch debugging output, informational messages, etc.  <a href="#aea37ca2e04077132c617c02780e352e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a96fe1dd85166a7f0da1b8f82f734296a">halide_print</a> (void *user_context, const char *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unformatted print used to support halide_printf.  <a href="#a96fe1dd85166a7f0da1b8f82f734296a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a570aecb8f41519bc12356d1e63f68160">halide_set_num_threads</a> (int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of threads used by <a class="el" href="namespace_halide.html">Halide</a>'s thread pool.  <a href="#a570aecb8f41519bc12356d1e63f68160"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a173a9669d4c2a9fb6fa0225a5fdabcd4">halide_debug_to_file</a> (void *user_context, const char *filename, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *data, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> s0, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> s1, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> s2, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> s3, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> type_code, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> bytes_per_element)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when debug_to_file is used inside Halide code.  <a href="#a173a9669d4c2a9fb6fa0225a5fdabcd4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a15078a46b8fe517dcfdd26acadd2293a">halide_trace</a> (void *user_context, const <a class="el" href="structhalide__trace__event.html">halide_trace_event</a> *event)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when Funcs are marked as trace_load, trace_store, or trace_realization.  <a href="#a15078a46b8fe517dcfdd26acadd2293a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a8761e708f878372e3201126e83d6f3b6">halide_set_trace_file</a> (int fd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the file descriptor that <a class="el" href="namespace_halide.html">Halide</a> should write binary trace events to.  <a href="#a8761e708f878372e3201126e83d6f3b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aee99b65dcbc81d91a0f22507eb7f8017">halide_get_trace_file</a> (void *user_context)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html">Halide</a> calls this to retrieve the file descriptor to write binary trace events to.  <a href="#aee99b65dcbc81d91a0f22507eb7f8017"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a618bb97f5d713e1097835a24670948f4">halide_shutdown_trace</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If tracing is writing to a file.  <a href="#a618bb97f5d713e1097835a24670948f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aa3336507011f272702be76b8668a4223">halide_release</a> (void *user_context)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all data associated with the current GPU backend, in particular all resources (memory, texture, context handles) allocated by <a class="el" href="namespace_halide.html">Halide</a>.  <a href="#aa3336507011f272702be76b8668a4223"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5980f17918155363078056e6a32de301">halide_copy_to_host</a> (void *user_context, struct buffer_t *buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image data from device memory to host memory.  <a href="#a5980f17918155363078056e6a32de301"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a51c066523af8ea5c476babebc051061a">halide_copy_to_dev</a> (void *user_context, struct buffer_t *buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image data from host memory to device memory.  <a href="#a51c066523af8ea5c476babebc051061a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5d0d5c66821f18b322fbef049632badc">halide_dev_sync</a> (void *user_context)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for current GPU operations to complete.  <a href="#a5d0d5c66821f18b322fbef049632badc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a1205c5228e24e6a947c43a4b9e10ffff">halide_dev_malloc</a> (void *user_context, struct buffer_t *buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate device memory to back a buffer_t.  <a href="#a1205c5228e24e6a947c43a4b9e10ffff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a3b79a2db1cf800928cdf19e9de6e188c">halide_dev_free</a> (void *user_context, struct buffer_t *buf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free any device memory associated with a buffer_t.  <a href="#a3b79a2db1cf800928cdf19e9de6e188c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ad5f681f46f851d44c4d173d66e5e910a">halide_set_ocl_platform_name</a> (const char *n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the platform name for OpenCL to use (e.g.  <a href="#ad5f681f46f851d44c4d173d66e5e910a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a64c33370bdb3a8658fd3af9761202327">halide_get_ocl_platform_name</a> (void *user_context)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html">Halide</a> calls this to get the desired OpenCL platform name.  <a href="#a64c33370bdb3a8658fd3af9761202327"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a2f3b66919538ffee8d34b9ef75363efc">halide_set_ocl_device_type</a> (const char *n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device type for OpenCL to use.  <a href="#a2f3b66919538ffee8d34b9ef75363efc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a72541e5329699ce42f5831f58c49bc58">halide_get_ocl_device_type</a> (void *user_context)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html">Halide</a> calls this to gets the desired OpenCL device type.  <a href="#a72541e5329699ce42f5831f58c49bc58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a9906fca5a688c26e0465a1b3da84ccfb">halide_set_gpu_device</a> (int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects which gpu device to use.  <a href="#a9906fca5a688c26e0465a1b3da84ccfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#adc511579a9ad82da9c1c611f008dd454">halide_get_gpu_device</a> (void *user_context)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html">Halide</a> calls this to get the desired halide gpu device setting.  <a href="#adc511579a9ad82da9c1c611f008dd454"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#abf85692a77aec0b887f345d0d3ca6777">halide_memoization_cache_set_size</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the soft maximum amount of memory, in bytes, that the LRU cache will use to memoize Func results.  <a href="#abf85692a77aec0b887f345d0d3ca6777"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a614935dfe37c71329d306f096eadc7d3">halide_memoization_cache_lookup</a> (void *user_context, const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *cache_key, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> size, buffer_t *realized_bounds, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> tuple_count,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, determine if the result is in the cache and return it if so.  <a href="#a614935dfe37c71329d306f096eadc7d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a8a984dad5fa50f432872335641e08479">halide_memoization_cache_store</a> (void *user_context, const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *cache_key, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> size, buffer_t *realized_bounds, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> tuple_count,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, store the result in the cache for futre access by halide_memoization_cache_lookup.  <a href="#a8a984dad5fa50f432872335641e08479"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a30f9bdd5b6ac08b3fa785f3332cca996">halide_memoization_cache_cleanup</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory and resources associated with the memoization cache.  <a href="#a30f9bdd5b6ac08b3fa785f3332cca996"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8">halide_error</a> (void *user_context, const char *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_error to catch errors messages at runtime, for example bounds checking failures.  <a href="#aea28d04de54b94f0dd6ada140b7734d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ac41e5e7a06aaa39fc69369755a1cb4f7">halide_error_varargs</a> (void *user_context, const char *,...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_error to catch errors messages at runtime, for example bounds checking failures.  <a href="#ac41e5e7a06aaa39fc69369755a1cb4f7"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a479133225b3cdf7b931f3c44e878e4e8">halide_mutex_lock</a> (struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *mutex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic set of mutex functions, which call platform specific code for mutual exclusion.  <a href="#a479133225b3cdf7b931f3c44e878e4e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5e9b62fd2c1d38e6f06100b827830377">halide_mutex_unlock</a> (struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *mutex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic set of mutex functions, which call platform specific code for mutual exclusion.  <a href="#a5e9b62fd2c1d38e6f06100b827830377"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aa6af6c192bfc0ad72171b66df883e2d4">halide_mutex_cleanup</a> (struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *mutex_arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic set of mutex functions, which call platform specific code for mutual exclusion.  <a href="#aa6af6c192bfc0ad72171b66df883e2d4"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a05193f80c8fc7df76ceadd82c4ce7b56">halide_do_par_for</a> (void *user_context, int(*f)(void *ctx, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *), int min, int size, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_do_par_for to replace the default thread pool implementation.  <a href="#a05193f80c8fc7df76ceadd82c4ce7b56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5e9d22d2b79a3dc66a32159423b17910">halide_shutdown_thread_pool</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_do_par_for to replace the default thread pool implementation.  <a href="#a5e9d22d2b79a3dc66a32159423b17910"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aa5bb359ed77ef4c1f89251bcd7eb2613">halide_malloc</a> (void *user_context, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_malloc and halide_free to replace the default memory allocator.  <a href="#aa5bb359ed77ef4c1f89251bcd7eb2613"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a2fa49d775b9a20fab152a0650c4c936b">halide_free</a> (void *user_context, void *ptr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_malloc and halide_free to replace the default memory allocator.  <a href="#a2fa49d775b9a20fab152a0650c4c936b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a1ba1ec4f81099a9999030b5829f55918">halide_init_kernels</a> (void *user_context, void **state_ptr, const char *src, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These are forward declared here to ensure they have the same signature across different <a class="el" href="namespace_halide.html">Halide</a> gpu backends.  <a href="#a1ba1ec4f81099a9999030b5829f55918"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a87dd2729ec5aafc370a8b64d5e438544">halide_dev_run</a> (void *user_context, void *state_ptr, const char *entry_name, int blocksX, int blocksY, int blocksZ, int threadsX, int threadsY, int threadsZ, int shared_mem_bytes, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> arg_sizes[], void *args[])</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">These are forward declared here to ensure they have the same signature across different <a class="el" href="namespace_halide.html">Halide</a> gpu backends.  <a href="#a87dd2729ec5aafc370a8b64d5e438544"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Set a custom malloc and free for halide to use. </p>
<p>This file exports all routines which can be replaced by an application hosting code generated by Halide.</p>
<p>Malloc should return 32-byte aligned chunks of memory, and it should be safe for <a class="el" href="namespace_halide.html">Halide</a> to read slightly out of bounds (up to 8 bytes before the start or beyond the end). If compiling statically, routines with appropriate signatures can be provided directly </p>
<div class="fragment"><pre class="fragment">     <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *<a class="code" href="_halide_runtime_8h.html#aa5bb359ed77ef4c1f89251bcd7eb2613" title="Define halide_malloc and halide_free to replace the default memory allocator.">halide_malloc</a>(<span class="keywordtype">void</span> *, <span class="keywordtype">size_t</span>)
     extern &quot;C&quot; <span class="keywordtype">void</span> <a class="code" href="_halide_runtime_8h.html#a2fa49d775b9a20fab152a0650c4c936b" title="Define halide_malloc and halide_free to replace the default memory allocator.">halide_free</a>(<span class="keywordtype">void</span> *, <span class="keywordtype">void</span> *)
</pre></div><p> These will clobber <a class="el" href="namespace_halide.html">Halide</a>'s versions. See for declarations.</p>
<p>These are used when doing Ahead Of Time (AOT) compilation and must be supplied to the linker to override a routine. I.e., just define your own version of any of these functions with extern "C" linkage, and it should replace the default one.</p>
<p>When doing Just In Time (JIT) compilation methods on the Func being compiled must be called instead. The corresponding methods are documented below.</p>
<p>All of these functions take a "void *user_context" parameter as their first argument; if the <a class="el" href="namespace_halide.html">Halide</a> kernel that calls back to any of these funcions has been defined with a "__user_context" parameter XXXXXXXX, then the value of that pointer passed from the code that calls the <a class="el" href="namespace_halide.html">Halide</a> kernel is piped through to the function.</p>
<p>Some of these are also useful to call when using the default implementation. E.g. halide_shutdown_thread_pool.</p>
<p>Note that some linker setups may not respect the override you provide. E.g. if the override is in a shared library and the halide object files are linked directly into the output, the builtin versions of the runtime functions will be called. See your linker documentation for more details. On Linux, LD_DYNAMIC_WEAK=1 may help. </p>

<p>Definition in file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="ac87d020eed3438306b57d1eec5de0364"></a><!-- doxytag: member="HalideRuntime.h::halide_assert" ref="ac87d020eed3438306b57d1eec5de0364" args="(user_context, cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="_halide_runtime_8h.html#ac87d020eed3438306b57d1eec5de0364">halide_assert</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">user_context, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cond&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;if (!(cond)) <a class="el" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8">halide_error</a>(user_context, #cond);</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A macro that calls halide_error if the supplied condition is false. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00074">74</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

<p>Referenced by <a class="el" href="cuda__opencl__shared_8h_source.html#l00014">Halide::Runtime::Internal::buf_size()</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7c"></a><!-- doxytag: member="HalideRuntime.h::halide_trace_event_code" ref="ad66527fdd9cb140d1e424c4567ef9b7c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7c">halide_trace_event_code</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7ca2cbd3048c959f6d8def944097d8e21c9"></a><!-- doxytag: member="halide_trace_load" ref="ad66527fdd9cb140d1e424c4567ef9b7ca2cbd3048c959f6d8def944097d8e21c9" args="" -->halide_trace_load</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7ca57b32d087e0862bd6ba748ce7743a851"></a><!-- doxytag: member="halide_trace_store" ref="ad66527fdd9cb140d1e424c4567ef9b7ca57b32d087e0862bd6ba748ce7743a851" args="" -->halide_trace_store</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7cad8657c19f6b2b9cc79fa3a438f39687b"></a><!-- doxytag: member="halide_trace_begin_realization" ref="ad66527fdd9cb140d1e424c4567ef9b7cad8657c19f6b2b9cc79fa3a438f39687b" args="" -->halide_trace_begin_realization</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7cacb0bdc3e4044609ab7fae05b921595ab"></a><!-- doxytag: member="halide_trace_end_realization" ref="ad66527fdd9cb140d1e424c4567ef9b7cacb0bdc3e4044609ab7fae05b921595ab" args="" -->halide_trace_end_realization</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7cac4047c93cd032261e8373e38944bf7a1"></a><!-- doxytag: member="halide_trace_produce" ref="ad66527fdd9cb140d1e424c4567ef9b7cac4047c93cd032261e8373e38944bf7a1" args="" -->halide_trace_produce</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7ca19c97ad2b3f68b3393eba6e48f8f828d"></a><!-- doxytag: member="halide_trace_update" ref="ad66527fdd9cb140d1e424c4567ef9b7ca19c97ad2b3f68b3393eba6e48f8f828d" args="" -->halide_trace_update</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7ca0dac17982d8ef6c404f94e5b7dd4de54"></a><!-- doxytag: member="halide_trace_consume" ref="ad66527fdd9cb140d1e424c4567ef9b7ca0dac17982d8ef6c404f94e5b7dd4de54" args="" -->halide_trace_consume</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7cac98849a734841652345dc3d37660c136"></a><!-- doxytag: member="halide_trace_end_consume" ref="ad66527fdd9cb140d1e424c4567ef9b7cac98849a734841652345dc3d37660c136" args="" -->halide_trace_end_consume</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00140">140</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aea37ca2e04077132c617c02780e352e7"></a><!-- doxytag: member="HalideRuntime.h::halide_printf" ref="aea37ca2e04077132c617c02780e352e7" args="(void *user_context, const char *,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_halide_runtime_8h.html#aea37ca2e04077132c617c02780e352e7">halide_printf</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define halide_printf to catch debugging output, informational messages, etc. </p>
<p>Main use is to support HL_TRACE functionality and PrintStmt in IR. Also called by the default halide_error implementation.</p>
<p>This function is implemented using <a class="el" href="_halide_runtime_8h.html#a96fe1dd85166a7f0da1b8f82f734296a">halide_print</a>. </p>

</div>
</div>
<a class="anchor" id="a96fe1dd85166a7f0da1b8f82f734296a"></a><!-- doxytag: member="HalideRuntime.h::halide_print" ref="a96fe1dd85166a7f0da1b8f82f734296a" args="(void *user_context, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#a96fe1dd85166a7f0da1b8f82f734296a">halide_print</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unformatted print used to support halide_printf. </p>
<p>This function can be replaced in JITed code by using halide_custom_print and providing an implementation of halide_print in AOT code. See Func::set_custom_print. </p>

</div>
</div>
<a class="anchor" id="aea28d04de54b94f0dd6ada140b7734d8"></a><!-- doxytag: member="HalideRuntime.h::halide_error" ref="aea28d04de54b94f0dd6ada140b7734d8" args="(void *user_context, const char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8">halide_error</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define halide_error to catch errors messages at runtime, for example bounds checking failures. </p>
<p>This function can be replaced in JITed code by using halide_set_error_handler and providing an implementation of halide_error in AOT code. See Func::set_error_handler. </p>

</div>
</div>
<a class="anchor" id="ac41e5e7a06aaa39fc69369755a1cb4f7"></a><!-- doxytag: member="HalideRuntime.h::halide_error_varargs" ref="ac41e5e7a06aaa39fc69369755a1cb4f7" args="(void *user_context, const char *,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#ac41e5e7a06aaa39fc69369755a1cb4f7">halide_error_varargs</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define halide_error to catch errors messages at runtime, for example bounds checking failures. </p>
<p>This function can be replaced in JITed code by using halide_set_error_handler and providing an implementation of halide_error in AOT code. See Func::set_error_handler. </p>

</div>
</div>
<a class="anchor" id="a479133225b3cdf7b931f3c44e878e4e8"></a><!-- doxytag: member="HalideRuntime.h::halide_mutex_lock" ref="a479133225b3cdf7b931f3c44e878e4e8" args="(struct halide_mutex *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#a479133225b3cdf7b931f3c44e878e4e8">halide_mutex_lock</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A basic set of mutex functions, which call platform specific code for mutual exclusion. </p>

<p>Referenced by <a class="el" href="scoped__mutex__lock_8h_source.html#l00012">Halide::Runtime::Internal::ScopedMutexLock::ScopedMutexLock()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e9b62fd2c1d38e6f06100b827830377"></a><!-- doxytag: member="HalideRuntime.h::halide_mutex_unlock" ref="a5e9b62fd2c1d38e6f06100b827830377" args="(struct halide_mutex *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#a5e9b62fd2c1d38e6f06100b827830377">halide_mutex_unlock</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A basic set of mutex functions, which call platform specific code for mutual exclusion. </p>

<p>Referenced by <a class="el" href="scoped__mutex__lock_8h_source.html#l00016">Halide::Runtime::Internal::ScopedMutexLock::~ScopedMutexLock()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6af6c192bfc0ad72171b66df883e2d4"></a><!-- doxytag: member="HalideRuntime.h::halide_mutex_cleanup" ref="aa6af6c192bfc0ad72171b66df883e2d4" args="(struct halide_mutex *mutex_arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#aa6af6c192bfc0ad72171b66df883e2d4">halide_mutex_cleanup</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A basic set of mutex functions, which call platform specific code for mutual exclusion. </p>

</div>
</div>
<a class="anchor" id="a05193f80c8fc7df76ceadd82c4ce7b56"></a><!-- doxytag: member="HalideRuntime.h::halide_do_par_for" ref="a05193f80c8fc7df76ceadd82c4ce7b56" args="(void *user_context, int(*f)(void *ctx, int, uint8_t *), int min, int size, uint8_t *closure)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_halide_runtime_8h.html#a05193f80c8fc7df76ceadd82c4ce7b56">halide_do_par_for</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *ctx, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define halide_do_par_for to replace the default thread pool implementation. </p>
<p>halide_shutdown_thread_pool can also be called to release resources used by the default thread pool on platforms where it makes sense. (E.g. On Mac OS, Grand Central Dispatch is used so Halide does not own the threads backing the pool and they cannot be released.) See Func::set_custom_do_task and Func::set_custom_do_par_for. Should return zero if all the jobs return zero, or an arbitrarily chosen return value from one of the jobs otherwise. </p>

</div>
</div>
<a class="anchor" id="a5e9d22d2b79a3dc66a32159423b17910"></a><!-- doxytag: member="HalideRuntime.h::halide_shutdown_thread_pool" ref="a5e9d22d2b79a3dc66a32159423b17910" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#a5e9d22d2b79a3dc66a32159423b17910">halide_shutdown_thread_pool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define halide_do_par_for to replace the default thread pool implementation. </p>
<p>halide_shutdown_thread_pool can also be called to release resources used by the default thread pool on platforms where it makes sense. (E.g. On Mac OS, Grand Central Dispatch is used so Halide does not own the threads backing the pool and they cannot be released.) See Func::set_custom_do_task and Func::set_custom_do_par_for. Should return zero if all the jobs return zero, or an arbitrarily chosen return value from one of the jobs otherwise. </p>

</div>
</div>
<a class="anchor" id="a570aecb8f41519bc12356d1e63f68160"></a><!-- doxytag: member="HalideRuntime.h::halide_set_num_threads" ref="a570aecb8f41519bc12356d1e63f68160" args="(int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#a570aecb8f41519bc12356d1e63f68160">halide_set_num_threads</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the number of threads used by <a class="el" href="namespace_halide.html">Halide</a>'s thread pool. </p>
<p>No effect on OS X or iOS. If changed after the first use of a parallel <a class="el" href="namespace_halide.html">Halide</a> routine, shuts down and then reinitializes the thread pool. </p>

</div>
</div>
<a class="anchor" id="aa5bb359ed77ef4c1f89251bcd7eb2613"></a><!-- doxytag: member="HalideRuntime.h::halide_malloc" ref="aa5bb359ed77ef4c1f89251bcd7eb2613" args="(void *user_context, size_t x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="_halide_runtime_8h.html#aa5bb359ed77ef4c1f89251bcd7eb2613">halide_malloc</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define halide_malloc and halide_free to replace the default memory allocator. </p>
<p>See Func::set_custom_allocator. (Specifically note that halide_malloc must return a 32-byte aligned pointer, and it must be safe to read at least 8 bytes before the start and beyond the end.) </p>

</div>
</div>
<a class="anchor" id="a2fa49d775b9a20fab152a0650c4c936b"></a><!-- doxytag: member="HalideRuntime.h::halide_free" ref="a2fa49d775b9a20fab152a0650c4c936b" args="(void *user_context, void *ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#a2fa49d775b9a20fab152a0650c4c936b">halide_free</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define halide_malloc and halide_free to replace the default memory allocator. </p>
<p>See Func::set_custom_allocator. (Specifically note that halide_malloc must return a 32-byte aligned pointer, and it must be safe to read at least 8 bytes before the start and beyond the end.) </p>

</div>
</div>
<a class="anchor" id="a173a9669d4c2a9fb6fa0225a5fdabcd4"></a><!-- doxytag: member="HalideRuntime.h::halide_debug_to_file" ref="a173a9669d4c2a9fb6fa0225a5fdabcd4" args="(void *user_context, const char *filename, uint8_t *data, int32_t s0, int32_t s1, int32_t s2, int32_t s3, int32_t type_code, int32_t bytes_per_element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> <a class="el" href="_halide_runtime_8h.html#a173a9669d4c2a9fb6fa0225a5fdabcd4">halide_debug_to_file</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>s0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>type_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>bytes_per_element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when debug_to_file is used inside Halide code. </p>
<p>See Func::debug_to_file for how this is called</p>
<p>Cannot be replaced in JITted code at present. </p>

</div>
</div>
<a class="anchor" id="a15078a46b8fe517dcfdd26acadd2293a"></a><!-- doxytag: member="HalideRuntime.h::halide_trace" ref="a15078a46b8fe517dcfdd26acadd2293a" args="(void *user_context, const halide_trace_event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> <a class="el" href="_halide_runtime_8h.html#a15078a46b8fe517dcfdd26acadd2293a">halide_trace</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__trace__event.html">halide_trace_event</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called when Funcs are marked as trace_load, trace_store, or trace_realization. </p>
<p>See Func::set_custom_trace. The default implementation either prints events via halide_printf, or if HL_TRACE_FILE is defined, dumps the trace to that file in a yet-to-be-documented binary format (see src/runtime/tracing.cpp to reverse engineer the format). If the trace is going to be large, you may want to make the file a named pipe, and then read from that pipe into gzip.</p>
<p>halide_trace returns a unique ID which will be passed to future events that "belong" to the earlier event as the parent id. The ownership hierarchy looks like:</p>
<p>begin_realization produce store update load/store consume load end_consume end_realization</p>
<p>Threading means that ownership cannot be inferred from the ordering of events. There can be many active realizations of a given function, or many active productions for a single realization. Within a single production, the ordering of events is meaningful. </p>

</div>
</div>
<a class="anchor" id="a8761e708f878372e3201126e83d6f3b6"></a><!-- doxytag: member="HalideRuntime.h::halide_set_trace_file" ref="a8761e708f878372e3201126e83d6f3b6" args="(int fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#a8761e708f878372e3201126e83d6f3b6">halide_set_trace_file</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the file descriptor that <a class="el" href="namespace_halide.html">Halide</a> should write binary trace events to. </p>
<p>If called with 0 as the argument, <a class="el" href="namespace_halide.html">Halide</a> outputs trace information to stdout in a human-readable format. If never called, <a class="el" href="namespace_halide.html">Halide</a> checks the for existence of an environment variable called HL_TRACE_FILE and opens that file. If HL_TRACE_FILE is not defined, it outputs trace information to stdout in a human-readable format. </p>

</div>
</div>
<a class="anchor" id="aee99b65dcbc81d91a0f22507eb7f8017"></a><!-- doxytag: member="HalideRuntime.h::halide_get_trace_file" ref="aee99b65dcbc81d91a0f22507eb7f8017" args="(void *user_context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_halide_runtime_8h.html#aee99b65dcbc81d91a0f22507eb7f8017">halide_get_trace_file</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespace_halide.html">Halide</a> calls this to retrieve the file descriptor to write binary trace events to. </p>
<p>The default implementation returns the value set by halide_set_trace_file. Implement it yourself if you wish to use a custom file descriptor per user_context. Return zero from your implementation to tell <a class="el" href="namespace_halide.html">Halide</a> to print human-readable trace information to stdout. </p>

</div>
</div>
<a class="anchor" id="a618bb97f5d713e1097835a24670948f4"></a><!-- doxytag: member="HalideRuntime.h::halide_shutdown_trace" ref="a618bb97f5d713e1097835a24670948f4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_halide_runtime_8h.html#a618bb97f5d713e1097835a24670948f4">halide_shutdown_trace</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If tracing is writing to a file. </p>
<p>This call closes that file (flushing the trace). Returns zero on success. </p>

</div>
</div>
<a class="anchor" id="aa3336507011f272702be76b8668a4223"></a><!-- doxytag: member="HalideRuntime.h::halide_release" ref="aa3336507011f272702be76b8668a4223" args="(void *user_context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#aa3336507011f272702be76b8668a4223">halide_release</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release all data associated with the current GPU backend, in particular all resources (memory, texture, context handles) allocated by <a class="el" href="namespace_halide.html">Halide</a>. </p>
<p>Must be called explicitly when using AOT compilation. </p>

</div>
</div>
<a class="anchor" id="a5980f17918155363078056e6a32de301"></a><!-- doxytag: member="HalideRuntime.h::halide_copy_to_host" ref="a5980f17918155363078056e6a32de301" args="(void *user_context, struct buffer_t *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_halide_runtime_8h.html#a5980f17918155363078056e6a32de301">halide_copy_to_host</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct buffer_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy image data from device memory to host memory. </p>
<p>This must be called explicitly to copy back the results of a GPU-based filter. </p>

</div>
</div>
<a class="anchor" id="a51c066523af8ea5c476babebc051061a"></a><!-- doxytag: member="HalideRuntime.h::halide_copy_to_dev" ref="a51c066523af8ea5c476babebc051061a" args="(void *user_context, struct buffer_t *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_halide_runtime_8h.html#a51c066523af8ea5c476babebc051061a">halide_copy_to_dev</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct buffer_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy image data from host memory to device memory. </p>
<p>This should not be called directly; <a class="el" href="namespace_halide.html">Halide</a> handles copying to the device automatically. </p>

</div>
</div>
<a class="anchor" id="a5d0d5c66821f18b322fbef049632badc"></a><!-- doxytag: member="HalideRuntime.h::halide_dev_sync" ref="a5d0d5c66821f18b322fbef049632badc" args="(void *user_context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_halide_runtime_8h.html#a5d0d5c66821f18b322fbef049632badc">halide_dev_sync</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for current GPU operations to complete. </p>
<p>Calling this explicitly should rarely be necessary, except maybe for profiling. </p>

</div>
</div>
<a class="anchor" id="a1205c5228e24e6a947c43a4b9e10ffff"></a><!-- doxytag: member="HalideRuntime.h::halide_dev_malloc" ref="a1205c5228e24e6a947c43a4b9e10ffff" args="(void *user_context, struct buffer_t *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_halide_runtime_8h.html#a1205c5228e24e6a947c43a4b9e10ffff">halide_dev_malloc</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct buffer_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate device memory to back a buffer_t. </p>

</div>
</div>
<a class="anchor" id="a3b79a2db1cf800928cdf19e9de6e188c"></a><!-- doxytag: member="HalideRuntime.h::halide_dev_free" ref="a3b79a2db1cf800928cdf19e9de6e188c" args="(void *user_context, struct buffer_t *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_halide_runtime_8h.html#a3b79a2db1cf800928cdf19e9de6e188c">halide_dev_free</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct buffer_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free any device memory associated with a buffer_t. </p>

</div>
</div>
<a class="anchor" id="a1ba1ec4f81099a9999030b5829f55918"></a><!-- doxytag: member="HalideRuntime.h::halide_init_kernels" ref="a1ba1ec4f81099a9999030b5829f55918" args="(void *user_context, void **state_ptr, const char *src, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_halide_runtime_8h.html#a1ba1ec4f81099a9999030b5829f55918">halide_init_kernels</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>state_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These are forward declared here to ensure they have the same signature across different <a class="el" href="namespace_halide.html">Halide</a> gpu backends. </p>
<p>Do not call them. </p>

</div>
</div>
<a class="anchor" id="a87dd2729ec5aafc370a8b64d5e438544"></a><!-- doxytag: member="HalideRuntime.h::halide_dev_run" ref="a87dd2729ec5aafc370a8b64d5e438544" args="(void *user_context, void *state_ptr, const char *entry_name, int blocksX, int blocksY, int blocksZ, int threadsX, int threadsY, int threadsZ, int shared_mem_bytes, size_t arg_sizes[], void *args[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_halide_runtime_8h.html#a87dd2729ec5aafc370a8b64d5e438544">halide_dev_run</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>state_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>entry_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocksZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threadsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threadsY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threadsZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shared_mem_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>arg_sizes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>These are forward declared here to ensure they have the same signature across different <a class="el" href="namespace_halide.html">Halide</a> gpu backends. </p>
<p>Do not call them. </p>

</div>
</div>
<a class="anchor" id="ad5f681f46f851d44c4d173d66e5e910a"></a><!-- doxytag: member="HalideRuntime.h::halide_set_ocl_platform_name" ref="ad5f681f46f851d44c4d173d66e5e910a" args="(const char *n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#ad5f681f46f851d44c4d173d66e5e910a">halide_set_ocl_platform_name</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the platform name for OpenCL to use (e.g. </p>
<p>"Intel" or "NVIDIA"). The argument is copied internally. The opencl runtime will select a platform that includes this as a substring. If never called, <a class="el" href="namespace_halide.html">Halide</a> uses the environment variable HL_OCL_PLATFORM_NAME, or defaults to the first available platform. </p>

</div>
</div>
<a class="anchor" id="a64c33370bdb3a8658fd3af9761202327"></a><!-- doxytag: member="HalideRuntime.h::halide_get_ocl_platform_name" ref="a64c33370bdb3a8658fd3af9761202327" args="(void *user_context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="_halide_runtime_8h.html#a64c33370bdb3a8658fd3af9761202327">halide_get_ocl_platform_name</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespace_halide.html">Halide</a> calls this to get the desired OpenCL platform name. </p>
<p>Implement this yourself to use a different platform per user_context. The default implementation returns the value set by halide_set_ocl_platform_name, or the value of the environment variable HL_OCL_PLATFORM_NAME. The output is valid until the next call to halide_set_ocl_platform_name. </p>

</div>
</div>
<a class="anchor" id="a2f3b66919538ffee8d34b9ef75363efc"></a><!-- doxytag: member="HalideRuntime.h::halide_set_ocl_device_type" ref="a2f3b66919538ffee8d34b9ef75363efc" args="(const char *n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#a2f3b66919538ffee8d34b9ef75363efc">halide_set_ocl_device_type</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the device type for OpenCL to use. </p>
<p>The argument is copied internally. It must be "cpu", "gpu", or "acc". If never called, <a class="el" href="namespace_halide.html">Halide</a> uses the environment variable HL_OCL_DEVICE_TYPE. </p>

</div>
</div>
<a class="anchor" id="a72541e5329699ce42f5831f58c49bc58"></a><!-- doxytag: member="HalideRuntime.h::halide_get_ocl_device_type" ref="a72541e5329699ce42f5831f58c49bc58" args="(void *user_context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="_halide_runtime_8h.html#a72541e5329699ce42f5831f58c49bc58">halide_get_ocl_device_type</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespace_halide.html">Halide</a> calls this to gets the desired OpenCL device type. </p>
<p>Implement this yourself to use a different device type per user_context. The default implementation returns the value set by halide_set_ocl_device_type, or the environment variable HL_OCL_DEVICE_TYPE. The result is valid until the next call to halide_set_ocl_device_type. </p>

</div>
</div>
<a class="anchor" id="a9906fca5a688c26e0465a1b3da84ccfb"></a><!-- doxytag: member="HalideRuntime.h::halide_set_gpu_device" ref="a9906fca5a688c26e0465a1b3da84ccfb" args="(int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#a9906fca5a688c26e0465a1b3da84ccfb">halide_set_gpu_device</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Selects which gpu device to use. </p>
<p>0 is usually the display device. If never called, <a class="el" href="namespace_halide.html">Halide</a> uses the environment variable HL_GPU_DEVICE. If that variable is unset, <a class="el" href="namespace_halide.html">Halide</a> uses the last device. Set this to -1 to use the last device. </p>

</div>
</div>
<a class="anchor" id="adc511579a9ad82da9c1c611f008dd454"></a><!-- doxytag: member="HalideRuntime.h::halide_get_gpu_device" ref="adc511579a9ad82da9c1c611f008dd454" args="(void *user_context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="_halide_runtime_8h.html#adc511579a9ad82da9c1c611f008dd454">halide_get_gpu_device</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespace_halide.html">Halide</a> calls this to get the desired halide gpu device setting. </p>
<p>Implement this yourself to use a different gpu device per user_context. The default implementation returns the value set by halide_set_gpu_device, or the environment variable HL_GPU_DEVICE. </p>

</div>
</div>
<a class="anchor" id="abf85692a77aec0b887f345d0d3ca6777"></a><!-- doxytag: member="HalideRuntime.h::halide_memoization_cache_set_size" ref="abf85692a77aec0b887f345d0d3ca6777" args="(int64_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#abf85692a77aec0b887f345d0d3ca6777">halide_memoization_cache_set_size</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the soft maximum amount of memory, in bytes, that the LRU cache will use to memoize Func results. </p>
<p>This is not a strict maximum in that concurrency and simultaneous use of memoized reults larger than the cache size can both cause it to temporariliy be larger than the size specified here. </p>

</div>
</div>
<a class="anchor" id="a614935dfe37c71329d306f096eadc7d3"></a><!-- doxytag: member="HalideRuntime.h::halide_memoization_cache_lookup" ref="a614935dfe37c71329d306f096eadc7d3" args="(void *user_context, const uint8_t *cache_key, int32_t size, buffer_t *realized_bounds, int32_t tuple_count,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="_halide_runtime_8h.html#a614935dfe37c71329d306f096eadc7d3">halide_memoization_cache_lookup</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>cache_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buffer_t *&#160;</td>
          <td class="paramname"><em>realized_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>tuple_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, determine if the result is in the cache and return it if so. </p>
<p>(The internals of the cache key should be considered opaque by this function.) If this routine returns true, it is a cache miss. Otherwise, it will return false and the buffers passed in will be filled, via copying, with memoized data. The last argument is a list if buffer_t pointers which represents the outputs of the memoized Func. If the Func does not return a Tuple, there will only be one buffer_t in the list. The tuple_count parameters determines the length of the list. </p>

</div>
</div>
<a class="anchor" id="a8a984dad5fa50f432872335641e08479"></a><!-- doxytag: member="HalideRuntime.h::halide_memoization_cache_store" ref="a8a984dad5fa50f432872335641e08479" args="(void *user_context, const uint8_t *cache_key, int32_t size, buffer_t *realized_bounds, int32_t tuple_count,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#a8a984dad5fa50f432872335641e08479">halide_memoization_cache_store</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>cache_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buffer_t *&#160;</td>
          <td class="paramname"><em>realized_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>tuple_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, store the result in the cache for futre access by halide_memoization_cache_lookup. </p>
<p>(The internals of the cache key should be considered opaque by this function.) Data is copied out from the inputs and inputs are unmodified. The last argument is a list if buffer_t pointers which represents the outputs of the memoized Func. If the Func does not return a Tuple, there will only be one buffer_t in the list. The tuple_count parameters determines the length of the list. </p>

</div>
</div>
<a class="anchor" id="a30f9bdd5b6ac08b3fa785f3332cca996"></a><!-- doxytag: member="HalideRuntime.h::halide_memoization_cache_cleanup" ref="a30f9bdd5b6ac08b3fa785f3332cca996" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="_halide_runtime_8h.html#a30f9bdd5b6ac08b3fa785f3332cca996">halide_memoization_cache_cleanup</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free all memory and resources associated with the memoization cache. </p>
<p>Must be called at a time when no other threads are accessing the cache. </p>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_halide_runtime_8h.html">HalideRuntime.h</a>      </li>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
