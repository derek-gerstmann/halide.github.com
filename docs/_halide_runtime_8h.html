<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: HalideRuntime.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_halide_runtime_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HalideRuntime.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Set a custom malloc and free for halide to use.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
</div>
<p><a href="_halide_runtime_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__mutex.html">halide_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are allocated statically inside the runtime, hence the fixed size.  <a href="structhalide__mutex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__trace__event.html">halide_trace_event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuffer__t.html">buffer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw representation of an image passed around by generated <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> code.  <a href="structbuffer__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__scalar__value__t.html">halide_scalar_value_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structhalide__scalar__value__t.html" title="halide_scalar_value_t is a simple union able to represent all the well-known scalar values in a filte...">halide_scalar_value_t</a> is a simple union able to represent all the well-known scalar values in a filter argument.  <a href="structhalide__scalar__value__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__filter__argument__t.html">halide_filter_argument_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structhalide__filter__argument__t.html" title="halide_filter_argument_t is essentially a plain-C-struct equivalent to Halide::Argument; most user co...">halide_filter_argument_t</a> is essentially a plain-C-struct equivalent to <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function. ">Halide::Argument</a>; most user code will never need to create one.  <a href="structhalide__filter__argument__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__filter__metadata__t.html">halide_filter_metadata_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac87d020eed3438306b57d1eec5de0364"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ac87d020eed3438306b57d1eec5de0364">halide_assert</a>(<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, cond)&#160;&#160;&#160;if (!(cond)) <a class="el" href="runtime__internal_8h.html#ac21fd6d789f7ccd2a6c1f91ec732cbf1">halide_error</a>(<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, #cond);</td></tr>
<tr class="memdesc:ac87d020eed3438306b57d1eec5de0364"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro that calls halide_error if the supplied condition is false.  <a href="#ac87d020eed3438306b57d1eec5de0364">More...</a><br/></td></tr>
<tr class="separator:ac87d020eed3438306b57d1eec5de0364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa0f73fc7954ac27a2c11020681cdf3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#afaa0f73fc7954ac27a2c11020681cdf3">HALIDE_ATTRIBUTE_ALIGN</a>(x)&#160;&#160;&#160;__attribute__((aligned(x)))</td></tr>
<tr class="separator:afaa0f73fc7954ac27a2c11020681cdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2622d62cd7688033c8c6ad612cf5c3e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a2622d62cd7688033c8c6ad612cf5c3e8">BUFFER_T_DEFINED</a></td></tr>
<tr class="separator:a2622d62cd7688033c8c6ad612cf5c3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abd8ef2cf42c925601df1b997c1b938bf"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#abd8ef2cf42c925601df1b997c1b938bf">halide_type_code_t</a></td></tr>
<tr class="memdesc:abd8ef2cf42c925601df1b997c1b938bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types in the halide type system.  <a href="#abd8ef2cf42c925601df1b997c1b938bf">More...</a><br/></td></tr>
<tr class="separator:abd8ef2cf42c925601df1b997c1b938bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe399a52d3e6b4c16909f8216198044"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structbuffer__t.html">buffer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aebe399a52d3e6b4c16909f8216198044">buffer_t</a></td></tr>
<tr class="memdesc:aebe399a52d3e6b4c16909f8216198044"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw representation of an image passed around by generated <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> code.  <a href="#aebe399a52d3e6b4c16909f8216198044">More...</a><br/></td></tr>
<tr class="separator:aebe399a52d3e6b4c16909f8216198044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc1ecebda4db1628bc2723f1517afa1"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#acfc1ecebda4db1628bc2723f1517afa1">enumerate_func_t</a> )(void *enumerate_context, const <a class="el" href="structhalide__filter__metadata__t.html">halide_filter_metadata_t</a> *metadata, int(*argv_func)(void **args))</td></tr>
<tr class="memdesc:acfc1ecebda4db1628bc2723f1517afa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumerate_func_t is a callback for halide_enumerate_registered_filters; it is called once per registered filter discovered.  <a href="#acfc1ecebda4db1628bc2723f1517afa1">More...</a><br/></td></tr>
<tr class="separator:acfc1ecebda4db1628bc2723f1517afa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad66527fdd9cb140d1e424c4567ef9b7c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7c">halide_trace_event_code</a> { <br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7ca2cbd3048c959f6d8def944097d8e21c9">halide_trace_load</a> = 0, 
<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7ca57b32d087e0862bd6ba748ce7743a851">halide_trace_store</a> = 1, 
<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7cad8657c19f6b2b9cc79fa3a438f39687b">halide_trace_begin_realization</a> = 2, 
<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7cacb0bdc3e4044609ab7fae05b921595ab">halide_trace_end_realization</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7cac4047c93cd032261e8373e38944bf7a1">halide_trace_produce</a> = 4, 
<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7ca19c97ad2b3f68b3393eba6e48f8f828d">halide_trace_update</a> = 5, 
<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7ca0dac17982d8ef6c404f94e5b7dd4de54">halide_trace_consume</a> = 6, 
<a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7cac98849a734841652345dc3d37660c136">halide_trace_end_consume</a> = 7
<br/>
 }</td></tr>
<tr class="separator:ad66527fdd9cb140d1e424c4567ef9b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba16e170cc9aa30b78ff703e101a448c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448c">halide_error_code_t</a> { <br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca61d939236ddc9e13ff364e2c18149f04">halide_error_code_success</a> = 0, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca463fb2939949a1e8634905edf23efe05">halide_error_code_generic_error</a> = -1, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448cad9e00397c85cca42380f43b2689a8b7c">halide_error_code_explicit_bounds_too_small</a> = -2, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca107d42b213aacaaecdc7332a5218abd8">halide_error_code_bad_elem_size</a> = -3, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca0e0423bbffc1b99dffcdcfb5f64982ea">halide_error_code_access_out_of_bounds</a> = -4, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448cac11c436ca3edba1a8d0e961f3320e7e6">halide_error_code_buffer_allocation_too_large</a> = -5, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448cae18e82f52439b79a5523c009904ff99b">halide_error_code_buffer_extents_too_large</a> = -6, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca2d28fcb409c42316eaa24f6a6a74eeb6">halide_error_code_constraints_make_required_region_smaller</a> = -7, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448caf63622ed5219be61db38d6aa49b72334">halide_error_code_constraint_violated</a> = -8, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca0d9f00cc44f9f77fa70836e7d25cfaf8">halide_error_code_param_too_small</a> = -9, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca0d5dfd64f10156a5d2d1453fad4bfb6c">halide_error_code_param_too_large</a> = -10, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448caf47d74c0b04724325995bb4bd58cecb0">halide_error_code_out_of_memory</a> = -11, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca86cb45d6014d16a06c0d9071c122ec9a">halide_error_code_buffer_argument_is_null</a> = -12, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca9e69757bbb1448560eff39ad38e28aff">halide_error_code_debug_to_file_failed</a> = -13, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca61e81a880002d327a8d1aa09c3233636">halide_error_code_copy_to_host_failed</a> = -14, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca40015fc733363a53e154bc8183c86b54">halide_error_code_copy_to_device_failed</a> = -15, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca92667ff05a79083a7de97843d507ecdb">halide_error_code_device_malloc_failed</a> = -16, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca79b37d315188ac600b479f68d2627952">halide_error_code_device_sync_failed</a> = -17, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448cab9688dd68dbb132ba66ea80186fc18d1">halide_error_code_device_free_failed</a> = -18, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca006100e2007527689fe7d6104b209956">halide_error_code_no_device_interface</a> = -19, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca6c123efceb388bfef491629d89065775">halide_error_code_matlab_init_failed</a> = -20, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448caf5c56ee69de59cfb5959461ac0a8c570">halide_error_code_matlab_bad_param_type</a> = -21, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca28e9d2c63f5933a4422b668b3f473867">halide_error_code_internal_error</a> = -22
<br/>
 }</td></tr>
<tr class="memdesc:aba16e170cc9aa30b78ff703e101a448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error codes that may be returned by a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> pipeline.  <a href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448c">More...</a><br/></td></tr>
<tr class="separator:aba16e170cc9aa30b78ff703e101a448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4c40f298e91dea4f532774dc57a450"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a> { <a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450a53ba65448e4cbe66680c29a1333c8bfa">halide_type_int</a> = 0, 
<a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450adfa8b0e2cbd616d1259c9471ec5c2b4d">halide_type_uint</a> = 1, 
<a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450a05c0160361d9fc5deb778f9a6744f42b">halide_type_float</a> = 2, 
<a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450a22f25129c6493f710ace985e0f8f01ef">halide_type_handle</a> = 3
 }</td></tr>
<tr class="memdesc:a9f4c40f298e91dea4f532774dc57a450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types in the halide type system.  <a href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450">More...</a><br/></td></tr>
<tr class="separator:a9f4c40f298e91dea4f532774dc57a450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdce5dc7a11fa96f39baa1aee2333745"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#afdce5dc7a11fa96f39baa1aee2333745">halide_argument_kind_t</a> { <a class="el" href="_halide_runtime_8h.html#afdce5dc7a11fa96f39baa1aee2333745a4cce082af093da2e1e886ed3a775b2b1">halide_argument_kind_input_scalar</a> = 0, 
<a class="el" href="_halide_runtime_8h.html#afdce5dc7a11fa96f39baa1aee2333745af4d5e7ee6d3fb12c5a5c0d9edd845a5b">halide_argument_kind_input_buffer</a> = 1, 
<a class="el" href="_halide_runtime_8h.html#afdce5dc7a11fa96f39baa1aee2333745a0113d76303e0327745f3b3e4070dccd8">halide_argument_kind_output_buffer</a> = 2
 }</td></tr>
<tr class="separator:afdce5dc7a11fa96f39baa1aee2333745"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96fe1dd85166a7f0da1b8f82f734296a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a96fe1dd85166a7f0da1b8f82f734296a">halide_print</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *)</td></tr>
<tr class="memdesc:a96fe1dd85166a7f0da1b8f82f734296a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message to stderr.  <a href="#a96fe1dd85166a7f0da1b8f82f734296a">More...</a><br/></td></tr>
<tr class="separator:a96fe1dd85166a7f0da1b8f82f734296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea28d04de54b94f0dd6ada140b7734d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8">halide_error</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *)</td></tr>
<tr class="memdesc:aea28d04de54b94f0dd6ada140b7734d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_error to catch errors messages at runtime (for example bounds checking failures).  <a href="#aea28d04de54b94f0dd6ada140b7734d8">More...</a><br/></td></tr>
<tr class="separator:aea28d04de54b94f0dd6ada140b7734d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570aecb8f41519bc12356d1e63f68160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a570aecb8f41519bc12356d1e63f68160">halide_set_num_threads</a> (int n)</td></tr>
<tr class="memdesc:a570aecb8f41519bc12356d1e63f68160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of threads used by <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s thread pool.  <a href="#a570aecb8f41519bc12356d1e63f68160">More...</a><br/></td></tr>
<tr class="separator:a570aecb8f41519bc12356d1e63f68160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173a9669d4c2a9fb6fa0225a5fdabcd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a173a9669d4c2a9fb6fa0225a5fdabcd4">halide_debug_to_file</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *filename, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *data, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> s0, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> s1, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> s2, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> s3, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> type_code, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> bytes_per_element)</td></tr>
<tr class="memdesc:a173a9669d4c2a9fb6fa0225a5fdabcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when debug_to_file is used inside Halide code.  <a href="#a173a9669d4c2a9fb6fa0225a5fdabcd4">More...</a><br/></td></tr>
<tr class="separator:a173a9669d4c2a9fb6fa0225a5fdabcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15078a46b8fe517dcfdd26acadd2293a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a15078a46b8fe517dcfdd26acadd2293a">halide_trace</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const <a class="el" href="structhalide__trace__event.html">halide_trace_event</a> *event)</td></tr>
<tr class="memdesc:a15078a46b8fe517dcfdd26acadd2293a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when Funcs are marked as trace_load, trace_store, or trace_realization.  <a href="#a15078a46b8fe517dcfdd26acadd2293a">More...</a><br/></td></tr>
<tr class="separator:a15078a46b8fe517dcfdd26acadd2293a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8761e708f878372e3201126e83d6f3b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a8761e708f878372e3201126e83d6f3b6">halide_set_trace_file</a> (int fd)</td></tr>
<tr class="memdesc:a8761e708f878372e3201126e83d6f3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the file descriptor that <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> should write binary trace events to.  <a href="#a8761e708f878372e3201126e83d6f3b6">More...</a><br/></td></tr>
<tr class="separator:a8761e708f878372e3201126e83d6f3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee99b65dcbc81d91a0f22507eb7f8017"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aee99b65dcbc81d91a0f22507eb7f8017">halide_get_trace_file</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>)</td></tr>
<tr class="memdesc:aee99b65dcbc81d91a0f22507eb7f8017"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> calls this to retrieve the file descriptor to write binary trace events to.  <a href="#aee99b65dcbc81d91a0f22507eb7f8017">More...</a><br/></td></tr>
<tr class="separator:aee99b65dcbc81d91a0f22507eb7f8017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618bb97f5d713e1097835a24670948f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a618bb97f5d713e1097835a24670948f4">halide_shutdown_trace</a> ()</td></tr>
<tr class="memdesc:a618bb97f5d713e1097835a24670948f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If tracing is writing to a file.  <a href="#a618bb97f5d713e1097835a24670948f4">More...</a><br/></td></tr>
<tr class="separator:a618bb97f5d713e1097835a24670948f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0dfed73af7da529e2d7e30d162d24c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a6d0dfed73af7da529e2d7e30d162d24c">halide_device_release</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const <a class="el" href="structhalide__device__interface.html">halide_device_interface</a> *interface)</td></tr>
<tr class="memdesc:a6d0dfed73af7da529e2d7e30d162d24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all data associated with the current GPU backend, in particular all resources (memory, texture, context handles) allocated by <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>.  <a href="#a6d0dfed73af7da529e2d7e30d162d24c">More...</a><br/></td></tr>
<tr class="separator:a6d0dfed73af7da529e2d7e30d162d24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5980f17918155363078056e6a32de301"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5980f17918155363078056e6a32de301">halide_copy_to_host</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structbuffer__t.html">buffer_t</a> *<a class="el" href="runtime__internal_8h.html#a820af5182fa2b758297c9db1af6b2256">buf</a>)</td></tr>
<tr class="memdesc:a5980f17918155363078056e6a32de301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image data from device memory to host memory.  <a href="#a5980f17918155363078056e6a32de301">More...</a><br/></td></tr>
<tr class="separator:a5980f17918155363078056e6a32de301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dee88259b2783c3559be8cd419d2d3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a4dee88259b2783c3559be8cd419d2d3d">halide_copy_to_device</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structbuffer__t.html">buffer_t</a> *<a class="el" href="runtime__internal_8h.html#a820af5182fa2b758297c9db1af6b2256">buf</a>, const <a class="el" href="structhalide__device__interface.html">halide_device_interface</a> *interface)</td></tr>
<tr class="memdesc:a4dee88259b2783c3559be8cd419d2d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image data from host memory to device memory.  <a href="#a4dee88259b2783c3559be8cd419d2d3d">More...</a><br/></td></tr>
<tr class="separator:a4dee88259b2783c3559be8cd419d2d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ef5b5e82021e9ffc31a734b9123903"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a68ef5b5e82021e9ffc31a734b9123903">halide_device_sync</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structbuffer__t.html">buffer_t</a> *<a class="el" href="runtime__internal_8h.html#a820af5182fa2b758297c9db1af6b2256">buf</a>)</td></tr>
<tr class="memdesc:a68ef5b5e82021e9ffc31a734b9123903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for current GPU operations to complete.  <a href="#a68ef5b5e82021e9ffc31a734b9123903">More...</a><br/></td></tr>
<tr class="separator:a68ef5b5e82021e9ffc31a734b9123903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ceaa392c87af3f8736236a5fce260c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a14ceaa392c87af3f8736236a5fce260c">halide_device_malloc</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structbuffer__t.html">buffer_t</a> *<a class="el" href="runtime__internal_8h.html#a820af5182fa2b758297c9db1af6b2256">buf</a>, const <a class="el" href="structhalide__device__interface.html">halide_device_interface</a> *interface)</td></tr>
<tr class="memdesc:a14ceaa392c87af3f8736236a5fce260c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate device memory to back a <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a>.  <a href="#a14ceaa392c87af3f8736236a5fce260c">More...</a><br/></td></tr>
<tr class="separator:a14ceaa392c87af3f8736236a5fce260c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab234e67973d0504a63002c64db55d6fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ab234e67973d0504a63002c64db55d6fa">halide_device_free</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structbuffer__t.html">buffer_t</a> *<a class="el" href="runtime__internal_8h.html#a820af5182fa2b758297c9db1af6b2256">buf</a>)</td></tr>
<tr class="separator:ab234e67973d0504a63002c64db55d6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9906fca5a688c26e0465a1b3da84ccfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a9906fca5a688c26e0465a1b3da84ccfb">halide_set_gpu_device</a> (int n)</td></tr>
<tr class="memdesc:a9906fca5a688c26e0465a1b3da84ccfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects which gpu device to use.  <a href="#a9906fca5a688c26e0465a1b3da84ccfb">More...</a><br/></td></tr>
<tr class="separator:a9906fca5a688c26e0465a1b3da84ccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc511579a9ad82da9c1c611f008dd454"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#adc511579a9ad82da9c1c611f008dd454">halide_get_gpu_device</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>)</td></tr>
<tr class="memdesc:adc511579a9ad82da9c1c611f008dd454"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> calls this to get the desired halide gpu device setting.  <a href="#adc511579a9ad82da9c1c611f008dd454">More...</a><br/></td></tr>
<tr class="separator:adc511579a9ad82da9c1c611f008dd454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf85692a77aec0b887f345d0d3ca6777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#abf85692a77aec0b887f345d0d3ca6777">halide_memoization_cache_set_size</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> size)</td></tr>
<tr class="memdesc:abf85692a77aec0b887f345d0d3ca6777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the soft maximum amount of memory, in bytes, that the LRU cache will use to memoize Func results.  <a href="#abf85692a77aec0b887f345d0d3ca6777">More...</a><br/></td></tr>
<tr class="separator:abf85692a77aec0b887f345d0d3ca6777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066561dd8530528cf8b5842852ec7657"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a066561dd8530528cf8b5842852ec7657">halide_memoization_cache_lookup</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *cache_key, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> size, <a class="el" href="structbuffer__t.html">buffer_t</a> *realized_bounds, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> tuple_count, <a class="el" href="structbuffer__t.html">buffer_t</a> **tuple_buffers)</td></tr>
<tr class="memdesc:a066561dd8530528cf8b5842852ec7657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, determine if the result is in the cache and return it if so.  <a href="#a066561dd8530528cf8b5842852ec7657">More...</a><br/></td></tr>
<tr class="separator:a066561dd8530528cf8b5842852ec7657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b915ff5eca660c4179b5f332fce0f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a89b915ff5eca660c4179b5f332fce0f3">halide_memoization_cache_store</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *cache_key, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> size, <a class="el" href="structbuffer__t.html">buffer_t</a> *realized_bounds, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> tuple_count, <a class="el" href="structbuffer__t.html">buffer_t</a> **tuple_buffers)</td></tr>
<tr class="memdesc:a89b915ff5eca660c4179b5f332fce0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, store the result in the cache for futre access by halide_memoization_cache_lookup.  <a href="#a89b915ff5eca660c4179b5f332fce0f3">More...</a><br/></td></tr>
<tr class="separator:a89b915ff5eca660c4179b5f332fce0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f9bdd5b6ac08b3fa785f3332cca996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a30f9bdd5b6ac08b3fa785f3332cca996">halide_memoization_cache_cleanup</a> ()</td></tr>
<tr class="memdesc:a30f9bdd5b6ac08b3fa785f3332cca996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory and resources associated with the memoization cache.  <a href="#a30f9bdd5b6ac08b3fa785f3332cca996">More...</a><br/></td></tr>
<tr class="separator:a30f9bdd5b6ac08b3fa785f3332cca996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56de7e95e571c442a05506a451318f00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a56de7e95e571c442a05506a451318f00">halide_error_bounds_inference_call_failed</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *extern_stage_name, int result)</td></tr>
<tr class="memdesc:a56de7e95e571c442a05506a451318f00"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> calls the functions below on various error conditions.  <a href="#a56de7e95e571c442a05506a451318f00">More...</a><br/></td></tr>
<tr class="separator:a56de7e95e571c442a05506a451318f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ec7fcc618e1b0508a6f4f726a7bcae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a83ec7fcc618e1b0508a6f4f726a7bcae">halide_error_extern_stage_failed</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *extern_stage_name, int result)</td></tr>
<tr class="memdesc:a83ec7fcc618e1b0508a6f4f726a7bcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call to an extern stage failed.  <a href="#a83ec7fcc618e1b0508a6f4f726a7bcae">More...</a><br/></td></tr>
<tr class="separator:a83ec7fcc618e1b0508a6f4f726a7bcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3454e11a6ec4e53fd2883fe291a1b0dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a3454e11a6ec4e53fd2883fe291a1b0dd">halide_enumerate_registered_filters</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, void *enumerate_context, <a class="el" href="_halide_runtime_8h.html#acfc1ecebda4db1628bc2723f1517afa1">enumerate_func_t</a> func)</td></tr>
<tr class="memdesc:a3454e11a6ec4e53fd2883fe291a1b0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a filter is compiled with Target::RegisterMetadata, it will register itself in an internal list at load time; <a class="el" href="_halide_runtime_8h.html#a3454e11a6ec4e53fd2883fe291a1b0dd" title="If a filter is compiled with Target::RegisterMetadata, it will register itself in an internal list at...">halide_enumerate_registered_filters()</a> allows you to enumerate all such filters at runtime.  <a href="#a3454e11a6ec4e53fd2883fe291a1b0dd">More...</a><br/></td></tr>
<tr class="separator:a3454e11a6ec4e53fd2883fe291a1b0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a479133225b3cdf7b931f3c44e878e4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a479133225b3cdf7b931f3c44e878e4e8">halide_mutex_lock</a> (struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a479133225b3cdf7b931f3c44e878e4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic set of mutex functions, which call platform specific code for mutual exclusion.  <a href="#a479133225b3cdf7b931f3c44e878e4e8">More...</a><br/></td></tr>
<tr class="separator:a479133225b3cdf7b931f3c44e878e4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9b62fd2c1d38e6f06100b827830377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5e9b62fd2c1d38e6f06100b827830377">halide_mutex_unlock</a> (struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a5e9b62fd2c1d38e6f06100b827830377"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic set of mutex functions, which call platform specific code for mutual exclusion.  <a href="#a5e9b62fd2c1d38e6f06100b827830377">More...</a><br/></td></tr>
<tr class="separator:a5e9b62fd2c1d38e6f06100b827830377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6af6c192bfc0ad72171b66df883e2d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aa6af6c192bfc0ad72171b66df883e2d4">halide_mutex_cleanup</a> (struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *mutex_arg)</td></tr>
<tr class="memdesc:aa6af6c192bfc0ad72171b66df883e2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic set of mutex functions, which call platform specific code for mutual exclusion.  <a href="#aa6af6c192bfc0ad72171b66df883e2d4">More...</a><br/></td></tr>
<tr class="separator:aa6af6c192bfc0ad72171b66df883e2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a05193f80c8fc7df76ceadd82c4ce7b56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a05193f80c8fc7df76ceadd82c4ce7b56">halide_do_par_for</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, int(*f)(void *ctx, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *), int min, int size, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td></tr>
<tr class="memdesc:a05193f80c8fc7df76ceadd82c4ce7b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_do_par_for to replace the default thread pool implementation.  <a href="#a05193f80c8fc7df76ceadd82c4ce7b56">More...</a><br/></td></tr>
<tr class="separator:a05193f80c8fc7df76ceadd82c4ce7b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9d22d2b79a3dc66a32159423b17910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5e9d22d2b79a3dc66a32159423b17910">halide_shutdown_thread_pool</a> ()</td></tr>
<tr class="memdesc:a5e9d22d2b79a3dc66a32159423b17910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_do_par_for to replace the default thread pool implementation.  <a href="#a5e9d22d2b79a3dc66a32159423b17910">More...</a><br/></td></tr>
<tr class="separator:a5e9d22d2b79a3dc66a32159423b17910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa5bb359ed77ef4c1f89251bcd7eb2613"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aa5bb359ed77ef4c1f89251bcd7eb2613">halide_malloc</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> x)</td></tr>
<tr class="memdesc:aa5bb359ed77ef4c1f89251bcd7eb2613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_malloc and halide_free to replace the default memory allocator.  <a href="#aa5bb359ed77ef4c1f89251bcd7eb2613">More...</a><br/></td></tr>
<tr class="separator:aa5bb359ed77ef4c1f89251bcd7eb2613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa49d775b9a20fab152a0650c4c936b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a2fa49d775b9a20fab152a0650c4c936b">halide_free</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, void *ptr)</td></tr>
<tr class="memdesc:a2fa49d775b9a20fab152a0650c4c936b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_malloc and halide_free to replace the default memory allocator.  <a href="#a2fa49d775b9a20fab152a0650c4c936b">More...</a><br/></td></tr>
<tr class="separator:a2fa49d775b9a20fab152a0650c4c936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa5b03b398e934c740dd4905a02a9bb81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aa5b03b398e934c740dd4905a02a9bb81">halide_error_explicit_bounds_too_small</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *func_name, const char *var_name, int min_bound, int max_bound, int min_required, int max_required)</td></tr>
<tr class="memdesc:aa5b03b398e934c740dd4905a02a9bb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#aa5b03b398e934c740dd4905a02a9bb81">More...</a><br/></td></tr>
<tr class="separator:aa5b03b398e934c740dd4905a02a9bb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359867540d70c0e91feb11831d7b2591"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a359867540d70c0e91feb11831d7b2591">halide_error_bad_elem_size</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *func_name, const char *type_name, int elem_size_given, int correct_elem_size)</td></tr>
<tr class="memdesc:a359867540d70c0e91feb11831d7b2591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a359867540d70c0e91feb11831d7b2591">More...</a><br/></td></tr>
<tr class="separator:a359867540d70c0e91feb11831d7b2591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54c6e910c7b7feb2a51c7a0a549a9bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aa54c6e910c7b7feb2a51c7a0a549a9bd">halide_error_access_out_of_bounds</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *func_name, int dimension, int min_touched, int max_touched, int min_valid, int max_valid)</td></tr>
<tr class="memdesc:aa54c6e910c7b7feb2a51c7a0a549a9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#aa54c6e910c7b7feb2a51c7a0a549a9bd">More...</a><br/></td></tr>
<tr class="separator:aa54c6e910c7b7feb2a51c7a0a549a9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22936015ebadbfb32e5a14c663d20060"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a22936015ebadbfb32e5a14c663d20060">halide_error_buffer_allocation_too_large</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *buffer_name, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> allocation_size, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> max_size)</td></tr>
<tr class="memdesc:a22936015ebadbfb32e5a14c663d20060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a22936015ebadbfb32e5a14c663d20060">More...</a><br/></td></tr>
<tr class="separator:a22936015ebadbfb32e5a14c663d20060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d5f3810ffacdc2950743193411c6d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a80d5f3810ffacdc2950743193411c6d4">halide_error_buffer_extents_too_large</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *buffer_name, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> actual_size, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> max_size)</td></tr>
<tr class="memdesc:a80d5f3810ffacdc2950743193411c6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a80d5f3810ffacdc2950743193411c6d4">More...</a><br/></td></tr>
<tr class="separator:a80d5f3810ffacdc2950743193411c6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcbb3316d10d47471e9d74ba74d8e6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5fcbb3316d10d47471e9d74ba74d8e6b">halide_error_constraints_make_required_region_smaller</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *buffer_name, int dimension, int constrained_min, int constrained_extent, int required_min, int required_extent)</td></tr>
<tr class="memdesc:a5fcbb3316d10d47471e9d74ba74d8e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a5fcbb3316d10d47471e9d74ba74d8e6b">More...</a><br/></td></tr>
<tr class="separator:a5fcbb3316d10d47471e9d74ba74d8e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a91525ca15c31958738cf7ec44e410"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a41a91525ca15c31958738cf7ec44e410">halide_error_constraint_violated</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *var, int val, const char *constrained_var, int constrained_val)</td></tr>
<tr class="memdesc:a41a91525ca15c31958738cf7ec44e410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a41a91525ca15c31958738cf7ec44e410">More...</a><br/></td></tr>
<tr class="separator:a41a91525ca15c31958738cf7ec44e410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc44166713b0e8fbef22542e4e0fe95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a9dc44166713b0e8fbef22542e4e0fe95">halide_error_param_too_small_i64</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *param_name, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> min_val)</td></tr>
<tr class="memdesc:a9dc44166713b0e8fbef22542e4e0fe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a9dc44166713b0e8fbef22542e4e0fe95">More...</a><br/></td></tr>
<tr class="separator:a9dc44166713b0e8fbef22542e4e0fe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fce86c8f8d93969bde686d502b4340"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a93fce86c8f8d93969bde686d502b4340">halide_error_param_too_small_u64</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *param_name, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> min_val)</td></tr>
<tr class="memdesc:a93fce86c8f8d93969bde686d502b4340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a93fce86c8f8d93969bde686d502b4340">More...</a><br/></td></tr>
<tr class="separator:a93fce86c8f8d93969bde686d502b4340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d06e8302739a4a26bfa2b0113fc376d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a8d06e8302739a4a26bfa2b0113fc376d">halide_error_param_too_small_f64</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *param_name, double val, double min_val)</td></tr>
<tr class="memdesc:a8d06e8302739a4a26bfa2b0113fc376d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a8d06e8302739a4a26bfa2b0113fc376d">More...</a><br/></td></tr>
<tr class="separator:a8d06e8302739a4a26bfa2b0113fc376d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f31f3a6a09ab3b5b798cecbd3f5e045"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a8f31f3a6a09ab3b5b798cecbd3f5e045">halide_error_param_too_large_i64</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *param_name, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> max_val)</td></tr>
<tr class="memdesc:a8f31f3a6a09ab3b5b798cecbd3f5e045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a8f31f3a6a09ab3b5b798cecbd3f5e045">More...</a><br/></td></tr>
<tr class="separator:a8f31f3a6a09ab3b5b798cecbd3f5e045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca082a34f38e8657551128db3969f8af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aca082a34f38e8657551128db3969f8af">halide_error_param_too_large_u64</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *param_name, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> max_val)</td></tr>
<tr class="memdesc:aca082a34f38e8657551128db3969f8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#aca082a34f38e8657551128db3969f8af">More...</a><br/></td></tr>
<tr class="separator:aca082a34f38e8657551128db3969f8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc42c90e0703c23c6f141fb476cfa04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a7bc42c90e0703c23c6f141fb476cfa04">halide_error_param_too_large_f64</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *param_name, double val, double max_val)</td></tr>
<tr class="memdesc:a7bc42c90e0703c23c6f141fb476cfa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a7bc42c90e0703c23c6f141fb476cfa04">More...</a><br/></td></tr>
<tr class="separator:a7bc42c90e0703c23c6f141fb476cfa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64356948f9a36e16664585fff6f0949d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a64356948f9a36e16664585fff6f0949d">halide_error_out_of_memory</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>)</td></tr>
<tr class="memdesc:a64356948f9a36e16664585fff6f0949d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a64356948f9a36e16664585fff6f0949d">More...</a><br/></td></tr>
<tr class="separator:a64356948f9a36e16664585fff6f0949d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab974b4b7963cad8613c3825a5689086"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aab974b4b7963cad8613c3825a5689086">halide_error_buffer_argument_is_null</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *buffer_name)</td></tr>
<tr class="memdesc:aab974b4b7963cad8613c3825a5689086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#aab974b4b7963cad8613c3825a5689086">More...</a><br/></td></tr>
<tr class="separator:aab974b4b7963cad8613c3825a5689086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d12212093b19b3c2ea2b83df15302e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a6d12212093b19b3c2ea2b83df15302e3">halide_error_debug_to_file_failed</a> (void *<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *func, const char *filename, int error_code)</td></tr>
<tr class="memdesc:a6d12212093b19b3c2ea2b83df15302e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a6d12212093b19b3c2ea2b83df15302e3">More...</a><br/></td></tr>
<tr class="separator:a6d12212093b19b3c2ea2b83df15302e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Set a custom malloc and free for halide to use. </p>
<p>This file exports all routines which can be replaced by an application hosting code generated by Halide.</p>
<p>Malloc should return 32-byte aligned chunks of memory, and it should be safe for <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> to read slightly out of bounds (up to 8 bytes before the start or beyond the end). If compiling statically, routines with appropriate signatures can be provided directly </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *<a class="code" href="_halide_runtime_8h.html#aa5bb359ed77ef4c1f89251bcd7eb2613">halide_malloc</a>(<span class="keywordtype">void</span> *, <span class="keywordtype">size_t</span>)</div>
<div class="line">extern &quot;C&quot; <span class="keywordtype">void</span> <a class="code" href="_halide_runtime_8h.html#a2fa49d775b9a20fab152a0650c4c936b">halide_free</a>(<span class="keywordtype">void</span> *, <span class="keywordtype">void</span> *)</div>
</div><!-- fragment --><p> These will clobber <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s versions. See for declarations.</p>
<p>These are used when doing Ahead Of Time (AOT) compilation and must be supplied to the linker to override a routine. I.e., just define your own version of any of these functions with extern "C" linkage, and it should replace the default one.</p>
<p>When doing Just In Time (JIT) compilation methods on the Func being compiled must be called instead. The corresponding methods are documented below.</p>
<p>All of these functions take a "void *user_context" parameter as their first argument; if the <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> kernel that calls back to any of these functions has been compiled with the UserContext feature set on its Target, then the value of that pointer passed from the code that calls the <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> kernel is piped through to the function.</p>
<p>Some of these are also useful to call when using the default implementation. E.g. halide_shutdown_thread_pool.</p>
<p>Note that some linker setups may not respect the override you provide. E.g. if the override is in a shared library and the halide object files are linked directly into the output, the builtin versions of the runtime functions will be called. See your linker documentation for more details. On Linux, LD_DYNAMIC_WEAK=1 may help. </p>

<p>Definition in file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ac87d020eed3438306b57d1eec5de0364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define halide_assert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cond&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;if (!(cond)) <a class="el" href="runtime__internal_8h.html#ac21fd6d789f7ccd2a6c1f91ec732cbf1">halide_error</a>(<a class="el" href="runtime__internal_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, #cond);</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A macro that calls halide_error if the supplied condition is false. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00063">63</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

<p>Referenced by <a class="el" href="cuda__opencl__shared_8h_source.html#l00011">Halide::Runtime::Internal::buf_size()</a>.</p>

</div>
</div>
<a class="anchor" id="afaa0f73fc7954ac27a2c11020681cdf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_ATTRIBUTE_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;__attribute__((aligned(x)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00457">457</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2622d62cd7688033c8c6ad612cf5c3e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFFER_T_DEFINED</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00462">462</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="abd8ef2cf42c925601df1b997c1b938bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a>  <a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types in the halide type system. </p>
<p>They can be ints, unsigned ints, or floats (of various bit-widths), or a handle (which is always pointer-sized). Note that the int/uint/float values do not imply a specific bit width (the bit width is expected to be encoded in a separate value). </p>

</div>
</div>
<a class="anchor" id="aebe399a52d3e6b4c16909f8216198044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structbuffer__t.html">buffer_t</a>  <a class="el" href="structbuffer__t.html">buffer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The raw representation of an image passed around by generated <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> code. </p>
<p>It includes some stuff to track whether the image is not actually in main memory, but instead on a device (like a GPU). </p>

</div>
</div>
<a class="anchor" id="acfc1ecebda4db1628bc2723f1517afa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* enumerate_func_t)(void *enumerate_context, const <a class="el" href="structhalide__filter__metadata__t.html">halide_filter_metadata_t</a> *metadata, int(*argv_func)(void **args))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enumerate_func_t is a callback for halide_enumerate_registered_filters; it is called once per registered filter discovered. </p>
<p>Return 0 to continue the enumeration, or nonzero to terminate the enumeration. enumerate_context is an arbitrary pointer you can use to provide a callback argument. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00600">600</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_halide_runtime_8h.html#ad66527fdd9cb140d1e424c4567ef9b7c">halide_trace_event_code</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7ca2cbd3048c959f6d8def944097d8e21c9"></a>halide_trace_load</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7ca57b32d087e0862bd6ba748ce7743a851"></a>halide_trace_store</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7cad8657c19f6b2b9cc79fa3a438f39687b"></a>halide_trace_begin_realization</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7cacb0bdc3e4044609ab7fae05b921595ab"></a>halide_trace_end_realization</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7cac4047c93cd032261e8373e38944bf7a1"></a>halide_trace_produce</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7ca19c97ad2b3f68b3393eba6e48f8f828d"></a>halide_trace_update</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7ca0dac17982d8ef6c404f94e5b7dd4de54"></a>halide_trace_consume</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad66527fdd9cb140d1e424c4567ef9b7cac98849a734841652345dc3d37660c136"></a>halide_trace_end_consume</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00129">129</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="aba16e170cc9aa30b78ff703e101a448c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448c">halide_error_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The error codes that may be returned by a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> pipeline. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca61d939236ddc9e13ff364e2c18149f04"></a>halide_error_code_success</em>&#160;</td><td class="fielddoc">
<p>There was no error. </p>
<p>This is the value returned by <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> on success. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca463fb2939949a1e8634905edf23efe05"></a>halide_error_code_generic_error</em>&#160;</td><td class="fielddoc">
<p>An uncategorized error occurred. </p>
<p>Refer to the string passed to halide_error. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448cad9e00397c85cca42380f43b2689a8b7c"></a>halide_error_code_explicit_bounds_too_small</em>&#160;</td><td class="fielddoc">
<p>A Func was given an explicit bound via Func::bound, but this was not large enough to encompass the region that is used of the Func by the rest of the pipeline. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca107d42b213aacaaecdc7332a5218abd8"></a>halide_error_code_bad_elem_size</em>&#160;</td><td class="fielddoc">
<p>The elem_size field of a <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> does not match the size in bytes of the type of that ImageParam. </p>
<p>Probable type mismatch. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca0e0423bbffc1b99dffcdcfb5f64982ea"></a>halide_error_code_access_out_of_bounds</em>&#160;</td><td class="fielddoc">
<p>A pipeline would access memory outside of the <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> passed in. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448cac11c436ca3edba1a8d0e961f3320e7e6"></a>halide_error_code_buffer_allocation_too_large</em>&#160;</td><td class="fielddoc">
<p>A <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> was given that spans more than 2GB of memory. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448cae18e82f52439b79a5523c009904ff99b"></a>halide_error_code_buffer_extents_too_large</em>&#160;</td><td class="fielddoc">
<p>A <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> was given with extents that multiply to a number greater than 2^31-1. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca2d28fcb409c42316eaa24f6a6a74eeb6"></a>halide_error_code_constraints_make_required_region_smaller</em>&#160;</td><td class="fielddoc">
<p>Applying explicit constraints on the size of an input or output buffer shrank the size of that buffer below what will be accessed by the pipeline. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448caf63622ed5219be61db38d6aa49b72334"></a>halide_error_code_constraint_violated</em>&#160;</td><td class="fielddoc">
<p>A constraint on a size or stride of an input or output buffer was not met by the <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> passed in. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca0d9f00cc44f9f77fa70836e7d25cfaf8"></a>halide_error_code_param_too_small</em>&#160;</td><td class="fielddoc">
<p>A scalar parameter passed in was smaller than its minimum declared value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca0d5dfd64f10156a5d2d1453fad4bfb6c"></a>halide_error_code_param_too_large</em>&#160;</td><td class="fielddoc">
<p>A scalar parameter passed in was greater than its minimum declared value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448caf47d74c0b04724325995bb4bd58cecb0"></a>halide_error_code_out_of_memory</em>&#160;</td><td class="fielddoc">
<p>A call to halide_malloc returned NULL. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca86cb45d6014d16a06c0d9071c122ec9a"></a>halide_error_code_buffer_argument_is_null</em>&#160;</td><td class="fielddoc">
<p>A <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> pointer passed in was NULL. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca9e69757bbb1448560eff39ad38e28aff"></a>halide_error_code_debug_to_file_failed</em>&#160;</td><td class="fielddoc">
<p>debug_to_file failed to open or write to the specified file. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca61e81a880002d327a8d1aa09c3233636"></a>halide_error_code_copy_to_host_failed</em>&#160;</td><td class="fielddoc">
<p>The <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> runtime encountered an error while trying to copy from device to host. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca40015fc733363a53e154bc8183c86b54"></a>halide_error_code_copy_to_device_failed</em>&#160;</td><td class="fielddoc">
<p>The <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> runtime encountered an error while trying to copy from host to device. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca92667ff05a79083a7de97843d507ecdb"></a>halide_error_code_device_malloc_failed</em>&#160;</td><td class="fielddoc">
<p>The <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> runtime encountered an error while trying to allocate memory on device. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca79b37d315188ac600b479f68d2627952"></a>halide_error_code_device_sync_failed</em>&#160;</td><td class="fielddoc">
<p>The <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> runtime encountered an error while trying to synchronize with a device. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448cab9688dd68dbb132ba66ea80186fc18d1"></a>halide_error_code_device_free_failed</em>&#160;</td><td class="fielddoc">
<p>The <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> runtime encountered an error while trying to free a device allocation. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca006100e2007527689fe7d6104b209956"></a>halide_error_code_no_device_interface</em>&#160;</td><td class="fielddoc">
<p>A device operation was attempted on a buffer with no device interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca6c123efceb388bfef491629d89065775"></a>halide_error_code_matlab_init_failed</em>&#160;</td><td class="fielddoc">
<p>An error occurred when attempting to initialize the Matlab runtime. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448caf5c56ee69de59cfb5959461ac0a8c570"></a>halide_error_code_matlab_bad_param_type</em>&#160;</td><td class="fielddoc">
<p>The type of an mxArray did not match the expected type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca28e9d2c63f5933a4422b668b3f473867"></a>halide_error_code_internal_error</em>&#160;</td><td class="fielddoc">
<p>There is a bug in the <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> compiler. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00293">293</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9f4c40f298e91dea4f532774dc57a450"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types in the halide type system. </p>
<p>They can be ints, unsigned ints, or floats (of various bit-widths), or a handle (which is always pointer-sized). Note that the int/uint/float values do not imply a specific bit width (the bit width is expected to be encoded in a separate value). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a9f4c40f298e91dea4f532774dc57a450a53ba65448e4cbe66680c29a1333c8bfa"></a>halide_type_int</em>&#160;</td><td class="fielddoc">
<p>signed integers </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9f4c40f298e91dea4f532774dc57a450adfa8b0e2cbd616d1259c9471ec5c2b4d"></a>halide_type_uint</em>&#160;</td><td class="fielddoc">
<p>unsigned integers </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9f4c40f298e91dea4f532774dc57a450a05c0160361d9fc5deb778f9a6744f42b"></a>halide_type_float</em>&#160;</td><td class="fielddoc">
<p>floating point numbers </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9f4c40f298e91dea4f532774dc57a450a22f25129c6493f710ace985e0f8f01ef"></a>halide_type_handle</em>&#160;</td><td class="fielddoc">
<p>opaque pointer type (void *) </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00444">444</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="afdce5dc7a11fa96f39baa1aee2333745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_halide_runtime_8h.html#afdce5dc7a11fa96f39baa1aee2333745">halide_argument_kind_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="afdce5dc7a11fa96f39baa1aee2333745a4cce082af093da2e1e886ed3a775b2b1"></a>halide_argument_kind_input_scalar</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afdce5dc7a11fa96f39baa1aee2333745af4d5e7ee6d3fb12c5a5c0d9edd845a5b"></a>halide_argument_kind_input_buffer</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afdce5dc7a11fa96f39baa1aee2333745a0113d76303e0327745f3b3e4070dccd8"></a>halide_argument_kind_output_buffer</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00540">540</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a96fe1dd85166a7f0da1b8f82f734296a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_print </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a message to stderr. </p>
<p>Main use is to support HL_TRACE functionality, print, and print_when calls. Also called by the default halide_error. This function can be replaced in JITed code by using halide_custom_print and providing an implementation of halide_print in AOT code. See Func::set_custom_print. </p>

</div>
</div>
<a class="anchor" id="aea28d04de54b94f0dd6ada140b7734d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_error </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define halide_error to catch errors messages at runtime (for example bounds checking failures). </p>
<p>This function can be replaced in JITed code by using halide_set_error_handler and providing an implementation of halide_error in AOT code. See Func::set_error_handler. </p>

</div>
</div>
<a class="anchor" id="a479133225b3cdf7b931f3c44e878e4e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A basic set of mutex functions, which call platform specific code for mutual exclusion. </p>

<p>Referenced by <a class="el" href="scoped__mutex__lock_8h_source.html#l00012">Halide::Runtime::Internal::ScopedMutexLock::ScopedMutexLock()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e9b62fd2c1d38e6f06100b827830377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A basic set of mutex functions, which call platform specific code for mutual exclusion. </p>

<p>Referenced by <a class="el" href="scoped__mutex__lock_8h_source.html#l00016">Halide::Runtime::Internal::ScopedMutexLock::~ScopedMutexLock()</a>.</p>

</div>
</div>
<a class="anchor" id="aa6af6c192bfc0ad72171b66df883e2d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_mutex_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex_arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A basic set of mutex functions, which call platform specific code for mutual exclusion. </p>

</div>
</div>
<a class="anchor" id="a05193f80c8fc7df76ceadd82c4ce7b56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_do_par_for </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *ctx, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define halide_do_par_for to replace the default thread pool implementation. </p>
<p>halide_shutdown_thread_pool can also be called to release resources used by the default thread pool on platforms where it makes sense. (E.g. On Mac OS, Grand Central Dispatch is used so Halide does not own the threads backing the pool and they cannot be released.) See Func::set_custom_do_task and Func::set_custom_do_par_for. Should return zero if all the jobs return zero, or an arbitrarily chosen return value from one of the jobs otherwise. </p>

</div>
</div>
<a class="anchor" id="a5e9d22d2b79a3dc66a32159423b17910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_shutdown_thread_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define halide_do_par_for to replace the default thread pool implementation. </p>
<p>halide_shutdown_thread_pool can also be called to release resources used by the default thread pool on platforms where it makes sense. (E.g. On Mac OS, Grand Central Dispatch is used so Halide does not own the threads backing the pool and they cannot be released.) See Func::set_custom_do_task and Func::set_custom_do_par_for. Should return zero if all the jobs return zero, or an arbitrarily chosen return value from one of the jobs otherwise. </p>

</div>
</div>
<a class="anchor" id="a570aecb8f41519bc12356d1e63f68160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of threads used by <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s thread pool. </p>
<p>No effect on OS X or iOS. If changed after the first use of a parallel <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> routine, shuts down and then reinitializes the thread pool. </p>

</div>
</div>
<a class="anchor" id="aa5bb359ed77ef4c1f89251bcd7eb2613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* halide_malloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define halide_malloc and halide_free to replace the default memory allocator. </p>
<p>See Func::set_custom_allocator. (Specifically note that halide_malloc must return a 32-byte aligned pointer, and it must be safe to read at least 8 bytes before the start and beyond the end.) </p>

</div>
</div>
<a class="anchor" id="a2fa49d775b9a20fab152a0650c4c936b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define halide_malloc and halide_free to replace the default memory allocator. </p>
<p>See Func::set_custom_allocator. (Specifically note that halide_malloc must return a 32-byte aligned pointer, and it must be safe to read at least 8 bytes before the start and beyond the end.) </p>

</div>
</div>
<a class="anchor" id="a173a9669d4c2a9fb6fa0225a5fdabcd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> halide_debug_to_file </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>s0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>s3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>type_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>bytes_per_element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when debug_to_file is used inside Halide code. </p>
<p>See Func::debug_to_file for how this is called</p>
<p>Cannot be replaced in JITted code at present. </p>

</div>
</div>
<a class="anchor" id="a15078a46b8fe517dcfdd26acadd2293a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> halide_trace </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__trace__event.html">halide_trace_event</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when Funcs are marked as trace_load, trace_store, or trace_realization. </p>
<p>See Func::set_custom_trace. The default implementation either prints events via halide_printf, or if HL_TRACE_FILE is defined, dumps the trace to that file in a yet-to-be-documented binary format (see src/runtime/tracing.cpp to reverse engineer the format). If the trace is going to be large, you may want to make the file a named pipe, and then read from that pipe into gzip.</p>
<p>halide_trace returns a unique ID which will be passed to future events that "belong" to the earlier event as the parent id. The ownership hierarchy looks like:</p>
<p>begin_realization produce store update load/store consume load end_consume end_realization</p>
<p>Threading means that ownership cannot be inferred from the ordering of events. There can be many active realizations of a given function, or many active productions for a single realization. Within a single production, the ordering of events is meaningful. </p>

</div>
</div>
<a class="anchor" id="a8761e708f878372e3201126e83d6f3b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_set_trace_file </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the file descriptor that <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> should write binary trace events to. </p>
<p>If called with 0 as the argument, <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> outputs trace information to stdout in a human-readable format. If never called, <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> checks the for existence of an environment variable called HL_TRACE_FILE and opens that file. If HL_TRACE_FILE is not defined, it outputs trace information to stdout in a human-readable format. </p>

</div>
</div>
<a class="anchor" id="aee99b65dcbc81d91a0f22507eb7f8017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_get_trace_file </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> calls this to retrieve the file descriptor to write binary trace events to. </p>
<p>The default implementation returns the value set by halide_set_trace_file. Implement it yourself if you wish to use a custom file descriptor per user_context. Return zero from your implementation to tell <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> to print human-readable trace information to stdout. </p>

</div>
</div>
<a class="anchor" id="a618bb97f5d713e1097835a24670948f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_shutdown_trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If tracing is writing to a file. </p>
<p>This call closes that file (flushing the trace). Returns zero on success. </p>

</div>
</div>
<a class="anchor" id="a6d0dfed73af7da529e2d7e30d162d24c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_device_release </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__device__interface.html">halide_device_interface</a> *&#160;</td>
          <td class="paramname"><em>interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release all data associated with the current GPU backend, in particular all resources (memory, texture, context handles) allocated by <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>. </p>
<p>Must be called explicitly when using AOT compilation. </p>

</div>
</div>
<a class="anchor" id="a5980f17918155363078056e6a32de301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_copy_to_host </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy image data from device memory to host memory. </p>
<p>This must be called explicitly to copy back the results of a GPU-based filter. </p>

</div>
</div>
<a class="anchor" id="a4dee88259b2783c3559be8cd419d2d3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_copy_to_device </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__device__interface.html">halide_device_interface</a> *&#160;</td>
          <td class="paramname"><em>interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy image data from host memory to device memory. </p>
<p>This should not be called directly; <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> handles copying to the device automatically. If interface is NULL and the bug has a non-zero dev field, the device associated with the dev handle will be used. Otherwise if the dev field is 0 and interface is NULL, an error is returned. </p>

</div>
</div>
<a class="anchor" id="a68ef5b5e82021e9ffc31a734b9123903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_sync </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for current GPU operations to complete. </p>
<p>Calling this explicitly should rarely be necessary, except maybe for profiling. </p>

</div>
</div>
<a class="anchor" id="a14ceaa392c87af3f8736236a5fce260c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_malloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__device__interface.html">halide_device_interface</a> *&#160;</td>
          <td class="paramname"><em>interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate device memory to back a <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a>. </p>

</div>
</div>
<a class="anchor" id="ab234e67973d0504a63002c64db55d6fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9906fca5a688c26e0465a1b3da84ccfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_set_gpu_device </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects which gpu device to use. </p>
<p>0 is usually the display device. If never called, <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> uses the environment variable HL_GPU_DEVICE. If that variable is unset, <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> uses the last device. Set this to -1 to use the last device. </p>

</div>
</div>
<a class="anchor" id="adc511579a9ad82da9c1c611f008dd454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_get_gpu_device </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> calls this to get the desired halide gpu device setting. </p>
<p>Implement this yourself to use a different gpu device per user_context. The default implementation returns the value set by halide_set_gpu_device, or the environment variable HL_GPU_DEVICE. </p>

</div>
</div>
<a class="anchor" id="abf85692a77aec0b887f345d0d3ca6777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_memoization_cache_set_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the soft maximum amount of memory, in bytes, that the LRU cache will use to memoize Func results. </p>
<p>This is not a strict maximum in that concurrency and simultaneous use of memoized reults larger than the cache size can both cause it to temporariliy be larger than the size specified here. </p>

</div>
</div>
<a class="anchor" id="a066561dd8530528cf8b5842852ec7657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool halide_memoization_cache_lookup </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>cache_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>realized_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>tuple_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> **&#160;</td>
          <td class="paramname"><em>tuple_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, determine if the result is in the cache and return it if so. </p>
<p>(The internals of the cache key should be considered opaque by this function.) If this routine returns true, it is a cache miss. Otherwise, it will return false and the buffers passed in will be filled, via copying, with memoized data. The last argument is a list if <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> pointers which represents the outputs of the memoized Func. If the Func does not return a Tuple, there will only be one <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> in the list. The tuple_count parameters determines the length of the list. </p>

</div>
</div>
<a class="anchor" id="a89b915ff5eca660c4179b5f332fce0f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_memoization_cache_store </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>cache_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>realized_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>tuple_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> **&#160;</td>
          <td class="paramname"><em>tuple_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, store the result in the cache for futre access by halide_memoization_cache_lookup. </p>
<p>(The internals of the cache key should be considered opaque by this function.) Data is copied out from the inputs and inputs are unmodified. The last argument is a list if <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> pointers which represents the outputs of the memoized Func. If the Func does not return a Tuple, there will only be one <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> in the list. The tuple_count parameters determines the length of the list. </p>

</div>
</div>
<a class="anchor" id="a30f9bdd5b6ac08b3fa785f3332cca996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_memoization_cache_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all memory and resources associated with the memoization cache. </p>
<p>Must be called at a time when no other threads are accessing the cache. </p>

</div>
</div>
<a class="anchor" id="a56de7e95e571c442a05506a451318f00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_bounds_inference_call_failed </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extern_stage_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> calls the functions below on various error conditions. </p>
<p>The default implementations construct an error message, call halide_error, then return the matching error code above. Override these to catch the errors individually. A call into an extern stage for the purposes of bounds inference failed. Returns the error code given by the extern stage. </p>

</div>
</div>
<a class="anchor" id="a83ec7fcc618e1b0508a6f4f726a7bcae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_extern_stage_failed </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extern_stage_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A call to an extern stage failed. </p>
<p>Returned the error code given by the extern stage. </p>

</div>
</div>
<a class="anchor" id="aa5b03b398e934c740dd4905a02a9bb81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_explicit_bounds_too_small </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_required</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a359867540d70c0e91feb11831d7b2591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_bad_elem_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elem_size_given</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>correct_elem_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="aa54c6e910c7b7feb2a51c7a0a549a9bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_access_out_of_bounds </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_touched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_touched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a22936015ebadbfb32e5a14c663d20060"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_buffer_allocation_too_large </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>allocation_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a80d5f3810ffacdc2950743193411c6d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_buffer_extents_too_large </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>actual_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a5fcbb3316d10d47471e9d74ba74d8e6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_constraints_make_required_region_smaller </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constrained_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constrained_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>required_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>required_extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a41a91525ca15c31958738cf7ec44e410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_constraint_violated </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>constrained_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constrained_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a9dc44166713b0e8fbef22542e4e0fe95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_small_i64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>min_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a93fce86c8f8d93969bde686d502b4340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_small_u64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>min_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a8d06e8302739a4a26bfa2b0113fc376d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_small_f64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a8f31f3a6a09ab3b5b798cecbd3f5e045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_large_i64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="aca082a34f38e8657551128db3969f8af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_large_u64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a7bc42c90e0703c23c6f141fb476cfa04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_large_f64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a64356948f9a36e16664585fff6f0949d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_out_of_memory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="aab974b4b7963cad8613c3825a5689086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_buffer_argument_is_null </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a6d12212093b19b3c2ea2b83df15302e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_debug_to_file_failed </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a3454e11a6ec4e53fd2883fe291a1b0dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_enumerate_registered_filters </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>enumerate_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#acfc1ecebda4db1628bc2723f1517afa1">enumerate_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a filter is compiled with Target::RegisterMetadata, it will register itself in an internal list at load time; <a class="el" href="_halide_runtime_8h.html#a3454e11a6ec4e53fd2883fe291a1b0dd" title="If a filter is compiled with Target::RegisterMetadata, it will register itself in an internal list at...">halide_enumerate_registered_filters()</a> allows you to enumerate all such filters at runtime. </p>
<p>This allows you to link together arbitrary AOT-compiled filters and introspect/call them easily. Note:</p>
<p>&ndash; Only filters compiled with Target::RegisterMetadata enabled will be enumerated. &ndash; This function should not be called before or after main() (i.e., must not be called from static ctors or dtors). &ndash; Filters will be enumerated in an unpredictable order; it is essential you do not rely on a particular order of enumeration. &ndash; It is <em>not</em> guaranteed that the names in an enumeration are unique!</p>
<p>The return value is zero if the enumerate_func_t always returns zero; if the enumerate_func_t returns a nonzero value, enumeration will terminate early and return that nonzero result. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_bf9f26469d00835ba20ff8d80ee5a804.html">runtime</a></li><li class="navelem"><a class="el" href="_halide_runtime_8h.html">HalideRuntime.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
