<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: HalideRuntime.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_halide_runtime_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">HalideRuntime.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Set a custom malloc and free for halide to use.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;stdbool.h&gt;</code><br/>
</div>
<p><a href="_halide_runtime_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__mutex.html">halide_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross-platform mutex.  <a href="structhalide__mutex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__type__t.html">halide_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A runtime tag for a type in the halide type system.  <a href="structhalide__type__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__trace__packet__t.html">halide_trace_packet_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The header of a packet in a binary trace.  <a href="structhalide__trace__packet__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw representation of an image passed around by generated <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> code.  <a href="structhalide__buffer__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbuffer__t.html">buffer_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__scalar__value__t.html">halide_scalar_value_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structhalide__scalar__value__t.html" title="halide_scalar_value_t is a simple union able to represent all the well-known scalar values in a filte...">halide_scalar_value_t</a> is a simple union able to represent all the well-known scalar values in a filter argument.  <a href="structhalide__scalar__value__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__filter__argument__t.html">halide_filter_argument_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structhalide__filter__argument__t.html" title="halide_filter_argument_t is essentially a plain-C-struct equivalent to Halide::Argument; most user co...">halide_filter_argument_t</a> is essentially a plain-C-struct equivalent to <a class="el" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function. ">Halide::Argument</a>; most user code will never need to create one.  <a href="structhalide__filter__argument__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__filter__metadata__t.html">halide_filter_metadata_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__profiler__func__stats.html">halide_profiler_func_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The functions below here are relevant for pipelines compiled with the -profile target flag, which runs a sampling profiler thread alongside the pipeline.  <a href="structhalide__profiler__func__stats.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__profiler__pipeline__stats.html">halide_profiler_pipeline_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-pipeline state tracked by the sampling profiler.  <a href="structhalide__profiler__pipeline__stats.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhalide__profiler__state.html">halide_profiler_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global state of the profiler.  <a href="structhalide__profiler__state.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac0c2048ce1a292798d15d9dc3346de26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a>&#160;&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a6b25bae9a0c908a7a45bc68f1b5c76c3">__attribute__</a>((always_inline)) inline</td></tr>
<tr class="separator:ac0c2048ce1a292798d15d9dc3346de26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa0f73fc7954ac27a2c11020681cdf3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#afaa0f73fc7954ac27a2c11020681cdf3">HALIDE_ATTRIBUTE_ALIGN</a>(x)&#160;&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a6b25bae9a0c908a7a45bc68f1b5c76c3">__attribute__</a>((aligned(x)))</td></tr>
<tr class="separator:afaa0f73fc7954ac27a2c11020681cdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb1030f4a2614c18adb6d088529f911"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a9bb1030f4a2614c18adb6d088529f911">HALIDE_ATTRIBUTE_DEPRECATED</a>(x)&#160;&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a6b25bae9a0c908a7a45bc68f1b5c76c3">__attribute__</a>((deprecated(x)))</td></tr>
<tr class="separator:a9bb1030f4a2614c18adb6d088529f911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2622d62cd7688033c8c6ad612cf5c3e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a2622d62cd7688033c8c6ad612cf5c3e8">BUFFER_T_DEFINED</a></td></tr>
<tr class="memdesc:a2622d62cd7688033c8c6ad612cf5c3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The old <a class="el" href="structbuffer__t.html">buffer_t</a>, included for compatibility with old code.  <a href="#a2622d62cd7688033c8c6ad612cf5c3e8">More...</a><br/></td></tr>
<tr class="separator:a2622d62cd7688033c8c6ad612cf5c3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a67106643662219b875b6e69775955944"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a67106643662219b875b6e69775955944">halide_do_par_for_t</a> )(void *, <a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a>, int, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td></tr>
<tr class="memdesc:a67106643662219b875b6e69775955944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom method for performing a parallel for loop.  <a href="#a67106643662219b875b6e69775955944">More...</a><br/></td></tr>
<tr class="separator:a67106643662219b875b6e69775955944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8ef2cf42c925601df1b997c1b938bf"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#abd8ef2cf42c925601df1b997c1b938bf">halide_type_code_t</a></td></tr>
<tr class="memdesc:abd8ef2cf42c925601df1b997c1b938bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types in the halide type system.  <a href="#abd8ef2cf42c925601df1b997c1b938bf">More...</a><br/></td></tr>
<tr class="separator:abd8ef2cf42c925601df1b997c1b938bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218cc381e4551fc66f009a05cb0b8041"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a218cc381e4551fc66f009a05cb0b8041">halide_trace_t</a> )(void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const struct <a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a> *)</td></tr>
<tr class="separator:a218cc381e4551fc66f009a05cb0b8041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64e96ae698ab344dec89bc8a172a243"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ae64e96ae698ab344dec89bc8a172a243">halide_device_free_t</a> )(void *, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *)</td></tr>
<tr class="memdesc:ae64e96ae698ab344dec89bc8a172a243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to halide_device_free if a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> runtime has been linked in.  <a href="#ae64e96ae698ab344dec89bc8a172a243">More...</a><br/></td></tr>
<tr class="separator:ae64e96ae698ab344dec89bc8a172a243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344de1f54ca97bc45193724bd7b3eaf3"><td class="memItemLeft" align="right" valign="top">typedef enum <br class="typebreak"/>
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3a">halide_target_feature_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a344de1f54ca97bc45193724bd7b3eaf3">halide_target_feature_t</a></td></tr>
<tr class="memdesc:a344de1f54ca97bc45193724bd7b3eaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional features a compilation Target can have.  <a href="#a344de1f54ca97bc45193724bd7b3eaf3">More...</a><br/></td></tr>
<tr class="separator:a344de1f54ca97bc45193724bd7b3eaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84da9f450b3335aeaf44fefb9be234e7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a84da9f450b3335aeaf44fefb9be234e7">halide_dimension_t</a></td></tr>
<tr class="separator:a84da9f450b3335aeaf44fefb9be234e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8ab0b07dcaa0d81d9abadae30242b6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5c8ab0b07dcaa0d81d9abadae30242b6">halide_buffer_t</a></td></tr>
<tr class="memdesc:a5c8ab0b07dcaa0d81d9abadae30242b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw representation of an image passed around by generated <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> code.  <a href="#a5c8ab0b07dcaa0d81d9abadae30242b6">More...</a><br/></td></tr>
<tr class="separator:a5c8ab0b07dcaa0d81d9abadae30242b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe399a52d3e6b4c16909f8216198044"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structbuffer__t.html">buffer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aebe399a52d3e6b4c16909f8216198044">buffer_t</a></td></tr>
<tr class="separator:aebe399a52d3e6b4c16909f8216198044"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9f4c40f298e91dea4f532774dc57a450"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a> { <a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450a53ba65448e4cbe66680c29a1333c8bfa">halide_type_int</a> = 0, 
<a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450adfa8b0e2cbd616d1259c9471ec5c2b4d">halide_type_uint</a> = 1, 
<a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450a05c0160361d9fc5deb778f9a6744f42b">halide_type_float</a> = 2, 
<a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450a22f25129c6493f710ace985e0f8f01ef">halide_type_handle</a> = 3
 }</td></tr>
<tr class="memdesc:a9f4c40f298e91dea4f532774dc57a450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types in the halide type system.  <a href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450">More...</a><br/></td></tr>
<tr class="separator:a9f4c40f298e91dea4f532774dc57a450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485130f12eb8bb5fa5a9478eeb6b0dfa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a485130f12eb8bb5fa5a9478eeb6b0dfa">halide_trace_event_code_t</a> { <br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a485130f12eb8bb5fa5a9478eeb6b0dfaa2cbd3048c959f6d8def944097d8e21c9">halide_trace_load</a> = 0, 
<a class="el" href="_halide_runtime_8h.html#a485130f12eb8bb5fa5a9478eeb6b0dfaa57b32d087e0862bd6ba748ce7743a851">halide_trace_store</a> = 1, 
<a class="el" href="_halide_runtime_8h.html#a485130f12eb8bb5fa5a9478eeb6b0dfaad8657c19f6b2b9cc79fa3a438f39687b">halide_trace_begin_realization</a> = 2, 
<a class="el" href="_halide_runtime_8h.html#a485130f12eb8bb5fa5a9478eeb6b0dfaacb0bdc3e4044609ab7fae05b921595ab">halide_trace_end_realization</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a485130f12eb8bb5fa5a9478eeb6b0dfaac4047c93cd032261e8373e38944bf7a1">halide_trace_produce</a> = 4, 
<a class="el" href="_halide_runtime_8h.html#a485130f12eb8bb5fa5a9478eeb6b0dfaac0c72771e1401fad47e3234caa121427">halide_trace_end_produce</a> = 5, 
<a class="el" href="_halide_runtime_8h.html#a485130f12eb8bb5fa5a9478eeb6b0dfaa0dac17982d8ef6c404f94e5b7dd4de54">halide_trace_consume</a> = 6, 
<a class="el" href="_halide_runtime_8h.html#a485130f12eb8bb5fa5a9478eeb6b0dfaac98849a734841652345dc3d37660c136">halide_trace_end_consume</a> = 7, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a485130f12eb8bb5fa5a9478eeb6b0dfaa7b9317d3544502c02e018db4bac2b97e">halide_trace_begin_pipeline</a> = 8, 
<a class="el" href="_halide_runtime_8h.html#a485130f12eb8bb5fa5a9478eeb6b0dfaa92151c79c44b19ad2c1074fb6f113b1c">halide_trace_end_pipeline</a> = 9
<br/>
 }</td></tr>
<tr class="separator:a485130f12eb8bb5fa5a9478eeb6b0dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba16e170cc9aa30b78ff703e101a448c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448c">halide_error_code_t</a> { <br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca61d939236ddc9e13ff364e2c18149f04">halide_error_code_success</a> = 0, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca463fb2939949a1e8634905edf23efe05">halide_error_code_generic_error</a> = -1, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448cad9e00397c85cca42380f43b2689a8b7c">halide_error_code_explicit_bounds_too_small</a> = -2, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448cac864d0a2ca831c3c757b6e410d8cdd3f">halide_error_code_bad_type</a> = -3, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca0e0423bbffc1b99dffcdcfb5f64982ea">halide_error_code_access_out_of_bounds</a> = -4, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448cac11c436ca3edba1a8d0e961f3320e7e6">halide_error_code_buffer_allocation_too_large</a> = -5, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448cae18e82f52439b79a5523c009904ff99b">halide_error_code_buffer_extents_too_large</a> = -6, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca2d28fcb409c42316eaa24f6a6a74eeb6">halide_error_code_constraints_make_required_region_smaller</a> = -7, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448caf63622ed5219be61db38d6aa49b72334">halide_error_code_constraint_violated</a> = -8, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca0d9f00cc44f9f77fa70836e7d25cfaf8">halide_error_code_param_too_small</a> = -9, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca0d5dfd64f10156a5d2d1453fad4bfb6c">halide_error_code_param_too_large</a> = -10, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448caf47d74c0b04724325995bb4bd58cecb0">halide_error_code_out_of_memory</a> = -11, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca86cb45d6014d16a06c0d9071c122ec9a">halide_error_code_buffer_argument_is_null</a> = -12, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca9e69757bbb1448560eff39ad38e28aff">halide_error_code_debug_to_file_failed</a> = -13, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca61e81a880002d327a8d1aa09c3233636">halide_error_code_copy_to_host_failed</a> = -14, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca40015fc733363a53e154bc8183c86b54">halide_error_code_copy_to_device_failed</a> = -15, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca92667ff05a79083a7de97843d507ecdb">halide_error_code_device_malloc_failed</a> = -16, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca79b37d315188ac600b479f68d2627952">halide_error_code_device_sync_failed</a> = -17, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448cab9688dd68dbb132ba66ea80186fc18d1">halide_error_code_device_free_failed</a> = -18, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca006100e2007527689fe7d6104b209956">halide_error_code_no_device_interface</a> = -19, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca6c123efceb388bfef491629d89065775">halide_error_code_matlab_init_failed</a> = -20, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448caf5c56ee69de59cfb5959461ac0a8c570">halide_error_code_matlab_bad_param_type</a> = -21, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca28e9d2c63f5933a4422b668b3f473867">halide_error_code_internal_error</a> = -22, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448cacf7f17603b30be3f4df86d701df4ee2a">halide_error_code_device_run_failed</a> = -23, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448caf843735e0a784d64e56fcff6069cdb5d">halide_error_code_unaligned_host_ptr</a> = -24, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca07b8321ceede9444ea7bba637a9bb7c1">halide_error_code_bad_fold</a> = -25, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca0a42d062cb8da32cf5158daab9c37c41">halide_error_code_fold_factor_too_small</a> = -26, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca180c55e696deec0e26fc4b82fadefd4c">halide_error_code_requirement_failed</a> = -27, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca2b91673e6f8ed8585e1571a03173ea22">halide_error_code_buffer_extents_negative</a> = -28, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca853a112ac8f7a04078f3bb50e840b9de">halide_error_code_failed_to_upgrade_buffer_t</a> = -29, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca83b466928774790b35bf676dfe173760">halide_error_code_failed_to_downgrade_buffer_t</a> = -30, 
<a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448ca0e0b319ab036506ee80df45c1f5cdac0">halide_error_code_specialize_fail</a> = -31
<br/>
 }</td></tr>
<tr class="memdesc:aba16e170cc9aa30b78ff703e101a448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error codes that may be returned by a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> pipeline.  <a href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448c">More...</a><br/></td></tr>
<tr class="separator:aba16e170cc9aa30b78ff703e101a448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccb96b3d427fff8f1d68cc5f1e92f3a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3a">halide_target_feature_t</a> { <br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aade7b43403349f5e8490128ec8a353ea0">halide_target_feature_jit</a> = 0, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa269192ac4c709ac4cd58a224aaa4ebed">halide_target_feature_debug</a> = 1, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa1091af1b1f0fd0f65a4cf11d9465421b">halide_target_feature_no_asserts</a> = 2, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf66b5dc5721dc9d3437418d2af78218a">halide_target_feature_no_bounds_query</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa8efcb48a15fdbfeb9a80f4e4b47f6c35">halide_target_feature_sse41</a> = 4, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aae30ffae7b5e51bd142e5902c6b60d2a5">halide_target_feature_avx</a> = 5, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa1b8d4c5f8ff39549eab349f8f9187f30">halide_target_feature_avx2</a> = 6, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa00ca2d6e033b225858ea63abb21123da">halide_target_feature_fma</a> = 7, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5c4a3ac722a0f391a41809f4fe1fa5e9">halide_target_feature_fma4</a> = 8, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aac3f0411bb6041392120209d5eb97dd20">halide_target_feature_f16c</a> = 9, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5fa253bc01a2a59792fd5da6d351d35f">halide_target_feature_armv7s</a> = 10, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5f1be27fa92915a8d2193f0bbeb9ada5">halide_target_feature_no_neon</a> = 11, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf10caf4d87b54ef2a1eeef0a1a9ef7a4">halide_target_feature_vsx</a> = 12, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa995a835a73267a3edd9822c6d1927c3a">halide_target_feature_power_arch_2_07</a> = 13, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aabaf8d7892508763403932f8e9e80b2e2">halide_target_feature_cuda</a> = 14, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5e16be3f2066021a8d24ee420d69b2a3">halide_target_feature_cuda_capability30</a> = 15, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aad6cf6481cb5a8f405115dd91a7d71987">halide_target_feature_cuda_capability32</a> = 16, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa72e1c9e35b9184f0a8b7157374c81e9b">halide_target_feature_cuda_capability35</a> = 17, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aaa45190927a84bdeab2a4195eae0b47f6">halide_target_feature_cuda_capability50</a> = 18, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa9af51d9a3d2a16a2053dee312567da3a">halide_target_feature_opencl</a> = 19, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa10dfd45f611103dce0fcdbf671b89e5a">halide_target_feature_cl_doubles</a> = 20, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aab19096f9cc22d728014cb0da3ac3fa9f">halide_target_feature_opengl</a> = 21, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa17e04f4f71026dd997991fbc1d97437f">halide_target_feature_openglcompute</a> = 22, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aae45ec1b677cea5f38e82dc776a70817e">halide_target_feature_unused_23</a> = 23, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf353c2e40c697e29b86a4e51829735df">halide_target_feature_user_context</a> = 24, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5563142075b821d2b5efad58c57f0431">halide_target_feature_matlab</a> = 25, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa700fd7b1280a9175b7cb3d43fe2c1754">halide_target_feature_profile</a> = 26, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa23b4add23a16a3cfe633b90f2fd6d292">halide_target_feature_no_runtime</a> = 27, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa596a01105ce4f5896b14c69210899e35">halide_target_feature_metal</a> = 28, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aaffc640375f557b19ce0f9ff540cc3f7a">halide_target_feature_mingw</a> = 29, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa1efec7b26946ba7f59cc887dcd45ea22">halide_target_feature_c_plus_plus_mangling</a> = 30, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa00aee1f2d9370a407522de5378d9901c">halide_target_feature_large_buffers</a> = 31, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aad88272637e7f1e81c66bff8c5f4ed831">halide_target_feature_hvx_64</a> = 32, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5bbb70ba548793579bef24d7bd8ffd6a">halide_target_feature_hvx_128</a> = 33, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aaac0b0401c077429c652dc5d2723756f0">halide_target_feature_hvx_v62</a> = 34, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aaf7f57223352cf39e7375d2e2af6004b2">halide_target_feature_fuzz_float_stores</a> = 35, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa484bc02e560762b1c51c0bf254b00a9f">halide_target_feature_soft_float_abi</a> = 36, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa068da87b16c87dd104d9720fec39ec42">halide_target_feature_msan</a> = 37, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aaa237eaab3cbd8d646c075b74f9958ba0">halide_target_feature_avx512</a> = 38, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aaa2779d4303538045aa9317c5cfefde48">halide_target_feature_avx512_knl</a> = 39, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa58fb5b7b5bc221459b800cc42930902f">halide_target_feature_avx512_skylake</a> = 40, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa591bbdef6ade866e52fa671d8ea2aed1">halide_target_feature_avx512_cannonlake</a> = 41, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aab3a23a74dcd2c56129fdac9b5487500e">halide_target_feature_hvx_use_shared_object</a> = 42, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa0de323126eca04377e205b6a67b93970">halide_target_feature_trace_loads</a> = 43, 
<br/>
&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa9d6461b681abeeb0ff4c850cfe4e1eb4">halide_target_feature_trace_stores</a> = 44, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa1cebf3f4e7137ca7f3a74b4c2049de4d">halide_target_feature_trace_realizations</a> = 45, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa5f6ed2f96b52eaeae62dc1beb66b74de">halide_target_feature_cuda_capability61</a> = 46, 
<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3aa3962d2fc2f69c69b85d29c4818d727c1">halide_target_feature_end</a> = 47
<br/>
 }</td></tr>
<tr class="memdesc:a2ccb96b3d427fff8f1d68cc5f1e92f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional features a compilation Target can have.  <a href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3a">More...</a><br/></td></tr>
<tr class="separator:a2ccb96b3d427fff8f1d68cc5f1e92f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320c79a12e6121c7468cb203373e6afc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a320c79a12e6121c7468cb203373e6afc">halide_buffer_flags</a> { <a class="el" href="_halide_runtime_8h.html#a320c79a12e6121c7468cb203373e6afca1b91e0ac0aba5891e4c7219878da7460">halide_buffer_flag_host_dirty</a> = 1, 
<a class="el" href="_halide_runtime_8h.html#a320c79a12e6121c7468cb203373e6afca117e8a76112638ba6510e084e1dfb292">halide_buffer_flag_device_dirty</a> = 2
 }</td></tr>
<tr class="separator:a320c79a12e6121c7468cb203373e6afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdce5dc7a11fa96f39baa1aee2333745"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#afdce5dc7a11fa96f39baa1aee2333745">halide_argument_kind_t</a> { <a class="el" href="_halide_runtime_8h.html#afdce5dc7a11fa96f39baa1aee2333745a4cce082af093da2e1e886ed3a775b2b1">halide_argument_kind_input_scalar</a> = 0, 
<a class="el" href="_halide_runtime_8h.html#afdce5dc7a11fa96f39baa1aee2333745af4d5e7ee6d3fb12c5a5c0d9edd845a5b">halide_argument_kind_input_buffer</a> = 1, 
<a class="el" href="_halide_runtime_8h.html#afdce5dc7a11fa96f39baa1aee2333745a0113d76303e0327745f3b3e4070dccd8">halide_argument_kind_output_buffer</a> = 2
 }</td></tr>
<tr class="separator:afdce5dc7a11fa96f39baa1aee2333745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf764cbdea00d65edcd07bb9953ad2b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="_halide_runtime_8h.html#adf764cbdea00d65edcd07bb9953ad2b7ab6b9a850264048aeff726f435f21ac25">halide_profiler_outside_of_halide</a> = -1, 
<a class="el" href="_halide_runtime_8h.html#adf764cbdea00d65edcd07bb9953ad2b7aa07fb8b03c126c5357f8bbe679def9b5">halide_profiler_please_stop</a> = -2
 }</td></tr>
<tr class="memdesc:adf764cbdea00d65edcd07bb9953ad2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profiler func ids with special meanings.  <a href="_halide_runtime_8h.html#adf764cbdea00d65edcd07bb9953ad2b7">More...</a><br/></td></tr>
<tr class="separator:adf764cbdea00d65edcd07bb9953ad2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab9eb8b02091849cfbcbdf7d2f4177857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#a67106643662219b875b6e69775955944">halide_do_par_for_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ab9eb8b02091849cfbcbdf7d2f4177857">halide_set_custom_do_par_for</a> (<a class="el" href="_halide_runtime_8h.html#a67106643662219b875b6e69775955944">halide_do_par_for_t</a> do_par_for)</td></tr>
<tr class="separator:ab9eb8b02091849cfbcbdf7d2f4177857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705adaf288bb596411feaa98e33710dc"><td class="memItemLeft" align="right" valign="top">struct halide_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a705adaf288bb596411feaa98e33710dc">halide_spawn_thread</a> (void(*f)(void *), void *closure)</td></tr>
<tr class="memdesc:a705adaf288bb596411feaa98e33710dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a thread.  <a href="#a705adaf288bb596411feaa98e33710dc">More...</a><br/></td></tr>
<tr class="separator:a705adaf288bb596411feaa98e33710dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba03c92519ed6b3df69caf08e8278720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aba03c92519ed6b3df69caf08e8278720">halide_join_thread</a> (struct halide_thread *)</td></tr>
<tr class="memdesc:aba03c92519ed6b3df69caf08e8278720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a thread.  <a href="#aba03c92519ed6b3df69caf08e8278720">More...</a><br/></td></tr>
<tr class="separator:aba03c92519ed6b3df69caf08e8278720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d93e0796319cf64432c511affba1a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a36d93e0796319cf64432c511affba1a5">halide_set_num_threads</a> (int n)</td></tr>
<tr class="memdesc:a36d93e0796319cf64432c511affba1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of threads used by <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s thread pool.  <a href="#a36d93e0796319cf64432c511affba1a5">More...</a><br/></td></tr>
<tr class="separator:a36d93e0796319cf64432c511affba1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d6415aa2c7d4e135527a83b30061b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a60d6415aa2c7d4e135527a83b30061b6">halide_debug_to_file</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *filename, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> type_code, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="memdesc:a60d6415aa2c7d4e135527a83b30061b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when debug_to_file is used inside Halide code.  <a href="#a60d6415aa2c7d4e135527a83b30061b6">More...</a><br/></td></tr>
<tr class="separator:a60d6415aa2c7d4e135527a83b30061b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d172a9f341a56bc9c5124d2c61a5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a83d172a9f341a56bc9c5124d2c61a5aa">halide_trace</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const struct <a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a> *event)</td></tr>
<tr class="memdesc:a83d172a9f341a56bc9c5124d2c61a5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when Funcs are marked as trace_load, trace_store, or trace_realization.  <a href="#a83d172a9f341a56bc9c5124d2c61a5aa">More...</a><br/></td></tr>
<tr class="separator:a83d172a9f341a56bc9c5124d2c61a5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9983cd83d6ff3aae428080d20e2af680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a9983cd83d6ff3aae428080d20e2af680">halide_default_trace</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const struct <a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a> *event)</td></tr>
<tr class="separator:a9983cd83d6ff3aae428080d20e2af680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963a4ee1ed5d4c89b29eadca3a2e0236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#a218cc381e4551fc66f009a05cb0b8041">halide_trace_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a963a4ee1ed5d4c89b29eadca3a2e0236">halide_set_custom_trace</a> (<a class="el" href="_halide_runtime_8h.html#a218cc381e4551fc66f009a05cb0b8041">halide_trace_t</a> trace)</td></tr>
<tr class="separator:a963a4ee1ed5d4c89b29eadca3a2e0236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8761e708f878372e3201126e83d6f3b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a8761e708f878372e3201126e83d6f3b6">halide_set_trace_file</a> (int fd)</td></tr>
<tr class="memdesc:a8761e708f878372e3201126e83d6f3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the file descriptor that <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> should write binary trace events to.  <a href="#a8761e708f878372e3201126e83d6f3b6">More...</a><br/></td></tr>
<tr class="separator:a8761e708f878372e3201126e83d6f3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee99b65dcbc81d91a0f22507eb7f8017"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aee99b65dcbc81d91a0f22507eb7f8017">halide_get_trace_file</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>)</td></tr>
<tr class="memdesc:aee99b65dcbc81d91a0f22507eb7f8017"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls this to retrieve the file descriptor to write binary trace events to.  <a href="#aee99b65dcbc81d91a0f22507eb7f8017">More...</a><br/></td></tr>
<tr class="separator:aee99b65dcbc81d91a0f22507eb7f8017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618bb97f5d713e1097835a24670948f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a618bb97f5d713e1097835a24670948f4">halide_shutdown_trace</a> ()</td></tr>
<tr class="memdesc:a618bb97f5d713e1097835a24670948f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If tracing is writing to a file.  <a href="#a618bb97f5d713e1097835a24670948f4">More...</a><br/></td></tr>
<tr class="separator:a618bb97f5d713e1097835a24670948f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5412b6569e456b0a85896d9afa986630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5412b6569e456b0a85896d9afa986630">halide_device_release</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface)</td></tr>
<tr class="memdesc:a5412b6569e456b0a85896d9afa986630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all data associated with the current GPU backend, in particular all resources (memory, texture, context handles) allocated by <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>.  <a href="#a5412b6569e456b0a85896d9afa986630">More...</a><br/></td></tr>
<tr class="separator:a5412b6569e456b0a85896d9afa986630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bb9875eba947a4ef1f8e4ee19a7f5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a37bb9875eba947a4ef1f8e4ee19a7f5e">halide_copy_to_host</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="memdesc:a37bb9875eba947a4ef1f8e4ee19a7f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image data from device memory to host memory.  <a href="#a37bb9875eba947a4ef1f8e4ee19a7f5e">More...</a><br/></td></tr>
<tr class="separator:a37bb9875eba947a4ef1f8e4ee19a7f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae564c907ea0e5b5520e876ce28f29af9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ae564c907ea0e5b5520e876ce28f29af9">halide_copy_to_device</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface)</td></tr>
<tr class="memdesc:ae564c907ea0e5b5520e876ce28f29af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy image data from host memory to device memory.  <a href="#ae564c907ea0e5b5520e876ce28f29af9">More...</a><br/></td></tr>
<tr class="separator:ae564c907ea0e5b5520e876ce28f29af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13dfb9b20f566b9221cbb883fd622595"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a13dfb9b20f566b9221cbb883fd622595">halide_device_sync</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="memdesc:a13dfb9b20f566b9221cbb883fd622595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for current GPU operations to complete.  <a href="#a13dfb9b20f566b9221cbb883fd622595">More...</a><br/></td></tr>
<tr class="separator:a13dfb9b20f566b9221cbb883fd622595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5dea3365145ef7bcda3df9c787d9bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a9f5dea3365145ef7bcda3df9c787d9bc">halide_device_malloc</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface)</td></tr>
<tr class="memdesc:a9f5dea3365145ef7bcda3df9c787d9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate device memory to back a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a>.  <a href="#a9f5dea3365145ef7bcda3df9c787d9bc">More...</a><br/></td></tr>
<tr class="separator:a9f5dea3365145ef7bcda3df9c787d9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac643953e77f882726d175d8bd9250c13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ac643953e77f882726d175d8bd9250c13">halide_device_free</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="memdesc:ac643953e77f882726d175d8bd9250c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free device memory.  <a href="#ac643953e77f882726d175d8bd9250c13">More...</a><br/></td></tr>
<tr class="separator:ac643953e77f882726d175d8bd9250c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b25bae9a0c908a7a45bc68f1b5c76c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a6b25bae9a0c908a7a45bc68f1b5c76c3">__attribute__</a> ((weak)) int halide_weak_device_free(void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a></td></tr>
<tr class="separator:a6b25bae9a0c908a7a45bc68f1b5c76c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871d17a8b699de9b2ca520feb3db89e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ae64e96ae698ab344dec89bc8a172a243">halide_device_free_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a871d17a8b699de9b2ca520feb3db89e5">halide_get_device_free_fn</a> ()</td></tr>
<tr class="separator:a871d17a8b699de9b2ca520feb3db89e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9906fca5a688c26e0465a1b3da84ccfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a9906fca5a688c26e0465a1b3da84ccfb">halide_set_gpu_device</a> (int n)</td></tr>
<tr class="memdesc:a9906fca5a688c26e0465a1b3da84ccfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects which gpu device to use.  <a href="#a9906fca5a688c26e0465a1b3da84ccfb">More...</a><br/></td></tr>
<tr class="separator:a9906fca5a688c26e0465a1b3da84ccfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc511579a9ad82da9c1c611f008dd454"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#adc511579a9ad82da9c1c611f008dd454">halide_get_gpu_device</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>)</td></tr>
<tr class="memdesc:adc511579a9ad82da9c1c611f008dd454"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls this to get the desired halide gpu device setting.  <a href="#adc511579a9ad82da9c1c611f008dd454">More...</a><br/></td></tr>
<tr class="separator:adc511579a9ad82da9c1c611f008dd454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf85692a77aec0b887f345d0d3ca6777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#abf85692a77aec0b887f345d0d3ca6777">halide_memoization_cache_set_size</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> size)</td></tr>
<tr class="memdesc:abf85692a77aec0b887f345d0d3ca6777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the soft maximum amount of memory, in bytes, that the LRU cache will use to memoize Func results.  <a href="#abf85692a77aec0b887f345d0d3ca6777">More...</a><br/></td></tr>
<tr class="separator:abf85692a77aec0b887f345d0d3ca6777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e828012fc956325101a835716f8ca22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a0e828012fc956325101a835716f8ca22">halide_memoization_cache_lookup</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *cache_key, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> size, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *realized_bounds, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> tuple_count, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> **tuple_buffers)</td></tr>
<tr class="memdesc:a0e828012fc956325101a835716f8ca22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, determine if the result is in the cache and return it if so.  <a href="#a0e828012fc956325101a835716f8ca22">More...</a><br/></td></tr>
<tr class="separator:a0e828012fc956325101a835716f8ca22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18887f3038f6749b0a3a682d1e352fbd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a18887f3038f6749b0a3a682d1e352fbd">halide_memoization_cache_store</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *cache_key, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> size, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *realized_bounds, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> tuple_count, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> **tuple_buffers)</td></tr>
<tr class="memdesc:a18887f3038f6749b0a3a682d1e352fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, store the result in the cache for futre access by halide_memoization_cache_lookup.  <a href="#a18887f3038f6749b0a3a682d1e352fbd">More...</a><br/></td></tr>
<tr class="separator:a18887f3038f6749b0a3a682d1e352fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714f9e341f1d71baf8abc77bc50e1db5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a714f9e341f1d71baf8abc77bc50e1db5">halide_memoization_cache_release</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, void *host)</td></tr>
<tr class="memdesc:a714f9e341f1d71baf8abc77bc50e1db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If halide_memoization_cache_lookup succeeds, halide_memoization_cache_release must be called to signal the storage is no longer being used by the caller.  <a href="#a714f9e341f1d71baf8abc77bc50e1db5">More...</a><br/></td></tr>
<tr class="separator:a714f9e341f1d71baf8abc77bc50e1db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f9bdd5b6ac08b3fa785f3332cca996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a30f9bdd5b6ac08b3fa785f3332cca996">halide_memoization_cache_cleanup</a> ()</td></tr>
<tr class="memdesc:a30f9bdd5b6ac08b3fa785f3332cca996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory and resources associated with the memoization cache.  <a href="#a30f9bdd5b6ac08b3fa785f3332cca996">More...</a><br/></td></tr>
<tr class="separator:a30f9bdd5b6ac08b3fa785f3332cca996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5643238925a57825f2c4b0e188a4639a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5643238925a57825f2c4b0e188a4639a">halide_create_temp_file</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *prefix, const char *suffix, char *path_buf, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> path_buf_size)</td></tr>
<tr class="memdesc:a5643238925a57825f2c4b0e188a4639a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary (but writable) directory; this is typically $TMP or /tmp, but the specific location is not guaranteed.  <a href="#a5643238925a57825f2c4b0e188a4639a">More...</a><br/></td></tr>
<tr class="separator:a5643238925a57825f2c4b0e188a4639a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce1cfbe9784a6ea36d08e0a05e7b75a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a3ce1cfbe9784a6ea36d08e0a05e7b75a">halide_msan_annotate_memory_is_initialized</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const void *ptr, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> len)</td></tr>
<tr class="memdesc:a3ce1cfbe9784a6ea36d08e0a05e7b75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate that a given range of memory has been initialized; only used when Target::MSAN is enabled.  <a href="#a3ce1cfbe9784a6ea36d08e0a05e7b75a">More...</a><br/></td></tr>
<tr class="separator:a3ce1cfbe9784a6ea36d08e0a05e7b75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3ee381d774d6a7c9971c0d4cfb2675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a8a3ee381d774d6a7c9971c0d4cfb2675">halide_msan_annotate_buffer_is_initialized</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *buffer)</td></tr>
<tr class="memdesc:a8a3ee381d774d6a7c9971c0d4cfb2675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the data pointed to by the <a class="el" href="structbuffer__t.html">buffer_t</a> as initialized (but <em>not</em> the <a class="el" href="structbuffer__t.html">buffer_t</a> itself), using <a class="el" href="_halide_runtime_8h.html#a3ce1cfbe9784a6ea36d08e0a05e7b75a" title="Annotate that a given range of memory has been initialized; only used when Target::MSAN is enabled...">halide_msan_annotate_memory_is_initialized()</a> for marking.  <a href="#a8a3ee381d774d6a7c9971c0d4cfb2675">More...</a><br/></td></tr>
<tr class="separator:a8a3ee381d774d6a7c9971c0d4cfb2675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506f6e93f28aa3a0a9af8cdd8f9039ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a506f6e93f28aa3a0a9af8cdd8f9039ec">halide_msan_annotate_buffer_is_initialized_as_destructor</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, void *buffer)</td></tr>
<tr class="separator:a506f6e93f28aa3a0a9af8cdd8f9039ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56de7e95e571c442a05506a451318f00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a56de7e95e571c442a05506a451318f00">halide_error_bounds_inference_call_failed</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *extern_stage_name, int result)</td></tr>
<tr class="memdesc:a56de7e95e571c442a05506a451318f00"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls the functions below on various error conditions.  <a href="#a56de7e95e571c442a05506a451318f00">More...</a><br/></td></tr>
<tr class="separator:a56de7e95e571c442a05506a451318f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ec7fcc618e1b0508a6f4f726a7bcae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a83ec7fcc618e1b0508a6f4f726a7bcae">halide_error_extern_stage_failed</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *extern_stage_name, int result)</td></tr>
<tr class="memdesc:a83ec7fcc618e1b0508a6f4f726a7bcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call to an extern stage failed.  <a href="#a83ec7fcc618e1b0508a6f4f726a7bcae">More...</a><br/></td></tr>
<tr class="separator:a83ec7fcc618e1b0508a6f4f726a7bcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171b181824451b5475461da3874c801e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a171b181824451b5475461da3874c801e">halide_default_can_use_target_features</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> features)</td></tr>
<tr class="memdesc:a171b181824451b5475461da3874c801e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the default implementation of halide_can_use_target_features; it is provided for convenience of user code that may wish to extend halide_can_use_target_features but continue providing existing support, e.g.  <a href="#a171b181824451b5475461da3874c801e">More...</a><br/></td></tr>
<tr class="separator:a171b181824451b5475461da3874c801e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9367e850a3dd3d7c16d0325046c0655a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a9367e850a3dd3d7c16d0325046c0655a">halide_upgrade_buffer_t</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *name, const <a class="el" href="structbuffer__t.html">buffer_t</a> *old_buf, <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *new_buf)</td></tr>
<tr class="memdesc:a9367e850a3dd3d7c16d0325046c0655a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies host pointer, mins, extents, strides, and device state from an old-style <a class="el" href="structbuffer__t.html">buffer_t</a> into a new-style <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a>.  <a href="#a9367e850a3dd3d7c16d0325046c0655a">More...</a><br/></td></tr>
<tr class="separator:a9367e850a3dd3d7c16d0325046c0655a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa249de70377b90d975e3e0e19d7b24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#adfa249de70377b90d975e3e0e19d7b24">halide_downgrade_buffer_t</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *name, const <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *new_buf, <a class="el" href="structbuffer__t.html">buffer_t</a> *old_buf)</td></tr>
<tr class="memdesc:adfa249de70377b90d975e3e0e19d7b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the host pointer, mins, extents, strides, and device state from a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> to a <a class="el" href="structbuffer__t.html">buffer_t</a>.  <a href="#adfa249de70377b90d975e3e0e19d7b24">More...</a><br/></td></tr>
<tr class="separator:adfa249de70377b90d975e3e0e19d7b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e9d4f7f68f0de4a649d120f4c58cdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ae8e9d4f7f68f0de4a649d120f4c58cdc">halide_downgrade_buffer_t_device_fields</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *name, const <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *new_buf, <a class="el" href="structbuffer__t.html">buffer_t</a> *old_buf)</td></tr>
<tr class="memdesc:ae8e9d4f7f68f0de4a649d120f4c58cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the dirty flags and device allocation state from a new <a class="el" href="structbuffer__t.html">buffer_t</a> back to a legacy <a class="el" href="structbuffer__t.html">buffer_t</a>.  <a href="#ae8e9d4f7f68f0de4a649d120f4c58cdc">More...</a><br/></td></tr>
<tr class="separator:ae8e9d4f7f68f0de4a649d120f4c58cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd65e97950c095f215ff77de9664f5e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structhalide__profiler__state.html">halide_profiler_state</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a3cd65e97950c095f215ff77de9664f5e">halide_profiler_get_state</a> ()</td></tr>
<tr class="memdesc:a3cd65e97950c095f215ff77de9664f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the global profiler state for programmatic inspection.  <a href="#a3cd65e97950c095f215ff77de9664f5e">More...</a><br/></td></tr>
<tr class="separator:a3cd65e97950c095f215ff77de9664f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab3ca1106a4e47109c1b8bb82f40ecf"><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="el" href="structhalide__profiler__pipeline__stats.html">halide_profiler_pipeline_stats</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5ab3ca1106a4e47109c1b8bb82f40ecf">halide_profiler_get_pipeline_state</a> (const char *pipeline_name)</td></tr>
<tr class="memdesc:a5ab3ca1106a4e47109c1b8bb82f40ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the pipeline state associated with pipeline_name.  <a href="#a5ab3ca1106a4e47109c1b8bb82f40ecf">More...</a><br/></td></tr>
<tr class="separator:a5ab3ca1106a4e47109c1b8bb82f40ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046ccf558100c9a2b0664074157c6563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a046ccf558100c9a2b0664074157c6563">halide_profiler_reset</a> ()</td></tr>
<tr class="memdesc:a046ccf558100c9a2b0664074157c6563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all profiler state.  <a href="#a046ccf558100c9a2b0664074157c6563">More...</a><br/></td></tr>
<tr class="separator:a046ccf558100c9a2b0664074157c6563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98690684642752376f858a9c6f1ccd29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a98690684642752376f858a9c6f1ccd29">halide_profiler_report</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>)</td></tr>
<tr class="memdesc:a98690684642752376f858a9c6f1ccd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out timing statistics for everything run since the last reset.  <a href="#a98690684642752376f858a9c6f1ccd29">More...</a><br/></td></tr>
<tr class="separator:a98690684642752376f858a9c6f1ccd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a479133225b3cdf7b931f3c44e878e4e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a479133225b3cdf7b931f3c44e878e4e8">halide_mutex_lock</a> (struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a479133225b3cdf7b931f3c44e878e4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic set of mutex and condition variable functions, which call platform specific code for mutual exclusion.  <a href="#a479133225b3cdf7b931f3c44e878e4e8">More...</a><br/></td></tr>
<tr class="separator:a479133225b3cdf7b931f3c44e878e4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9b62fd2c1d38e6f06100b827830377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5e9b62fd2c1d38e6f06100b827830377">halide_mutex_unlock</a> (struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a5e9b62fd2c1d38e6f06100b827830377"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic set of mutex and condition variable functions, which call platform specific code for mutual exclusion.  <a href="#a5e9b62fd2c1d38e6f06100b827830377">More...</a><br/></td></tr>
<tr class="separator:a5e9b62fd2c1d38e6f06100b827830377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6daa319e15be120217dc6d393004aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#acb6daa319e15be120217dc6d393004aa">halide_mutex_destroy</a> (struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *mutex)</td></tr>
<tr class="memdesc:acb6daa319e15be120217dc6d393004aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic set of mutex and condition variable functions, which call platform specific code for mutual exclusion.  <a href="#acb6daa319e15be120217dc6d393004aa">More...</a><br/></td></tr>
<tr class="separator:acb6daa319e15be120217dc6d393004aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3a20aae4f3c690d66578775e1245ec22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a3a20aae4f3c690d66578775e1245ec22">halide_default_do_par_for</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, <a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a> task, int min, int size, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td></tr>
<tr class="memdesc:a3a20aae4f3c690d66578775e1245ec22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default versions of do_task and do_par_for.  <a href="#a3a20aae4f3c690d66578775e1245ec22">More...</a><br/></td></tr>
<tr class="separator:a3a20aae4f3c690d66578775e1245ec22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1529a6494b14d3a4f19b8080fdd77e31"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a1529a6494b14d3a4f19b8080fdd77e31">halide_default_do_task</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, <a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a> f, int idx, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td></tr>
<tr class="memdesc:a1529a6494b14d3a4f19b8080fdd77e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default versions of do_task and do_par_for.  <a href="#a1529a6494b14d3a4f19b8080fdd77e31">More...</a><br/></td></tr>
<tr class="separator:a1529a6494b14d3a4f19b8080fdd77e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af9f160afebe19fe9bdc28e4765804279"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#af9f160afebe19fe9bdc28e4765804279">halide_copy_to_host_legacy</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structbuffer__t.html">buffer_t</a> *<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="memdesc:af9f160afebe19fe9bdc28e4765804279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Versions of the above functions that accept legacy <a class="el" href="structbuffer__t.html">buffer_t</a> structs.  <a href="#af9f160afebe19fe9bdc28e4765804279">More...</a><br/></td></tr>
<tr class="separator:af9f160afebe19fe9bdc28e4765804279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7663c89d41be39b5d8c4225d3fc44eea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a7663c89d41be39b5d8c4225d3fc44eea">halide_copy_to_device_legacy</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structbuffer__t.html">buffer_t</a> *<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface)</td></tr>
<tr class="memdesc:a7663c89d41be39b5d8c4225d3fc44eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Versions of the above functions that accept legacy <a class="el" href="structbuffer__t.html">buffer_t</a> structs.  <a href="#a7663c89d41be39b5d8c4225d3fc44eea">More...</a><br/></td></tr>
<tr class="separator:a7663c89d41be39b5d8c4225d3fc44eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d3627b25e08ac431688252c835177a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a61d3627b25e08ac431688252c835177a">halide_device_sync_legacy</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structbuffer__t.html">buffer_t</a> *<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="memdesc:a61d3627b25e08ac431688252c835177a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Versions of the above functions that accept legacy <a class="el" href="structbuffer__t.html">buffer_t</a> structs.  <a href="#a61d3627b25e08ac431688252c835177a">More...</a><br/></td></tr>
<tr class="separator:a61d3627b25e08ac431688252c835177a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5a8bca9d4b3453fac9c1f07281a793"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a8d5a8bca9d4b3453fac9c1f07281a793">halide_device_malloc_legacy</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structbuffer__t.html">buffer_t</a> *<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface)</td></tr>
<tr class="memdesc:a8d5a8bca9d4b3453fac9c1f07281a793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Versions of the above functions that accept legacy <a class="el" href="structbuffer__t.html">buffer_t</a> structs.  <a href="#a8d5a8bca9d4b3453fac9c1f07281a793">More...</a><br/></td></tr>
<tr class="separator:a8d5a8bca9d4b3453fac9c1f07281a793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f7d13d2925638256d75cbf4bceedeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ab5f7d13d2925638256d75cbf4bceedeb">halide_device_free_legacy</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, struct <a class="el" href="structbuffer__t.html">buffer_t</a> *<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>)</td></tr>
<tr class="memdesc:ab5f7d13d2925638256d75cbf4bceedeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Versions of the above functions that accept legacy <a class="el" href="structbuffer__t.html">buffer_t</a> structs.  <a href="#ab5f7d13d2925638256d75cbf4bceedeb">More...</a><br/></td></tr>
<tr class="separator:ab5f7d13d2925638256d75cbf4bceedeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa5b03b398e934c740dd4905a02a9bb81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aa5b03b398e934c740dd4905a02a9bb81">halide_error_explicit_bounds_too_small</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *func_name, const char *var_name, int min_bound, int max_bound, int min_required, int max_required)</td></tr>
<tr class="memdesc:aa5b03b398e934c740dd4905a02a9bb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#aa5b03b398e934c740dd4905a02a9bb81">More...</a><br/></td></tr>
<tr class="separator:aa5b03b398e934c740dd4905a02a9bb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73381e1cadf99212c8ef05c8e1bc64d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a73381e1cadf99212c8ef05c8e1bc64d8">halide_error_bad_type</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *func_name, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> code_given, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> correct_code, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> bits_given, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> correct_bits, <a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a> lanes_given, <a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a> correct_lanes)</td></tr>
<tr class="memdesc:a73381e1cadf99212c8ef05c8e1bc64d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a73381e1cadf99212c8ef05c8e1bc64d8">More...</a><br/></td></tr>
<tr class="separator:a73381e1cadf99212c8ef05c8e1bc64d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54c6e910c7b7feb2a51c7a0a549a9bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aa54c6e910c7b7feb2a51c7a0a549a9bd">halide_error_access_out_of_bounds</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *func_name, int dimension, int min_touched, int max_touched, int min_valid, int max_valid)</td></tr>
<tr class="memdesc:aa54c6e910c7b7feb2a51c7a0a549a9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#aa54c6e910c7b7feb2a51c7a0a549a9bd">More...</a><br/></td></tr>
<tr class="separator:aa54c6e910c7b7feb2a51c7a0a549a9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fa368bf1d21414be0ab0a00e8ca7f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a33fa368bf1d21414be0ab0a00e8ca7f6">halide_error_buffer_allocation_too_large</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *buffer_name, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> allocation_size, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> max_size)</td></tr>
<tr class="memdesc:a33fa368bf1d21414be0ab0a00e8ca7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a33fa368bf1d21414be0ab0a00e8ca7f6">More...</a><br/></td></tr>
<tr class="separator:a33fa368bf1d21414be0ab0a00e8ca7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0d5408cb06758ec15b51de93d6772c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5c0d5408cb06758ec15b51de93d6772c">halide_error_buffer_extents_negative</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *buffer_name, int dimension, int extent)</td></tr>
<tr class="memdesc:a5c0d5408cb06758ec15b51de93d6772c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a5c0d5408cb06758ec15b51de93d6772c">More...</a><br/></td></tr>
<tr class="separator:a5c0d5408cb06758ec15b51de93d6772c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d5f3810ffacdc2950743193411c6d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a80d5f3810ffacdc2950743193411c6d4">halide_error_buffer_extents_too_large</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *buffer_name, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> actual_size, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> max_size)</td></tr>
<tr class="memdesc:a80d5f3810ffacdc2950743193411c6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a80d5f3810ffacdc2950743193411c6d4">More...</a><br/></td></tr>
<tr class="separator:a80d5f3810ffacdc2950743193411c6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcbb3316d10d47471e9d74ba74d8e6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5fcbb3316d10d47471e9d74ba74d8e6b">halide_error_constraints_make_required_region_smaller</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *buffer_name, int dimension, int constrained_min, int constrained_extent, int required_min, int required_extent)</td></tr>
<tr class="memdesc:a5fcbb3316d10d47471e9d74ba74d8e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a5fcbb3316d10d47471e9d74ba74d8e6b">More...</a><br/></td></tr>
<tr class="separator:a5fcbb3316d10d47471e9d74ba74d8e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a91525ca15c31958738cf7ec44e410"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a41a91525ca15c31958738cf7ec44e410">halide_error_constraint_violated</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *var, int val, const char *constrained_var, int constrained_val)</td></tr>
<tr class="memdesc:a41a91525ca15c31958738cf7ec44e410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a41a91525ca15c31958738cf7ec44e410">More...</a><br/></td></tr>
<tr class="separator:a41a91525ca15c31958738cf7ec44e410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc44166713b0e8fbef22542e4e0fe95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a9dc44166713b0e8fbef22542e4e0fe95">halide_error_param_too_small_i64</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *param_name, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> min_val)</td></tr>
<tr class="memdesc:a9dc44166713b0e8fbef22542e4e0fe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a9dc44166713b0e8fbef22542e4e0fe95">More...</a><br/></td></tr>
<tr class="separator:a9dc44166713b0e8fbef22542e4e0fe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fce86c8f8d93969bde686d502b4340"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a93fce86c8f8d93969bde686d502b4340">halide_error_param_too_small_u64</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *param_name, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> min_val)</td></tr>
<tr class="memdesc:a93fce86c8f8d93969bde686d502b4340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a93fce86c8f8d93969bde686d502b4340">More...</a><br/></td></tr>
<tr class="separator:a93fce86c8f8d93969bde686d502b4340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d06e8302739a4a26bfa2b0113fc376d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a8d06e8302739a4a26bfa2b0113fc376d">halide_error_param_too_small_f64</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *param_name, double val, double min_val)</td></tr>
<tr class="memdesc:a8d06e8302739a4a26bfa2b0113fc376d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a8d06e8302739a4a26bfa2b0113fc376d">More...</a><br/></td></tr>
<tr class="separator:a8d06e8302739a4a26bfa2b0113fc376d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f31f3a6a09ab3b5b798cecbd3f5e045"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a8f31f3a6a09ab3b5b798cecbd3f5e045">halide_error_param_too_large_i64</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *param_name, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> max_val)</td></tr>
<tr class="memdesc:a8f31f3a6a09ab3b5b798cecbd3f5e045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a8f31f3a6a09ab3b5b798cecbd3f5e045">More...</a><br/></td></tr>
<tr class="separator:a8f31f3a6a09ab3b5b798cecbd3f5e045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca082a34f38e8657551128db3969f8af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aca082a34f38e8657551128db3969f8af">halide_error_param_too_large_u64</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *param_name, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> max_val)</td></tr>
<tr class="memdesc:aca082a34f38e8657551128db3969f8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#aca082a34f38e8657551128db3969f8af">More...</a><br/></td></tr>
<tr class="separator:aca082a34f38e8657551128db3969f8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc42c90e0703c23c6f141fb476cfa04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a7bc42c90e0703c23c6f141fb476cfa04">halide_error_param_too_large_f64</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *param_name, double val, double max_val)</td></tr>
<tr class="memdesc:a7bc42c90e0703c23c6f141fb476cfa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a7bc42c90e0703c23c6f141fb476cfa04">More...</a><br/></td></tr>
<tr class="separator:a7bc42c90e0703c23c6f141fb476cfa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64356948f9a36e16664585fff6f0949d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a64356948f9a36e16664585fff6f0949d">halide_error_out_of_memory</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>)</td></tr>
<tr class="memdesc:a64356948f9a36e16664585fff6f0949d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a64356948f9a36e16664585fff6f0949d">More...</a><br/></td></tr>
<tr class="separator:a64356948f9a36e16664585fff6f0949d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab974b4b7963cad8613c3825a5689086"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aab974b4b7963cad8613c3825a5689086">halide_error_buffer_argument_is_null</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *buffer_name)</td></tr>
<tr class="memdesc:aab974b4b7963cad8613c3825a5689086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#aab974b4b7963cad8613c3825a5689086">More...</a><br/></td></tr>
<tr class="separator:aab974b4b7963cad8613c3825a5689086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d12212093b19b3c2ea2b83df15302e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a6d12212093b19b3c2ea2b83df15302e3">halide_error_debug_to_file_failed</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *func, const char *filename, int error_code)</td></tr>
<tr class="memdesc:a6d12212093b19b3c2ea2b83df15302e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a6d12212093b19b3c2ea2b83df15302e3">More...</a><br/></td></tr>
<tr class="separator:a6d12212093b19b3c2ea2b83df15302e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c72825991b91cbc68d0ee35b5dd6eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#af4c72825991b91cbc68d0ee35b5dd6eb">halide_error_unaligned_host_ptr</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *func_name, int alignment)</td></tr>
<tr class="memdesc:af4c72825991b91cbc68d0ee35b5dd6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#af4c72825991b91cbc68d0ee35b5dd6eb">More...</a><br/></td></tr>
<tr class="separator:af4c72825991b91cbc68d0ee35b5dd6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8c8355e8fe70169455e0e178a8ee13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#afb8c8355e8fe70169455e0e178a8ee13">halide_error_failed_to_upgrade_buffer_t</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *input_name, const char *reason)</td></tr>
<tr class="memdesc:afb8c8355e8fe70169455e0e178a8ee13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#afb8c8355e8fe70169455e0e178a8ee13">More...</a><br/></td></tr>
<tr class="separator:afb8c8355e8fe70169455e0e178a8ee13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecf7fc5cc972ef64bafd956dd2a9d13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aeecf7fc5cc972ef64bafd956dd2a9d13">halide_error_failed_to_downgrade_buffer_t</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *input_name, const char *reason)</td></tr>
<tr class="memdesc:aeecf7fc5cc972ef64bafd956dd2a9d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#aeecf7fc5cc972ef64bafd956dd2a9d13">More...</a><br/></td></tr>
<tr class="separator:aeecf7fc5cc972ef64bafd956dd2a9d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184d4a3242a700a5bfa984202d150058"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a184d4a3242a700a5bfa984202d150058">halide_error_bad_fold</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *func_name, const char *var_name, const char *loop_name)</td></tr>
<tr class="memdesc:a184d4a3242a700a5bfa984202d150058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a184d4a3242a700a5bfa984202d150058">More...</a><br/></td></tr>
<tr class="separator:a184d4a3242a700a5bfa984202d150058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc79be62fbe8dec0a9fe81880809d09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a8bc79be62fbe8dec0a9fe81880809d09">halide_error_fold_factor_too_small</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *func_name, const char *var_name, int fold_factor, const char *loop_name, int required_extent)</td></tr>
<tr class="memdesc:a8bc79be62fbe8dec0a9fe81880809d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a8bc79be62fbe8dec0a9fe81880809d09">More...</a><br/></td></tr>
<tr class="separator:a8bc79be62fbe8dec0a9fe81880809d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2a64a173a5f8f76b77f495782bf3d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a6f2a64a173a5f8f76b77f495782bf3d0">halide_error_requirement_failed</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *condition, const char *message)</td></tr>
<tr class="memdesc:a6f2a64a173a5f8f76b77f495782bf3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#a6f2a64a173a5f8f76b77f495782bf3d0">More...</a><br/></td></tr>
<tr class="separator:a6f2a64a173a5f8f76b77f495782bf3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b32bec5b0969e6c79bccb4f92fd295"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aa4b32bec5b0969e6c79bccb4f92fd295">halide_error_specialize_fail</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *message)</td></tr>
<tr class="memdesc:aa4b32bec5b0969e6c79bccb4f92fd295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various other error conditions.  <a href="#aa4b32bec5b0969e6c79bccb4f92fd295">More...</a><br/></td></tr>
<tr class="separator:aa4b32bec5b0969e6c79bccb4f92fd295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">"Float16" functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions operate of bits (<code>uint16_t</code>) representing a half precision floating point number (IEEE-754 2008 binary16).</p>
</div></td></tr>
<tr class="memitem:af23e3224639e2458c55cebf2a6dccfaf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#af23e3224639e2458c55cebf2a6dccfaf">halide_float16_bits_to_float</a> (<a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a>)</td></tr>
<tr class="memdesc:af23e3224639e2458c55cebf2a6dccfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bits representing a half precision floating point number and return the float that represents the same value.  <a href="#af23e3224639e2458c55cebf2a6dccfaf">More...</a><br/></td></tr>
<tr class="separator:af23e3224639e2458c55cebf2a6dccfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2494e69e2956ca6af09befd1d5bbf142"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a2494e69e2956ca6af09befd1d5bbf142">halide_float16_bits_to_double</a> (<a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a>)</td></tr>
<tr class="memdesc:a2494e69e2956ca6af09befd1d5bbf142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bits representing a half precision floating point number and return the double that represents the same value.  <a href="#a2494e69e2956ca6af09befd1d5bbf142">More...</a><br/></td></tr>
<tr class="separator:a2494e69e2956ca6af09befd1d5bbf142"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a709648b930f033620ec2192cb84c3b62"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a709648b930f033620ec2192cb84c3b62">buf</a></td></tr>
<tr class="separator:a709648b930f033620ec2192cb84c3b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1fa162445be01b45cec2460ec2f00a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5c1fa162445be01b45cec2460ec2f00a">halide_print_t</a> )(void *, const char *)</td></tr>
<tr class="memdesc:a5c1fa162445be01b45cec2460ec2f00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message to stderr.  <a href="#a5c1fa162445be01b45cec2460ec2f00a">More...</a><br/></td></tr>
<tr class="separator:a5c1fa162445be01b45cec2460ec2f00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fe1dd85166a7f0da1b8f82f734296a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a96fe1dd85166a7f0da1b8f82f734296a">halide_print</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *)</td></tr>
<tr class="memdesc:a96fe1dd85166a7f0da1b8f82f734296a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message to stderr.  <a href="#a96fe1dd85166a7f0da1b8f82f734296a">More...</a><br/></td></tr>
<tr class="separator:a96fe1dd85166a7f0da1b8f82f734296a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1ae09f6ef33a2508fc67ac50f2c207"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a2c1ae09f6ef33a2508fc67ac50f2c207">halide_default_print</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *)</td></tr>
<tr class="memdesc:a2c1ae09f6ef33a2508fc67ac50f2c207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message to stderr.  <a href="#a2c1ae09f6ef33a2508fc67ac50f2c207">More...</a><br/></td></tr>
<tr class="separator:a2c1ae09f6ef33a2508fc67ac50f2c207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3e4cf6c510fd8bc26420af06b7e4f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#a5c1fa162445be01b45cec2460ec2f00a">halide_print_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a3d3e4cf6c510fd8bc26420af06b7e4f3">halide_set_custom_print</a> (<a class="el" href="_halide_runtime_8h.html#a5c1fa162445be01b45cec2460ec2f00a">halide_print_t</a> print)</td></tr>
<tr class="memdesc:a3d3e4cf6c510fd8bc26420af06b7e4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message to stderr.  <a href="#a3d3e4cf6c510fd8bc26420af06b7e4f3">More...</a><br/></td></tr>
<tr class="separator:a3d3e4cf6c510fd8bc26420af06b7e4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f5f1ebda2ee82c39cc1050aaa7cd8a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a48f5f1ebda2ee82c39cc1050aaa7cd8a">halide_error_handler_t</a> )(void *, const char *)</td></tr>
<tr class="memdesc:a48f5f1ebda2ee82c39cc1050aaa7cd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls this function on runtime errors (for example bounds checking failures).  <a href="#a48f5f1ebda2ee82c39cc1050aaa7cd8a">More...</a><br/></td></tr>
<tr class="separator:a48f5f1ebda2ee82c39cc1050aaa7cd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea28d04de54b94f0dd6ada140b7734d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8">halide_error</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *)</td></tr>
<tr class="memdesc:aea28d04de54b94f0dd6ada140b7734d8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls this function on runtime errors (for example bounds checking failures).  <a href="#aea28d04de54b94f0dd6ada140b7734d8">More...</a><br/></td></tr>
<tr class="separator:aea28d04de54b94f0dd6ada140b7734d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9ec52392edc2a7b65aab13183a2543"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aaf9ec52392edc2a7b65aab13183a2543">halide_default_error</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const char *)</td></tr>
<tr class="memdesc:aaf9ec52392edc2a7b65aab13183a2543"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls this function on runtime errors (for example bounds checking failures).  <a href="#aaf9ec52392edc2a7b65aab13183a2543">More...</a><br/></td></tr>
<tr class="separator:aaf9ec52392edc2a7b65aab13183a2543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d18a3f649e46538666fb87ab3fb6ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#a48f5f1ebda2ee82c39cc1050aaa7cd8a">halide_error_handler_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a02d18a3f649e46538666fb87ab3fb6ba">halide_set_error_handler</a> (<a class="el" href="_halide_runtime_8h.html#a48f5f1ebda2ee82c39cc1050aaa7cd8a">halide_error_handler_t</a> handler)</td></tr>
<tr class="memdesc:a02d18a3f649e46538666fb87ab3fb6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls this function on runtime errors (for example bounds checking failures).  <a href="#a02d18a3f649e46538666fb87ab3fb6ba">More...</a><br/></td></tr>
<tr class="separator:a02d18a3f649e46538666fb87ab3fb6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6465a3a2522d24a2e83e56e263616dcb"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a> )(void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, int task_number, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td></tr>
<tr class="memdesc:a6465a3a2522d24a2e83e56e263616dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_do_par_for to replace the default thread pool implementation.  <a href="#a6465a3a2522d24a2e83e56e263616dcb">More...</a><br/></td></tr>
<tr class="separator:a6465a3a2522d24a2e83e56e263616dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f85711e52c707df2e484f69dfaf7c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a15f85711e52c707df2e484f69dfaf7c5">halide_do_par_for</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, <a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a> task, int min, int size, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td></tr>
<tr class="memdesc:a15f85711e52c707df2e484f69dfaf7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_do_par_for to replace the default thread pool implementation.  <a href="#a15f85711e52c707df2e484f69dfaf7c5">More...</a><br/></td></tr>
<tr class="separator:a15f85711e52c707df2e484f69dfaf7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9d22d2b79a3dc66a32159423b17910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5e9d22d2b79a3dc66a32159423b17910">halide_shutdown_thread_pool</a> ()</td></tr>
<tr class="memdesc:a5e9d22d2b79a3dc66a32159423b17910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define halide_do_par_for to replace the default thread pool implementation.  <a href="#a5e9d22d2b79a3dc66a32159423b17910">More...</a><br/></td></tr>
<tr class="separator:a5e9d22d2b79a3dc66a32159423b17910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b38fa796412d8e1b26a38c2f8a37713"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a4b38fa796412d8e1b26a38c2f8a37713">halide_do_task_t</a> )(void *, <a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a>, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td></tr>
<tr class="memdesc:a4b38fa796412d8e1b26a38c2f8a37713"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you use the default do_par_for, you can still set a custom handler to perform each individual task.  <a href="#a4b38fa796412d8e1b26a38c2f8a37713">More...</a><br/></td></tr>
<tr class="separator:a4b38fa796412d8e1b26a38c2f8a37713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece7417671894d7557b9e93ea0ebc0ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#a4b38fa796412d8e1b26a38c2f8a37713">halide_do_task_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aece7417671894d7557b9e93ea0ebc0ae">halide_set_custom_do_task</a> (<a class="el" href="_halide_runtime_8h.html#a4b38fa796412d8e1b26a38c2f8a37713">halide_do_task_t</a> do_task)</td></tr>
<tr class="memdesc:aece7417671894d7557b9e93ea0ebc0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you use the default do_par_for, you can still set a custom handler to perform each individual task.  <a href="#aece7417671894d7557b9e93ea0ebc0ae">More...</a><br/></td></tr>
<tr class="separator:aece7417671894d7557b9e93ea0ebc0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b73ddae74b80251d2ffce9a624b6125"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a4b73ddae74b80251d2ffce9a624b6125">halide_do_task</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, <a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a> f, int idx, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td></tr>
<tr class="memdesc:a4b73ddae74b80251d2ffce9a624b6125"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you use the default do_par_for, you can still set a custom handler to perform each individual task.  <a href="#a4b73ddae74b80251d2ffce9a624b6125">More...</a><br/></td></tr>
<tr class="separator:a4b73ddae74b80251d2ffce9a624b6125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1789361c8c7393c2efa66fc768f71f6"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#af1789361c8c7393c2efa66fc768f71f6">halide_malloc_t</a> )(void *, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)</td></tr>
<tr class="memdesc:af1789361c8c7393c2efa66fc768f71f6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory.  <a href="#af1789361c8c7393c2efa66fc768f71f6">More...</a><br/></td></tr>
<tr class="separator:af1789361c8c7393c2efa66fc768f71f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad708200fb55818d42238cb2457f797"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5ad708200fb55818d42238cb2457f797">halide_free_t</a> )(void *, void *)</td></tr>
<tr class="memdesc:a5ad708200fb55818d42238cb2457f797"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory.  <a href="#a5ad708200fb55818d42238cb2457f797">More...</a><br/></td></tr>
<tr class="separator:a5ad708200fb55818d42238cb2457f797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bb359ed77ef4c1f89251bcd7eb2613"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aa5bb359ed77ef4c1f89251bcd7eb2613">halide_malloc</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> x)</td></tr>
<tr class="memdesc:aa5bb359ed77ef4c1f89251bcd7eb2613"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory.  <a href="#aa5bb359ed77ef4c1f89251bcd7eb2613">More...</a><br/></td></tr>
<tr class="separator:aa5bb359ed77ef4c1f89251bcd7eb2613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa49d775b9a20fab152a0650c4c936b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a2fa49d775b9a20fab152a0650c4c936b">halide_free</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, void *ptr)</td></tr>
<tr class="memdesc:a2fa49d775b9a20fab152a0650c4c936b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory.  <a href="#a2fa49d775b9a20fab152a0650c4c936b">More...</a><br/></td></tr>
<tr class="separator:a2fa49d775b9a20fab152a0650c4c936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8133de16210a46515502f007ee571fbe"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a8133de16210a46515502f007ee571fbe">halide_default_malloc</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> x)</td></tr>
<tr class="memdesc:a8133de16210a46515502f007ee571fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory.  <a href="#a8133de16210a46515502f007ee571fbe">More...</a><br/></td></tr>
<tr class="separator:a8133de16210a46515502f007ee571fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab246841764b58f9675fdb27db0b4bd34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ab246841764b58f9675fdb27db0b4bd34">halide_default_free</a> (void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, void *ptr)</td></tr>
<tr class="memdesc:ab246841764b58f9675fdb27db0b4bd34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory.  <a href="#ab246841764b58f9675fdb27db0b4bd34">More...</a><br/></td></tr>
<tr class="separator:ab246841764b58f9675fdb27db0b4bd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0668aaae035f2f4f3132857acee4e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#af1789361c8c7393c2efa66fc768f71f6">halide_malloc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a4d0668aaae035f2f4f3132857acee4e3">halide_set_custom_malloc</a> (<a class="el" href="_halide_runtime_8h.html#af1789361c8c7393c2efa66fc768f71f6">halide_malloc_t</a> user_malloc)</td></tr>
<tr class="memdesc:a4d0668aaae035f2f4f3132857acee4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory.  <a href="#a4d0668aaae035f2f4f3132857acee4e3">More...</a><br/></td></tr>
<tr class="separator:a4d0668aaae035f2f4f3132857acee4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd43bc97b2337e57fd6af03be17a5bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#a5ad708200fb55818d42238cb2457f797">halide_free_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#acd43bc97b2337e57fd6af03be17a5bb8">halide_set_custom_free</a> (<a class="el" href="_halide_runtime_8h.html#a5ad708200fb55818d42238cb2457f797">halide_free_t</a> user_free)</td></tr>
<tr class="memdesc:acd43bc97b2337e57fd6af03be17a5bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory.  <a href="#acd43bc97b2337e57fd6af03be17a5bb8">More...</a><br/></td></tr>
<tr class="separator:acd43bc97b2337e57fd6af03be17a5bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b395a78ed47c06139df7a8582d593c3"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a9b395a78ed47c06139df7a8582d593c3">halide_get_symbol_t</a> )(const char *name)</td></tr>
<tr class="memdesc:a9b395a78ed47c06139df7a8582d593c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions.  <a href="#a9b395a78ed47c06139df7a8582d593c3">More...</a><br/></td></tr>
<tr class="separator:a9b395a78ed47c06139df7a8582d593c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6a2be492b550a90837409ab6fa30c4"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a0e6a2be492b550a90837409ab6fa30c4">halide_load_library_t</a> )(const char *name)</td></tr>
<tr class="memdesc:a0e6a2be492b550a90837409ab6fa30c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions.  <a href="#a0e6a2be492b550a90837409ab6fa30c4">More...</a><br/></td></tr>
<tr class="separator:a0e6a2be492b550a90837409ab6fa30c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ff288a7d64c44a4fa6410a10efed40"><td class="memItemLeft" align="right" valign="top">typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a22ff288a7d64c44a4fa6410a10efed40">halide_get_library_symbol_t</a> )(void *lib, const char *name)</td></tr>
<tr class="memdesc:a22ff288a7d64c44a4fa6410a10efed40"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions.  <a href="#a22ff288a7d64c44a4fa6410a10efed40">More...</a><br/></td></tr>
<tr class="separator:a22ff288a7d64c44a4fa6410a10efed40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6304bb2284705fd7ee1b016b237016"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a2b6304bb2284705fd7ee1b016b237016">halide_get_symbol</a> (const char *name)</td></tr>
<tr class="memdesc:a2b6304bb2284705fd7ee1b016b237016"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions.  <a href="#a2b6304bb2284705fd7ee1b016b237016">More...</a><br/></td></tr>
<tr class="separator:a2b6304bb2284705fd7ee1b016b237016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5769941d99b24d54ecc3b59d284a9b15"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a5769941d99b24d54ecc3b59d284a9b15">halide_load_library</a> (const char *name)</td></tr>
<tr class="memdesc:a5769941d99b24d54ecc3b59d284a9b15"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions.  <a href="#a5769941d99b24d54ecc3b59d284a9b15">More...</a><br/></td></tr>
<tr class="separator:a5769941d99b24d54ecc3b59d284a9b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c49f4bcdad4b5b28ca6f9949bfd74b4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a2c49f4bcdad4b5b28ca6f9949bfd74b4">halide_get_library_symbol</a> (void *lib, const char *name)</td></tr>
<tr class="memdesc:a2c49f4bcdad4b5b28ca6f9949bfd74b4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions.  <a href="#a2c49f4bcdad4b5b28ca6f9949bfd74b4">More...</a><br/></td></tr>
<tr class="separator:a2c49f4bcdad4b5b28ca6f9949bfd74b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b92ee99852a155096e369c228a6218"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a26b92ee99852a155096e369c228a6218">halide_default_get_symbol</a> (const char *name)</td></tr>
<tr class="memdesc:a26b92ee99852a155096e369c228a6218"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions.  <a href="#a26b92ee99852a155096e369c228a6218">More...</a><br/></td></tr>
<tr class="separator:a26b92ee99852a155096e369c228a6218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47851b7037e6d6cecffb2aba5c1d7a98"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a47851b7037e6d6cecffb2aba5c1d7a98">halide_default_load_library</a> (const char *name)</td></tr>
<tr class="memdesc:a47851b7037e6d6cecffb2aba5c1d7a98"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions.  <a href="#a47851b7037e6d6cecffb2aba5c1d7a98">More...</a><br/></td></tr>
<tr class="separator:a47851b7037e6d6cecffb2aba5c1d7a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e47b500bb86a710c02a8c0b11a682e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#aa5e47b500bb86a710c02a8c0b11a682e">halide_default_get_library_symbol</a> (void *lib, const char *name)</td></tr>
<tr class="memdesc:aa5e47b500bb86a710c02a8c0b11a682e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions.  <a href="#aa5e47b500bb86a710c02a8c0b11a682e">More...</a><br/></td></tr>
<tr class="separator:aa5e47b500bb86a710c02a8c0b11a682e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237a39b6dc5c4059539983984c3ef4f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#a9b395a78ed47c06139df7a8582d593c3">halide_get_symbol_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a237a39b6dc5c4059539983984c3ef4f7">halide_set_custom_get_symbol</a> (<a class="el" href="_halide_runtime_8h.html#a9b395a78ed47c06139df7a8582d593c3">halide_get_symbol_t</a> user_get_symbol)</td></tr>
<tr class="memdesc:a237a39b6dc5c4059539983984c3ef4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions.  <a href="#a237a39b6dc5c4059539983984c3ef4f7">More...</a><br/></td></tr>
<tr class="separator:a237a39b6dc5c4059539983984c3ef4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201fccb476f83105b06389a7701f5bef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#a0e6a2be492b550a90837409ab6fa30c4">halide_load_library_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef">halide_set_custom_load_library</a> (<a class="el" href="_halide_runtime_8h.html#a0e6a2be492b550a90837409ab6fa30c4">halide_load_library_t</a> user_load_library)</td></tr>
<tr class="memdesc:a201fccb476f83105b06389a7701f5bef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions.  <a href="#a201fccb476f83105b06389a7701f5bef">More...</a><br/></td></tr>
<tr class="separator:a201fccb476f83105b06389a7701f5bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d93a904e3a104ff12c4760aad458ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#a22ff288a7d64c44a4fa6410a10efed40">halide_get_library_symbol_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef">halide_set_custom_get_library_symbol</a> (<a class="el" href="_halide_runtime_8h.html#a22ff288a7d64c44a4fa6410a10efed40">halide_get_library_symbol_t</a> user_get_library_symbol)</td></tr>
<tr class="memdesc:ae6d93a904e3a104ff12c4760aad458ef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions.  <a href="#ae6d93a904e3a104ff12c4760aad458ef">More...</a><br/></td></tr>
<tr class="separator:ae6d93a904e3a104ff12c4760aad458ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10019efe4ef71dc796a049f7c6afd2b9"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a10019efe4ef71dc796a049f7c6afd2b9">halide_can_use_target_features_t</a> )(<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>)</td></tr>
<tr class="memdesc:a10019efe4ef71dc796a049f7c6afd2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called internally by <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> in some situations to determine if the current execution environment can support the given set of halide_target_feature_t flags.  <a href="#a10019efe4ef71dc796a049f7c6afd2b9">More...</a><br/></td></tr>
<tr class="separator:a10019efe4ef71dc796a049f7c6afd2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a30d570bab6ffb46b8de976d536d12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a25a30d570bab6ffb46b8de976d536d12">halide_can_use_target_features</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> features)</td></tr>
<tr class="memdesc:a25a30d570bab6ffb46b8de976d536d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called internally by <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> in some situations to determine if the current execution environment can support the given set of halide_target_feature_t flags.  <a href="#a25a30d570bab6ffb46b8de976d536d12">More...</a><br/></td></tr>
<tr class="separator:a25a30d570bab6ffb46b8de976d536d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d894ba76723de46670273e21186516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#a10019efe4ef71dc796a049f7c6afd2b9">halide_can_use_target_features_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_halide_runtime_8h.html#a85d894ba76723de46670273e21186516">halide_set_custom_can_use_target_features</a> (<a class="el" href="_halide_runtime_8h.html#a10019efe4ef71dc796a049f7c6afd2b9">halide_can_use_target_features_t</a>)</td></tr>
<tr class="memdesc:a85d894ba76723de46670273e21186516"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called internally by <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> in some situations to determine if the current execution environment can support the given set of halide_target_feature_t flags.  <a href="#a85d894ba76723de46670273e21186516">More...</a><br/></td></tr>
<tr class="separator:a85d894ba76723de46670273e21186516"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Set a custom malloc and free for halide to use. </p>
<p>This file declares the routines used by <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> internally in its runtime.</p>
<p>Malloc should return 32-byte aligned chunks of memory, and it should be safe for <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> to read slightly out of bounds (up to 8 bytes before the start or beyond the end). If compiling statically, routines with appropriate signatures can be provided directly </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *<a class="code" href="_halide_runtime_8h.html#aa5bb359ed77ef4c1f89251bcd7eb2613">halide_malloc</a>(<span class="keywordtype">void</span> *, <span class="keywordtype">size_t</span>)</div>
<div class="line">extern &quot;C&quot; <span class="keywordtype">void</span> <a class="code" href="_halide_runtime_8h.html#a2fa49d775b9a20fab152a0650c4c936b">halide_free</a>(<span class="keywordtype">void</span> *, <span class="keywordtype">void</span> *)</div>
</div><!-- fragment --><p> These will clobber <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s versions. See for declarations.</p>
<p>On platforms that support weak linking, these can be replaced with user-defined versions by defining an extern "C" function with the same name and signature.</p>
<p>When doing Just In Time (JIT) compilation methods on the Func being compiled must be called instead. The corresponding methods are documented below.</p>
<p>All of these functions take a "void *user_context" parameter as their first argument; if the <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> kernel that calls back to any of these functions has been compiled with the UserContext feature set on its Target, then the value of that pointer passed from the code that calls the <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> kernel is piped through to the function.</p>
<p>Some of these are also useful to call when using the default implementation. E.g. halide_shutdown_thread_pool.</p>
<p>Note that even on platforms with weak linking, some linker setups may not respect the override you provide. E.g. if the override is in a shared library and the halide object files are linked directly into the output, the builtin versions of the runtime functions will be called. See your linker documentation for more details. On Linux, LD_DYNAMIC_WEAK=1 may help. </p>

<p>Definition in file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ac0c2048ce1a292798d15d9dc3346de26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_ALWAYS_INLINE&#160;&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a6b25bae9a0c908a7a45bc68f1b5c76c3">__attribute__</a>((always_inline)) inline</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00027">27</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="afaa0f73fc7954ac27a2c11020681cdf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_ATTRIBUTE_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a6b25bae9a0c908a7a45bc68f1b5c76c3">__attribute__</a>((aligned(x)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00267">267</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9bb1030f4a2614c18adb6d088529f911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_ATTRIBUTE_DEPRECATED</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="_halide_runtime_8h.html#a6b25bae9a0c908a7a45bc68f1b5c76c3">__attribute__</a>((deprecated(x)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l01142">1142</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01229">Halide::Func::reorder()</a>.</p>

</div>
</div>
<a class="anchor" id="a2622d62cd7688033c8c6ad612cf5c3e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFFER_T_DEFINED</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The old <a class="el" href="structbuffer__t.html">buffer_t</a>, included for compatibility with old code. </p>
<p>Don't use it. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l01150">1150</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a5c1fa162445be01b45cec2460ec2f00a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* halide_print_t)(void *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a message to stderr. </p>
<p>Main use is to support tracing functionality, print, and print_when calls. Also called by the default halide_error. This function can be replaced in JITed code by using halide_custom_print and providing an implementation of halide_print in AOT code. See Func::set_custom_print. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00072">72</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a48f5f1ebda2ee82c39cc1050aaa7cd8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* halide_error_handler_t)(void *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls this function on runtime errors (for example bounds checking failures). </p>
<p>This function can be replaced in JITed code by using Func::set_error_handler, or in AOT code by calling halide_set_error_handler. In AOT code on platforms that support weak linking (i.e. not Windows), you can also override it by simply defining your own halide_error. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00086">86</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6465a3a2522d24a2e83e56e263616dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_task_t)(void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, int task_number, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define halide_do_par_for to replace the default thread pool implementation. </p>
<p>halide_shutdown_thread_pool can also be called to release resources used by the default thread pool on platforms where it makes sense. (E.g. On Mac OS, Grand Central Dispatch is used so Halide does not own the threads backing the pool and they cannot be released.) See Func::set_custom_do_task and Func::set_custom_do_par_for. Should return zero if all the jobs return zero, or an arbitrarily chosen return value from one of the jobs otherwise. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00124">124</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a67106643662219b875b6e69775955944"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_do_par_for_t)(void *, <a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a>, int, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a custom method for performing a parallel for loop. </p>
<p>Returns the old do_par_for handler. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00133">133</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b38fa796412d8e1b26a38c2f8a37713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_do_task_t)(void *, <a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a>, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you use the default do_par_for, you can still set a custom handler to perform each individual task. </p>
<p>Returns the old handler. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00139">139</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="af1789361c8c7393c2efa66fc768f71f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* halide_malloc_t)(void *, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory. </p>
<p>To replace in AOT code, use the halide_set_custom_malloc and halide_set_custom_free, or (on platforms that support weak linking), simply define these functions yourself. In JIT-compiled code use Func::set_custom_allocator.</p>
<p>If you override them, and find yourself wanting to call the default implementation from within your override, use halide_default_malloc/free.</p>
<p>Note that halide_malloc must return a pointer aligned to the maximum meaningful alignment for the platform for the purpose of vector loads and stores. The default implementation uses 32-byte alignment, which is safe for arm and x86. Additionally, it must be safe to read at least 8 bytes before the start and beyond the end. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00205">205</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5ad708200fb55818d42238cb2457f797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* halide_free_t)(void *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory. </p>
<p>To replace in AOT code, use the halide_set_custom_malloc and halide_set_custom_free, or (on platforms that support weak linking), simply define these functions yourself. In JIT-compiled code use Func::set_custom_allocator.</p>
<p>If you override them, and find yourself wanting to call the default implementation from within your override, use halide_default_malloc/free.</p>
<p>Note that halide_malloc must return a pointer aligned to the maximum meaningful alignment for the platform for the purpose of vector loads and stores. The default implementation uses 32-byte alignment, which is safe for arm and x86. Additionally, it must be safe to read at least 8 bytes before the start and beyond the end. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00206">206</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9b395a78ed47c06139df7a8582d593c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* halide_get_symbol_t)(const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_load_library()</a> and <a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00228">228</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0e6a2be492b550a90837409ab6fa30c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* halide_load_library_t)(const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_load_library()</a> and <a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00229">229</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a22ff288a7d64c44a4fa6410a10efed40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* halide_get_library_symbol_t)(void *lib, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_load_library()</a> and <a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00230">230</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="abd8ef2cf42c925601df1b997c1b938bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a>  <a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types in the halide type system. </p>
<p>They can be ints, unsigned ints, or floats (of various bit-widths), or a handle (which is always 64-bits). Note that the int/uint/float values do not imply a specific bit width (the bit width is expected to be encoded in a separate value). </p>

</div>
</div>
<a class="anchor" id="a218cc381e4551fc66f009a05cb0b8041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>(* halide_trace_t)(void *<a class="el" href="printer_8h.html#a9a395374120db0d0280e16f53201d5cf">user_context</a>, const struct <a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00409">409</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae64e96ae698ab344dec89bc8a172a243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_device_free_t)(void *, struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to halide_device_free if a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> runtime has been linked in. </p>
<p>Returns null if it has not. This requires a different mechanism on different platforms. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00519">519</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a344de1f54ca97bc45193724bd7b3eaf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3a">halide_target_feature_t</a>  <a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3a">halide_target_feature_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional features a compilation Target can have. </p>

</div>
</div>
<a class="anchor" id="a10019efe4ef71dc796a049f7c6afd2b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* halide_can_use_target_features_t)(<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called internally by <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> in some situations to determine if the current execution environment can support the given set of halide_target_feature_t flags. </p>
<p>The implementation must do the following:</p>
<p>&ndash; If there are flags set in features that the function knows <em>cannot</em> be supported, return 0. &ndash; Otherwise, return 1. &ndash; Note that any flags set in features that the function doesn't know how to test should be ignored; this implies that a return value of 1 means "not known to be bad" rather than "known to be good".</p>
<p>In other words: a return value of 0 means "It is not safe to use code compiled with these features", while a return value of 1 means "It is not obviously unsafe to use code compiled with these features".</p>
<p>The default implementation simply calls halide_default_can_use_target_features. </p>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00963">963</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a84da9f450b3335aeaf44fefb9be234e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a>  <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5c8ab0b07dcaa0d81d9abadae30242b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a>  <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The raw representation of an image passed around by generated <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> code. </p>
<p>It includes some stuff to track whether the image is not actually in main memory, but instead on a device (like a GPU). For a more convenient C++ wrapper, use Halide::Buffer&lt;T&gt;. </p>

</div>
</div>
<a class="anchor" id="aebe399a52d3e6b4c16909f8216198044"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structbuffer__t.html">buffer_t</a>  <a class="el" href="structbuffer__t.html">buffer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a9f4c40f298e91dea4f532774dc57a450"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_halide_runtime_8h.html#a9f4c40f298e91dea4f532774dc57a450">halide_type_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types in the halide type system. </p>
<p>They can be ints, unsigned ints, or floats (of various bit-widths), or a handle (which is always 64-bits). Note that the int/uint/float values do not imply a specific bit width (the bit width is expected to be encoded in a separate value). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a9f4c40f298e91dea4f532774dc57a450a53ba65448e4cbe66680c29a1333c8bfa"></a>halide_type_int</em>&#160;</td><td class="fielddoc">
<p>signed integers </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9f4c40f298e91dea4f532774dc57a450adfa8b0e2cbd616d1259c9471ec5c2b4d"></a>halide_type_uint</em>&#160;</td><td class="fielddoc">
<p>unsigned integers </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9f4c40f298e91dea4f532774dc57a450a05c0160361d9fc5deb778f9a6744f42b"></a>halide_type_float</em>&#160;</td><td class="fielddoc">
<p>floating point numbers </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9f4c40f298e91dea4f532774dc57a450a22f25129c6493f710ace985e0f8f01ef"></a>halide_type_handle</em>&#160;</td><td class="fielddoc">
<p>opaque pointer type (void *) </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00250">250</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a485130f12eb8bb5fa5a9478eeb6b0dfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_halide_runtime_8h.html#a485130f12eb8bb5fa5a9478eeb6b0dfa">halide_trace_event_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a485130f12eb8bb5fa5a9478eeb6b0dfaa2cbd3048c959f6d8def944097d8e21c9"></a>halide_trace_load</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a485130f12eb8bb5fa5a9478eeb6b0dfaa57b32d087e0862bd6ba748ce7743a851"></a>halide_trace_store</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a485130f12eb8bb5fa5a9478eeb6b0dfaad8657c19f6b2b9cc79fa3a438f39687b"></a>halide_trace_begin_realization</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a485130f12eb8bb5fa5a9478eeb6b0dfaacb0bdc3e4044609ab7fae05b921595ab"></a>halide_trace_end_realization</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a485130f12eb8bb5fa5a9478eeb6b0dfaac4047c93cd032261e8373e38944bf7a1"></a>halide_trace_produce</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a485130f12eb8bb5fa5a9478eeb6b0dfaac0c72771e1401fad47e3234caa121427"></a>halide_trace_end_produce</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a485130f12eb8bb5fa5a9478eeb6b0dfaa0dac17982d8ef6c404f94e5b7dd4de54"></a>halide_trace_consume</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a485130f12eb8bb5fa5a9478eeb6b0dfaac98849a734841652345dc3d37660c136"></a>halide_trace_end_consume</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a485130f12eb8bb5fa5a9478eeb6b0dfaa7b9317d3544502c02e018db4bac2b97e"></a>halide_trace_begin_pipeline</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a485130f12eb8bb5fa5a9478eeb6b0dfaa92151c79c44b19ad2c1074fb6f113b1c"></a>halide_trace_end_pipeline</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00319">319</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="aba16e170cc9aa30b78ff703e101a448c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_halide_runtime_8h.html#aba16e170cc9aa30b78ff703e101a448c">halide_error_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The error codes that may be returned by a <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> pipeline. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca61d939236ddc9e13ff364e2c18149f04"></a>halide_error_code_success</em>&#160;</td><td class="fielddoc">
<p>There was no error. </p>
<p>This is the value returned by <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> on success. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca463fb2939949a1e8634905edf23efe05"></a>halide_error_code_generic_error</em>&#160;</td><td class="fielddoc">
<p>An uncategorized error occurred. </p>
<p>Refer to the string passed to halide_error. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448cad9e00397c85cca42380f43b2689a8b7c"></a>halide_error_code_explicit_bounds_too_small</em>&#160;</td><td class="fielddoc">
<p>A Func was given an explicit bound via Func::bound, but this was not large enough to encompass the region that is used of the Func by the rest of the pipeline. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448cac864d0a2ca831c3c757b6e410d8cdd3f"></a>halide_error_code_bad_type</em>&#160;</td><td class="fielddoc">
<p>The elem_size field of a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> does not match the size in bytes of the type of that ImageParam. </p>
<p>Probable type mismatch. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca0e0423bbffc1b99dffcdcfb5f64982ea"></a>halide_error_code_access_out_of_bounds</em>&#160;</td><td class="fielddoc">
<p>A pipeline would access memory outside of the <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> passed in. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448cac11c436ca3edba1a8d0e961f3320e7e6"></a>halide_error_code_buffer_allocation_too_large</em>&#160;</td><td class="fielddoc">
<p>A <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> was given that spans more than 2GB of memory. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448cae18e82f52439b79a5523c009904ff99b"></a>halide_error_code_buffer_extents_too_large</em>&#160;</td><td class="fielddoc">
<p>A <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> was given with extents that multiply to a number greater than 2^31-1. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca2d28fcb409c42316eaa24f6a6a74eeb6"></a>halide_error_code_constraints_make_required_region_smaller</em>&#160;</td><td class="fielddoc">
<p>Applying explicit constraints on the size of an input or output buffer shrank the size of that buffer below what will be accessed by the pipeline. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448caf63622ed5219be61db38d6aa49b72334"></a>halide_error_code_constraint_violated</em>&#160;</td><td class="fielddoc">
<p>A constraint on a size or stride of an input or output buffer was not met by the <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> passed in. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca0d9f00cc44f9f77fa70836e7d25cfaf8"></a>halide_error_code_param_too_small</em>&#160;</td><td class="fielddoc">
<p>A scalar parameter passed in was smaller than its minimum declared value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca0d5dfd64f10156a5d2d1453fad4bfb6c"></a>halide_error_code_param_too_large</em>&#160;</td><td class="fielddoc">
<p>A scalar parameter passed in was greater than its minimum declared value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448caf47d74c0b04724325995bb4bd58cecb0"></a>halide_error_code_out_of_memory</em>&#160;</td><td class="fielddoc">
<p>A call to halide_malloc returned NULL. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca86cb45d6014d16a06c0d9071c122ec9a"></a>halide_error_code_buffer_argument_is_null</em>&#160;</td><td class="fielddoc">
<p>A <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> pointer passed in was NULL. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca9e69757bbb1448560eff39ad38e28aff"></a>halide_error_code_debug_to_file_failed</em>&#160;</td><td class="fielddoc">
<p>debug_to_file failed to open or write to the specified file. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca61e81a880002d327a8d1aa09c3233636"></a>halide_error_code_copy_to_host_failed</em>&#160;</td><td class="fielddoc">
<p>The <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> runtime encountered an error while trying to copy from device to host. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca40015fc733363a53e154bc8183c86b54"></a>halide_error_code_copy_to_device_failed</em>&#160;</td><td class="fielddoc">
<p>The <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> runtime encountered an error while trying to copy from host to device. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca92667ff05a79083a7de97843d507ecdb"></a>halide_error_code_device_malloc_failed</em>&#160;</td><td class="fielddoc">
<p>The <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> runtime encountered an error while trying to allocate memory on device. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca79b37d315188ac600b479f68d2627952"></a>halide_error_code_device_sync_failed</em>&#160;</td><td class="fielddoc">
<p>The <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> runtime encountered an error while trying to synchronize with a device. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448cab9688dd68dbb132ba66ea80186fc18d1"></a>halide_error_code_device_free_failed</em>&#160;</td><td class="fielddoc">
<p>The <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> runtime encountered an error while trying to free a device allocation. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca006100e2007527689fe7d6104b209956"></a>halide_error_code_no_device_interface</em>&#160;</td><td class="fielddoc">
<p>A device operation was attempted on a buffer with no device interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca6c123efceb388bfef491629d89065775"></a>halide_error_code_matlab_init_failed</em>&#160;</td><td class="fielddoc">
<p>An error occurred when attempting to initialize the Matlab runtime. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448caf5c56ee69de59cfb5959461ac0a8c570"></a>halide_error_code_matlab_bad_param_type</em>&#160;</td><td class="fielddoc">
<p>The type of an mxArray did not match the expected type. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca28e9d2c63f5933a4422b668b3f473867"></a>halide_error_code_internal_error</em>&#160;</td><td class="fielddoc">
<p>There is a bug in the <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> compiler. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448cacf7f17603b30be3f4df86d701df4ee2a"></a>halide_error_code_device_run_failed</em>&#160;</td><td class="fielddoc">
<p>The <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> runtime encountered an error while trying to launch a GPU kernel. </p>
<p>Turn on -debug in your target string to see more details. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448caf843735e0a784d64e56fcff6069cdb5d"></a>halide_error_code_unaligned_host_ptr</em>&#160;</td><td class="fielddoc">
<p>The <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> runtime encountered a host pointer that violated the alignment set for it by way of a call to set_host_alignment. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca07b8321ceede9444ea7bba637a9bb7c1"></a>halide_error_code_bad_fold</em>&#160;</td><td class="fielddoc">
<p>A fold_storage directive was used on a dimension that is not accessed in a monotonically increasing or decreasing fashion. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca0a42d062cb8da32cf5158daab9c37c41"></a>halide_error_code_fold_factor_too_small</em>&#160;</td><td class="fielddoc">
<p>A fold_storage directive was used with a fold factor that was too small to store all the values of a producer needed by the consumer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca180c55e696deec0e26fc4b82fadefd4c"></a>halide_error_code_requirement_failed</em>&#160;</td><td class="fielddoc">
<p>User-specified <a class="el" href="namespace_halide.html#aaae7edaa63f7191418f5b79902ac3b3f" title="Create an Expr that that guarantees a precondition. ">require()</a> expression was not satisfied. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca2b91673e6f8ed8585e1571a03173ea22"></a>halide_error_code_buffer_extents_negative</em>&#160;</td><td class="fielddoc">
<p>At least one of the buffer's extents are negative. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca853a112ac8f7a04078f3bb50e840b9de"></a>halide_error_code_failed_to_upgrade_buffer_t</em>&#160;</td><td class="fielddoc">
<p>A compiled pipeline was passed the old deprecated <a class="el" href="structbuffer__t.html">buffer_t</a> struct, and it could not be upgraded to a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca83b466928774790b35bf676dfe173760"></a>halide_error_code_failed_to_downgrade_buffer_t</em>&#160;</td><td class="fielddoc">
<p>A compiled pipeline was passed the old deprecated <a class="el" href="structbuffer__t.html">buffer_t</a> struct in bounds inference mode, but the returned information can't be expressed in the old <a class="el" href="structbuffer__t.html">buffer_t</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aba16e170cc9aa30b78ff703e101a448ca0e0b319ab036506ee80df45c1f5cdac0"></a>halide_error_code_specialize_fail</em>&#160;</td><td class="fielddoc">
<p>A specialize_fail() schedule branch was selected at runtime. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00678">678</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3a">halide_target_feature_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional features a compilation Target can have. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aade7b43403349f5e8490128ec8a353ea0"></a>halide_target_feature_jit</em>&#160;</td><td class="fielddoc">
<p>Generate code that will run immediately inside the calling process. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa269192ac4c709ac4cd58a224aaa4ebed"></a>halide_target_feature_debug</em>&#160;</td><td class="fielddoc">
<p>Turn on debug info and output for runtime code. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1091af1b1f0fd0f65a4cf11d9465421b"></a>halide_target_feature_no_asserts</em>&#160;</td><td class="fielddoc">
<p>Disable all runtime checks, for slightly tighter code. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf66b5dc5721dc9d3437418d2af78218a"></a>halide_target_feature_no_bounds_query</em>&#160;</td><td class="fielddoc">
<p>Disable the bounds querying functionality. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa8efcb48a15fdbfeb9a80f4e4b47f6c35"></a>halide_target_feature_sse41</em>&#160;</td><td class="fielddoc">
<p>Use SSE 4.1 and earlier instructions. Only relevant on x86. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aae30ffae7b5e51bd142e5902c6b60d2a5"></a>halide_target_feature_avx</em>&#160;</td><td class="fielddoc">
<p>Use AVX 1 instructions. Only relevant on x86. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1b8d4c5f8ff39549eab349f8f9187f30"></a>halide_target_feature_avx2</em>&#160;</td><td class="fielddoc">
<p>Use AVX 2 instructions. Only relevant on x86. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa00ca2d6e033b225858ea63abb21123da"></a>halide_target_feature_fma</em>&#160;</td><td class="fielddoc">
<p>Enable x86 FMA instruction. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5c4a3ac722a0f391a41809f4fe1fa5e9"></a>halide_target_feature_fma4</em>&#160;</td><td class="fielddoc">
<p>Enable x86 (AMD) FMA4 instruction set. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aac3f0411bb6041392120209d5eb97dd20"></a>halide_target_feature_f16c</em>&#160;</td><td class="fielddoc">
<p>Enable x86 16-bit float support. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5fa253bc01a2a59792fd5da6d351d35f"></a>halide_target_feature_armv7s</em>&#160;</td><td class="fielddoc">
<p>Generate code for ARMv7s. Only relevant for 32-bit ARM. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5f1be27fa92915a8d2193f0bbeb9ada5"></a>halide_target_feature_no_neon</em>&#160;</td><td class="fielddoc">
<p>Avoid using NEON instructions. Only relevant for 32-bit ARM. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf10caf4d87b54ef2a1eeef0a1a9ef7a4"></a>halide_target_feature_vsx</em>&#160;</td><td class="fielddoc">
<p>Use VSX instructions. Only relevant on POWERPC. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa995a835a73267a3edd9822c6d1927c3a"></a>halide_target_feature_power_arch_2_07</em>&#160;</td><td class="fielddoc">
<p>Use POWER ISA 2.07 new instructions. Only relevant on POWERPC. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aabaf8d7892508763403932f8e9e80b2e2"></a>halide_target_feature_cuda</em>&#160;</td><td class="fielddoc">
<p>Enable the CUDA runtime. Defaults to compute capability 2.0 (Fermi) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5e16be3f2066021a8d24ee420d69b2a3"></a>halide_target_feature_cuda_capability30</em>&#160;</td><td class="fielddoc">
<p>Enable CUDA compute capability 3.0 (Kepler) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aad6cf6481cb5a8f405115dd91a7d71987"></a>halide_target_feature_cuda_capability32</em>&#160;</td><td class="fielddoc">
<p>Enable CUDA compute capability 3.2 (Tegra K1) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa72e1c9e35b9184f0a8b7157374c81e9b"></a>halide_target_feature_cuda_capability35</em>&#160;</td><td class="fielddoc">
<p>Enable CUDA compute capability 3.5 (Kepler) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa45190927a84bdeab2a4195eae0b47f6"></a>halide_target_feature_cuda_capability50</em>&#160;</td><td class="fielddoc">
<p>Enable CUDA compute capability 5.0 (Maxwell) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa9af51d9a3d2a16a2053dee312567da3a"></a>halide_target_feature_opencl</em>&#160;</td><td class="fielddoc">
<p>Enable the OpenCL runtime. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa10dfd45f611103dce0fcdbf671b89e5a"></a>halide_target_feature_cl_doubles</em>&#160;</td><td class="fielddoc">
<p>Enable double support on OpenCL targets. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aab19096f9cc22d728014cb0da3ac3fa9f"></a>halide_target_feature_opengl</em>&#160;</td><td class="fielddoc">
<p>Enable the OpenGL runtime. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa17e04f4f71026dd997991fbc1d97437f"></a>halide_target_feature_openglcompute</em>&#160;</td><td class="fielddoc">
<p>Enable OpenGL Compute runtime. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aae45ec1b677cea5f38e82dc776a70817e"></a>halide_target_feature_unused_23</em>&#160;</td><td class="fielddoc">
<p>Unused. (Formerly: Enable the RenderScript runtime.) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf353c2e40c697e29b86a4e51829735df"></a>halide_target_feature_user_context</em>&#160;</td><td class="fielddoc">
<p>Generated code takes a user_context pointer as first argument. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5563142075b821d2b5efad58c57f0431"></a>halide_target_feature_matlab</em>&#160;</td><td class="fielddoc">
<p>Generate a mexFunction compatible with Matlab mex libraries. See tools/mex_halide.m. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa700fd7b1280a9175b7cb3d43fe2c1754"></a>halide_target_feature_profile</em>&#160;</td><td class="fielddoc">
<p>Launch a sampling profiler alongside the <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> pipeline that monitors and reports the runtime used by each Func. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa23b4add23a16a3cfe633b90f2fd6d292"></a>halide_target_feature_no_runtime</em>&#160;</td><td class="fielddoc">
<p>Do not include a copy of the <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> runtime in any generated object file or assembly. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa596a01105ce4f5896b14c69210899e35"></a>halide_target_feature_metal</em>&#160;</td><td class="fielddoc">
<p>Enable the (Apple) Metal runtime. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaffc640375f557b19ce0f9ff540cc3f7a"></a>halide_target_feature_mingw</em>&#160;</td><td class="fielddoc">
<p>For Windows compile to MinGW toolset rather then Visual Studio. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1efec7b26946ba7f59cc887dcd45ea22"></a>halide_target_feature_c_plus_plus_mangling</em>&#160;</td><td class="fielddoc">
<p>Generate C++ mangled names for result function, et al. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa00aee1f2d9370a407522de5378d9901c"></a>halide_target_feature_large_buffers</em>&#160;</td><td class="fielddoc">
<p>Enable 64-bit buffer indexing to support buffers &gt; 2GB. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aad88272637e7f1e81c66bff8c5f4ed831"></a>halide_target_feature_hvx_64</em>&#160;</td><td class="fielddoc">
<p>Enable HVX 64 byte mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5bbb70ba548793579bef24d7bd8ffd6a"></a>halide_target_feature_hvx_128</em>&#160;</td><td class="fielddoc">
<p>Enable HVX 128 byte mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaac0b0401c077429c652dc5d2723756f0"></a>halide_target_feature_hvx_v62</em>&#160;</td><td class="fielddoc">
<p>Enable Hexagon v62 architecture. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaf7f57223352cf39e7375d2e2af6004b2"></a>halide_target_feature_fuzz_float_stores</em>&#160;</td><td class="fielddoc">
<p>On every floating point store, set the last bit of the mantissa to zero. Pipelines for which the output is very different with this feature enabled may also produce very different output on different processors. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa484bc02e560762b1c51c0bf254b00a9f"></a>halide_target_feature_soft_float_abi</em>&#160;</td><td class="fielddoc">
<p>Enable soft float ABI. This only enables the soft float ABI calling convention, which does not necessarily use soft floats. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa068da87b16c87dd104d9720fec39ec42"></a>halide_target_feature_msan</em>&#160;</td><td class="fielddoc">
<p>Enable hooks for MSAN support. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa237eaab3cbd8d646c075b74f9958ba0"></a>halide_target_feature_avx512</em>&#160;</td><td class="fielddoc">
<p>Enable the base AVX512 subset supported by all AVX512 architectures. The specific feature sets are AVX-512F and AVX512-CD. See <a href="https://en.wikipedia.org/wiki/AVX-512">https://en.wikipedia.org/wiki/AVX-512</a> for a description of each AVX subset. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aaa2779d4303538045aa9317c5cfefde48"></a>halide_target_feature_avx512_knl</em>&#160;</td><td class="fielddoc">
<p>Enable the AVX512 features supported by Knight's Landing chips, such as the Xeon Phi x200. This includes the base AVX512 set, and also AVX512-CD and AVX512-ER. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa58fb5b7b5bc221459b800cc42930902f"></a>halide_target_feature_avx512_skylake</em>&#160;</td><td class="fielddoc">
<p>Enable the AVX512 features supported by Skylake Xeon server processors. This adds AVX512-VL, AVX512-BW, and AVX512-DQ to the base set. The main difference from the base AVX512 set is better support for small integer ops. Note that this does not include the Knight's Landing features. Note also that these features are not available on Skylake desktop and mobile processors. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa591bbdef6ade866e52fa671d8ea2aed1"></a>halide_target_feature_avx512_cannonlake</em>&#160;</td><td class="fielddoc">
<p>Enable the AVX512 features expected to be supported by future Cannonlake processors. This includes all of the Skylake features, plus AVX512-IFMA and AVX512-VBMI. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aab3a23a74dcd2c56129fdac9b5487500e"></a>halide_target_feature_hvx_use_shared_object</em>&#160;</td><td class="fielddoc">
<p>Deprecated. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa0de323126eca04377e205b6a67b93970"></a>halide_target_feature_trace_loads</em>&#160;</td><td class="fielddoc">
<p>Trace all loads done by the pipeline. Equivalent to calling Func::trace_loads on every non-inlined Func. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa9d6461b681abeeb0ff4c850cfe4e1eb4"></a>halide_target_feature_trace_stores</em>&#160;</td><td class="fielddoc">
<p>Trace all stores done by the pipeline. Equivalent to calling Func::trace_stores on every non-inlined Func. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa1cebf3f4e7137ca7f3a74b4c2049de4d"></a>halide_target_feature_trace_realizations</em>&#160;</td><td class="fielddoc">
<p>Trace all realizations done by the pipeline. Equivalent to calling Func::trace_realizations on every non-inlined Func. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa5f6ed2f96b52eaeae62dc1beb66b74de"></a>halide_target_feature_cuda_capability61</em>&#160;</td><td class="fielddoc">
<p>Enable CUDA compute capability 6.1 (Pascal) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2ccb96b3d427fff8f1d68cc5f1e92f3aa3962d2fc2f69c69b85d29c4818d727c1"></a>halide_target_feature_end</em>&#160;</td><td class="fielddoc">
<p>A sentinel. Every target is considered to have this feature, and setting this feature does nothing. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00882">882</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="a320c79a12e6121c7468cb203373e6afc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_halide_runtime_8h.html#a320c79a12e6121c7468cb203373e6afc">halide_buffer_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a320c79a12e6121c7468cb203373e6afca1b91e0ac0aba5891e4c7219878da7460"></a>halide_buffer_flag_host_dirty</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a320c79a12e6121c7468cb203373e6afca117e8a76112638ba6510e084e1dfb292"></a>halide_buffer_flag_device_dirty</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l01012">1012</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="afdce5dc7a11fa96f39baa1aee2333745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_halide_runtime_8h.html#afdce5dc7a11fa96f39baa1aee2333745">halide_argument_kind_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="afdce5dc7a11fa96f39baa1aee2333745a4cce082af093da2e1e886ed3a775b2b1"></a>halide_argument_kind_input_scalar</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afdce5dc7a11fa96f39baa1aee2333745af4d5e7ee6d3fb12c5a5c0d9edd845a5b"></a>halide_argument_kind_input_buffer</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afdce5dc7a11fa96f39baa1aee2333745a0113d76303e0327745f3b3e4070dccd8"></a>halide_argument_kind_output_buffer</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l01208">1208</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Profiler func ids with special meanings. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7ab6b9a850264048aeff726f435f21ac25"></a>halide_profiler_outside_of_halide</em>&#160;</td><td class="fielddoc">
<p>current_func takes on this value when not inside <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> code </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="adf764cbdea00d65edcd07bb9953ad2b7aa07fb8b03c126c5357f8bbe679def9b5"></a>halide_profiler_please_stop</em>&#160;</td><td class="fielddoc">
<p>Set current_func to this value to tell the profiling thread to halt. </p>
<p>It will start up again next time you run a pipeline with profiling enabled. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l01373">1373</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a96fe1dd85166a7f0da1b8f82f734296a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_print </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a message to stderr. </p>
<p>Main use is to support tracing functionality, print, and print_when calls. Also called by the default halide_error. This function can be replaced in JITed code by using halide_custom_print and providing an implementation of halide_print in AOT code. See Func::set_custom_print. </p>

</div>
</div>
<a class="anchor" id="a2c1ae09f6ef33a2508fc67ac50f2c207"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_default_print </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a message to stderr. </p>
<p>Main use is to support tracing functionality, print, and print_when calls. Also called by the default halide_error. This function can be replaced in JITed code by using halide_custom_print and providing an implementation of halide_print in AOT code. See Func::set_custom_print. </p>

</div>
</div>
<a class="anchor" id="a3d3e4cf6c510fd8bc26420af06b7e4f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#a5c1fa162445be01b45cec2460ec2f00a">halide_print_t</a> halide_set_custom_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a5c1fa162445be01b45cec2460ec2f00a">halide_print_t</a>&#160;</td>
          <td class="paramname"><em>print</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a message to stderr. </p>
<p>Main use is to support tracing functionality, print, and print_when calls. Also called by the default halide_error. This function can be replaced in JITed code by using halide_custom_print and providing an implementation of halide_print in AOT code. See Func::set_custom_print. </p>

</div>
</div>
<a class="anchor" id="aea28d04de54b94f0dd6ada140b7734d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_error </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls this function on runtime errors (for example bounds checking failures). </p>
<p>This function can be replaced in JITed code by using Func::set_error_handler, or in AOT code by calling halide_set_error_handler. In AOT code on platforms that support weak linking (i.e. not Windows), you can also override it by simply defining your own halide_error. </p>

<p>Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00251">halide_set_num_threads()</a>.</p>

</div>
</div>
<a class="anchor" id="aaf9ec52392edc2a7b65aab13183a2543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_default_error </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls this function on runtime errors (for example bounds checking failures). </p>
<p>This function can be replaced in JITed code by using Func::set_error_handler, or in AOT code by calling halide_set_error_handler. In AOT code on platforms that support weak linking (i.e. not Windows), you can also override it by simply defining your own halide_error. </p>

</div>
</div>
<a class="anchor" id="a02d18a3f649e46538666fb87ab3fb6ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#a48f5f1ebda2ee82c39cc1050aaa7cd8a">halide_error_handler_t</a> halide_set_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a48f5f1ebda2ee82c39cc1050aaa7cd8a">halide_error_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls this function on runtime errors (for example bounds checking failures). </p>
<p>This function can be replaced in JITed code by using Func::set_error_handler, or in AOT code by calling halide_set_error_handler. In AOT code on platforms that support weak linking (i.e. not Windows), you can also override it by simply defining your own halide_error. </p>

</div>
</div>
<a class="anchor" id="a479133225b3cdf7b931f3c44e878e4e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A basic set of mutex and condition variable functions, which call platform specific code for mutual exclusion. </p>
<p>Equivalent to posix calls. Mutexes should initially be set to zero'd memory. Any resources required are created on first lock. Calling destroy re-zeros the memory. </p>

<p>Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00169">halide_default_do_par_for()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00251">halide_set_num_threads()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00268">halide_shutdown_thread_pool()</a>, <a class="el" href="scoped__mutex__lock_8h_source.html#l00012">Halide::Runtime::Internal::ScopedMutexLock::ScopedMutexLock()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00152">Halide::Runtime::Internal::worker_thread()</a>, and <a class="el" href="thread__pool__common_8h_source.html#l00086">Halide::Runtime::Internal::worker_thread_already_locked()</a>.</p>

</div>
</div>
<a class="anchor" id="a5e9b62fd2c1d38e6f06100b827830377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A basic set of mutex and condition variable functions, which call platform specific code for mutual exclusion. </p>
<p>Equivalent to posix calls. Mutexes should initially be set to zero'd memory. Any resources required are created on first lock. Calling destroy re-zeros the memory. </p>

<p>Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00169">halide_default_do_par_for()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00251">halide_set_num_threads()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00268">halide_shutdown_thread_pool()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00152">Halide::Runtime::Internal::worker_thread()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00086">Halide::Runtime::Internal::worker_thread_already_locked()</a>, and <a class="el" href="scoped__mutex__lock_8h_source.html#l00016">Halide::Runtime::Internal::ScopedMutexLock::~ScopedMutexLock()</a>.</p>

</div>
</div>
<a class="anchor" id="acb6daa319e15be120217dc6d393004aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_mutex_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhalide__mutex.html">halide_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A basic set of mutex and condition variable functions, which call platform specific code for mutual exclusion. </p>
<p>Equivalent to posix calls. Mutexes should initially be set to zero'd memory. Any resources required are created on first lock. Calling destroy re-zeros the memory. </p>

<p>Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00268">halide_shutdown_thread_pool()</a>.</p>

</div>
</div>
<a class="anchor" id="a15f85711e52c707df2e484f69dfaf7c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_do_par_for </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define halide_do_par_for to replace the default thread pool implementation. </p>
<p>halide_shutdown_thread_pool can also be called to release resources used by the default thread pool on platforms where it makes sense. (E.g. On Mac OS, Grand Central Dispatch is used so Halide does not own the threads backing the pool and they cannot be released.) See Func::set_custom_do_task and Func::set_custom_do_par_for. Should return zero if all the jobs return zero, or an arbitrarily chosen return value from one of the jobs otherwise. </p>

</div>
</div>
<a class="anchor" id="a5e9d22d2b79a3dc66a32159423b17910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_shutdown_thread_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define halide_do_par_for to replace the default thread pool implementation. </p>
<p>halide_shutdown_thread_pool can also be called to release resources used by the default thread pool on platforms where it makes sense. (E.g. On Mac OS, Grand Central Dispatch is used so Halide does not own the threads backing the pool and they cannot be released.) See Func::set_custom_do_task and Func::set_custom_do_par_for. Should return zero if all the jobs return zero, or an arbitrarily chosen return value from one of the jobs otherwise. </p>

<p>Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00268">268</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p>References <a class="el" href="runtime__internal_8h.html#ab2c4d6ba930105ad50607232ba0f4083">halide_cond_broadcast()</a>, <a class="el" href="runtime__internal_8h.html#ab2aff9bb27c22b5e991a4637912c0dd4">halide_cond_destroy()</a>, <a class="el" href="_halide_runtime_8h.html#aba03c92519ed6b3df69caf08e8278720">halide_join_thread()</a>, <a class="el" href="_halide_runtime_8h.html#acb6daa319e15be120217dc6d393004aa">halide_mutex_destroy()</a>, <a class="el" href="_halide_runtime_8h.html#a479133225b3cdf7b931f3c44e878e4e8">halide_mutex_lock()</a>, <a class="el" href="_halide_runtime_8h.html#a5e9b62fd2c1d38e6f06100b827830377">halide_mutex_unlock()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00053">Halide::Runtime::Internal::work_queue_t::initialized</a>, <a class="el" href="thread__pool__common_8h_source.html#l00019">Halide::Runtime::Internal::work_queue_t::mutex</a>, <a class="el" href="thread__pool__common_8h_source.html#l00053">Halide::Runtime::Internal::work_queue_t::shutdown</a>, <a class="el" href="thread__pool__common_8h_source.html#l00043">Halide::Runtime::Internal::work_queue_t::threads</a>, <a class="el" href="thread__pool__common_8h_source.html#l00046">Halide::Runtime::Internal::work_queue_t::threads_created</a>, <a class="el" href="thread__pool__common_8h_source.html#l00036">Halide::Runtime::Internal::work_queue_t::wakeup_a_team</a>, <a class="el" href="thread__pool__common_8h_source.html#l00040">Halide::Runtime::Internal::work_queue_t::wakeup_b_team</a>, <a class="el" href="thread__pool__common_8h_source.html#l00033">Halide::Runtime::Internal::work_queue_t::wakeup_owners</a>, and <a class="el" href="thread__pool__common_8h_source.html#l00060">Halide::Runtime::Internal::work_queue</a>.</p>

</div>
</div>
<a class="anchor" id="ab9eb8b02091849cfbcbdf7d2f4177857"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#a67106643662219b875b6e69775955944">halide_do_par_for_t</a> halide_set_custom_do_par_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a67106643662219b875b6e69775955944">halide_do_par_for_t</a>&#160;</td>
          <td class="paramname"><em>do_par_for</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aece7417671894d7557b9e93ea0ebc0ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#a4b38fa796412d8e1b26a38c2f8a37713">halide_do_task_t</a> halide_set_custom_do_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a4b38fa796412d8e1b26a38c2f8a37713">halide_do_task_t</a>&#160;</td>
          <td class="paramname"><em>do_task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you use the default do_par_for, you can still set a custom handler to perform each individual task. </p>
<p>Returns the old handler. </p>

</div>
</div>
<a class="anchor" id="a4b73ddae74b80251d2ffce9a624b6125"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_do_task </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If you use the default do_par_for, you can still set a custom handler to perform each individual task. </p>
<p>Returns the old handler. </p>

<p>Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00086">Halide::Runtime::Internal::worker_thread_already_locked()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a20aae4f3c690d66578775e1245ec22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_default_do_par_for </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default versions of do_task and do_par_for. </p>
<p>Can be convenient to call from overrides in certain circumstances. </p>

<p>Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00169">169</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p>References <a class="el" href="thread__pool__common_8h_source.html#l00030">Halide::Runtime::Internal::work_queue_t::a_team_size</a>, <a class="el" href="thread__pool__common_8h_source.html#l00010">Halide::Runtime::Internal::work::active_workers</a>, <a class="el" href="thread__pool__common_8h_source.html#l00062">Halide::Runtime::Internal::clamp_num_threads()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00009">Halide::Runtime::Internal::work::closure</a>, <a class="el" href="thread__pool__common_8h_source.html#l00071">Halide::Runtime::Internal::default_desired_num_threads()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00049">Halide::Runtime::Internal::work_queue_t::desired_num_threads</a>, <a class="el" href="thread__pool__common_8h_source.html#l00011">Halide::Runtime::Internal::work::exit_status</a>, <a class="el" href="thread__pool__common_8h_source.html#l00006">Halide::Runtime::Internal::work::f</a>, <a class="el" href="runtime__internal_8h.html#ab2c4d6ba930105ad50607232ba0f4083">halide_cond_broadcast()</a>, <a class="el" href="runtime__internal_8h.html#ae5e411471520993318515419675ca91e">halide_cond_init()</a>, <a class="el" href="_halide_runtime_8h.html#a479133225b3cdf7b931f3c44e878e4e8">halide_mutex_lock()</a>, <a class="el" href="_halide_runtime_8h.html#a5e9b62fd2c1d38e6f06100b827830377">halide_mutex_unlock()</a>, <a class="el" href="_halide_runtime_8h.html#a705adaf288bb596411feaa98e33710dc">halide_spawn_thread()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00053">Halide::Runtime::Internal::work_queue_t::initialized</a>, <a class="el" href="thread__pool__common_8h_source.html#l00022">Halide::Runtime::Internal::work_queue_t::jobs</a>, <a class="el" href="thread__pool__common_8h_source.html#l00008">Halide::Runtime::Internal::work::max</a>, <a class="el" href="_generator_8h_source.html#l00881">Halide::min()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00019">Halide::Runtime::Internal::work_queue_t::mutex</a>, <a class="el" href="thread__pool__common_8h_source.html#l00008">Halide::Runtime::Internal::work::next</a>, <a class="el" href="thread__pool__common_8h_source.html#l00005">Halide::Runtime::Internal::work::next_job</a>, <a class="el" href="runtime__internal_8h_source.html#l00032">NULL</a>, <a class="el" href="thread__pool__common_8h_source.html#l00053">Halide::Runtime::Internal::work_queue_t::shutdown</a>, <a class="el" href="thread__pool__common_8h_source.html#l00030">Halide::Runtime::Internal::work_queue_t::target_a_team_size</a>, <a class="el" href="thread__pool__common_8h_source.html#l00043">Halide::Runtime::Internal::work_queue_t::threads</a>, <a class="el" href="thread__pool__common_8h_source.html#l00046">Halide::Runtime::Internal::work_queue_t::threads_created</a>, <a class="el" href="thread__pool__common_8h_source.html#l00007">Halide::Runtime::Internal::work::user_context</a>, <a class="el" href="printer_8h_source.html#l00031">user_context</a>, <a class="el" href="thread__pool__common_8h_source.html#l00036">Halide::Runtime::Internal::work_queue_t::wakeup_a_team</a>, <a class="el" href="thread__pool__common_8h_source.html#l00040">Halide::Runtime::Internal::work_queue_t::wakeup_b_team</a>, <a class="el" href="thread__pool__common_8h_source.html#l00033">Halide::Runtime::Internal::work_queue_t::wakeup_owners</a>, <a class="el" href="thread__pool__common_8h_source.html#l00060">Halide::Runtime::Internal::work_queue</a>, <a class="el" href="thread__pool__common_8h_source.html#l00152">Halide::Runtime::Internal::worker_thread()</a>, and <a class="el" href="thread__pool__common_8h_source.html#l00086">Halide::Runtime::Internal::worker_thread_already_locked()</a>.</p>

</div>
</div>
<a class="anchor" id="a1529a6494b14d3a4f19b8080fdd77e31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_default_do_task </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a6465a3a2522d24a2e83e56e263616dcb">halide_task_t</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default versions of do_task and do_par_for. </p>
<p>Can be convenient to call from overrides in certain circumstances. </p>

<p>Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00164">164</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

</div>
</div>
<a class="anchor" id="a705adaf288bb596411feaa98e33710dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct halide_thread* halide_spawn_thread </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawn a thread. </p>
<p>Returns a handle to the thread for the purposes of joining it. The thread must be joined in order to clean up any resources associated with it. </p>

<p>Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00169">halide_default_do_par_for()</a>.</p>

</div>
</div>
<a class="anchor" id="aba03c92519ed6b3df69caf08e8278720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_join_thread </td>
          <td>(</td>
          <td class="paramtype">struct halide_thread *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a thread. </p>

<p>Referenced by <a class="el" href="thread__pool__common_8h_source.html#l00268">halide_shutdown_thread_pool()</a>.</p>

</div>
</div>
<a class="anchor" id="a36d93e0796319cf64432c511affba1a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of threads used by <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s thread pool. </p>
<p>Returns the old number.</p>
<p>n &lt; 0 : error condition n == 0 : use a reasonable system default (typically, number of cpus online). n == 1 : use exactly one thread; this will always enforce serial execution n &gt; 1 : use a pool of exactly n threads.</p>
<p>Note that the default iOS and OSX behavior will treat n &gt; 1 like n == 0; that is, any positive value other than 1 will use a system-determined number of threads.</p>
<p>(Note that this is only guaranteed when using the default implementations of <a class="el" href="_halide_runtime_8h.html#a15f85711e52c707df2e484f69dfaf7c5" title="Define halide_do_par_for to replace the default thread pool implementation. ">halide_do_par_for()</a>; custom implementations may completely ignore values passed to <a class="el" href="_halide_runtime_8h.html#a36d93e0796319cf64432c511affba1a5" title="Set the number of threads used by Halide&#39;s thread pool. ">halide_set_num_threads()</a>.) </p>

<p>Definition at line <a class="el" href="thread__pool__common_8h_source.html#l00251">251</a> of file <a class="el" href="thread__pool__common_8h_source.html">thread_pool_common.h</a>.</p>

<p>References <a class="el" href="thread__pool__common_8h_source.html#l00062">Halide::Runtime::Internal::clamp_num_threads()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00071">Halide::Runtime::Internal::default_desired_num_threads()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00049">Halide::Runtime::Internal::work_queue_t::desired_num_threads</a>, <a class="el" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8">halide_error()</a>, <a class="el" href="_halide_runtime_8h.html#a479133225b3cdf7b931f3c44e878e4e8">halide_mutex_lock()</a>, <a class="el" href="_halide_runtime_8h.html#a5e9b62fd2c1d38e6f06100b827830377">halide_mutex_unlock()</a>, <a class="el" href="thread__pool__common_8h_source.html#l00019">Halide::Runtime::Internal::work_queue_t::mutex</a>, <a class="el" href="runtime__internal_8h_source.html#l00032">NULL</a>, and <a class="el" href="thread__pool__common_8h_source.html#l00060">Halide::Runtime::Internal::work_queue</a>.</p>

</div>
</div>
<a class="anchor" id="aa5bb359ed77ef4c1f89251bcd7eb2613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* halide_malloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory. </p>
<p>To replace in AOT code, use the halide_set_custom_malloc and halide_set_custom_free, or (on platforms that support weak linking), simply define these functions yourself. In JIT-compiled code use Func::set_custom_allocator.</p>
<p>If you override them, and find yourself wanting to call the default implementation from within your override, use halide_default_malloc/free.</p>
<p>Note that halide_malloc must return a pointer aligned to the maximum meaningful alignment for the platform for the purpose of vector loads and stores. The default implementation uses 32-byte alignment, which is safe for arm and x86. Additionally, it must be safe to read at least 8 bytes before the start and beyond the end. </p>

</div>
</div>
<a class="anchor" id="a2fa49d775b9a20fab152a0650c4c936b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory. </p>
<p>To replace in AOT code, use the halide_set_custom_malloc and halide_set_custom_free, or (on platforms that support weak linking), simply define these functions yourself. In JIT-compiled code use Func::set_custom_allocator.</p>
<p>If you override them, and find yourself wanting to call the default implementation from within your override, use halide_default_malloc/free.</p>
<p>Note that halide_malloc must return a pointer aligned to the maximum meaningful alignment for the platform for the purpose of vector loads and stores. The default implementation uses 32-byte alignment, which is safe for arm and x86. Additionally, it must be safe to read at least 8 bytes before the start and beyond the end. </p>

</div>
</div>
<a class="anchor" id="a8133de16210a46515502f007ee571fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* halide_default_malloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory. </p>
<p>To replace in AOT code, use the halide_set_custom_malloc and halide_set_custom_free, or (on platforms that support weak linking), simply define these functions yourself. In JIT-compiled code use Func::set_custom_allocator.</p>
<p>If you override them, and find yourself wanting to call the default implementation from within your override, use halide_default_malloc/free.</p>
<p>Note that halide_malloc must return a pointer aligned to the maximum meaningful alignment for the platform for the purpose of vector loads and stores. The default implementation uses 32-byte alignment, which is safe for arm and x86. Additionally, it must be safe to read at least 8 bytes before the start and beyond the end. </p>

</div>
</div>
<a class="anchor" id="ab246841764b58f9675fdb27db0b4bd34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_default_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory. </p>
<p>To replace in AOT code, use the halide_set_custom_malloc and halide_set_custom_free, or (on platforms that support weak linking), simply define these functions yourself. In JIT-compiled code use Func::set_custom_allocator.</p>
<p>If you override them, and find yourself wanting to call the default implementation from within your override, use halide_default_malloc/free.</p>
<p>Note that halide_malloc must return a pointer aligned to the maximum meaningful alignment for the platform for the purpose of vector loads and stores. The default implementation uses 32-byte alignment, which is safe for arm and x86. Additionally, it must be safe to read at least 8 bytes before the start and beyond the end. </p>

</div>
</div>
<a class="anchor" id="a4d0668aaae035f2f4f3132857acee4e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#af1789361c8c7393c2efa66fc768f71f6">halide_malloc_t</a> halide_set_custom_malloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#af1789361c8c7393c2efa66fc768f71f6">halide_malloc_t</a>&#160;</td>
          <td class="paramname"><em>user_malloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory. </p>
<p>To replace in AOT code, use the halide_set_custom_malloc and halide_set_custom_free, or (on platforms that support weak linking), simply define these functions yourself. In JIT-compiled code use Func::set_custom_allocator.</p>
<p>If you override them, and find yourself wanting to call the default implementation from within your override, use halide_default_malloc/free.</p>
<p>Note that halide_malloc must return a pointer aligned to the maximum meaningful alignment for the platform for the purpose of vector loads and stores. The default implementation uses 32-byte alignment, which is safe for arm and x86. Additionally, it must be safe to read at least 8 bytes before the start and beyond the end. </p>

</div>
</div>
<a class="anchor" id="acd43bc97b2337e57fd6af03be17a5bb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#a5ad708200fb55818d42238cb2457f797">halide_free_t</a> halide_set_custom_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a5ad708200fb55818d42238cb2457f797">halide_free_t</a>&#160;</td>
          <td class="paramname"><em>user_free</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to allocate and free memory. </p>
<p>To replace in AOT code, use the halide_set_custom_malloc and halide_set_custom_free, or (on platforms that support weak linking), simply define these functions yourself. In JIT-compiled code use Func::set_custom_allocator.</p>
<p>If you override them, and find yourself wanting to call the default implementation from within your override, use halide_default_malloc/free.</p>
<p>Note that halide_malloc must return a pointer aligned to the maximum meaningful alignment for the platform for the purpose of vector loads and stores. The default implementation uses 32-byte alignment, which is safe for arm and x86. Additionally, it must be safe to read at least 8 bytes before the start and beyond the end. </p>

</div>
</div>
<a class="anchor" id="a2b6304bb2284705fd7ee1b016b237016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* halide_get_symbol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_load_library()</a> and <a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

</div>
</div>
<a class="anchor" id="a5769941d99b24d54ecc3b59d284a9b15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* halide_load_library </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_load_library()</a> and <a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

</div>
</div>
<a class="anchor" id="a2c49f4bcdad4b5b28ca6f9949bfd74b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* halide_get_library_symbol </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_load_library()</a> and <a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

</div>
</div>
<a class="anchor" id="a26b92ee99852a155096e369c228a6218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* halide_default_get_symbol </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_load_library()</a> and <a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

</div>
</div>
<a class="anchor" id="a47851b7037e6d6cecffb2aba5c1d7a98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* halide_default_load_library </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_load_library()</a> and <a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

</div>
</div>
<a class="anchor" id="aa5e47b500bb86a710c02a8c0b11a682e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* halide_default_get_library_symbol </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_load_library()</a> and <a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

</div>
</div>
<a class="anchor" id="a237a39b6dc5c4059539983984c3ef4f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#a9b395a78ed47c06139df7a8582d593c3">halide_get_symbol_t</a> halide_set_custom_get_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a9b395a78ed47c06139df7a8582d593c3">halide_get_symbol_t</a>&#160;</td>
          <td class="paramname"><em>user_get_symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_load_library()</a> and <a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

</div>
</div>
<a class="anchor" id="a201fccb476f83105b06389a7701f5bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#a0e6a2be492b550a90837409ab6fa30c4">halide_load_library_t</a> halide_set_custom_load_library </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a0e6a2be492b550a90837409ab6fa30c4">halide_load_library_t</a>&#160;</td>
          <td class="paramname"><em>user_load_library</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_load_library()</a> and <a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

</div>
</div>
<a class="anchor" id="ae6d93a904e3a104ff12c4760aad458ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#a22ff288a7d64c44a4fa6410a10efed40">halide_get_library_symbol_t</a> halide_set_custom_get_library_symbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a22ff288a7d64c44a4fa6410a10efed40">halide_get_library_symbol_t</a>&#160;</td>
          <td class="paramname"><em>user_get_library_symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls these functions to interact with the underlying system runtime functions. </p>
<p>To replace in AOT code on platforms that support weak linking, define these functions yourself, or use the <a class="el" href="_halide_runtime_8h.html#a201fccb476f83105b06389a7701f5bef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_load_library()</a> and <a class="el" href="_halide_runtime_8h.html#ae6d93a904e3a104ff12c4760aad458ef" title="Halide calls these functions to interact with the underlying system runtime functions. ">halide_set_custom_get_library_symbol()</a> functions. In JIT-compiled code, use JITSharedRuntime::set_default_handlers().</p>
<p>halide_load_library and halide_get_library_symbol are equivalent to dlopen and dlsym. halide_get_symbol(sym) is equivalent to dlsym(RTLD_DEFAULT, sym). </p>

</div>
</div>
<a class="anchor" id="a60d6415aa2c7d4e135527a83b30061b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> halide_debug_to_file </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>type_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when debug_to_file is used inside Halide code. </p>
<p>See Func::debug_to_file for how this is called</p>
<p>Cannot be replaced in JITted code at present. </p>

</div>
</div>
<a class="anchor" id="a83d172a9f341a56bc9c5124d2c61a5aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> halide_trace </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when Funcs are marked as trace_load, trace_store, or trace_realization. </p>
<p>See Func::set_custom_trace. The default implementation either prints events via halide_print, or if HL_TRACE_FILE is defined, dumps the trace to that file in a sequence of trace packets. The header for a trace packet is defined below. If the trace is going to be large, you may want to make the file a named pipe, and then read from that pipe into gzip.</p>
<p>halide_trace returns a unique ID which will be passed to future events that "belong" to the earlier event as the parent id. The ownership hierarchy looks like:</p>
<p>begin_pipeline +&ndash;begin_realization | +&ndash;produce | | +&ndash;load/store | | +&ndash;end_produce | +&ndash;consume | | +&ndash;load | | +&ndash;end_consume | +&ndash;end_realization +&ndash;end_pipeline</p>
<p>Threading means that ownership cannot be inferred from the ordering of events. There can be many active realizations of a given function, or many active productions for a single realization. Within a single production, the ordering of events is meaningful. </p>

</div>
</div>
<a class="anchor" id="a9983cd83d6ff3aae428080d20e2af680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> halide_default_trace </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__trace__event__t.html">halide_trace_event_t</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a963a4ee1ed5d4c89b29eadca3a2e0236"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#a218cc381e4551fc66f009a05cb0b8041">halide_trace_t</a> halide_set_custom_trace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a218cc381e4551fc66f009a05cb0b8041">halide_trace_t</a>&#160;</td>
          <td class="paramname"><em>trace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8761e708f878372e3201126e83d6f3b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_set_trace_file </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the file descriptor that <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> should write binary trace events to. </p>
<p>If called with 0 as the argument, <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> outputs trace information to stdout in a human-readable format. If never called, <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> checks the for existence of an environment variable called HL_TRACE_FILE and opens that file. If HL_TRACE_FILE is not defined, it outputs trace information to stdout in a human-readable format. </p>

</div>
</div>
<a class="anchor" id="aee99b65dcbc81d91a0f22507eb7f8017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_get_trace_file </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls this to retrieve the file descriptor to write binary trace events to. </p>
<p>The default implementation returns the value set by halide_set_trace_file. Implement it yourself if you wish to use a custom file descriptor per user_context. Return zero from your implementation to tell <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> to print human-readable trace information to stdout. </p>

</div>
</div>
<a class="anchor" id="a618bb97f5d713e1097835a24670948f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_shutdown_trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If tracing is writing to a file. </p>
<p>This call closes that file (flushing the trace). Returns zero on success. </p>

</div>
</div>
<a class="anchor" id="a5412b6569e456b0a85896d9afa986630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_device_release </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release all data associated with the current GPU backend, in particular all resources (memory, texture, context handles) allocated by <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>. </p>
<p>Must be called explicitly when using AOT compilation. </p>

</div>
</div>
<a class="anchor" id="a37bb9875eba947a4ef1f8e4ee19a7f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_copy_to_host </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy image data from device memory to host memory. </p>
<p>This must be called explicitly to copy back the results of a GPU-based filter. </p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01243">Halide::Runtime::Buffer&lt; T, D &gt;::copy_to_host()</a>.</p>

</div>
</div>
<a class="anchor" id="ae564c907ea0e5b5520e876ce28f29af9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_copy_to_device </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy image data from host memory to device memory. </p>
<p>This should not be called directly; <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> handles copying to the device automatically. If interface is NULL and the bug has a non-zero dev field, the device associated with the dev handle will be used. Otherwise if the dev field is 0 and interface is NULL, an error is returned. </p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01250">Halide::Runtime::Buffer&lt; T, D &gt;::copy_to_device()</a>.</p>

</div>
</div>
<a class="anchor" id="a13dfb9b20f566b9221cbb883fd622595"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_sync </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for current GPU operations to complete. </p>
<p>Calling this explicitly should rarely be necessary, except maybe for profiling. </p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01278">Halide::Runtime::Buffer&lt; T, D &gt;::device_sync()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f5dea3365145ef7bcda3df9c787d9bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_malloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate device memory to back a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a>. </p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01257">Halide::Runtime::Buffer&lt; T, D &gt;::device_malloc()</a>.</p>

</div>
</div>
<a class="anchor" id="ac643953e77f882726d175d8bd9250c13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free device memory. </p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01261">Halide::Runtime::Buffer&lt; T, D &gt;::device_free()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b25bae9a0c908a7a45bc68f1b5c76c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(weak)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a871d17a8b699de9b2ca520feb3db89e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ae64e96ae698ab344dec89bc8a172a243">halide_device_free_t</a> halide_get_device_free_fn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00545">545</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

</div>
</div>
<a class="anchor" id="af9f160afebe19fe9bdc28e4765804279"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_copy_to_host_legacy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Versions of the above functions that accept legacy <a class="el" href="structbuffer__t.html">buffer_t</a> structs. </p>

</div>
</div>
<a class="anchor" id="a7663c89d41be39b5d8c4225d3fc44eea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_copy_to_device_legacy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Versions of the above functions that accept legacy <a class="el" href="structbuffer__t.html">buffer_t</a> structs. </p>

</div>
</div>
<a class="anchor" id="a61d3627b25e08ac431688252c835177a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_sync_legacy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Versions of the above functions that accept legacy <a class="el" href="structbuffer__t.html">buffer_t</a> structs. </p>

</div>
</div>
<a class="anchor" id="a8d5a8bca9d4b3453fac9c1f07281a793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_malloc_legacy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Versions of the above functions that accept legacy <a class="el" href="structbuffer__t.html">buffer_t</a> structs. </p>

</div>
</div>
<a class="anchor" id="ab5f7d13d2925638256d75cbf4bceedeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_device_free_legacy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Versions of the above functions that accept legacy <a class="el" href="structbuffer__t.html">buffer_t</a> structs. </p>

</div>
</div>
<a class="anchor" id="a9906fca5a688c26e0465a1b3da84ccfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_set_gpu_device </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects which gpu device to use. </p>
<p>0 is usually the display device. If never called, <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> uses the environment variable HL_GPU_DEVICE. If that variable is unset, <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> uses the last device. Set this to -1 to use the last device. </p>

</div>
</div>
<a class="anchor" id="adc511579a9ad82da9c1c611f008dd454"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_get_gpu_device </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls this to get the desired halide gpu device setting. </p>
<p>Implement this yourself to use a different gpu device per user_context. The default implementation returns the value set by halide_set_gpu_device, or the environment variable HL_GPU_DEVICE. </p>

</div>
</div>
<a class="anchor" id="abf85692a77aec0b887f345d0d3ca6777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_memoization_cache_set_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the soft maximum amount of memory, in bytes, that the LRU cache will use to memoize Func results. </p>
<p>This is not a strict maximum in that concurrency and simultaneous use of memoized reults larger than the cache size can both cause it to temporariliy be larger than the size specified here. </p>

</div>
</div>
<a class="anchor" id="a0e828012fc956325101a835716f8ca22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_memoization_cache_lookup </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>cache_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>realized_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>tuple_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> **&#160;</td>
          <td class="paramname"><em>tuple_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, determine if the result is in the cache and return it if so. </p>
<p>(The internals of the cache key should be considered opaque by this function.) If this routine returns true, it is a cache miss. Otherwise, it will return false and the buffers passed in will be filled, via copying, with memoized data. The last argument is a list if <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> pointers which represents the outputs of the memoized Func. If the Func does not return a Tuple, there will only be one <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> in the list. The tuple_count parameters determines the length of the list.</p>
<p>The return values are: -1: Signals an error. 0: Success and cache hit. 1: Success and cache miss. </p>

</div>
</div>
<a class="anchor" id="a18887f3038f6749b0a3a682d1e352fbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_memoization_cache_store </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *&#160;</td>
          <td class="paramname"><em>cache_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>realized_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a>&#160;</td>
          <td class="paramname"><em>tuple_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> **&#160;</td>
          <td class="paramname"><em>tuple_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a cache key for a memoized result, currently constructed from the Func name and top-level Func name plus the arguments of the computation, store the result in the cache for futre access by halide_memoization_cache_lookup. </p>
<p>(The internals of the cache key should be considered opaque by this function.) Data is copied out from the inputs and inputs are unmodified. The last argument is a list if <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> pointers which represents the outputs of the memoized Func. If the Func does not return a Tuple, there will only be one <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> in the list. The tuple_count parameters determines the length of the list.</p>
<p>If there is a memory allocation failure, the store does not store the data into the cache. </p>

</div>
</div>
<a class="anchor" id="a714f9e341f1d71baf8abc77bc50e1db5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_memoization_cache_release </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>host</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If halide_memoization_cache_lookup succeeds, halide_memoization_cache_release must be called to signal the storage is no longer being used by the caller. </p>
<p>It will be passed the host pointer of one the buffers returned by halide_memoization_cache_lookup. That is halide_memoization_cache_release will be called multiple times for the case where halide_memoization_cache_lookup is handling multiple buffers. (This corresponds to memoizing a Tuple in <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>.) Note that the host pointer must be sufficient to get to all information the relase operation needs. The default <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> cache impleemntation accomplishes this by storing extra data before the start of the user modifiable host storage.</p>
<p>This call is like free and does not have a failure return. </p>

</div>
</div>
<a class="anchor" id="a30f9bdd5b6ac08b3fa785f3332cca996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_memoization_cache_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all memory and resources associated with the memoization cache. </p>
<p>Must be called at a time when no other threads are accessing the cache. </p>

</div>
</div>
<a class="anchor" id="a5643238925a57825f2c4b0e188a4639a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_create_temp_file </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>path_buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a unique file with a name of the form prefixXXXXXsuffix in an arbitrary (but writable) directory; this is typically $TMP or /tmp, but the specific location is not guaranteed. </p>
<p>(Note that the exact form of the file name may vary; in particular, the suffix may be ignored on non-Posix systems.) The file is created (but not opened), thus this can be called from different threads (or processes, e.g. when building with parallel make) without risking collision. Note that the caller is always responsible for deleting this file. Returns nonzero value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="a3ce1cfbe9784a6ea36d08e0a05e7b75a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_msan_annotate_memory_is_initialized </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotate that a given range of memory has been initialized; only used when Target::MSAN is enabled. </p>
<p>The default implementation uses the LLVM-provided AnnotateMemoryIsInitialized() function. </p>

</div>
</div>
<a class="anchor" id="a8a3ee381d774d6a7c9971c0d4cfb2675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_msan_annotate_buffer_is_initialized </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the data pointed to by the <a class="el" href="structbuffer__t.html">buffer_t</a> as initialized (but <em>not</em> the <a class="el" href="structbuffer__t.html">buffer_t</a> itself), using <a class="el" href="_halide_runtime_8h.html#a3ce1cfbe9784a6ea36d08e0a05e7b75a" title="Annotate that a given range of memory has been initialized; only used when Target::MSAN is enabled...">halide_msan_annotate_memory_is_initialized()</a> for marking. </p>
<p>The default implementation takes pains to only mark the active memory ranges (skipping padding), and sorting into ranges to always mark the smallest number of ranges, in monotonically increasing memory order.</p>
<p>Most client code should never need to replace the default implementation. </p>

</div>
</div>
<a class="anchor" id="a506f6e93f28aa3a0a9af8cdd8f9039ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_msan_annotate_buffer_is_initialized_as_destructor </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a56de7e95e571c442a05506a451318f00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_bounds_inference_call_failed </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extern_stage_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> calls the functions below on various error conditions. </p>
<p>The default implementations construct an error message, call halide_error, then return the matching error code above. On platforms that support weak linking, you can override these to catch the errors individually. A call into an extern stage for the purposes of bounds inference failed. Returns the error code given by the extern stage. </p>

</div>
</div>
<a class="anchor" id="a83ec7fcc618e1b0508a6f4f726a7bcae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_extern_stage_failed </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extern_stage_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A call to an extern stage failed. </p>
<p>Returned the error code given by the extern stage. </p>

</div>
</div>
<a class="anchor" id="aa5b03b398e934c740dd4905a02a9bb81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_explicit_bounds_too_small </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_required</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a73381e1cadf99212c8ef05c8e1bc64d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_bad_type </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a>&#160;</td>
          <td class="paramname"><em>code_given</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a>&#160;</td>
          <td class="paramname"><em>correct_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a>&#160;</td>
          <td class="paramname"><em>bits_given</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a>&#160;</td>
          <td class="paramname"><em>correct_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a>&#160;</td>
          <td class="paramname"><em>lanes_given</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a>&#160;</td>
          <td class="paramname"><em>correct_lanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="aa54c6e910c7b7feb2a51c7a0a549a9bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_access_out_of_bounds </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_touched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_touched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a33fa368bf1d21414be0ab0a00e8ca7f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_buffer_allocation_too_large </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>allocation_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a5c0d5408cb06758ec15b51de93d6772c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_buffer_extents_negative </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a80d5f3810ffacdc2950743193411c6d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_buffer_extents_too_large </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>actual_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a5fcbb3316d10d47471e9d74ba74d8e6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_constraints_make_required_region_smaller </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constrained_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constrained_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>required_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>required_extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a41a91525ca15c31958738cf7ec44e410"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_constraint_violated </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>constrained_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constrained_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a9dc44166713b0e8fbef22542e4e0fe95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_small_i64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>min_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a93fce86c8f8d93969bde686d502b4340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_small_u64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>min_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a8d06e8302739a4a26bfa2b0113fc376d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_small_f64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a8f31f3a6a09ab3b5b798cecbd3f5e045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_large_i64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="aca082a34f38e8657551128db3969f8af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_large_u64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a7bc42c90e0703c23c6f141fb476cfa04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_param_too_large_f64 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a64356948f9a36e16664585fff6f0949d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_out_of_memory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="aab974b4b7963cad8613c3825a5689086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_buffer_argument_is_null </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a6d12212093b19b3c2ea2b83df15302e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_debug_to_file_failed </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="af4c72825991b91cbc68d0ee35b5dd6eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_unaligned_host_ptr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="afb8c8355e8fe70169455e0e178a8ee13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_failed_to_upgrade_buffer_t </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="aeecf7fc5cc972ef64bafd956dd2a9d13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_failed_to_downgrade_buffer_t </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a184d4a3242a700a5bfa984202d150058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_bad_fold </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loop_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a8bc79be62fbe8dec0a9fe81880809d09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_fold_factor_too_small </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fold_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loop_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>required_extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a6f2a64a173a5f8f76b77f495782bf3d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_requirement_failed </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="aa4b32bec5b0969e6c79bccb4f92fd295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_error_specialize_fail </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Various other error conditions. </p>
<p>See the enum above for a description of each. </p>

</div>
</div>
<a class="anchor" id="a25a30d570bab6ffb46b8de976d536d12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_can_use_target_features </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>features</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called internally by <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> in some situations to determine if the current execution environment can support the given set of halide_target_feature_t flags. </p>
<p>The implementation must do the following:</p>
<p>&ndash; If there are flags set in features that the function knows <em>cannot</em> be supported, return 0. &ndash; Otherwise, return 1. &ndash; Note that any flags set in features that the function doesn't know how to test should be ignored; this implies that a return value of 1 means "not known to be bad" rather than "known to be good".</p>
<p>In other words: a return value of 0 means "It is not safe to use code compiled with these features", while a return value of 1 means "It is not obviously unsafe to use code compiled with these features".</p>
<p>The default implementation simply calls halide_default_can_use_target_features. </p>

</div>
</div>
<a class="anchor" id="a85d894ba76723de46670273e21186516"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#a10019efe4ef71dc796a049f7c6afd2b9">halide_can_use_target_features_t</a> halide_set_custom_can_use_target_features </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a10019efe4ef71dc796a049f7c6afd2b9">halide_can_use_target_features_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called internally by <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> in some situations to determine if the current execution environment can support the given set of halide_target_feature_t flags. </p>
<p>The implementation must do the following:</p>
<p>&ndash; If there are flags set in features that the function knows <em>cannot</em> be supported, return 0. &ndash; Otherwise, return 1. &ndash; Note that any flags set in features that the function doesn't know how to test should be ignored; this implies that a return value of 1 means "not known to be bad" rather than "known to be good".</p>
<p>In other words: a return value of 0 means "It is not safe to use code compiled with these features", while a return value of 1 means "It is not obviously unsafe to use code compiled with these features".</p>
<p>The default implementation simply calls halide_default_can_use_target_features. </p>

</div>
</div>
<a class="anchor" id="a171b181824451b5475461da3874c801e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_default_can_use_target_features </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>features</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the default implementation of halide_can_use_target_features; it is provided for convenience of user code that may wish to extend halide_can_use_target_features but continue providing existing support, e.g. </p>
<p>int <a class="el" href="_halide_runtime_8h.html#a25a30d570bab6ffb46b8de976d536d12" title="This function is called internally by Halide in some situations to determine if the current execution...">halide_can_use_target_features(uint64_t features)</a> { if (features &amp; halide_target_somefeature) { if (!can_use_somefeature()) { return 0; } } return halide_default_can_use_target_features(features); } </p>

</div>
</div>
<a class="anchor" id="a9367e850a3dd3d7c16d0325046c0655a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_upgrade_buffer_t </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>old_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>new_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies host pointer, mins, extents, strides, and device state from an old-style <a class="el" href="structbuffer__t.html">buffer_t</a> into a new-style <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a>. </p>
<p>The dimensions and type fields of the new <a class="el" href="structbuffer__t.html">buffer_t</a> should already be set. Returns an error code if the upgrade could not be performed. </p>

</div>
</div>
<a class="anchor" id="adfa249de70377b90d975e3e0e19d7b24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_downgrade_buffer_t </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>new_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>old_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the host pointer, mins, extents, strides, and device state from a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> to a <a class="el" href="structbuffer__t.html">buffer_t</a>. </p>
<p>Also sets elem_size. Useful for backporting the results of bounds inference. </p>

</div>
</div>
<a class="anchor" id="ae8e9d4f7f68f0de4a649d120f4c58cdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int halide_downgrade_buffer_t_device_fields </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td>
          <td class="paramname"><em>new_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td>
          <td class="paramname"><em>old_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the dirty flags and device allocation state from a new <a class="el" href="structbuffer__t.html">buffer_t</a> back to a legacy <a class="el" href="structbuffer__t.html">buffer_t</a>. </p>

</div>
</div>
<a class="anchor" id="a3cd65e97950c095f215ff77de9664f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structhalide__profiler__state.html">halide_profiler_state</a>* halide_profiler_get_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the global profiler state for programmatic inspection. </p>
<p>Lock it before using to pause the profiler. </p>

</div>
</div>
<a class="anchor" id="a5ab3ca1106a4e47109c1b8bb82f40ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structhalide__profiler__pipeline__stats.html">halide_profiler_pipeline_stats</a>* halide_profiler_get_pipeline_state </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pipeline_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the pipeline state associated with pipeline_name. </p>
<p>This function grabs the global profiler state's lock on entry. </p>

</div>
</div>
<a class="anchor" id="a046ccf558100c9a2b0664074157c6563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_profiler_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset all profiler state. </p>
<p>WARNING: Do NOT call this method while any halide pipeline is running; halide_profiler_memory_allocate/free and halide_profiler_stack_peak_update update the profiler pipeline's state without grabbing the global profiler state's lock. </p>

</div>
</div>
<a class="anchor" id="a98690684642752376f858a9c6f1ccd29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halide_profiler_report </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out timing statistics for everything run since the last reset. </p>
<p>Also happens at process exit. </p>

</div>
</div>
<a class="anchor" id="af23e3224639e2458c55cebf2a6dccfaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float halide_float16_bits_to_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bits representing a half precision floating point number and return the float that represents the same value. </p>

</div>
</div>
<a class="anchor" id="a2494e69e2956ca6af09befd1d5bbf142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double halide_float16_bits_to_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bits representing a half precision floating point number and return the double that represents the same value. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a709648b930f033620ec2192cb84c3b62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a>* buf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_runtime_8h_source.html#l00544">544</a> of file <a class="el" href="_halide_runtime_8h_source.html">HalideRuntime.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01189">Halide::Runtime::Buffer&lt; T, D &gt;::add_dimension()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01220">Halide::Runtime::Buffer&lt; T, D &gt;::add_dimension_with_stride()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00642">Halide::Runtime::Buffer&lt; T, D &gt;::allocate()</a>, <a class="el" href="_buffer_8h_source.html#l00126">Halide::Buffer&lt;&gt;::Buffer()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00690">Halide::Runtime::Buffer&lt; T, D &gt;::Buffer()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01250">Halide::Runtime::Buffer&lt; T, D &gt;::copy_to_device()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01243">Halide::Runtime::Buffer&lt; T, D &gt;::copy_to_host()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01032">Halide::Runtime::Buffer&lt; T, D &gt;::crop()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01430">Halide::Runtime::Buffer&lt; T, D &gt;::data()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01231">Halide::Runtime::Buffer&lt; T, D &gt;::device_dirty()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01261">Halide::Runtime::Buffer&lt; T, D &gt;::device_free()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01257">Halide::Runtime::Buffer&lt; T, D &gt;::device_malloc()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01278">Halide::Runtime::Buffer&lt; T, D &gt;::device_sync()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01282">Halide::Runtime::Buffer&lt; T, D &gt;::has_device_allocation()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01235">Halide::Runtime::Buffer&lt; T, D &gt;::host_dirty()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01331">Halide::Runtime::Buffer&lt; T, D &gt;::make_scalar()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00885">Halide::Runtime::Buffer&lt; T, D &gt;::operator halide_buffer_t *()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00566">Halide::Runtime::Buffer&lt; T, D &gt;::operator=()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00874">Halide::Runtime::Buffer&lt; T, D &gt;::raw_buffer()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01239">Halide::Runtime::Buffer&lt; T, D &gt;::set_device_dirty()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01227">Halide::Runtime::Buffer&lt; T, D &gt;::set_host_dirty()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01096">Halide::Runtime::Buffer&lt; T, D &gt;::set_min()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01140">Halide::Runtime::Buffer&lt; T, D &gt;::slice()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01073">Halide::Runtime::Buffer&lt; T, D &gt;::translate()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01127">Halide::Runtime::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_bf9f26469d00835ba20ff8d80ee5a804.html">runtime</a></li><li class="navelem"><a class="el" href="_halide_runtime_8h.html">HalideRuntime.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
