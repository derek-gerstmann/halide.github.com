<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: Halide::Target Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('struct_halide_1_1_target.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_halide_1_1_target-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Target Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A struct representing a target machine and os to generate code for.  
 <a href="struct_halide_1_1_target.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_target_8h_source.html">Target.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af2b0caf9e5badd6a8ebe22493752df20"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">OS</a> { <br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20a22c6a2fea606af61fa20b1ad6548ff29">OSUnknown</a> = 0, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20af58b4735f0d8e76502ef70fe11d548d4">Linux</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20a33d246944800a2b478899132d76a95b2">Windows</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20acef0ce22d32cc53d0f72df159f62b691">OSX</a>, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20a5c630f5107a5a01870143d6dc042ea8c">Android</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20aae1a309042fed9d4369e831047a55447">IOS</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20affed0e31d5bf7caedc76111c34768987">QuRT</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20a9e33a7f637d78aff56173e2a4fe5dea2">NoOS</a>
<br/>
 }</td></tr>
<tr class="memdesc:af2b0caf9e5badd6a8ebe22493752df20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operating system used by the target.  <a href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">More...</a><br/></td></tr>
<tr class="separator:af2b0caf9e5badd6a8ebe22493752df20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17585cfd5ec92952fd361117d89d4b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Arch</a> { <br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1ae6d33003db3020c4c578c645239f2973">ArchUnknown</a> = 0, 
<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1aba7faedbdb35e2ef2927e248c687a391">X86</a>, 
<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1a1c5f188b9b8eb5ffd951917bbbdd85f2">ARM</a>, 
<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1a93b7e567e560c4e8275e8f1bab214d85">MIPS</a>, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1a25390aa4e88778d47cddac690dbd23ea">Hexagon</a>, 
<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1a1112c6ec7ad8f531deec9461de99f1d2">POWERPC</a>
<br/>
 }</td></tr>
<tr class="memdesc:af17585cfd5ec92952fd361117d89d4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The architecture used by the target.  <a href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">More...</a><br/></td></tr>
<tr class="separator:af17585cfd5ec92952fd361117d89d4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9398276edd5784185e1a08f8a4dfc43f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> { <br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fac04af3ed2dc70791a8ba8f793a746b30">JIT</a> = halide_target_feature_jit, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf3cc1f2941a6b4df016ac08e68b9c660">Debug</a> = halide_target_feature_debug, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa1fc53f322ecd95ae65274a9f16c71ac2">NoAsserts</a> = halide_target_feature_no_asserts, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa6f7593c40bf078bf7906ea1c391bcd80">NoBoundsQuery</a> = halide_target_feature_no_bounds_query, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf6ada84d24838f818391b465b9a94165">SSE41</a> = halide_target_feature_sse41, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa620c10914ea92a26c16878ab73933b2b">AVX</a> = halide_target_feature_avx, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fad7b64a080d84e2145fd219e9f7a33547">AVX2</a> = halide_target_feature_avx2, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa9764990d6a6294a8a23f8fb6598c2c88">FMA</a> = halide_target_feature_fma, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa6ba1375f5f5982d91779173b71542e5f">FMA4</a> = halide_target_feature_fma4, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fafc9c513f157e362fa6851a66e5d2aa90">F16C</a> = halide_target_feature_f16c, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf37c16007f6547612713259e648cc41e">ARMv7s</a> = halide_target_feature_armv7s, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa77c151e388125519528caf75193145ee">NoNEON</a> = halide_target_feature_no_neon, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa519b97837177a3c627e8143ad5721100">VSX</a> = halide_target_feature_vsx, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf77d9e657019773706af29b2389b75b7">POWER_ARCH_2_07</a> = halide_target_feature_power_arch_2_07, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fabfd3f02d7bd5f8e2d251a62f465ebcfb">CUDA</a> = halide_target_feature_cuda, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faae6f2116a68aa9477888010a605ec0a5">CUDACapability30</a> = halide_target_feature_cuda_capability30, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa770a75467c600c8ce9a5efa476776742">CUDACapability32</a> = halide_target_feature_cuda_capability32, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa15c6f4c8ec0241c9f34f303670c18af3">CUDACapability35</a> = halide_target_feature_cuda_capability35, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa027631ce082530506684842b44123b8a">CUDACapability50</a> = halide_target_feature_cuda_capability50, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa4698e1c27e0da8a649de1a3769677a90">CUDACapability61</a> = halide_target_feature_cuda_capability61, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa84c6211e4fb941603f6104e98427d7e5">OpenCL</a> = halide_target_feature_opencl, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faa371c9fa5610dc3a9efbb3fde547a719">CLDoubles</a> = halide_target_feature_cl_doubles, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa491aa42775c6c9d6f35f784e86b09abc">OpenGL</a> = halide_target_feature_opengl, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa17e80def356dcd03337ef044ccee459a">OpenGLCompute</a> = halide_target_feature_openglcompute, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fab7dbd399d2a833d37bd52451f99c50c1">UserContext</a> = halide_target_feature_user_context, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf1da45381c688687c95e97987fcc67cb">Matlab</a> = halide_target_feature_matlab, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faec9457be1a9efa835825706a62551cd7">Profile</a> = halide_target_feature_profile, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa90bf2d575c86cf9ca5a2302afbfb9f6b">NoRuntime</a> = halide_target_feature_no_runtime, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa6e7f7184a2b03865bf82159648bd5993">Metal</a> = halide_target_feature_metal, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fac52782fca7077bb12d52bba0b328be6a">MinGW</a> = halide_target_feature_mingw, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fac8a1a9505f550b3ba2f5f75f05b90eeb">CPlusPlusMangling</a> = halide_target_feature_c_plus_plus_mangling, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faeb06f21cee3c57b4dc3dcaa54b9704aa">LargeBuffers</a> = halide_target_feature_large_buffers, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa68e589d244cb5ff06b0fd0813423f194">HVX_64</a> = halide_target_feature_hvx_64, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fabdaeb92fc334091a76a9344db17c4ae5">HVX_128</a> = halide_target_feature_hvx_128, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa7d07df9ddc9273982f55d7af7aff670e">HVX_v62</a> = halide_target_feature_hvx_v62, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa41b3499e22e1a6290a29cdca716cb309">HVX_shared_object</a> = halide_target_feature_hvx_use_shared_object, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faec43c9ff5ae1b4b7ccee8798575b62b4">FuzzFloatStores</a> = halide_target_feature_fuzz_float_stores, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa69af866bb508872e3f46e200db714997">SoftFloatABI</a> = halide_target_feature_soft_float_abi, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa117ad175ca197efc42b4abdb2628f4a9">MSAN</a> = halide_target_feature_msan, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa59e40bba2ff121dd95ed2420eb89e17b">AVX512</a> = halide_target_feature_avx512, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa127077fe0f11b9909db6b366170d7dd4">AVX512_KNL</a> = halide_target_feature_avx512_knl, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa7b522bc2d0021790ba47cb302bc4ca6f">AVX512_Skylake</a> = halide_target_feature_avx512_skylake, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa37434c314da6b640c8ac37e1b378225e">AVX512_Cannonlake</a> = halide_target_feature_avx512_cannonlake, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fafca30f177d1e4bdac6551c43119d7893">TraceLoads</a> = halide_target_feature_trace_loads, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fad9b234dbac225381e9e9ea50ed83c75d">TraceStores</a> = halide_target_feature_trace_stores, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa2bf7608dc0fbb54137134c1bcf91ffd8">TraceRealizations</a> = halide_target_feature_trace_realizations, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa17b9cbfef8d1e84e32c8aaa7b2936dbc">FeatureEnd</a> = halide_target_feature_end
<br/>
 }</td></tr>
<tr class="memdesc:a9398276edd5784185e1a08f8a4dfc43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional features a target can have.  <a href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">More...</a><br/></td></tr>
<tr class="separator:a9398276edd5784185e1a08f8a4dfc43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb11109583253fe6e358bba73d3e4a86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aeb11109583253fe6e358bba73d3e4a86">Target</a> ()</td></tr>
<tr class="separator:aeb11109583253fe6e358bba73d3e4a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849870678f8ce67d10f84a0097b9eb09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a849870678f8ce67d10f84a0097b9eb09">Target</a> (<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">OS</a> o, <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Arch</a> a, int b, std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; initial_features=std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;())</td></tr>
<tr class="separator:a849870678f8ce67d10f84a0097b9eb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab667943ebf46b2da858370e44eae124d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ab667943ebf46b2da858370e44eae124d">set_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f, bool value=true)</td></tr>
<tr class="separator:ab667943ebf46b2da858370e44eae124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dddb1542193fca806cd9f0d9079ba32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a6dddb1542193fca806cd9f0d9079ba32">set_features</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; features_to_set, bool value=true)</td></tr>
<tr class="separator:a6dddb1542193fca806cd9f0d9079ba32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbcbe93a4d5ee7f9f93c6b3d7914bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#acbbcbe93a4d5ee7f9f93c6b3d7914bf3">has_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f) const </td></tr>
<tr class="separator:acbbcbe93a4d5ee7f9f93c6b3d7914bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3d3b016c13819515090e9a3a9e673f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a7a3d3b016c13819515090e9a3a9e673f">features_any_of</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; test_features) const </td></tr>
<tr class="separator:a7a3d3b016c13819515090e9a3a9e673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1f002f2b4899039558036e0a4276d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a6b1f002f2b4899039558036e0a4276d9">features_all_of</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; test_features) const </td></tr>
<tr class="separator:a6b1f002f2b4899039558036e0a4276d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc1372f492ae82156f56792eccc6a64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aafc1372f492ae82156f56792eccc6a64">with_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f) const </td></tr>
<tr class="memdesc:aafc1372f492ae82156f56792eccc6a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the target with the given feature set.  <a href="#aafc1372f492ae82156f56792eccc6a64">More...</a><br/></td></tr>
<tr class="separator:aafc1372f492ae82156f56792eccc6a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52878468db5e366d04748ed6fc64cf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ab52878468db5e366d04748ed6fc64cf5">without_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f) const </td></tr>
<tr class="memdesc:ab52878468db5e366d04748ed6fc64cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the target with the given feature cleared.  <a href="#ab52878468db5e366d04748ed6fc64cf5">More...</a><br/></td></tr>
<tr class="separator:ab52878468db5e366d04748ed6fc64cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653f58c7d0efbd7dac22cf239576a660"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a653f58c7d0efbd7dac22cf239576a660">has_gpu_feature</a> () const </td></tr>
<tr class="memdesc:a653f58c7d0efbd7dac22cf239576a660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a fully feature GPU compute runtime enabled? I.e.  <a href="#a653f58c7d0efbd7dac22cf239576a660">More...</a><br/></td></tr>
<tr class="separator:a653f58c7d0efbd7dac22cf239576a660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e54d89ba0566f57268363b967e1133c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a0e54d89ba0566f57268363b967e1133c">supports_type</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t) const </td></tr>
<tr class="memdesc:a0e54d89ba0566f57268363b967e1133c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this target allow using a certain type.  <a href="#a0e54d89ba0566f57268363b967e1133c">More...</a><br/></td></tr>
<tr class="separator:a0e54d89ba0566f57268363b967e1133c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0087637eae109668d625d5875e11e26c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a0087637eae109668d625d5875e11e26c">supports_device_api</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> api) const </td></tr>
<tr class="memdesc:a0087637eae109668d625d5875e11e26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a particular device API can be used with this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a0087637eae109668d625d5875e11e26c">More...</a><br/></td></tr>
<tr class="separator:a0087637eae109668d625d5875e11e26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052486b9b96e649b9311bcc00e0a9405"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a052486b9b96e649b9311bcc00e0a9405">operator==</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;other) const </td></tr>
<tr class="separator:a052486b9b96e649b9311bcc00e0a9405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d02d1fc5b8b3a38ba48316519b389c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a2d02d1fc5b8b3a38ba48316519b389c0">operator!=</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;other) const </td></tr>
<tr class="separator:a2d02d1fc5b8b3a38ba48316519b389c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902e58d463f8babb79f6263709d06f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a902e58d463f8babb79f6263709d06f01">to_string</a> () const </td></tr>
<tr class="memdesc:a902e58d463f8babb79f6263709d06f01"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_convert.html">Convert</a> the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> into a string form that can be reconstituted by merge_string(), which will always be of the form.  <a href="#a902e58d463f8babb79f6263709d06f01">More...</a><br/></td></tr>
<tr class="separator:a902e58d463f8babb79f6263709d06f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4855075b6ce0bb90bc981787c311a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a8d4855075b6ce0bb90bc981787c311a3">natural_vector_size</a> (<a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> t) const </td></tr>
<tr class="memdesc:a8d4855075b6ce0bb90bc981787c311a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a8d4855075b6ce0bb90bc981787c311a3">More...</a><br/></td></tr>
<tr class="separator:a8d4855075b6ce0bb90bc981787c311a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef57e03c4031aa9105ab037e074cad4"><td class="memTemplParams" colspan="2">template&lt;typename data_t &gt; </td></tr>
<tr class="memitem:a0ef57e03c4031aa9105ab037e074cad4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a0ef57e03c4031aa9105ab037e074cad4">natural_vector_size</a> () const </td></tr>
<tr class="memdesc:a0ef57e03c4031aa9105ab037e074cad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a0ef57e03c4031aa9105ab037e074cad4">More...</a><br/></td></tr>
<tr class="separator:a0ef57e03c4031aa9105ab037e074cad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987059e686d9665d6c63441a21e0ffe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a987059e686d9665d6c63441a21e0ffe2">maximum_buffer_size</a> () const </td></tr>
<tr class="memdesc:a987059e686d9665d6c63441a21e0ffe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum buffer size in bytes supported on this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a987059e686d9665d6c63441a21e0ffe2">More...</a><br/></td></tr>
<tr class="separator:a987059e686d9665d6c63441a21e0ffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104a7543417083771de716958e575e5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a104a7543417083771de716958e575e5b">supported</a> () const </td></tr>
<tr class="memdesc:a104a7543417083771de716958e575e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was libHalide compiled with support for this target?  <a href="#a104a7543417083771de716958e575e5b">More...</a><br/></td></tr>
<tr class="separator:a104a7543417083771de716958e575e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a93e30e33412ec965a87383aed8e9e248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a93e30e33412ec965a87383aed8e9e248">Target</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a93e30e33412ec965a87383aed8e9e248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string of the form used in HL_TARGET (e.g.  <a href="#a93e30e33412ec965a87383aed8e9e248">More...</a><br/></td></tr>
<tr class="separator:a93e30e33412ec965a87383aed8e9e248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae325c67b9fd42cfe0197dac10ca354d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ae325c67b9fd42cfe0197dac10ca354d8">Target</a> (const char *s)</td></tr>
<tr class="memdesc:ae325c67b9fd42cfe0197dac10ca354d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string of the form used in HL_TARGET (e.g.  <a href="#ae325c67b9fd42cfe0197dac10ca354d8">More...</a><br/></td></tr>
<tr class="separator:ae325c67b9fd42cfe0197dac10ca354d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab4c374828bc47e5ada5aded0b1c3e9e1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ab4c374828bc47e5ada5aded0b1c3e9e1">validate_target_string</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ab4c374828bc47e5ada5aded0b1c3e9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a target string is valid.  <a href="#ab4c374828bc47e5ada5aded0b1c3e9e1">More...</a><br/></td></tr>
<tr class="separator:ab4c374828bc47e5ada5aded0b1c3e9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa2d0cedb02dc84eb7a9675df89f1d3ec"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">Halide::Target::OS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aa2d0cedb02dc84eb7a9675df89f1d3ec">os</a></td></tr>
<tr class="separator:aa2d0cedb02dc84eb7a9675df89f1d3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d1006f89ed385a62cf9e2e5a4fe5a9"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Halide::Target::Arch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a53d1006f89ed385a62cf9e2e5a4fe5a9">arch</a></td></tr>
<tr class="separator:a53d1006f89ed385a62cf9e2e5a4fe5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72366c6d01ef023ff3b2801017779e32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a72366c6d01ef023ff3b2801017779e32">bits</a></td></tr>
<tr class="memdesc:a72366c6d01ef023ff3b2801017779e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit-width of the target machine.  <a href="#a72366c6d01ef023ff3b2801017779e32">More...</a><br/></td></tr>
<tr class="separator:a72366c6d01ef023ff3b2801017779e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A struct representing a target machine and os to generate code for. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#_a7">tutorial/lesson_11_cross_compilation.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#_a7">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_target_8h_source.html#l00021">21</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">Halide::Target::OS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operating system used by the target. </p>
<p>Determines which system calls to generate. Corresponds to os_name_map in Target.cpp. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a22c6a2fea606af61fa20b1ad6548ff29"></a>OSUnknown</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20af58b4735f0d8e76502ef70fe11d548d4"></a>Linux</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a33d246944800a2b478899132d76a95b2"></a>Windows</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20acef0ce22d32cc53d0f72df159f62b691"></a>OSX</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a5c630f5107a5a01870143d6dc042ea8c"></a>Android</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20aae1a309042fed9d4369e831047a55447"></a>IOS</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20affed0e31d5bf7caedc76111c34768987"></a>QuRT</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a9e33a7f637d78aff56173e2a4fe5dea2"></a>NoOS</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00025">25</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Halide::Target::Arch</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The architecture used by the target. </p>
<p>Determines the instruction set to use. Corresponds to arch_name_map in Target.cpp. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1ae6d33003db3020c4c578c645239f2973"></a>ArchUnknown</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1aba7faedbdb35e2ef2927e248c687a391"></a>X86</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a1c5f188b9b8eb5ffd951917bbbdd85f2"></a>ARM</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a93b7e567e560c4e8275e8f1bab214d85"></a>MIPS</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a25390aa4e88778d47cddac690dbd23ea"></a>Hexagon</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a1112c6ec7ad8f531deec9461de99f1d2"></a>POWERPC</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00030">30</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Halide::Target::Feature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional features a target can have. </p>
<p>Corresponds to feature_name_map in Target.cpp. See definitions in <a class="el" href="_halide_runtime_8h.html" title="Set a custom malloc and free for halide to use. ">HalideRuntime.h</a> for full information. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fac04af3ed2dc70791a8ba8f793a746b30"></a>JIT</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf3cc1f2941a6b4df016ac08e68b9c660"></a>Debug</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa1fc53f322ecd95ae65274a9f16c71ac2"></a>NoAsserts</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa6f7593c40bf078bf7906ea1c391bcd80"></a>NoBoundsQuery</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf6ada84d24838f818391b465b9a94165"></a>SSE41</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa620c10914ea92a26c16878ab73933b2b"></a>AVX</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fad7b64a080d84e2145fd219e9f7a33547"></a>AVX2</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa9764990d6a6294a8a23f8fb6598c2c88"></a>FMA</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa6ba1375f5f5982d91779173b71542e5f"></a>FMA4</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fafc9c513f157e362fa6851a66e5d2aa90"></a>F16C</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf37c16007f6547612713259e648cc41e"></a>ARMv7s</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa77c151e388125519528caf75193145ee"></a>NoNEON</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa519b97837177a3c627e8143ad5721100"></a>VSX</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf77d9e657019773706af29b2389b75b7"></a>POWER_ARCH_2_07</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fabfd3f02d7bd5f8e2d251a62f465ebcfb"></a>CUDA</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faae6f2116a68aa9477888010a605ec0a5"></a>CUDACapability30</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa770a75467c600c8ce9a5efa476776742"></a>CUDACapability32</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa15c6f4c8ec0241c9f34f303670c18af3"></a>CUDACapability35</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa027631ce082530506684842b44123b8a"></a>CUDACapability50</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa4698e1c27e0da8a649de1a3769677a90"></a>CUDACapability61</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa84c6211e4fb941603f6104e98427d7e5"></a>OpenCL</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faa371c9fa5610dc3a9efbb3fde547a719"></a>CLDoubles</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa491aa42775c6c9d6f35f784e86b09abc"></a>OpenGL</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa17e80def356dcd03337ef044ccee459a"></a>OpenGLCompute</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fab7dbd399d2a833d37bd52451f99c50c1"></a>UserContext</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf1da45381c688687c95e97987fcc67cb"></a>Matlab</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faec9457be1a9efa835825706a62551cd7"></a>Profile</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa90bf2d575c86cf9ca5a2302afbfb9f6b"></a>NoRuntime</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa6e7f7184a2b03865bf82159648bd5993"></a>Metal</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fac52782fca7077bb12d52bba0b328be6a"></a>MinGW</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fac8a1a9505f550b3ba2f5f75f05b90eeb"></a>CPlusPlusMangling</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faeb06f21cee3c57b4dc3dcaa54b9704aa"></a>LargeBuffers</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa68e589d244cb5ff06b0fd0813423f194"></a>HVX_64</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fabdaeb92fc334091a76a9344db17c4ae5"></a>HVX_128</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa7d07df9ddc9273982f55d7af7aff670e"></a>HVX_v62</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa41b3499e22e1a6290a29cdca716cb309"></a>HVX_shared_object</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faec43c9ff5ae1b4b7ccee8798575b62b4"></a>FuzzFloatStores</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa69af866bb508872e3f46e200db714997"></a>SoftFloatABI</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa117ad175ca197efc42b4abdb2628f4a9"></a>MSAN</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa59e40bba2ff121dd95ed2420eb89e17b"></a>AVX512</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa127077fe0f11b9909db6b366170d7dd4"></a>AVX512_KNL</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa7b522bc2d0021790ba47cb302bc4ca6f"></a>AVX512_Skylake</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa37434c314da6b640c8ac37e1b378225e"></a>AVX512_Cannonlake</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fafca30f177d1e4bdac6551c43119d7893"></a>TraceLoads</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fad9b234dbac225381e9e9ea50ed83c75d"></a>TraceStores</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa2bf7608dc0fbb54137134c1bcf91ffd8"></a>TraceRealizations</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa17b9cbfef8d1e84e32c8aaa7b2936dbc"></a>FeatureEnd</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00039">39</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeb11109583253fe6e358bba73d3e4a86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Target::Target </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00088">88</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a class="anchor" id="a849870678f8ce67d10f84a0097b9eb09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Target::Target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">OS</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Arch</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;&#160;</td>
          <td class="paramname"><em>initial_features</em> = <code>std::vector&lt;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00089">89</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00114">set_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="a93e30e33412ec965a87383aed8e9e248"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Target::Target </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string of the form used in HL_TARGET (e.g. </p>
<p>"x86-64-avx"), construct the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> it specifies. Note that this always starts with the result of <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e" title="Return the target corresponding to the host machine. ">get_host_target()</a>, replacing only the parts found in the target string, so if you omit (say) an OS specification, the host OS will be used instead. An empty string is exactly equivalent to <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e" title="Return the target corresponding to the host machine. ">get_host_target()</a>.</p>
<p>Invalid target strings will fail with a user_error. </p>

</div>
</div>
<a class="anchor" id="ae325c67b9fd42cfe0197dac10ca354d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Target::Target </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string of the form used in HL_TARGET (e.g. </p>
<p>"x86-64-avx"), construct the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> it specifies. Note that this always starts with the result of <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e" title="Return the target corresponding to the host machine. ">get_host_target()</a>, replacing only the parts found in the target string, so if you omit (say) an OS specification, the host OS will be used instead. An empty string is exactly equivalent to <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e" title="Return the target corresponding to the host machine. ">get_host_target()</a>.</p>
<p>Invalid target strings will fail with a user_error. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab4c374828bc47e5ada5aded0b1c3e9e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Target::validate_target_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a target string is valid. </p>

</div>
</div>
<a class="anchor" id="ab667943ebf46b2da858370e44eae124d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Target::set_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a11">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_target_8h_source.html#l00114">114</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00086">FeatureEnd</a>, and <a class="el" href="_error_8h_source.html#l00141">user_assert</a>.</p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00120">set_features()</a>, <a class="el" href="_target_8h_source.html#l00089">Target()</a>, <a class="el" href="_target_8h_source.html#l00154">with_feature()</a>, and <a class="el" href="_target_8h_source.html#l00164">without_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="a6dddb1542193fca806cd9f0d9079ba32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Target::set_features </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;&#160;</td>
          <td class="paramname"><em>features_to_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a13">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_target_8h_source.html#l00120">120</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00114">set_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="acbbcbe93a4d5ee7f9f93c6b3d7914bf3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::has_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00126">126</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00086">FeatureEnd</a>, and <a class="el" href="_error_8h_source.html#l00141">user_assert</a>.</p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00141">features_all_of()</a>, <a class="el" href="_target_8h_source.html#l00132">features_any_of()</a>, <a class="el" href="_target_8h_source.html#l00176">has_gpu_feature()</a>, <a class="el" href="_target_8h_source.html#l00286">maximum_buffer_size()</a>, <a class="el" href="_target_8h_source.html#l00226">natural_vector_size()</a>, <a class="el" href="_code_gen___a_r_m_8h_source.html#l00073">Halide::Internal::CodeGen_ARM::neon_intrinsics_disabled()</a>, <a class="el" href="_func_8h_source.html#l02054">Halide::Internal::schedule_scalar()</a>, and <a class="el" href="_target_8h_source.html#l00184">supports_type()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a3d3b016c13819515090e9a3a9e673f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::features_any_of </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;&#160;</td>
          <td class="paramname"><em>test_features</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00132">132</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00126">has_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b1f002f2b4899039558036e0a4276d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::features_all_of </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;&#160;</td>
          <td class="paramname"><em>test_features</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00141">141</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00126">has_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="aafc1372f492ae82156f56792eccc6a64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::Target::with_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the target with the given feature set. </p>
<p>This is convenient when enabling certain features (e.g. NoBoundsQuery) in an initialization list, where the target to be mutated may be a const reference. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00154">154</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00114">set_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="ab52878468db5e366d04748ed6fc64cf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::Target::without_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the target with the given feature cleared. </p>
<p>This is convenient when disabling certain features (e.g. NoBoundsQuery) in an initialization list, where the target to be mutated may be a const reference. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00164">164</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00114">set_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="a653f58c7d0efbd7dac22cf239576a660"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::has_gpu_feature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a fully feature GPU compute runtime enabled? I.e. </p>
<p>is <a class="el" href="class_halide_1_1_func.html#a29639a0f784916d50387a019389dd5f5" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">Func::gpu_tile</a> and similar going to work? Currently includes CUDA, OpenCL, and Metal. We do not include OpenGL, because it is not capable of gpgpu, and is not scheduled via <a class="el" href="class_halide_1_1_func.html#a29639a0f784916d50387a019389dd5f5" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">Func::gpu_tile</a>. TODO: Should OpenGLCompute be included here? </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00176">176</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00054">CUDA</a>, <a class="el" href="_target_8h_source.html#l00126">has_feature()</a>, <a class="el" href="_target_8h_source.html#l00068">Metal</a>, and <a class="el" href="_target_8h_source.html#l00060">OpenCL</a>.</p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l02054">Halide::Internal::schedule_scalar()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e54d89ba0566f57268363b967e1133c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::supports_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this target allow using a certain type. </p>
<p>Generally all types except 64-bit float and int/uint should be supported by all backends. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00184">184</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_type_8h_source.html#l00331">Halide::Type::bits()</a>, <a class="el" href="_target_8h_source.html#l00061">CLDoubles</a>, <a class="el" href="_target_8h_source.html#l00126">has_feature()</a>, <a class="el" href="_type_8h_source.html#l00369">Halide::Type::is_float()</a>, <a class="el" href="_target_8h_source.html#l00068">Metal</a>, and <a class="el" href="_target_8h_source.html#l00060">OpenCL</a>.</p>

</div>
</div>
<a class="anchor" id="a0087637eae109668d625d5875e11e26c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::supports_device_api </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a particular device API can be used with this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

</div>
</div>
<a class="anchor" id="a052486b9b96e649b9311bcc00e0a9405"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00200">200</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_target.html#a53d1006f89ed385a62cf9e2e5a4fe5a9">arch</a>, <a class="el" href="_target_8h_source.html#l00033">bits</a>, and <a class="el" href="struct_halide_1_1_target.html#aa2d0cedb02dc84eb7a9675df89f1d3ec">os</a>.</p>

</div>
</div>
<a class="anchor" id="a2d02d1fc5b8b3a38ba48316519b389c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00207">207</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a class="anchor" id="a902e58d463f8babb79f6263709d06f01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Target::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_convert.html">Convert</a> the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> into a string form that can be reconstituted by merge_string(), which will always be of the form. </p>
<p>arch-bits-os-feature1-feature2...featureN.</p>
<p>Note that is guaranteed that <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>(t1.to_string()) == t1, but not that Target(s).<a class="el" href="struct_halide_1_1_target.html#a902e58d463f8babb79f6263709d06f01" title="Convert the Target into a string form that can be reconstituted by merge_string(), which will always be of the form. ">to_string()</a> == s (since there can be multiple strings that parse to the same <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>)... <em>unless</em> t1 contains 'unknown' fields (in which case you'll get a string that can't be parsed, which is intentional). </p>

</div>
</div>
<a class="anchor" id="a8d4855075b6ce0bb90bc981787c311a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::natural_vector_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00226">226</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_target.html#a53d1006f89ed385a62cf9e2e5a4fe5a9">arch</a>, <a class="el" href="_target_8h_source.html#l00030">ArchUnknown</a>, <a class="el" href="_target_8h_source.html#l00045">AVX</a>, <a class="el" href="_target_8h_source.html#l00046">AVX2</a>, <a class="el" href="_target_8h_source.html#l00079">AVX512</a>, <a class="el" href="_target_8h_source.html#l00082">AVX512_Cannonlake</a>, <a class="el" href="_target_8h_source.html#l00080">AVX512_KNL</a>, <a class="el" href="_target_8h_source.html#l00081">AVX512_Skylake</a>, <a class="el" href="_target_8h_source.html#l00033">bits</a>, <a class="el" href="_type_8h_source.html#l00300">Halide::Type::bytes()</a>, <a class="el" href="_target_8h_source.html#l00126">has_feature()</a>, <a class="el" href="_target_8h_source.html#l00030">Hexagon</a>, <a class="el" href="_target_8h_source.html#l00073">HVX_128</a>, <a class="el" href="_target_8h_source.html#l00072">HVX_64</a>, <a class="el" href="_type_8h_source.html#l00369">Halide::Type::is_float()</a>, <a class="el" href="_type_8h_source.html#l00372">Halide::Type::is_int()</a>, <a class="el" href="_type_8h_source.html#l00375">Halide::Type::is_uint()</a>, <a class="el" href="struct_halide_1_1_target.html#aa2d0cedb02dc84eb7a9675df89f1d3ec">os</a>, <a class="el" href="_target_8h_source.html#l00025">OSUnknown</a>, <a class="el" href="_error_8h_source.html#l00141">user_assert</a>, <a class="el" href="_error_8h_source.html#l00136">user_error</a>, and <a class="el" href="_target_8h_source.html#l00030">X86</a>.</p>

</div>
</div>
<a class="anchor" id="a0ef57e03c4031aa9105ab037e074cad4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::natural_vector_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00279">279</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a class="anchor" id="a987059e686d9665d6c63441a21e0ffe2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Target::maximum_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum buffer size in bytes supported on this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>
<p>This is 2^31 - 1 except when the LargeBuffers feature is enabled, which expands the maximum to 2^63 - 1. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00286">286</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00033">bits</a>, <a class="el" href="_target_8h_source.html#l00126">has_feature()</a>, and <a class="el" href="_target_8h_source.html#l00071">LargeBuffers</a>.</p>

</div>
</div>
<a class="anchor" id="a104a7543417083771de716958e575e5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Target::supported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Was libHalide compiled with support for this target? </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa2d0cedb02dc84eb7a9675df89f1d3ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">Halide::Target::OS</a>  Halide::Target::os</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a8">tutorial/lesson_11_cross_compilation.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a9">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="_external_code_8h_source.html#l00103">Halide::ExternalCode::is_for_cpu_target()</a>, <a class="el" href="_target_8h_source.html#l00226">natural_vector_size()</a>, and <a class="el" href="_target_8h_source.html#l00200">operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a53d1006f89ed385a62cf9e2e5a4fe5a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Halide::Target::Arch</a>  Halide::Target::arch</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a10">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="_external_code_8h_source.html#l00103">Halide::ExternalCode::is_for_cpu_target()</a>, <a class="el" href="_target_8h_source.html#l00226">natural_vector_size()</a>, and <a class="el" href="_target_8h_source.html#l00200">operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a72366c6d01ef023ff3b2801017779e32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::bits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The bit-width of the target machine. </p>
<p>Must be 0 for unknown, or 32 or 64. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a12">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_target_8h_source.html#l00033">33</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>Referenced by <a class="el" href="_external_code_8h_source.html#l00103">Halide::ExternalCode::is_for_cpu_target()</a>, <a class="el" href="_target_8h_source.html#l00286">maximum_buffer_size()</a>, <a class="el" href="_target_8h_source.html#l00226">natural_vector_size()</a>, and <a class="el" href="_target_8h_source.html#l00200">operator==()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_target_8h_source.html">Target.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="struct_halide_1_1_target.html">Target</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
