<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Target Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('struct_halide_1_1_target.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_halide_1_1_target-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Target Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A struct representing a target machine and os to generate code for.  
 <a href="struct_halide_1_1_target.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_target_8h_source.html">Target.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af2b0caf9e5badd6a8ebe22493752df20"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">OS</a> { <br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20a22c6a2fea606af61fa20b1ad6548ff29">OSUnknown</a> = 0, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20af58b4735f0d8e76502ef70fe11d548d4">Linux</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20a33d246944800a2b478899132d76a95b2">Windows</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20acef0ce22d32cc53d0f72df159f62b691">OSX</a>, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20a5c630f5107a5a01870143d6dc042ea8c">Android</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20aae1a309042fed9d4369e831047a55447">IOS</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20affed0e31d5bf7caedc76111c34768987">QuRT</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20a9e33a7f637d78aff56173e2a4fe5dea2">NoOS</a>
<br />
 }<tr class="memdesc:af2b0caf9e5badd6a8ebe22493752df20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operating system used by the target.  <a href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af2b0caf9e5badd6a8ebe22493752df20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17585cfd5ec92952fd361117d89d4b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Arch</a> { <br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1ae6d33003db3020c4c578c645239f2973">ArchUnknown</a> = 0, 
<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1aba7faedbdb35e2ef2927e248c687a391">X86</a>, 
<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1a1c5f188b9b8eb5ffd951917bbbdd85f2">ARM</a>, 
<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1a93b7e567e560c4e8275e8f1bab214d85">MIPS</a>, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1a25390aa4e88778d47cddac690dbd23ea">Hexagon</a>, 
<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1a1112c6ec7ad8f531deec9461de99f1d2">POWERPC</a>
<br />
 }<tr class="memdesc:af17585cfd5ec92952fd361117d89d4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The architecture used by the target.  <a href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af17585cfd5ec92952fd361117d89d4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9398276edd5784185e1a08f8a4dfc43f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> { <br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fac04af3ed2dc70791a8ba8f793a746b30">JIT</a> = halide_target_feature_jit, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf3cc1f2941a6b4df016ac08e68b9c660">Debug</a> = halide_target_feature_debug, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa1fc53f322ecd95ae65274a9f16c71ac2">NoAsserts</a> = halide_target_feature_no_asserts, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa6f7593c40bf078bf7906ea1c391bcd80">NoBoundsQuery</a> = halide_target_feature_no_bounds_query, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf6ada84d24838f818391b465b9a94165">SSE41</a> = halide_target_feature_sse41, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa620c10914ea92a26c16878ab73933b2b">AVX</a> = halide_target_feature_avx, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fad7b64a080d84e2145fd219e9f7a33547">AVX2</a> = halide_target_feature_avx2, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa9764990d6a6294a8a23f8fb6598c2c88">FMA</a> = halide_target_feature_fma, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa6ba1375f5f5982d91779173b71542e5f">FMA4</a> = halide_target_feature_fma4, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fafc9c513f157e362fa6851a66e5d2aa90">F16C</a> = halide_target_feature_f16c, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf37c16007f6547612713259e648cc41e">ARMv7s</a> = halide_target_feature_armv7s, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa77c151e388125519528caf75193145ee">NoNEON</a> = halide_target_feature_no_neon, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa519b97837177a3c627e8143ad5721100">VSX</a> = halide_target_feature_vsx, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf77d9e657019773706af29b2389b75b7">POWER_ARCH_2_07</a> = halide_target_feature_power_arch_2_07, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fabfd3f02d7bd5f8e2d251a62f465ebcfb">CUDA</a> = halide_target_feature_cuda, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faae6f2116a68aa9477888010a605ec0a5">CUDACapability30</a> = halide_target_feature_cuda_capability30, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa770a75467c600c8ce9a5efa476776742">CUDACapability32</a> = halide_target_feature_cuda_capability32, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa15c6f4c8ec0241c9f34f303670c18af3">CUDACapability35</a> = halide_target_feature_cuda_capability35, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa027631ce082530506684842b44123b8a">CUDACapability50</a> = halide_target_feature_cuda_capability50, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa4698e1c27e0da8a649de1a3769677a90">CUDACapability61</a> = halide_target_feature_cuda_capability61, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa84c6211e4fb941603f6104e98427d7e5">OpenCL</a> = halide_target_feature_opencl, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faa371c9fa5610dc3a9efbb3fde547a719">CLDoubles</a> = halide_target_feature_cl_doubles, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa491aa42775c6c9d6f35f784e86b09abc">OpenGL</a> = halide_target_feature_opengl, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa17e80def356dcd03337ef044ccee459a">OpenGLCompute</a> = halide_target_feature_openglcompute, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fab7dbd399d2a833d37bd52451f99c50c1">UserContext</a> = halide_target_feature_user_context, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf1da45381c688687c95e97987fcc67cb">Matlab</a> = halide_target_feature_matlab, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faec9457be1a9efa835825706a62551cd7">Profile</a> = halide_target_feature_profile, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa90bf2d575c86cf9ca5a2302afbfb9f6b">NoRuntime</a> = halide_target_feature_no_runtime, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa6e7f7184a2b03865bf82159648bd5993">Metal</a> = halide_target_feature_metal, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fac52782fca7077bb12d52bba0b328be6a">MinGW</a> = halide_target_feature_mingw, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fac8a1a9505f550b3ba2f5f75f05b90eeb">CPlusPlusMangling</a> = halide_target_feature_c_plus_plus_mangling, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faeb06f21cee3c57b4dc3dcaa54b9704aa">LargeBuffers</a> = halide_target_feature_large_buffers, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa68e589d244cb5ff06b0fd0813423f194">HVX_64</a> = halide_target_feature_hvx_64, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fabdaeb92fc334091a76a9344db17c4ae5">HVX_128</a> = halide_target_feature_hvx_128, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa7d07df9ddc9273982f55d7af7aff670e">HVX_v62</a> = halide_target_feature_hvx_v62, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa3d08dedf474112248d3f1634737f9054">HVX_v65</a> = halide_target_feature_hvx_v65, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa5fe32761fd8012070c9d38608cc85ac0">HVX_v66</a> = halide_target_feature_hvx_v66, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa41b3499e22e1a6290a29cdca716cb309">HVX_shared_object</a> = halide_target_feature_hvx_use_shared_object, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faec43c9ff5ae1b4b7ccee8798575b62b4">FuzzFloatStores</a> = halide_target_feature_fuzz_float_stores, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa69af866bb508872e3f46e200db714997">SoftFloatABI</a> = halide_target_feature_soft_float_abi, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa117ad175ca197efc42b4abdb2628f4a9">MSAN</a> = halide_target_feature_msan, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa59e40bba2ff121dd95ed2420eb89e17b">AVX512</a> = halide_target_feature_avx512, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa127077fe0f11b9909db6b366170d7dd4">AVX512_KNL</a> = halide_target_feature_avx512_knl, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa7b522bc2d0021790ba47cb302bc4ca6f">AVX512_Skylake</a> = halide_target_feature_avx512_skylake, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa37434c314da6b640c8ac37e1b378225e">AVX512_Cannonlake</a> = halide_target_feature_avx512_cannonlake, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fafca30f177d1e4bdac6551c43119d7893">TraceLoads</a> = halide_target_feature_trace_loads, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fad9b234dbac225381e9e9ea50ed83c75d">TraceStores</a> = halide_target_feature_trace_stores, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa2bf7608dc0fbb54137134c1bcf91ffd8">TraceRealizations</a> = halide_target_feature_trace_realizations, 
<br />
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa17b9cbfef8d1e84e32c8aaa7b2936dbc">FeatureEnd</a> = halide_target_feature_end
<br />
 }<tr class="memdesc:a9398276edd5784185e1a08f8a4dfc43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional features a target can have.  <a href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9398276edd5784185e1a08f8a4dfc43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb11109583253fe6e358bba73d3e4a86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aeb11109583253fe6e358bba73d3e4a86">Target</a> ()</td></tr>
<tr class="separator:aeb11109583253fe6e358bba73d3e4a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849870678f8ce67d10f84a0097b9eb09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a849870678f8ce67d10f84a0097b9eb09">Target</a> (<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">OS</a> o, <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Arch</a> a, int b, std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; initial_features=std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;())</td></tr>
<tr class="separator:a849870678f8ce67d10f84a0097b9eb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab667943ebf46b2da858370e44eae124d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ab667943ebf46b2da858370e44eae124d">set_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f, bool value=true)</td></tr>
<tr class="separator:ab667943ebf46b2da858370e44eae124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dddb1542193fca806cd9f0d9079ba32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a6dddb1542193fca806cd9f0d9079ba32">set_features</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; features_to_set, bool value=true)</td></tr>
<tr class="separator:a6dddb1542193fca806cd9f0d9079ba32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512386389886e2fa0ec57383b0ed6af0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a512386389886e2fa0ec57383b0ed6af0">has_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f) const</td></tr>
<tr class="separator:a512386389886e2fa0ec57383b0ed6af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634976641067077e2df44eff5a060482"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a634976641067077e2df44eff5a060482">features_any_of</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; test_features) const</td></tr>
<tr class="separator:a634976641067077e2df44eff5a060482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5db837f91e8bc4c6771ac86f8245304"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aa5db837f91e8bc4c6771ac86f8245304">features_all_of</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; test_features) const</td></tr>
<tr class="separator:aa5db837f91e8bc4c6771ac86f8245304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24ab465fa42249d0a9ad2a659c4c8cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ae24ab465fa42249d0a9ad2a659c4c8cc">with_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f) const</td></tr>
<tr class="memdesc:ae24ab465fa42249d0a9ad2a659c4c8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the target with the given feature set.  <a href="#ae24ab465fa42249d0a9ad2a659c4c8cc">More...</a><br /></td></tr>
<tr class="separator:ae24ab465fa42249d0a9ad2a659c4c8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b198d9f0c5f96f8a6627d9fcf3c9464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a8b198d9f0c5f96f8a6627d9fcf3c9464">without_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f) const</td></tr>
<tr class="memdesc:a8b198d9f0c5f96f8a6627d9fcf3c9464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the target with the given feature cleared.  <a href="#a8b198d9f0c5f96f8a6627d9fcf3c9464">More...</a><br /></td></tr>
<tr class="separator:a8b198d9f0c5f96f8a6627d9fcf3c9464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bf80aa6dc3a700c9732050d2341a80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a22bf80aa6dc3a700c9732050d2341a80">has_gpu_feature</a> () const</td></tr>
<tr class="memdesc:a22bf80aa6dc3a700c9732050d2341a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a fully feature GPU compute runtime enabled? I.e.  <a href="#a22bf80aa6dc3a700c9732050d2341a80">More...</a><br /></td></tr>
<tr class="separator:a22bf80aa6dc3a700c9732050d2341a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f0564bf2dda4f8f169ae38a43d82bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ac6f0564bf2dda4f8f169ae38a43d82bd">supports_type</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t) const</td></tr>
<tr class="memdesc:ac6f0564bf2dda4f8f169ae38a43d82bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this target allow using a certain type.  <a href="#ac6f0564bf2dda4f8f169ae38a43d82bd">More...</a><br /></td></tr>
<tr class="separator:ac6f0564bf2dda4f8f169ae38a43d82bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3207a15175219374ea97c47dc0f9e41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ae3207a15175219374ea97c47dc0f9e41">supports_type</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device) const</td></tr>
<tr class="memdesc:ae3207a15175219374ea97c47dc0f9e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this target allow using a certain type on a certain device.  <a href="#ae3207a15175219374ea97c47dc0f9e41">More...</a><br /></td></tr>
<tr class="separator:ae3207a15175219374ea97c47dc0f9e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91acf2cc7294b336189478a9ab5fb505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a91acf2cc7294b336189478a9ab5fb505">supports_device_api</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> api) const</td></tr>
<tr class="memdesc:a91acf2cc7294b336189478a9ab5fb505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a particular device API can be used with this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a91acf2cc7294b336189478a9ab5fb505">More...</a><br /></td></tr>
<tr class="separator:a91acf2cc7294b336189478a9ab5fb505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f803372af689cf370650c8b21543c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a08f803372af689cf370650c8b21543c1">operator==</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;other) const</td></tr>
<tr class="separator:a08f803372af689cf370650c8b21543c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa197a765a3df1db99ab0c89c3c9aec75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aa197a765a3df1db99ab0c89c3c9aec75">operator!=</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;other) const</td></tr>
<tr class="separator:aa197a765a3df1db99ab0c89c3c9aec75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95786c068bcceae3202ba0643fe56527"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a95786c068bcceae3202ba0643fe56527">to_string</a> () const</td></tr>
<tr class="memdesc:a95786c068bcceae3202ba0643fe56527"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_convert.html">Convert</a> the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> into a string form that can be reconstituted by merge_string(), which will always be of the form.  <a href="#a95786c068bcceae3202ba0643fe56527">More...</a><br /></td></tr>
<tr class="separator:a95786c068bcceae3202ba0643fe56527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4bb957cb20650e207f91857e1c65e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#abea4bb957cb20650e207f91857e1c65e">natural_vector_size</a> (<a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> t) const</td></tr>
<tr class="memdesc:abea4bb957cb20650e207f91857e1c65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#abea4bb957cb20650e207f91857e1c65e">More...</a><br /></td></tr>
<tr class="separator:abea4bb957cb20650e207f91857e1c65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52479ce7e8fc608dc572b54c04e0fab0"><td class="memTemplParams" colspan="2">template&lt;typename data_t &gt; </td></tr>
<tr class="memitem:a52479ce7e8fc608dc572b54c04e0fab0"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a52479ce7e8fc608dc572b54c04e0fab0">natural_vector_size</a> () const</td></tr>
<tr class="memdesc:a52479ce7e8fc608dc572b54c04e0fab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a52479ce7e8fc608dc572b54c04e0fab0">More...</a><br /></td></tr>
<tr class="separator:a52479ce7e8fc608dc572b54c04e0fab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee756a2df03043cecb1225d6b86e731"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a3ee756a2df03043cecb1225d6b86e731">has_large_buffers</a> () const</td></tr>
<tr class="memdesc:a3ee756a2df03043cecb1225d6b86e731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff 64 bits and has_feature(LargeBuffers).  <a href="#a3ee756a2df03043cecb1225d6b86e731">More...</a><br /></td></tr>
<tr class="separator:a3ee756a2df03043cecb1225d6b86e731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47394e5e8a2e06f5e5dbbbb4aea5d6e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a47394e5e8a2e06f5e5dbbbb4aea5d6e9">maximum_buffer_size</a> () const</td></tr>
<tr class="memdesc:a47394e5e8a2e06f5e5dbbbb4aea5d6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum buffer size in bytes supported on this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a47394e5e8a2e06f5e5dbbbb4aea5d6e9">More...</a><br /></td></tr>
<tr class="separator:a47394e5e8a2e06f5e5dbbbb4aea5d6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5981fb0ab6c483e1850747f06851c36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ab5981fb0ab6c483e1850747f06851c36">supported</a> () const</td></tr>
<tr class="memdesc:ab5981fb0ab6c483e1850747f06851c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was libHalide compiled with support for this target?  <a href="#ab5981fb0ab6c483e1850747f06851c36">More...</a><br /></td></tr>
<tr class="separator:ab5981fb0ab6c483e1850747f06851c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a93e30e33412ec965a87383aed8e9e248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a93e30e33412ec965a87383aed8e9e248">Target</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a93e30e33412ec965a87383aed8e9e248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string of the form used in HL_TARGET (e.g.  <a href="#a93e30e33412ec965a87383aed8e9e248">More...</a><br /></td></tr>
<tr class="separator:a93e30e33412ec965a87383aed8e9e248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae325c67b9fd42cfe0197dac10ca354d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ae325c67b9fd42cfe0197dac10ca354d8">Target</a> (const char *s)</td></tr>
<tr class="memdesc:ae325c67b9fd42cfe0197dac10ca354d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string of the form used in HL_TARGET (e.g.  <a href="#ae325c67b9fd42cfe0197dac10ca354d8">More...</a><br /></td></tr>
<tr class="separator:ae325c67b9fd42cfe0197dac10ca354d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab4c374828bc47e5ada5aded0b1c3e9e1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ab4c374828bc47e5ada5aded0b1c3e9e1">validate_target_string</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ab4c374828bc47e5ada5aded0b1c3e9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a target string is valid.  <a href="#ab4c374828bc47e5ada5aded0b1c3e9e1">More...</a><br /></td></tr>
<tr class="separator:ab4c374828bc47e5ada5aded0b1c3e9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa2d0cedb02dc84eb7a9675df89f1d3ec"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">Halide::Target::OS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aa2d0cedb02dc84eb7a9675df89f1d3ec">os</a></td></tr>
<tr class="separator:aa2d0cedb02dc84eb7a9675df89f1d3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d1006f89ed385a62cf9e2e5a4fe5a9"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Halide::Target::Arch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a53d1006f89ed385a62cf9e2e5a4fe5a9">arch</a></td></tr>
<tr class="separator:a53d1006f89ed385a62cf9e2e5a4fe5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72366c6d01ef023ff3b2801017779e32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a72366c6d01ef023ff3b2801017779e32">bits</a></td></tr>
<tr class="memdesc:a72366c6d01ef023ff3b2801017779e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit-width of the target machine.  <a href="#a72366c6d01ef023ff3b2801017779e32">More...</a><br /></td></tr>
<tr class="separator:a72366c6d01ef023ff3b2801017779e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A struct representing a target machine and os to generate code for. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#_a7">tutorial/lesson_11_cross_compilation.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#_a18">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00021">21</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af2b0caf9e5badd6a8ebe22493752df20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b0caf9e5badd6a8ebe22493752df20">&#9670;&nbsp;</a></span>OS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">Halide::Target::OS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operating system used by the target. </p>
<p>Determines which system calls to generate. Corresponds to os_name_map in Target.cpp. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af2b0caf9e5badd6a8ebe22493752df20a22c6a2fea606af61fa20b1ad6548ff29"></a>OSUnknown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2b0caf9e5badd6a8ebe22493752df20af58b4735f0d8e76502ef70fe11d548d4"></a>Linux&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2b0caf9e5badd6a8ebe22493752df20a33d246944800a2b478899132d76a95b2"></a>Windows&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2b0caf9e5badd6a8ebe22493752df20acef0ce22d32cc53d0f72df159f62b691"></a>OSX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2b0caf9e5badd6a8ebe22493752df20a5c630f5107a5a01870143d6dc042ea8c"></a>Android&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2b0caf9e5badd6a8ebe22493752df20aae1a309042fed9d4369e831047a55447"></a>IOS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2b0caf9e5badd6a8ebe22493752df20affed0e31d5bf7caedc76111c34768987"></a>QuRT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2b0caf9e5badd6a8ebe22493752df20a9e33a7f637d78aff56173e2a4fe5dea2"></a>NoOS&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00025">25</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a id="af17585cfd5ec92952fd361117d89d4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17585cfd5ec92952fd361117d89d4b1">&#9670;&nbsp;</a></span>Arch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Halide::Target::Arch</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The architecture used by the target. </p>
<p>Determines the instruction set to use. Corresponds to arch_name_map in Target.cpp. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af17585cfd5ec92952fd361117d89d4b1ae6d33003db3020c4c578c645239f2973"></a>ArchUnknown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af17585cfd5ec92952fd361117d89d4b1aba7faedbdb35e2ef2927e248c687a391"></a>X86&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af17585cfd5ec92952fd361117d89d4b1a1c5f188b9b8eb5ffd951917bbbdd85f2"></a>ARM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af17585cfd5ec92952fd361117d89d4b1a93b7e567e560c4e8275e8f1bab214d85"></a>MIPS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af17585cfd5ec92952fd361117d89d4b1a25390aa4e88778d47cddac690dbd23ea"></a>Hexagon&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af17585cfd5ec92952fd361117d89d4b1a1112c6ec7ad8f531deec9461de99f1d2"></a>POWERPC&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00030">30</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a id="a9398276edd5784185e1a08f8a4dfc43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9398276edd5784185e1a08f8a4dfc43f">&#9670;&nbsp;</a></span>Feature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Halide::Target::Feature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional features a target can have. </p>
<p>Corresponds to feature_name_map in Target.cpp. See definitions in <a class="el" href="_halide_runtime_8h.html" title="Set a custom malloc and free for halide to use. ">HalideRuntime.h</a> for full information. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fac04af3ed2dc70791a8ba8f793a746b30"></a>JIT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43faf3cc1f2941a6b4df016ac08e68b9c660"></a>Debug&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa1fc53f322ecd95ae65274a9f16c71ac2"></a>NoAsserts&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa6f7593c40bf078bf7906ea1c391bcd80"></a>NoBoundsQuery&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43faf6ada84d24838f818391b465b9a94165"></a>SSE41&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa620c10914ea92a26c16878ab73933b2b"></a>AVX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fad7b64a080d84e2145fd219e9f7a33547"></a>AVX2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa9764990d6a6294a8a23f8fb6598c2c88"></a>FMA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa6ba1375f5f5982d91779173b71542e5f"></a>FMA4&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fafc9c513f157e362fa6851a66e5d2aa90"></a>F16C&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43faf37c16007f6547612713259e648cc41e"></a>ARMv7s&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa77c151e388125519528caf75193145ee"></a>NoNEON&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa519b97837177a3c627e8143ad5721100"></a>VSX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43faf77d9e657019773706af29b2389b75b7"></a>POWER_ARCH_2_07&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fabfd3f02d7bd5f8e2d251a62f465ebcfb"></a>CUDA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43faae6f2116a68aa9477888010a605ec0a5"></a>CUDACapability30&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa770a75467c600c8ce9a5efa476776742"></a>CUDACapability32&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa15c6f4c8ec0241c9f34f303670c18af3"></a>CUDACapability35&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa027631ce082530506684842b44123b8a"></a>CUDACapability50&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa4698e1c27e0da8a649de1a3769677a90"></a>CUDACapability61&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa84c6211e4fb941603f6104e98427d7e5"></a>OpenCL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43faa371c9fa5610dc3a9efbb3fde547a719"></a>CLDoubles&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa491aa42775c6c9d6f35f784e86b09abc"></a>OpenGL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa17e80def356dcd03337ef044ccee459a"></a>OpenGLCompute&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fab7dbd399d2a833d37bd52451f99c50c1"></a>UserContext&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43faf1da45381c688687c95e97987fcc67cb"></a>Matlab&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43faec9457be1a9efa835825706a62551cd7"></a>Profile&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa90bf2d575c86cf9ca5a2302afbfb9f6b"></a>NoRuntime&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa6e7f7184a2b03865bf82159648bd5993"></a>Metal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fac52782fca7077bb12d52bba0b328be6a"></a>MinGW&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fac8a1a9505f550b3ba2f5f75f05b90eeb"></a>CPlusPlusMangling&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43faeb06f21cee3c57b4dc3dcaa54b9704aa"></a>LargeBuffers&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa68e589d244cb5ff06b0fd0813423f194"></a>HVX_64&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fabdaeb92fc334091a76a9344db17c4ae5"></a>HVX_128&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa7d07df9ddc9273982f55d7af7aff670e"></a>HVX_v62&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa3d08dedf474112248d3f1634737f9054"></a>HVX_v65&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa5fe32761fd8012070c9d38608cc85ac0"></a>HVX_v66&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa41b3499e22e1a6290a29cdca716cb309"></a>HVX_shared_object&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43faec43c9ff5ae1b4b7ccee8798575b62b4"></a>FuzzFloatStores&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa69af866bb508872e3f46e200db714997"></a>SoftFloatABI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa117ad175ca197efc42b4abdb2628f4a9"></a>MSAN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa59e40bba2ff121dd95ed2420eb89e17b"></a>AVX512&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa127077fe0f11b9909db6b366170d7dd4"></a>AVX512_KNL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa7b522bc2d0021790ba47cb302bc4ca6f"></a>AVX512_Skylake&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa37434c314da6b640c8ac37e1b378225e"></a>AVX512_Cannonlake&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fafca30f177d1e4bdac6551c43119d7893"></a>TraceLoads&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fad9b234dbac225381e9e9ea50ed83c75d"></a>TraceStores&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa2bf7608dc0fbb54137134c1bcf91ffd8"></a>TraceRealizations&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9398276edd5784185e1a08f8a4dfc43fa17b9cbfef8d1e84e32c8aaa7b2936dbc"></a>FeatureEnd&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00039">39</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeb11109583253fe6e358bba73d3e4a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb11109583253fe6e358bba73d3e4a86">&#9670;&nbsp;</a></span>Target() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Target::Target </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00090">90</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_target_8h_source.html#l00091">Target()</a>.</p>

</div>
</div>
<a id="a849870678f8ce67d10f84a0097b9eb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849870678f8ce67d10f84a0097b9eb09">&#9670;&nbsp;</a></span>Target() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Target::Target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">OS</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Arch</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;&#160;</td>
          <td class="paramname"><em>initial_features</em> = <code>std::vector&lt;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00091">91</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00030">EXPORT</a>, <a class="el" href="_target_8h_source.html#l00116">set_feature()</a>, <a class="el" href="_target_8h_source.html#l00090">Target()</a>, and <a class="el" href="struct_halide_1_1_target.html#ab4c374828bc47e5ada5aded0b1c3e9e1">validate_target_string()</a>.</p>

</div>
</div>
<a id="a93e30e33412ec965a87383aed8e9e248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e30e33412ec965a87383aed8e9e248">&#9670;&nbsp;</a></span>Target() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Target::Target </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string of the form used in HL_TARGET (e.g. </p>
<p>"x86-64-avx"), construct the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> it specifies. Note that this always starts with the result of <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e" title="Return the target corresponding to the host machine. ">get_host_target()</a>, replacing only the parts found in the target string, so if you omit (say) an OS specification, the host OS will be used instead. An empty string is exactly equivalent to <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e" title="Return the target corresponding to the host machine. ">get_host_target()</a>.</p>
<p>Invalid target strings will fail with a user_error. </p>

</div>
</div>
<a id="ae325c67b9fd42cfe0197dac10ca354d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae325c67b9fd42cfe0197dac10ca354d8">&#9670;&nbsp;</a></span>Target() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Target::Target </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string of the form used in HL_TARGET (e.g. </p>
<p>"x86-64-avx"), construct the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> it specifies. Note that this always starts with the result of <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e" title="Return the target corresponding to the host machine. ">get_host_target()</a>, replacing only the parts found in the target string, so if you omit (say) an OS specification, the host OS will be used instead. An empty string is exactly equivalent to <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e" title="Return the target corresponding to the host machine. ">get_host_target()</a>.</p>
<p>Invalid target strings will fail with a user_error. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab4c374828bc47e5ada5aded0b1c3e9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c374828bc47e5ada5aded0b1c3e9e1">&#9670;&nbsp;</a></span>validate_target_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Target::validate_target_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a target string is valid. </p>

<p class="reference">Referenced by <a class="el" href="_target_8h_source.html#l00091">Target()</a>.</p>

</div>
</div>
<a id="ab667943ebf46b2da858370e44eae124d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab667943ebf46b2da858370e44eae124d">&#9670;&nbsp;</a></span>set_feature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Target::set_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a22">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00116">116</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_target_8h_source.html#l00088">FeatureEnd</a>, and <a class="el" href="_error_8h_source.html#l00141">user_assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_target_8h_source.html#l00122">set_features()</a>, <a class="el" href="_target_8h_source.html#l00091">Target()</a>, <a class="el" href="_target_8h_source.html#l00156">with_feature()</a>, and <a class="el" href="_target_8h_source.html#l00166">without_feature()</a>.</p>

</div>
</div>
<a id="a6dddb1542193fca806cd9f0d9079ba32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dddb1542193fca806cd9f0d9079ba32">&#9670;&nbsp;</a></span>set_features()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Target::set_features </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;&#160;</td>
          <td class="paramname"><em>features_to_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a13">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00122">122</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_target_8h_source.html#l00116">set_feature()</a>.</p>

</div>
</div>
<a id="a512386389886e2fa0ec57383b0ed6af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512386389886e2fa0ec57383b0ed6af0">&#9670;&nbsp;</a></span>has_feature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::has_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00128">128</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_target_8h_source.html#l00088">FeatureEnd</a>, and <a class="el" href="_error_8h_source.html#l00141">user_assert</a>.</p>

<p class="reference">Referenced by <a class="el" href="_target_8h_source.html#l00143">features_all_of()</a>, <a class="el" href="_target_8h_source.html#l00134">features_any_of()</a>, <a class="el" href="_target_8h_source.html#l00178">has_gpu_feature()</a>, <a class="el" href="_target_8h_source.html#l00293">has_large_buffers()</a>, <a class="el" href="_target_8h_source.html#l00235">natural_vector_size()</a>, <a class="el" href="_code_gen___a_r_m_8h_source.html#l00072">Halide::Internal::CodeGen_ARM::neon_intrinsics_disabled()</a>, <a class="el" href="_func_8h_source.html#l02121">Halide::Internal::schedule_scalar()</a>, and <a class="el" href="_target_8h_source.html#l00188">supports_type()</a>.</p>

</div>
</div>
<a id="a634976641067077e2df44eff5a060482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634976641067077e2df44eff5a060482">&#9670;&nbsp;</a></span>features_any_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::features_any_of </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;&#160;</td>
          <td class="paramname"><em>test_features</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00134">134</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_target_8h_source.html#l00128">has_feature()</a>.</p>

</div>
</div>
<a id="aa5db837f91e8bc4c6771ac86f8245304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5db837f91e8bc4c6771ac86f8245304">&#9670;&nbsp;</a></span>features_all_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::features_all_of </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;&#160;</td>
          <td class="paramname"><em>test_features</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00143">143</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_target_8h_source.html#l00128">has_feature()</a>.</p>

</div>
</div>
<a id="ae24ab465fa42249d0a9ad2a659c4c8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24ab465fa42249d0a9ad2a659c4c8cc">&#9670;&nbsp;</a></span>with_feature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::Target::with_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the target with the given feature set. </p>
<p>This is convenient when enabling certain features (e.g. NoBoundsQuery) in an initialization list, where the target to be mutated may be a const reference. </p>

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00156">156</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_target_8h_source.html#l00116">set_feature()</a>.</p>

</div>
</div>
<a id="a8b198d9f0c5f96f8a6627d9fcf3c9464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b198d9f0c5f96f8a6627d9fcf3c9464">&#9670;&nbsp;</a></span>without_feature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::Target::without_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the target with the given feature cleared. </p>
<p>This is convenient when disabling certain features (e.g. NoBoundsQuery) in an initialization list, where the target to be mutated may be a const reference. </p>

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00166">166</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_target_8h_source.html#l00116">set_feature()</a>.</p>

</div>
</div>
<a id="a22bf80aa6dc3a700c9732050d2341a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bf80aa6dc3a700c9732050d2341a80">&#9670;&nbsp;</a></span>has_gpu_feature()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::has_gpu_feature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a fully feature GPU compute runtime enabled? I.e. </p>
<p>is <a class="el" href="class_halide_1_1_func.html#a29639a0f784916d50387a019389dd5f5" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">Func::gpu_tile</a> and similar going to work? Currently includes CUDA, OpenCL, and Metal. We do not include OpenGL, because it is not capable of gpgpu, and is not scheduled via <a class="el" href="class_halide_1_1_func.html#a29639a0f784916d50387a019389dd5f5" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">Func::gpu_tile</a>. TODO: Should OpenGLCompute be included here? </p>

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00178">178</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_target_8h_source.html#l00054">CUDA</a>, <a class="el" href="_target_8h_source.html#l00128">has_feature()</a>, <a class="el" href="_target_8h_source.html#l00068">Metal</a>, and <a class="el" href="_target_8h_source.html#l00060">OpenCL</a>.</p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l02121">Halide::Internal::schedule_scalar()</a>.</p>

</div>
</div>
<a id="ac6f0564bf2dda4f8f169ae38a43d82bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f0564bf2dda4f8f169ae38a43d82bd">&#9670;&nbsp;</a></span>supports_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::supports_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this target allow using a certain type. </p>
<p>Generally all types except 64-bit float and int/uint should be supported by all backends.</p>
<p>It is likely better to call the version below which takes a DeviceAPI. </p>

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00188">188</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_type_8h_source.html#l00331">Halide::Type::bits()</a>, <a class="el" href="_target_8h_source.html#l00061">CLDoubles</a>, <a class="el" href="_util_8h_source.html#l00030">EXPORT</a>, <a class="el" href="_target_8h_source.html#l00128">has_feature()</a>, <a class="el" href="_type_8h_source.html#l00369">Halide::Type::is_float()</a>, <a class="el" href="_target_8h_source.html#l00068">Metal</a>, <a class="el" href="_target_8h_source.html#l00060">OpenCL</a>, and <a class="el" href="struct_halide_1_1_target.html#a91acf2cc7294b336189478a9ab5fb505">supports_device_api()</a>.</p>

</div>
</div>
<a id="ae3207a15175219374ea97c47dc0f9e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3207a15175219374ea97c47dc0f9e41">&#9670;&nbsp;</a></span>supports_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Target::supports_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this target allow using a certain type on a certain device. </p>
<p>This is the prefered version of this routine. </p>

</div>
</div>
<a id="a91acf2cc7294b336189478a9ab5fb505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91acf2cc7294b336189478a9ab5fb505">&#9670;&nbsp;</a></span>supports_device_api()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Target::supports_device_api </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a particular device API can be used with this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

<p class="reference">Referenced by <a class="el" href="_target_8h_source.html#l00188">supports_type()</a>.</p>

</div>
</div>
<a id="a08f803372af689cf370650c8b21543c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f803372af689cf370650c8b21543c1">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00209">209</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="struct_halide_1_1_target.html#a53d1006f89ed385a62cf9e2e5a4fe5a9">arch</a>, <a class="el" href="_target_8h_source.html#l00033">bits</a>, and <a class="el" href="struct_halide_1_1_target.html#aa2d0cedb02dc84eb7a9675df89f1d3ec">os</a>.</p>

</div>
</div>
<a id="aa197a765a3df1db99ab0c89c3c9aec75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa197a765a3df1db99ab0c89c3c9aec75">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00216">216</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00030">EXPORT</a>, and <a class="el" href="struct_halide_1_1_target.html#a95786c068bcceae3202ba0643fe56527">to_string()</a>.</p>

</div>
</div>
<a id="a95786c068bcceae3202ba0643fe56527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95786c068bcceae3202ba0643fe56527">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Target::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_convert.html">Convert</a> the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> into a string form that can be reconstituted by merge_string(), which will always be of the form. </p>
<p>arch-bits-os-feature1-feature2...featureN.</p>
<p>Note that is guaranteed that <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>(t1.to_string()) == t1, but not that Target(s).<a class="el" href="struct_halide_1_1_target.html#a95786c068bcceae3202ba0643fe56527" title="Convert the Target into a string form that can be reconstituted by merge_string(), which will always be of the form. ">to_string()</a> == s (since there can be multiple strings that parse to the same <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>)... <em>unless</em> t1 contains 'unknown' fields (in which case you'll get a string that can't be parsed, which is intentional). </p>

<p class="reference">Referenced by <a class="el" href="_target_8h_source.html#l00216">operator!=()</a>.</p>

</div>
</div>
<a id="abea4bb957cb20650e207f91857e1c65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea4bb957cb20650e207f91857e1c65e">&#9670;&nbsp;</a></span>natural_vector_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::natural_vector_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00235">235</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_target_8h_source.html#l00030">ArchUnknown</a>, <a class="el" href="_target_8h_source.html#l00045">AVX</a>, <a class="el" href="_target_8h_source.html#l00046">AVX2</a>, <a class="el" href="_target_8h_source.html#l00081">AVX512</a>, <a class="el" href="_target_8h_source.html#l00084">AVX512_Cannonlake</a>, <a class="el" href="_target_8h_source.html#l00082">AVX512_KNL</a>, <a class="el" href="_target_8h_source.html#l00083">AVX512_Skylake</a>, <a class="el" href="_type_8h_source.html#l00300">Halide::Type::bytes()</a>, <a class="el" href="_target_8h_source.html#l00128">has_feature()</a>, <a class="el" href="_target_8h_source.html#l00030">Hexagon</a>, <a class="el" href="_target_8h_source.html#l00073">HVX_128</a>, <a class="el" href="_target_8h_source.html#l00072">HVX_64</a>, <a class="el" href="_type_8h_source.html#l00369">Halide::Type::is_float()</a>, <a class="el" href="_type_8h_source.html#l00372">Halide::Type::is_int()</a>, <a class="el" href="_type_8h_source.html#l00375">Halide::Type::is_uint()</a>, <a class="el" href="_target_8h_source.html#l00025">OSUnknown</a>, <a class="el" href="_error_8h_source.html#l00141">user_assert</a>, <a class="el" href="_error_8h_source.html#l00136">user_error</a>, and <a class="el" href="_target_8h_source.html#l00030">X86</a>.</p>

</div>
</div>
<a id="a52479ce7e8fc608dc572b54c04e0fab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52479ce7e8fc608dc572b54c04e0fab0">&#9670;&nbsp;</a></span>natural_vector_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::natural_vector_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00288">288</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a id="a3ee756a2df03043cecb1225d6b86e731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee756a2df03043cecb1225d6b86e731">&#9670;&nbsp;</a></span>has_large_buffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::has_large_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff 64 bits and has_feature(LargeBuffers). </p>

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00293">293</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_target_8h_source.html#l00128">has_feature()</a>, and <a class="el" href="_target_8h_source.html#l00071">LargeBuffers</a>.</p>

<p class="reference">Referenced by <a class="el" href="_target_8h_source.html#l00300">maximum_buffer_size()</a>.</p>

</div>
</div>
<a id="a47394e5e8a2e06f5e5dbbbb4aea5d6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47394e5e8a2e06f5e5dbbbb4aea5d6e9">&#9670;&nbsp;</a></span>maximum_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Target::maximum_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum buffer size in bytes supported on this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>
<p>This is 2^31 - 1 except on 64-bit targets when the LargeBuffers feature is enabled, which expands the maximum to 2^63 - 1. </p>

<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00300">300</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00030">EXPORT</a>, <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e">Halide::get_host_target()</a>, <a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">Halide::get_jit_target_from_environment()</a>, <a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">Halide::get_target_from_environment()</a>, <a class="el" href="_target_8h_source.html#l00293">has_large_buffers()</a>, <a class="el" href="struct_halide_1_1_target.html#ab5981fb0ab6c483e1850747f06851c36">supported()</a>, <a class="el" href="namespace_halide.html#a1c3b78bf207020ef9e7a91f0f12db471">Halide::target_feature_for_device_api()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#a75c39fdac13dbbf178d4ae1680c7dbf7">Halide::Internal::target_test()</a>.</p>

</div>
</div>
<a id="ab5981fb0ab6c483e1850747f06851c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5981fb0ab6c483e1850747f06851c36">&#9670;&nbsp;</a></span>supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Target::supported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Was libHalide compiled with support for this target? </p>

<p class="reference">Referenced by <a class="el" href="_target_8h_source.html#l00300">maximum_buffer_size()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa2d0cedb02dc84eb7a9675df89f1d3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d0cedb02dc84eb7a9675df89f1d3ec">&#9670;&nbsp;</a></span>os</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">Halide::Target::OS</a>  Halide::Target::os</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a8">tutorial/lesson_11_cross_compilation.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a20">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="_external_code_8h_source.html#l00103">Halide::ExternalCode::is_for_cpu_target()</a>, and <a class="el" href="_target_8h_source.html#l00209">operator==()</a>.</p>

</div>
</div>
<a id="a53d1006f89ed385a62cf9e2e5a4fe5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d1006f89ed385a62cf9e2e5a4fe5a9">&#9670;&nbsp;</a></span>arch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Halide::Target::Arch</a>  Halide::Target::arch</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a10">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="_external_code_8h_source.html#l00103">Halide::ExternalCode::is_for_cpu_target()</a>, and <a class="el" href="_target_8h_source.html#l00209">operator==()</a>.</p>

</div>
</div>
<a id="a72366c6d01ef023ff3b2801017779e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72366c6d01ef023ff3b2801017779e32">&#9670;&nbsp;</a></span>bits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::bits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The bit-width of the target machine. </p>
<p>Must be 0 for unknown, or 32 or 64. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a12">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="_target_8h_source.html#l00033">33</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_external_code_8h_source.html#l00103">Halide::ExternalCode::is_for_cpu_target()</a>, and <a class="el" href="_target_8h_source.html#l00209">operator==()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_target_8h_source.html">Target.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="struct_halide_1_1_target.html">Target</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
