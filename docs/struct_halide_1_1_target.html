<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Halide: Halide::Target Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">10.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('struct_halide_1_1_target.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_halide_1_1_target-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Target Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A struct representing a target machine and os to generate code for.  
 <a href="struct_halide_1_1_target.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_target_8h_source.html">Target.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb11109583253fe6e358bba73d3e4a86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aeb11109583253fe6e358bba73d3e4a86">Target</a> ()</td></tr>
<tr class="separator:aeb11109583253fe6e358bba73d3e4a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff20ad58e15b48104f0261f22592496"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a2ff20ad58e15b48104f0261f22592496">Target</a> (<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">OS</a> o, <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Arch</a> a, int b, const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; &amp;initial_features=std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;())</td></tr>
<tr class="separator:a2ff20ad58e15b48104f0261f22592496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f3eb5428e4e3b090c3b17f8c088ee5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a95f3eb5428e4e3b090c3b17f8c088ee5">has_unknowns</a> () const </td></tr>
<tr class="memdesc:a95f3eb5428e4e3b090c3b17f8c088ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of the arch/bits/os fields are "unknown"/0; return false otherwise.  <a href="#a95f3eb5428e4e3b090c3b17f8c088ee5">More...</a><br /></td></tr>
<tr class="separator:a95f3eb5428e4e3b090c3b17f8c088ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab667943ebf46b2da858370e44eae124d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ab667943ebf46b2da858370e44eae124d">set_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f, bool value=true)</td></tr>
<tr class="separator:ab667943ebf46b2da858370e44eae124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d29dd2c38d71ec30f872031fb24fa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a30d29dd2c38d71ec30f872031fb24fa8">set_features</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; &amp;features_to_set, bool value=true)</td></tr>
<tr class="separator:a30d29dd2c38d71ec30f872031fb24fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbcbe93a4d5ee7f9f93c6b3d7914bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#acbbcbe93a4d5ee7f9f93c6b3d7914bf3">has_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f) const </td></tr>
<tr class="separator:acbbcbe93a4d5ee7f9f93c6b3d7914bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac2971a8b1526e25aa7ad1bdfb1ea4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a6ac2971a8b1526e25aa7ad1bdfb1ea4a">has_feature</a> (<a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3a">halide_target_feature_t</a> f) const </td></tr>
<tr class="separator:a6ac2971a8b1526e25aa7ad1bdfb1ea4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303605d5010bb0cd5de25351bb89fe7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a303605d5010bb0cd5de25351bb89fe7d">features_any_of</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; &amp;test_features) const </td></tr>
<tr class="separator:a303605d5010bb0cd5de25351bb89fe7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f91d5c5e6d841627ad242525c237f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a64f91d5c5e6d841627ad242525c237f3">features_all_of</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; &amp;test_features) const </td></tr>
<tr class="separator:a64f91d5c5e6d841627ad242525c237f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc1372f492ae82156f56792eccc6a64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aafc1372f492ae82156f56792eccc6a64">with_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f) const </td></tr>
<tr class="memdesc:aafc1372f492ae82156f56792eccc6a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the target with the given feature set.  <a href="#aafc1372f492ae82156f56792eccc6a64">More...</a><br /></td></tr>
<tr class="separator:aafc1372f492ae82156f56792eccc6a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52878468db5e366d04748ed6fc64cf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ab52878468db5e366d04748ed6fc64cf5">without_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f) const </td></tr>
<tr class="memdesc:ab52878468db5e366d04748ed6fc64cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the target with the given feature cleared.  <a href="#ab52878468db5e366d04748ed6fc64cf5">More...</a><br /></td></tr>
<tr class="separator:ab52878468db5e366d04748ed6fc64cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653f58c7d0efbd7dac22cf239576a660"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a653f58c7d0efbd7dac22cf239576a660">has_gpu_feature</a> () const </td></tr>
<tr class="memdesc:a653f58c7d0efbd7dac22cf239576a660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a fully feature GPU compute runtime enabled? I.e.  <a href="#a653f58c7d0efbd7dac22cf239576a660">More...</a><br /></td></tr>
<tr class="separator:a653f58c7d0efbd7dac22cf239576a660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e54d89ba0566f57268363b967e1133c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a0e54d89ba0566f57268363b967e1133c">supports_type</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t) const </td></tr>
<tr class="memdesc:a0e54d89ba0566f57268363b967e1133c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this target allow using a certain type.  <a href="#a0e54d89ba0566f57268363b967e1133c">More...</a><br /></td></tr>
<tr class="separator:a0e54d89ba0566f57268363b967e1133c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab524021da23650078dcfa52c9f93f937"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ab524021da23650078dcfa52c9f93f937">supports_type</a> (const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;t, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device) const </td></tr>
<tr class="memdesc:ab524021da23650078dcfa52c9f93f937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this target allow using a certain type on a certain device.  <a href="#ab524021da23650078dcfa52c9f93f937">More...</a><br /></td></tr>
<tr class="separator:ab524021da23650078dcfa52c9f93f937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0087637eae109668d625d5875e11e26c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a0087637eae109668d625d5875e11e26c">supports_device_api</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> api) const </td></tr>
<tr class="memdesc:a0087637eae109668d625d5875e11e26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a particular device API can be used with this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a0087637eae109668d625d5875e11e26c">More...</a><br /></td></tr>
<tr class="separator:a0087637eae109668d625d5875e11e26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff05590690644c714f14d91452e1c42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a5ff05590690644c714f14d91452e1c42">get_required_device_api</a> () const </td></tr>
<tr class="memdesc:a5ff05590690644c714f14d91452e1c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> (including all Features) requires a specific DeviceAPI, return it.  <a href="#a5ff05590690644c714f14d91452e1c42">More...</a><br /></td></tr>
<tr class="separator:a5ff05590690644c714f14d91452e1c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052486b9b96e649b9311bcc00e0a9405"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a052486b9b96e649b9311bcc00e0a9405">operator==</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;other) const </td></tr>
<tr class="separator:a052486b9b96e649b9311bcc00e0a9405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d02d1fc5b8b3a38ba48316519b389c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a2d02d1fc5b8b3a38ba48316519b389c0">operator!=</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;other) const </td></tr>
<tr class="separator:a2d02d1fc5b8b3a38ba48316519b389c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000e35902bb5bcb26cea9955c87c4894"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a000e35902bb5bcb26cea9955c87c4894">get_runtime_compatible_target</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;other, <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;result)</td></tr>
<tr class="memdesc:a000e35902bb5bcb26cea9955c87c4894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a "greatest common denominator" runtime target that is compatible with both this target and <code>other</code>.  <a href="#a000e35902bb5bcb26cea9955c87c4894">More...</a><br /></td></tr>
<tr class="separator:a000e35902bb5bcb26cea9955c87c4894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbea5be66f9dbe6bc1d75ff0691b6b1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a5cbea5be66f9dbe6bc1d75ff0691b6b1">to_string</a> () const </td></tr>
<tr class="memdesc:a5cbea5be66f9dbe6bc1d75ff0691b6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> into a string form that can be reconstituted by merge_string(), which will always be of the form.  <a href="#a5cbea5be66f9dbe6bc1d75ff0691b6b1">More...</a><br /></td></tr>
<tr class="separator:a5cbea5be66f9dbe6bc1d75ff0691b6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcd948b0b269988478d526ff9a4cb1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a5fcd948b0b269988478d526ff9a4cb1c">natural_vector_size</a> (const <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> &amp;t) const </td></tr>
<tr class="memdesc:a5fcd948b0b269988478d526ff9a4cb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a5fcd948b0b269988478d526ff9a4cb1c">More...</a><br /></td></tr>
<tr class="separator:a5fcd948b0b269988478d526ff9a4cb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef57e03c4031aa9105ab037e074cad4"><td class="memTemplParams" colspan="2">template&lt;typename data_t &gt; </td></tr>
<tr class="memitem:a0ef57e03c4031aa9105ab037e074cad4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a0ef57e03c4031aa9105ab037e074cad4">natural_vector_size</a> () const </td></tr>
<tr class="memdesc:a0ef57e03c4031aa9105ab037e074cad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a0ef57e03c4031aa9105ab037e074cad4">More...</a><br /></td></tr>
<tr class="separator:a0ef57e03c4031aa9105ab037e074cad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba4941fc8dd4993c2b3f95b355352eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a0ba4941fc8dd4993c2b3f95b355352eb">has_large_buffers</a> () const </td></tr>
<tr class="memdesc:a0ba4941fc8dd4993c2b3f95b355352eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff 64 bits and has_feature(LargeBuffers).  <a href="#a0ba4941fc8dd4993c2b3f95b355352eb">More...</a><br /></td></tr>
<tr class="separator:a0ba4941fc8dd4993c2b3f95b355352eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987059e686d9665d6c63441a21e0ffe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a987059e686d9665d6c63441a21e0ffe2">maximum_buffer_size</a> () const </td></tr>
<tr class="memdesc:a987059e686d9665d6c63441a21e0ffe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum buffer size in bytes supported on this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a987059e686d9665d6c63441a21e0ffe2">More...</a><br /></td></tr>
<tr class="separator:a987059e686d9665d6c63441a21e0ffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fac5e03833403a92e629544bb5918d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a5fac5e03833403a92e629544bb5918d4">get_cuda_capability_lower_bound</a> () const </td></tr>
<tr class="memdesc:a5fac5e03833403a92e629544bb5918d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum cuda capability found as an integer.  <a href="#a5fac5e03833403a92e629544bb5918d4">More...</a><br /></td></tr>
<tr class="separator:a5fac5e03833403a92e629544bb5918d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace49d3d1390937c3fa82476fe411a5db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ace49d3d1390937c3fa82476fe411a5db">supported</a> () const </td></tr>
<tr class="memdesc:ace49d3d1390937c3fa82476fe411a5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was libHalide compiled with support for this target?  <a href="#ace49d3d1390937c3fa82476fe411a5db">More...</a><br /></td></tr>
<tr class="separator:ace49d3d1390937c3fa82476fe411a5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb63f14ed3eed059fba247ab843d6cc"><td class="memItemLeft" align="right" valign="top">const std::bitset&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa17b9cbfef8d1e84e32c8aaa7b2936dbc">FeatureEnd</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#acbb63f14ed3eed059fba247ab843d6cc">get_features_bitset</a> () const </td></tr>
<tr class="memdesc:acbb63f14ed3eed059fba247ab843d6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a bitset of the Featuress set in this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> (set = 1).  <a href="#acbb63f14ed3eed059fba247ab843d6cc">More...</a><br /></td></tr>
<tr class="separator:acbb63f14ed3eed059fba247ab843d6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6ea1860548b9d8e26939d29e92faef31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a6ea1860548b9d8e26939d29e92faef31">Target</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a6ea1860548b9d8e26939d29e92faef31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string of the form used in HL_TARGET (e.g.  <a href="#a6ea1860548b9d8e26939d29e92faef31">More...</a><br /></td></tr>
<tr class="separator:a6ea1860548b9d8e26939d29e92faef31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0dbc7af1d5379912254df2914af759"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aff0dbc7af1d5379912254df2914af759">Target</a> (const char *s)</td></tr>
<tr class="memdesc:aff0dbc7af1d5379912254df2914af759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a string of the form used in HL_TARGET (e.g.  <a href="#aff0dbc7af1d5379912254df2914af759">More...</a><br /></td></tr>
<tr class="separator:aff0dbc7af1d5379912254df2914af759"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8560dca9ecc5f4b80b990b241e7ca632"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a8560dca9ecc5f4b80b990b241e7ca632">validate_target_string</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a8560dca9ecc5f4b80b990b241e7ca632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a target string is valid.  <a href="#a8560dca9ecc5f4b80b990b241e7ca632">More...</a><br /></td></tr>
<tr class="separator:a8560dca9ecc5f4b80b990b241e7ca632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3292b77bf4aad3917aa27c7c9cb86c"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a2c3292b77bf4aad3917aa27c7c9cb86c">feature_to_name</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Target::Feature</a> feature)</td></tr>
<tr class="memdesc:a2c3292b77bf4aad3917aa27c7c9cb86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name corresponding to a given Feature, in the form used to construct <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> strings (e.g., Feature::Debug is "debug" and not "Debug").  <a href="#a2c3292b77bf4aad3917aa27c7c9cb86c">More...</a><br /></td></tr>
<tr class="separator:a2c3292b77bf4aad3917aa27c7c9cb86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e26b5f9fca8f1bcf142709f12f5f934"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Target::Feature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a2e26b5f9fca8f1bcf142709f12f5f934">feature_from_name</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2e26b5f9fca8f1bcf142709f12f5f934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the feature corresponding to a given name, in the form used to construct <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> strings (e.g., Feature::Debug is "debug" and not "Debug").  <a href="#a2e26b5f9fca8f1bcf142709f12f5f934">More...</a><br /></td></tr>
<tr class="separator:a2e26b5f9fca8f1bcf142709f12f5f934"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa2d0cedb02dc84eb7a9675df89f1d3ec"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">Halide::Target::OS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aa2d0cedb02dc84eb7a9675df89f1d3ec">os</a></td></tr>
<tr class="separator:aa2d0cedb02dc84eb7a9675df89f1d3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d1006f89ed385a62cf9e2e5a4fe5a9"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Halide::Target::Arch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a53d1006f89ed385a62cf9e2e5a4fe5a9">arch</a></td></tr>
<tr class="separator:a53d1006f89ed385a62cf9e2e5a4fe5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72366c6d01ef023ff3b2801017779e32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a72366c6d01ef023ff3b2801017779e32">bits</a></td></tr>
<tr class="memdesc:a72366c6d01ef023ff3b2801017779e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit-width of the target machine.  <a href="#a72366c6d01ef023ff3b2801017779e32">More...</a><br /></td></tr>
<tr class="separator:a72366c6d01ef023ff3b2801017779e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A struct representing a target machine and os to generate code for. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#_a7">tutorial/lesson_11_cross_compilation.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#_a0">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_target_8h_source.html#l00019">19</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">Halide::Target::OS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operating system used by the target. </p>
<p>Determines which system calls to generate. Corresponds to os_name_map in Target.cpp. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a22c6a2fea606af61fa20b1ad6548ff29"></a>OSUnknown&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20af58b4735f0d8e76502ef70fe11d548d4"></a>Linux&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a33d246944800a2b478899132d76a95b2"></a>Windows&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20acef0ce22d32cc53d0f72df159f62b691"></a>OSX&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a5c630f5107a5a01870143d6dc042ea8c"></a>Android&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20aae1a309042fed9d4369e831047a55447"></a>IOS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20affed0e31d5bf7caedc76111c34768987"></a>QuRT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a9e33a7f637d78aff56173e2a4fe5dea2"></a>NoOS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20ab3e4f046c38f387019c7afe853d1e54f"></a>Fuchsia&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a9271c8d20c5e676be8a58ed152d0c2c6"></a>WebAssemblyRuntime&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00023">23</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Halide::Target::Arch</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The architecture used by the target. </p>
<p>Determines the instruction set to use. Corresponds to arch_name_map in Target.cpp. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1ae6d33003db3020c4c578c645239f2973"></a>ArchUnknown&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1aba7faedbdb35e2ef2927e248c687a391"></a>X86&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a1c5f188b9b8eb5ffd951917bbbdd85f2"></a>ARM&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a93b7e567e560c4e8275e8f1bab214d85"></a>MIPS&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a25390aa4e88778d47cddac690dbd23ea"></a>Hexagon&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a1112c6ec7ad8f531deec9461de99f1d2"></a>POWERPC&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a6532c751e5ed692a3697b42e16245103"></a>WebAssembly&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a17a3e9018141a1ee808bca53786e973a"></a>RISCV&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00039">39</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Halide::Target::Feature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional features a target can have. </p>
<p>Corresponds to feature_name_map in Target.cpp. See definitions in <a class="el" href="_halide_runtime_8h.html" title="This file declares the routines used by Halide internally in its runtime. ">HalideRuntime.h</a> for full information. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fac04af3ed2dc70791a8ba8f793a746b30"></a>JIT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf3cc1f2941a6b4df016ac08e68b9c660"></a>Debug&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa1fc53f322ecd95ae65274a9f16c71ac2"></a>NoAsserts&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa6f7593c40bf078bf7906ea1c391bcd80"></a>NoBoundsQuery&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf6ada84d24838f818391b465b9a94165"></a>SSE41&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa620c10914ea92a26c16878ab73933b2b"></a>AVX&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fad7b64a080d84e2145fd219e9f7a33547"></a>AVX2&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa9764990d6a6294a8a23f8fb6598c2c88"></a>FMA&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa6ba1375f5f5982d91779173b71542e5f"></a>FMA4&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fafc9c513f157e362fa6851a66e5d2aa90"></a>F16C&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf37c16007f6547612713259e648cc41e"></a>ARMv7s&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa77c151e388125519528caf75193145ee"></a>NoNEON&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa519b97837177a3c627e8143ad5721100"></a>VSX&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf77d9e657019773706af29b2389b75b7"></a>POWER_ARCH_2_07&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fabfd3f02d7bd5f8e2d251a62f465ebcfb"></a>CUDA&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faae6f2116a68aa9477888010a605ec0a5"></a>CUDACapability30&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa770a75467c600c8ce9a5efa476776742"></a>CUDACapability32&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa15c6f4c8ec0241c9f34f303670c18af3"></a>CUDACapability35&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa027631ce082530506684842b44123b8a"></a>CUDACapability50&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa4698e1c27e0da8a649de1a3769677a90"></a>CUDACapability61&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa0d74ff49399ae262e113c2835141ab01"></a>CUDACapability70&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fae7cbec868d975c4aa7b322fa76bb7c92"></a>CUDACapability75&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fabd7d2e15b3b2ea52d792c39fad72ae70"></a>CUDACapability80&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa84c6211e4fb941603f6104e98427d7e5"></a>OpenCL&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faa371c9fa5610dc3a9efbb3fde547a719"></a>CLDoubles&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa83b38d45d65d541678d96fc9ca78ce48"></a>CLHalf&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faa6dbac107b96f0f7a887243635428e9e"></a>CLAtomics64&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa491aa42775c6c9d6f35f784e86b09abc"></a>OpenGL&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa17e80def356dcd03337ef044ccee459a"></a>OpenGLCompute&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa126ccb07c0612499b349ac4b622c84ea"></a>EGL&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fab7dbd399d2a833d37bd52451f99c50c1"></a>UserContext&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf1da45381c688687c95e97987fcc67cb"></a>Matlab&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faec9457be1a9efa835825706a62551cd7"></a>Profile&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa90bf2d575c86cf9ca5a2302afbfb9f6b"></a>NoRuntime&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa6e7f7184a2b03865bf82159648bd5993"></a>Metal&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fac8a1a9505f550b3ba2f5f75f05b90eeb"></a>CPlusPlusMangling&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faeb06f21cee3c57b4dc3dcaa54b9704aa"></a>LargeBuffers&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa0cc9df360b1be51fb3fb2c9bc2df0571"></a>HexagonDma&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa68e589d244cb5ff06b0fd0813423f194"></a>HVX_64&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fabdaeb92fc334091a76a9344db17c4ae5"></a>HVX_128&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa7d07df9ddc9273982f55d7af7aff670e"></a>HVX_v62&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa3d08dedf474112248d3f1634737f9054"></a>HVX_v65&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa5fe32761fd8012070c9d38608cc85ac0"></a>HVX_v66&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa41b3499e22e1a6290a29cdca716cb309"></a>HVX_shared_object&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faec43c9ff5ae1b4b7ccee8798575b62b4"></a>FuzzFloatStores&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa69af866bb508872e3f46e200db714997"></a>SoftFloatABI&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa117ad175ca197efc42b4abdb2628f4a9"></a>MSAN&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa59e40bba2ff121dd95ed2420eb89e17b"></a>AVX512&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa127077fe0f11b9909db6b366170d7dd4"></a>AVX512_KNL&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa7b522bc2d0021790ba47cb302bc4ca6f"></a>AVX512_Skylake&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa37434c314da6b640c8ac37e1b378225e"></a>AVX512_Cannonlake&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fafca30f177d1e4bdac6551c43119d7893"></a>TraceLoads&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fad9b234dbac225381e9e9ea50ed83c75d"></a>TraceStores&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa2bf7608dc0fbb54137134c1bcf91ffd8"></a>TraceRealizations&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faac0b2d5333a5282acb477066f14e9907"></a>TracePipeline&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fadef31da48a8e5d3b6fedd1812987716f"></a>D3D12Compute&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa6e99d2e5d2365e4b2cf9fb7dbe1671c4"></a>StrictFloat&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa58d95b1dcba192fb5d4641ffff36432a"></a>TSAN&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fae59cd5aeb05ef28cdbcbd83bcbba4469"></a>ASAN&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa067b0eb1f99b6ad38c8d8489458bd547"></a>CheckUnsafePromises&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fad9abe4d72830168bd0e0ef8baa2910b7"></a>EmbedBitcode&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa28b51c8db700df63d4c0af413c6f86e5"></a>EnableLLVMLoopOpt&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa78393c3592fa34c7e4cf6346d169981d"></a>DisableLLVMLoopOpt&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa64ad3f5f11c8c24afe565c156afe4d52"></a>WasmSimd128&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fad95c59042a85b7145e903bcff2da6386"></a>WasmSignExt&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa5844b91ea7f9eb256f4d86451bb8b3b7"></a>WasmSatFloatToInt&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa48a5b339558dbb638a86369323ab90cf"></a>SVE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa89a6517304ddf8ed742553313f42fb5e"></a>SVE2&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa390691902caad2332bea136892ad1f07"></a>ARMDotProd&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa17b9cbfef8d1e84e32c8aaa7b2936dbc"></a>FeatureEnd&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00057">57</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeb11109583253fe6e358bba73d3e4a86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Target::Target </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00129">129</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00132">Target()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ff20ad58e15b48104f0261f22592496"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Target::Target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">OS</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Arch</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_features</em> = <code>std::vector&lt;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00132">132</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_target.html#acbbcbe93a4d5ee7f9f93c6b3d7914bf3">has_feature()</a>, <a class="el" href="struct_halide_1_1_target.html#a95f3eb5428e4e3b090c3b17f8c088ee5">has_unknowns()</a>, <a class="el" href="struct_halide_1_1_target.html#ab667943ebf46b2da858370e44eae124d">set_feature()</a>, <a class="el" href="struct_halide_1_1_target.html#a30d29dd2c38d71ec30f872031fb24fa8">set_features()</a>, <a class="el" href="_target_8h_source.html#l00129">Target()</a>, and <a class="el" href="struct_halide_1_1_target.html#a8560dca9ecc5f4b80b990b241e7ca632">validate_target_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ea1860548b9d8e26939d29e92faef31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Target::Target </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string of the form used in HL_TARGET (e.g. </p>
<p>"x86-64-avx"), construct the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> it specifies. Note that this always starts with the result of <a class="el" href="namespace_halide.html#a0ae94266acfeba1bce3298e333ba4b8c" title="Return the target corresponding to the host machine. ">get_host_target()</a>, replacing only the parts found in the target string, so if you omit (say) an OS specification, the host OS will be used instead. An empty string is exactly equivalent to <a class="el" href="namespace_halide.html#a0ae94266acfeba1bce3298e333ba4b8c" title="Return the target corresponding to the host machine. ">get_host_target()</a>.</p>
<p>Invalid target strings will fail with a user_error. </p>

</div>
</div>
<a class="anchor" id="aff0dbc7af1d5379912254df2914af759"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Target::Target </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a string of the form used in HL_TARGET (e.g. </p>
<p>"x86-64-avx"), construct the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> it specifies. Note that this always starts with the result of <a class="el" href="namespace_halide.html#a0ae94266acfeba1bce3298e333ba4b8c" title="Return the target corresponding to the host machine. ">get_host_target()</a>, replacing only the parts found in the target string, so if you omit (say) an OS specification, the host OS will be used instead. An empty string is exactly equivalent to <a class="el" href="namespace_halide.html#a0ae94266acfeba1bce3298e333ba4b8c" title="Return the target corresponding to the host machine. ">get_host_target()</a>.</p>
<p>Invalid target strings will fail with a user_error. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8560dca9ecc5f4b80b990b241e7ca632"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Halide::Target::validate_target_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a target string is valid. </p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00132">Target()</a>.</p>

</div>
</div>
<a class="anchor" id="a95f3eb5428e4e3b090c3b17f8c088ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::has_unknowns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if any of the arch/bits/os fields are "unknown"/0; return false otherwise. </p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00132">Target()</a>.</p>

</div>
</div>
<a class="anchor" id="ab667943ebf46b2da858370e44eae124d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Target::set_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_target_8h_source.html#l00132">Target()</a>.</p>

</div>
</div>
<a class="anchor" id="a30d29dd2c38d71ec30f872031fb24fa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Target::set_features </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>features_to_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a13">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="_target_8h_source.html#l00132">Target()</a>.</p>

</div>
</div>
<a class="anchor" id="acbbcbe93a4d5ee7f9f93c6b3d7914bf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::has_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="simd__op__check_8h_source.html#l00063">Halide::SimdOpCheckTest::can_run_code()</a>, <a class="el" href="_target_8h_source.html#l00167">has_feature()</a>, <a class="el" href="_target_8h_source.html#l00265">has_large_buffers()</a>, <a class="el" href="_code_gen___a_r_m_8h_source.html#l00074">Halide::Internal::CodeGen_ARM::neon_intrinsics_disabled()</a>, <a class="el" href="_func_8h_source.html#l02509">Halide::Internal::schedule_scalar()</a>, and <a class="el" href="_target_8h_source.html#l00132">Target()</a>.</p>

</div>
</div>
<a class="anchor" id="a6ac2971a8b1526e25aa7ad1bdfb1ea4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::has_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_halide_runtime_8h.html#a2ccb96b3d427fff8f1d68cc5f1e92f3a">halide_target_feature_t</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00167">167</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_target.html#a64f91d5c5e6d841627ad242525c237f3">features_all_of()</a>, <a class="el" href="struct_halide_1_1_target.html#a303605d5010bb0cd5de25351bb89fe7d">features_any_of()</a>, <a class="el" href="struct_halide_1_1_target.html#a5ff05590690644c714f14d91452e1c42">get_required_device_api()</a>, <a class="el" href="struct_halide_1_1_target.html#acbbcbe93a4d5ee7f9f93c6b3d7914bf3">has_feature()</a>, <a class="el" href="struct_halide_1_1_target.html#a653f58c7d0efbd7dac22cf239576a660">has_gpu_feature()</a>, <a class="el" href="struct_halide_1_1_target.html#a0087637eae109668d625d5875e11e26c">supports_device_api()</a>, <a class="el" href="struct_halide_1_1_target.html#a0e54d89ba0566f57268363b967e1133c">supports_type()</a>, <a class="el" href="struct_halide_1_1_target.html#aafc1372f492ae82156f56792eccc6a64">with_feature()</a>, and <a class="el" href="struct_halide_1_1_target.html#ab52878468db5e366d04748ed6fc64cf5">without_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="a303605d5010bb0cd5de25351bb89fe7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::features_any_of </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>test_features</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_target_8h_source.html#l00167">has_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="a64f91d5c5e6d841627ad242525c237f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::features_all_of </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>test_features</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_target_8h_source.html#l00167">has_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="aafc1372f492ae82156f56792eccc6a64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::Target::with_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of the target with the given feature set. </p>
<p>This is convenient when enabling certain features (e.g. NoBoundsQuery) in an initialization list, where the target to be mutated may be a const reference. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a29">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="_target_8h_source.html#l00167">has_feature()</a>, and <a class="el" href="simd__op__check_8h_source.html#l00046">Halide::SimdOpCheckTest::SimdOpCheckTest()</a>.</p>

</div>
</div>
<a class="anchor" id="ab52878468db5e366d04748ed6fc64cf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::Target::without_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of the target with the given feature cleared. </p>
<p>This is convenient when disabling certain features (e.g. NoBoundsQuery) in an initialization list, where the target to be mutated may be a const reference. </p>

<p>Referenced by <a class="el" href="simd__op__check_8h_source.html#l00130">Halide::SimdOpCheckTest::check_one()</a>, and <a class="el" href="_target_8h_source.html#l00167">has_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="a653f58c7d0efbd7dac22cf239576a660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::has_gpu_feature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is a fully feature GPU compute runtime enabled? I.e. </p>
<p>is <a class="el" href="class_halide_1_1_func.html#a86835964da8b0b94e57fdf2767eb900f" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">Func::gpu_tile</a> and similar going to work? Currently includes CUDA, OpenCL, Metal and D3D12Compute. We do not include OpenGL, because it is not capable of gpgpu, and is not scheduled via <a class="el" href="class_halide_1_1_func.html#a86835964da8b0b94e57fdf2767eb900f" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">Func::gpu_tile</a>. TODO: Should OpenGLCompute be included here? </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a17">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="_target_8h_source.html#l00167">has_feature()</a>, and <a class="el" href="_func_8h_source.html#l02509">Halide::Internal::schedule_scalar()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e54d89ba0566f57268363b967e1133c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::supports_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this target allow using a certain type. </p>
<p>Generally all types except 64-bit float and int/uint should be supported by all backends.</p>
<p>It is likely better to call the version below which takes a DeviceAPI. </p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00167">has_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="ab524021da23650078dcfa52c9f93f937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::supports_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this target allow using a certain type on a certain device. </p>
<p>This is the prefered version of this routine. </p>

</div>
</div>
<a class="anchor" id="a0087637eae109668d625d5875e11e26c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::supports_device_api </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>api</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a particular device API can be used with this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00167">has_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ff05590690644c714f14d91452e1c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> Halide::Target::get_required_device_api </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> (including all Features) requires a specific DeviceAPI, return it. </p>
<p>If it doesn't, return <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6ea6adf97f83acf6453d4a6a4b1070f3754">DeviceAPI::None</a>. If the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> has features with multiple (different) DeviceAPI requirements, the result will be an arbitrary DeviceAPI. </p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00167">has_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="a052486b9b96e649b9311bcc00e0a9405"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00218">218</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_target.html#a53d1006f89ed385a62cf9e2e5a4fe5a9">arch</a>, <a class="el" href="_target_8h_source.html#l00051">bits</a>, and <a class="el" href="struct_halide_1_1_target.html#aa2d0cedb02dc84eb7a9675df89f1d3ec">os</a>.</p>

</div>
</div>
<a class="anchor" id="a2d02d1fc5b8b3a38ba48316519b389c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00225">225</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_target.html#a000e35902bb5bcb26cea9955c87c4894">get_runtime_compatible_target()</a>, <a class="el" href="_target_8h_source.html#l00260">natural_vector_size()</a>, and <a class="el" href="struct_halide_1_1_target.html#a5cbea5be66f9dbe6bc1d75ff0691b6b1">to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a000e35902bb5bcb26cea9955c87c4894"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::get_runtime_compatible_target </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a "greatest common denominator" runtime target that is compatible with both this target and <code>other</code>. </p>
<p>Used by generators to conveniently select a suitable runtime when linking together multiple functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">other</td><td>The other target from which we compute the gcd target. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The gcd target if we return true, otherwise unmodified. Can be the same as *this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether it was possible to find a compatible target (true) or not. </dd></dl>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00225">operator!=()</a>.</p>

</div>
</div>
<a class="anchor" id="a5cbea5be66f9dbe6bc1d75ff0691b6b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Target::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> into a string form that can be reconstituted by merge_string(), which will always be of the form. </p>
<p>arch-bits-os-feature1-feature2...featureN.</p>
<p>Note that is guaranteed that <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>(t1.to_string()) == t1, but not that Target(s).<a class="el" href="struct_halide_1_1_target.html#a5cbea5be66f9dbe6bc1d75ff0691b6b1" title="Convert the Target into a string form that can be reconstituted by merge_string(), which will always be of the form. ">to_string()</a> == s (since there can be multiple strings that parse to the same <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>)... <em>unless</em> t1 contains 'unknown' fields (in which case you'll get a string that can't be parsed, which is intentional). </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a21">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="simd__op__check_8h_source.html#l00130">Halide::SimdOpCheckTest::check_one()</a>, and <a class="el" href="_target_8h_source.html#l00225">operator!=()</a>.</p>

</div>
</div>
<a class="anchor" id="a5fcd948b0b269988478d526ff9a4cb1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::natural_vector_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

</div>
</div>
<a class="anchor" id="a0ef57e03c4031aa9105ab037e074cad4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::natural_vector_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00260">260</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00225">operator!=()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ba4941fc8dd4993c2b3f95b355352eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::has_large_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff 64 bits and has_feature(LargeBuffers). </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00265">265</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_target.html#acbbcbe93a4d5ee7f9f93c6b3d7914bf3">has_feature()</a>, and <a class="el" href="_target_8h_source.html#l00094">LargeBuffers</a>.</p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00272">maximum_buffer_size()</a>.</p>

</div>
</div>
<a class="anchor" id="a987059e686d9665d6c63441a21e0ffe2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> Halide::Target::maximum_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum buffer size in bytes supported on this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>
<p>This is 2^31 - 1 except on 64-bit targets when the LargeBuffers feature is enabled, which expands the maximum to 2^63 - 1. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00272">272</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_target.html#a5fac5e03833403a92e629544bb5918d4">get_cuda_capability_lower_bound()</a>, <a class="el" href="_target_8h_source.html#l00265">has_large_buffers()</a>, and <a class="el" href="struct_halide_1_1_target.html#ace49d3d1390937c3fa82476fe411a5db">supported()</a>.</p>

</div>
</div>
<a class="anchor" id="a5fac5e03833403a92e629544bb5918d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::get_cuda_capability_lower_bound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum cuda capability found as an integer. </p>
<p>Returns 20 (our minimum supported cuda compute capability) if no cuda features are set. </p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00272">maximum_buffer_size()</a>.</p>

</div>
</div>
<a class="anchor" id="ace49d3d1390937c3fa82476fe411a5db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::supported </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Was libHalide compiled with support for this target? </p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00272">maximum_buffer_size()</a>.</p>

</div>
</div>
<a class="anchor" id="acbb63f14ed3eed059fba247ab843d6cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::bitset&lt;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa17b9cbfef8d1e84e32c8aaa7b2936dbc">FeatureEnd</a>&gt;&amp; Halide::Target::get_features_bitset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a bitset of the Featuress set in this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> (set = 1). </p>
<p>Note that while this happens to be the current internal representation, that might not always be the case. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00291">291</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_target.html#a2e26b5f9fca8f1bcf142709f12f5f934">feature_from_name()</a>, <a class="el" href="struct_halide_1_1_target.html#a2c3292b77bf4aad3917aa27c7c9cb86c">feature_to_name()</a>, <a class="el" href="namespace_halide.html#a0ae94266acfeba1bce3298e333ba4b8c">Halide::get_host_target()</a>, <a class="el" href="namespace_halide.html#a9d2cf046902155db63e83374f23a47b5">Halide::get_jit_target_from_environment()</a>, <a class="el" href="namespace_halide.html#ab25236e75d4d73bee045028da680215d">Halide::get_target_from_environment()</a>, <a class="el" href="namespace_halide.html#a172db5c21e58bfed0793b7152657623caafbf0897a5a83fdd873dfb032ec695d3">Halide::Internal</a>, <a class="el" href="namespace_halide.html#a8ab19de8fa28eb2396a0b8d40c338491">Halide::target_feature_for_device_api()</a>, and <a class="el" href="namespace_halide_1_1_internal.html#ae0ca85eaf8baf3957bda33b83b20c694">Halide::Internal::target_test()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c3292b77bf4aad3917aa27c7c9cb86c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string Halide::Target::feature_to_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Target::Feature</a>&#160;</td>
          <td class="paramname"><em>feature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the name corresponding to a given Feature, in the form used to construct <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> strings (e.g., Feature::Debug is "debug" and not "Debug"). </p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00291">get_features_bitset()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e26b5f9fca8f1bcf142709f12f5f934"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Target::Feature</a> Halide::Target::feature_from_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the feature corresponding to a given name, in the form used to construct <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> strings (e.g., Feature::Debug is "debug" and not "Debug"). </p>
<p>If the string is not a known feature name, return FeatureEnd. </p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00291">get_features_bitset()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa2d0cedb02dc84eb7a9675df89f1d3ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">Halide::Target::OS</a>  Halide::Target::os</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a8">tutorial/lesson_11_cross_compilation.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a23">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="simd__op__check_8h_source.html#l00063">Halide::SimdOpCheckTest::can_run_code()</a>, <a class="el" href="_external_code_8h_source.html#l00102">Halide::ExternalCode::is_for_cpu_target()</a>, and <a class="el" href="_target_8h_source.html#l00218">operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a53d1006f89ed385a62cf9e2e5a4fe5a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Halide::Target::Arch</a>  Halide::Target::arch</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a10">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="simd__op__check_8h_source.html#l00063">Halide::SimdOpCheckTest::can_run_code()</a>, <a class="el" href="_external_code_8h_source.html#l00102">Halide::ExternalCode::is_for_cpu_target()</a>, and <a class="el" href="_target_8h_source.html#l00218">operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a72366c6d01ef023ff3b2801017779e32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::bits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The bit-width of the target machine. </p>
<p>Must be 0 for unknown, or 32 or 64. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a12">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_target_8h_source.html#l00051">51</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>Referenced by <a class="el" href="simd__op__check_8h_source.html#l00063">Halide::SimdOpCheckTest::can_run_code()</a>, <a class="el" href="_external_code_8h_source.html#l00102">Halide::ExternalCode::is_for_cpu_target()</a>, and <a class="el" href="_target_8h_source.html#l00218">operator==()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/halidenightly/build_bot/worker/x86-64-linux-1000-cmake/halide/src/<a class="el" href="_target_8h_source.html">Target.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="struct_halide_1_1_target.html">Target</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
