<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: Halide::Target Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('struct_halide_1_1_target.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_halide_1_1_target-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Target Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A struct representing a target machine and os to generate code for.  
 <a href="struct_halide_1_1_target.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_target_8h_source.html">Target.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af2b0caf9e5badd6a8ebe22493752df20"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">OS</a> { <br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20a22c6a2fea606af61fa20b1ad6548ff29">OSUnknown</a> = 0, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20af58b4735f0d8e76502ef70fe11d548d4">Linux</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20a33d246944800a2b478899132d76a95b2">Windows</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20acef0ce22d32cc53d0f72df159f62b691">OSX</a>, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20a5c630f5107a5a01870143d6dc042ea8c">Android</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20aae1a309042fed9d4369e831047a55447">IOS</a>, 
<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20a9a87c261ea02f280b2357b893b7f7725">NaCl</a>
<br/>
 }</td></tr>
<tr class="memdesc:af2b0caf9e5badd6a8ebe22493752df20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operating system used by the target.  <a href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">More...</a><br/></td></tr>
<tr class="separator:af2b0caf9e5badd6a8ebe22493752df20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17585cfd5ec92952fd361117d89d4b1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Arch</a> { <br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1ae6d33003db3020c4c578c645239f2973">ArchUnknown</a> = 0, 
<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1aba7faedbdb35e2ef2927e248c687a391">X86</a>, 
<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1a1c5f188b9b8eb5ffd951917bbbdd85f2">ARM</a>, 
<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1a7a929ec3b88d34ff832d2446c6f96a15">PNaCl</a>, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1a93b7e567e560c4e8275e8f1bab214d85">MIPS</a>
<br/>
 }</td></tr>
<tr class="memdesc:af17585cfd5ec92952fd361117d89d4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The architecture used by the target.  <a href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">More...</a><br/></td></tr>
<tr class="separator:af17585cfd5ec92952fd361117d89d4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9398276edd5784185e1a08f8a4dfc43f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> { <br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fac04af3ed2dc70791a8ba8f793a746b30">JIT</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf3cc1f2941a6b4df016ac08e68b9c660">Debug</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa1fc53f322ecd95ae65274a9f16c71ac2">NoAsserts</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa6f7593c40bf078bf7906ea1c391bcd80">NoBoundsQuery</a>, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf6ada84d24838f818391b465b9a94165">SSE41</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa620c10914ea92a26c16878ab73933b2b">AVX</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fad7b64a080d84e2145fd219e9f7a33547">AVX2</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa9764990d6a6294a8a23f8fb6598c2c88">FMA</a>, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa6ba1375f5f5982d91779173b71542e5f">FMA4</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fafc9c513f157e362fa6851a66e5d2aa90">F16C</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faf37c16007f6547612713259e648cc41e">ARMv7s</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fabfd3f02d7bd5f8e2d251a62f465ebcfb">CUDA</a>, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faae6f2116a68aa9477888010a605ec0a5">CUDACapability30</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa770a75467c600c8ce9a5efa476776742">CUDACapability32</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa15c6f4c8ec0241c9f34f303670c18af3">CUDACapability35</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa027631ce082530506684842b44123b8a">CUDACapability50</a>, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa84c6211e4fb941603f6104e98427d7e5">OpenCL</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43faa371c9fa5610dc3a9efbb3fde547a719">CLDoubles</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa491aa42775c6c9d6f35f784e86b09abc">OpenGL</a>, 
<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fab7dbd399d2a833d37bd52451f99c50c1">UserContext</a>, 
<br/>
&#160;&#160;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43fa17b9cbfef8d1e84e32c8aaa7b2936dbc">FeatureEnd</a>
<br/>
 }</td></tr>
<tr class="memdesc:a9398276edd5784185e1a08f8a4dfc43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional features a target can have.  <a href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">More...</a><br/></td></tr>
<tr class="separator:a9398276edd5784185e1a08f8a4dfc43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb11109583253fe6e358bba73d3e4a86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aeb11109583253fe6e358bba73d3e4a86">Target</a> ()</td></tr>
<tr class="separator:aeb11109583253fe6e358bba73d3e4a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849870678f8ce67d10f84a0097b9eb09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a849870678f8ce67d10f84a0097b9eb09">Target</a> (<a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">OS</a> o, <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Arch</a> a, int b, std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; initial_features=std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;())</td></tr>
<tr class="separator:a849870678f8ce67d10f84a0097b9eb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab667943ebf46b2da858370e44eae124d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ab667943ebf46b2da858370e44eae124d">set_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f, bool value=true)</td></tr>
<tr class="separator:ab667943ebf46b2da858370e44eae124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dddb1542193fca806cd9f0d9079ba32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a6dddb1542193fca806cd9f0d9079ba32">set_features</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; features_to_set, bool value=true)</td></tr>
<tr class="separator:a6dddb1542193fca806cd9f0d9079ba32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbcbe93a4d5ee7f9f93c6b3d7914bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#acbbcbe93a4d5ee7f9f93c6b3d7914bf3">has_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f) const </td></tr>
<tr class="separator:acbbcbe93a4d5ee7f9f93c6b3d7914bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3d3b016c13819515090e9a3a9e673f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a7a3d3b016c13819515090e9a3a9e673f">features_any_of</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; test_features) const </td></tr>
<tr class="separator:a7a3d3b016c13819515090e9a3a9e673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1f002f2b4899039558036e0a4276d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a6b1f002f2b4899039558036e0a4276d9">features_all_of</a> (std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt; test_features) const </td></tr>
<tr class="separator:a6b1f002f2b4899039558036e0a4276d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc1372f492ae82156f56792eccc6a64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aafc1372f492ae82156f56792eccc6a64">with_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f) const </td></tr>
<tr class="memdesc:aafc1372f492ae82156f56792eccc6a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the target with the given feature set.  <a href="#aafc1372f492ae82156f56792eccc6a64">More...</a><br/></td></tr>
<tr class="separator:aafc1372f492ae82156f56792eccc6a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52878468db5e366d04748ed6fc64cf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#ab52878468db5e366d04748ed6fc64cf5">without_feature</a> (<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> f) const </td></tr>
<tr class="memdesc:ab52878468db5e366d04748ed6fc64cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the target with the given feature cleared.  <a href="#ab52878468db5e366d04748ed6fc64cf5">More...</a><br/></td></tr>
<tr class="separator:ab52878468db5e366d04748ed6fc64cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653f58c7d0efbd7dac22cf239576a660"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a653f58c7d0efbd7dac22cf239576a660">has_gpu_feature</a> () const </td></tr>
<tr class="memdesc:a653f58c7d0efbd7dac22cf239576a660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is OpenCL or CUDA enabled in this target? I.e.  <a href="#a653f58c7d0efbd7dac22cf239576a660">More...</a><br/></td></tr>
<tr class="separator:a653f58c7d0efbd7dac22cf239576a660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052486b9b96e649b9311bcc00e0a9405"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a052486b9b96e649b9311bcc00e0a9405">operator==</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;other) const </td></tr>
<tr class="separator:a052486b9b96e649b9311bcc00e0a9405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d02d1fc5b8b3a38ba48316519b389c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a2d02d1fc5b8b3a38ba48316519b389c0">operator!=</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;other) const </td></tr>
<tr class="separator:a2d02d1fc5b8b3a38ba48316519b389c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902e58d463f8babb79f6263709d06f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a902e58d463f8babb79f6263709d06f01">to_string</a> () const </td></tr>
<tr class="memdesc:a902e58d463f8babb79f6263709d06f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> into a string form that can be reconstituted by <a class="el" href="struct_halide_1_1_target.html#a02c6fd99be575af8792a66777631c85b" title="Parse the contents of &#39;target&#39; and merge into &#39;this&#39;, replacing only the parts that are specified...">merge_string()</a>, which will always be of the form.  <a href="#a902e58d463f8babb79f6263709d06f01">More...</a><br/></td></tr>
<tr class="separator:a902e58d463f8babb79f6263709d06f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c6fd99be575af8792a66777631c85b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a02c6fd99be575af8792a66777631c85b">merge_string</a> (const std::string &amp;target)</td></tr>
<tr class="memdesc:a02c6fd99be575af8792a66777631c85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the contents of 'target' and merge into 'this', replacing only the parts that are specified.  <a href="#a02c6fd99be575af8792a66777631c85b">More...</a><br/></td></tr>
<tr class="separator:a02c6fd99be575af8792a66777631c85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407597a3202793e72c6a9907fe8fb2c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a407597a3202793e72c6a9907fe8fb2c7">from_string</a> (const std::string &amp;target)</td></tr>
<tr class="memdesc:a407597a3202793e72c6a9907fe8fb2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="struct_halide_1_1_target.html#a02c6fd99be575af8792a66777631c85b" title="Parse the contents of &#39;target&#39; and merge into &#39;this&#39;, replacing only the parts that are specified...">merge_string()</a>, but reset the contents of 'this' first.  <a href="#a407597a3202793e72c6a9907fe8fb2c7">More...</a><br/></td></tr>
<tr class="separator:a407597a3202793e72c6a9907fe8fb2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4855075b6ce0bb90bc981787c311a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a8d4855075b6ce0bb90bc981787c311a3">natural_vector_size</a> (<a class="el" href="struct_halide_1_1_type.html">Halide::Type</a> t) const </td></tr>
<tr class="memdesc:a8d4855075b6ce0bb90bc981787c311a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a8d4855075b6ce0bb90bc981787c311a3">More...</a><br/></td></tr>
<tr class="separator:a8d4855075b6ce0bb90bc981787c311a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef57e03c4031aa9105ab037e074cad4"><td class="memTemplParams" colspan="2">template&lt;typename data_t &gt; </td></tr>
<tr class="memitem:a0ef57e03c4031aa9105ab037e074cad4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a0ef57e03c4031aa9105ab037e074cad4">natural_vector_size</a> () const </td></tr>
<tr class="memdesc:a0ef57e03c4031aa9105ab037e074cad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>.  <a href="#a0ef57e03c4031aa9105ab037e074cad4">More...</a><br/></td></tr>
<tr class="separator:a0ef57e03c4031aa9105ab037e074cad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa2d0cedb02dc84eb7a9675df89f1d3ec"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">Halide::Target::OS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#aa2d0cedb02dc84eb7a9675df89f1d3ec">os</a></td></tr>
<tr class="separator:aa2d0cedb02dc84eb7a9675df89f1d3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d1006f89ed385a62cf9e2e5a4fe5a9"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Halide::Target::Arch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a53d1006f89ed385a62cf9e2e5a4fe5a9">arch</a></td></tr>
<tr class="separator:a53d1006f89ed385a62cf9e2e5a4fe5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72366c6d01ef023ff3b2801017779e32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_target.html#a72366c6d01ef023ff3b2801017779e32">bits</a></td></tr>
<tr class="memdesc:a72366c6d01ef023ff3b2801017779e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit-width of the target machine.  <a href="#a72366c6d01ef023ff3b2801017779e32">More...</a><br/></td></tr>
<tr class="separator:a72366c6d01ef023ff3b2801017779e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A struct representing a target machine and os to generate code for. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#_a7">tutorial/lesson_11_cross_compilation.cpp</a>, and <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#_a7">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_target_8h_source.html#l00024">24</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">Halide::Target::OS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The operating system used by the target. </p>
<p>Determines which system calls to generate. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a22c6a2fea606af61fa20b1ad6548ff29"></a>OSUnknown</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20af58b4735f0d8e76502ef70fe11d548d4"></a>Linux</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a33d246944800a2b478899132d76a95b2"></a>Windows</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20acef0ce22d32cc53d0f72df159f62b691"></a>OSX</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a5c630f5107a5a01870143d6dc042ea8c"></a>Android</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20aae1a309042fed9d4369e831047a55447"></a>IOS</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af2b0caf9e5badd6a8ebe22493752df20a9a87c261ea02f280b2357b893b7f7725"></a>NaCl</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00027">27</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Halide::Target::Arch</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The architecture used by the target. </p>
<p>Determines the instruction set to use. For the PNaCl target, the "instruction
set" is actually llvm bitcode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1ae6d33003db3020c4c578c645239f2973"></a>ArchUnknown</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1aba7faedbdb35e2ef2927e248c687a391"></a>X86</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a1c5f188b9b8eb5ffd951917bbbdd85f2"></a>ARM</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a7a929ec3b88d34ff832d2446c6f96a15"></a>PNaCl</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af17585cfd5ec92952fd361117d89d4b1a93b7e567e560c4e8275e8f1bab214d85"></a>MIPS</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00032">32</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Halide::Target::Feature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional features a target can have. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fac04af3ed2dc70791a8ba8f793a746b30"></a>JIT</em>&#160;</td><td class="fielddoc">
<p>Generate code that will run immediately inside the calling process. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf3cc1f2941a6b4df016ac08e68b9c660"></a>Debug</em>&#160;</td><td class="fielddoc">
<p>Turn on debug info and output for runtime code. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa1fc53f322ecd95ae65274a9f16c71ac2"></a>NoAsserts</em>&#160;</td><td class="fielddoc">
<p>Disable all runtime checks, for slightly tighter code. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa6f7593c40bf078bf7906ea1c391bcd80"></a>NoBoundsQuery</em>&#160;</td><td class="fielddoc">
<p>Disable the bounds querying functionality. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf6ada84d24838f818391b465b9a94165"></a>SSE41</em>&#160;</td><td class="fielddoc">
<p>Use SSE 4.1 and earlier instructions. Only relevant on x86. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa620c10914ea92a26c16878ab73933b2b"></a>AVX</em>&#160;</td><td class="fielddoc">
<p>Use AVX 1 instructions. Only relevant on x86. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fad7b64a080d84e2145fd219e9f7a33547"></a>AVX2</em>&#160;</td><td class="fielddoc">
<p>Use AVX 2 instructions. Only relevant on x86. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa9764990d6a6294a8a23f8fb6598c2c88"></a>FMA</em>&#160;</td><td class="fielddoc">
<p>Enable x86 FMA instruction. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa6ba1375f5f5982d91779173b71542e5f"></a>FMA4</em>&#160;</td><td class="fielddoc">
<p>Enable x86 (AMD) FMA4 instruction set. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fafc9c513f157e362fa6851a66e5d2aa90"></a>F16C</em>&#160;</td><td class="fielddoc">
<p>Enable x86 16-bit float support. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faf37c16007f6547612713259e648cc41e"></a>ARMv7s</em>&#160;</td><td class="fielddoc">
<p>Generate code for ARMv7s. Only relevant for 32-bit ARM. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fabfd3f02d7bd5f8e2d251a62f465ebcfb"></a>CUDA</em>&#160;</td><td class="fielddoc">
<p>Enable the CUDA runtime. Defaults to compute capability 2.0 (Fermi) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faae6f2116a68aa9477888010a605ec0a5"></a>CUDACapability30</em>&#160;</td><td class="fielddoc">
<p>Enable CUDA compute capability 3.0 (Kepler) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa770a75467c600c8ce9a5efa476776742"></a>CUDACapability32</em>&#160;</td><td class="fielddoc">
<p>Enable CUDA compute capability 3.2 (Tegra K1) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa15c6f4c8ec0241c9f34f303670c18af3"></a>CUDACapability35</em>&#160;</td><td class="fielddoc">
<p>Enable CUDA compute capability 3.5 (Kepler) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa027631ce082530506684842b44123b8a"></a>CUDACapability50</em>&#160;</td><td class="fielddoc">
<p>Enable CUDA compute capability 5.0 (Maxwell) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa84c6211e4fb941603f6104e98427d7e5"></a>OpenCL</em>&#160;</td><td class="fielddoc">
<p>Enable the OpenCL runtime. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43faa371c9fa5610dc3a9efbb3fde547a719"></a>CLDoubles</em>&#160;</td><td class="fielddoc">
<p>Enable double support on OpenCL targets. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa491aa42775c6c9d6f35f784e86b09abc"></a>OpenGL</em>&#160;</td><td class="fielddoc">
<p>Enable the OpenGL runtime. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fab7dbd399d2a833d37bd52451f99c50c1"></a>UserContext</em>&#160;</td><td class="fielddoc">
<p>Generated code takes a user_context pointer as first argument. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9398276edd5784185e1a08f8a4dfc43fa17b9cbfef8d1e84e32c8aaa7b2936dbc"></a>FeatureEnd</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00038">38</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeb11109583253fe6e358bba73d3e4a86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Target::Target </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00071">71</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00195">from_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a849870678f8ce67d10f84a0097b9eb09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Target::Target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">OS</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Arch</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;&#160;</td>
          <td class="paramname"><em>initial_features</em> = <code>std::vector&lt;<a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00072">72</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00079">set_feature()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab667943ebf46b2da858370e44eae124d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Target::set_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#a9">tutorial/lesson_12_using_the_gpu.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_target_8h_source.html#l00079">79</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00066">FeatureEnd</a>, and <a class="el" href="_error_8h_source.html#l00150">user_assert</a>.</p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00084">set_features()</a>, <a class="el" href="_target_8h_source.html#l00072">Target()</a>, <a class="el" href="_target_8h_source.html#l00121">with_feature()</a>, and <a class="el" href="_target_8h_source.html#l00131">without_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="a6dddb1542193fca806cd9f0d9079ba32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Target::set_features </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;&#160;</td>
          <td class="paramname"><em>features_to_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a13">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_target_8h_source.html#l00084">84</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00079">set_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="acbbcbe93a4d5ee7f9f93c6b3d7914bf3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::has_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00090">90</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00066">FeatureEnd</a>, and <a class="el" href="_error_8h_source.html#l00150">user_assert</a>.</p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00141">has_gpu_feature()</a>, and <a class="el" href="_target_8h_source.html#l00202">natural_vector_size()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a3d3b016c13819515090e9a3a9e673f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::features_any_of </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;&#160;</td>
          <td class="paramname"><em>test_features</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00095">95</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00066">FeatureEnd</a>, and <a class="el" href="_error_8h_source.html#l00150">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="a6b1f002f2b4899039558036e0a4276d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::features_all_of </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a> &gt;&#160;</td>
          <td class="paramname"><em>test_features</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00106">106</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00066">FeatureEnd</a>, and <a class="el" href="_error_8h_source.html#l00150">user_assert</a>.</p>

</div>
</div>
<a class="anchor" id="aafc1372f492ae82156f56792eccc6a64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::Target::with_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the target with the given feature set. </p>
<p>This is convenient when enabling certain features (e.g. NoBoundsQuery) in an initialization list, where the target to be mutated may be a const reference. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00121">121</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00079">set_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="ab52878468db5e366d04748ed6fc64cf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_target.html">Target</a> Halide::Target::without_feature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_target.html#a9398276edd5784185e1a08f8a4dfc43f">Feature</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a copy of the target with the given feature cleared. </p>
<p>This is convenient when disabling certain features (e.g. NoBoundsQuery) in an initialization list, where the target to be mutated may be a const reference. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00131">131</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00079">set_feature()</a>.</p>

</div>
</div>
<a class="anchor" id="a653f58c7d0efbd7dac22cf239576a660"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::has_gpu_feature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is OpenCL or CUDA enabled in this target? I.e. </p>
<p>is <a class="el" href="class_halide_1_1_func.html#a5f5fc7359a2ca66e557a9f129088c223" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">Func::gpu_tile</a> and similar going to work? We do not include OpenGL, because it is not capable of gpgpu, and is not scheduled via <a class="el" href="class_halide_1_1_func.html#a5f5fc7359a2ca66e557a9f129088c223" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">Func::gpu_tile</a>. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00141">141</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00053">CUDA</a>, <a class="el" href="_target_8h_source.html#l00090">has_feature()</a>, and <a class="el" href="_target_8h_source.html#l00059">OpenCL</a>.</p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l01881">Halide::evaluate_may_gpu()</a>.</p>

</div>
</div>
<a class="anchor" id="a052486b9b96e649b9311bcc00e0a9405"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00145">145</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_target.html#a53d1006f89ed385a62cf9e2e5a4fe5a9">arch</a>, <a class="el" href="_target_8h_source.html#l00035">bits</a>, and <a class="el" href="struct_halide_1_1_target.html#aa2d0cedb02dc84eb7a9675df89f1d3ec">os</a>.</p>

</div>
</div>
<a class="anchor" id="a2d02d1fc5b8b3a38ba48316519b389c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Target::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_target_8h_source.html#l00152">152</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<a class="anchor" id="a902e58d463f8babb79f6263709d06f01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::string Halide::Target::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> into a string form that can be reconstituted by <a class="el" href="struct_halide_1_1_target.html#a02c6fd99be575af8792a66777631c85b" title="Parse the contents of &#39;target&#39; and merge into &#39;this&#39;, replacing only the parts that are specified...">merge_string()</a>, which will always be of the form. </p>
<p>arch-bits-os-feature1-feature2...featureN.</p>
<p>Note that is guaranteed that t2.from_string(t1.to_string()) == t1, but not that from_string(s).<a class="el" href="struct_halide_1_1_target.html#a902e58d463f8babb79f6263709d06f01" title="Convert the Target into a string form that can be reconstituted by merge_string(), which will always be of the form. ">to_string()</a> == s (since there can be multiple strings that parse to the same <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>)... <em>unless</em> t1 contains 'unknown' fields (in which case you'll get a string that can't be parsed, which is intentional). </p>

</div>
</div>
<a class="anchor" id="a02c6fd99be575af8792a66777631c85b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Target::merge_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the contents of 'target' and merge into 'this', replacing only the parts that are specified. </p>
<p>(e.g., if 'target' specifies only an arch, only the arch field of 'this' will be changed, leaving the other fields untouched). Any features specified in 'target' are added to 'this', whether or not originally present.</p>
<p>If the string contains unknown tokens, or multiple tokens of the same category (e.g. multiple arch values), return false (possibly leaving 'this' munged). (Multiple feature specifications will not cause a failure.)</p>
<p>If 'target' contains "host" as the first token, it replaces the entire contents of 'this' with <a class="el" href="namespace_halide.html#a4fb1734eaadb362e875519e6ab68158e" title="Return the target corresponding to the host machine. ">get_host_target()</a>, then proceeds to parse the remaining tokens (allowing for things like "host-opencl" to mean "host configuration, but with opencl added").</p>
<p>Note that unlike parse_from_string(), this will never print to cerr or assert in the event of a parse failure. Note also that an empty target string is essentially a no-op, leaving 'this' unaffected. </p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00195">from_string()</a>.</p>

</div>
</div>
<a class="anchor" id="a407597a3202793e72c6a9907fe8fb2c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Target::from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="struct_halide_1_1_target.html#a02c6fd99be575af8792a66777631c85b" title="Parse the contents of &#39;target&#39; and merge into &#39;this&#39;, replacing only the parts that are specified...">merge_string()</a>, but reset the contents of 'this' first. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00195">195</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="struct_halide_1_1_target.html#a02c6fd99be575af8792a66777631c85b">merge_string()</a>, and <a class="el" href="_target_8h_source.html#l00071">Target()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d4855075b6ce0bb90bc981787c311a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::natural_vector_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_type.html">Halide::Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00202">202</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>References <a class="el" href="_target_8h_source.html#l00045">AVX</a>, <a class="el" href="_target_8h_source.html#l00046">AVX2</a>, <a class="el" href="_type_8h_source.html#l00030">Halide::Type::bits</a>, <a class="el" href="_target_8h_source.html#l00090">has_feature()</a>, <a class="el" href="_type_8h_source.html#l00051">Halide::Type::is_int()</a>, and <a class="el" href="_type_8h_source.html#l00054">Halide::Type::is_uint()</a>.</p>

</div>
</div>
<a class="anchor" id="a0ef57e03c4031aa9105ab037e074cad4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::natural_vector_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a data type, return an estimate of the "natural" vector size for that data type when compiling for this <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a>. </p>

<p>Definition at line <a class="el" href="_target_8h_source.html#l00220">220</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa2d0cedb02dc84eb7a9675df89f1d3ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af2b0caf9e5badd6a8ebe22493752df20">Halide::Target::OS</a>  Halide::Target::os</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a8">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="_target_8h_source.html#l00145">operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a53d1006f89ed385a62cf9e2e5a4fe5a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_halide_1_1_target.html#af17585cfd5ec92952fd361117d89d4b1">Halide::Target::Arch</a>  Halide::Target::arch</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a10">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="_target_8h_source.html#l00145">operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a72366c6d01ef023ff3b2801017779e32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Halide::Target::bits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The bit-width of the target machine. </p>
<p>Must be 0 for unknown, or 32 or 64. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_11_cross_compilation_8cpp-example.html#a12">tutorial/lesson_11_cross_compilation.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_target_8h_source.html#l00035">35</a> of file <a class="el" href="_target_8h_source.html">Target.h</a>.</p>

<p>Referenced by <a class="el" href="_target_8h_source.html#l00145">operator==()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_target_8h_source.html">Target.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="struct_halide_1_1_target.html">Target</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
