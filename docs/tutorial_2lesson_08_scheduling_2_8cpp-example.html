<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Halide: tutorial/lesson_08_scheduling_2.cpp</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('tutorial_2lesson_08_scheduling_2_8cpp-example.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">tutorial/lesson_08_scheduling_2.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><span class="comment">// Halide tutorial lesson 8</span>

<span class="comment">// This lesson demonstrates how schedule multi-stage pipelines.</span>

<span class="comment">// On linux, you can compile and run it like so:</span>
<span class="comment">// g++ lesson_08*.cpp -g -I ../include -L ../bin -lHalide -lpthread -ldl -o lesson_08</span>
<span class="comment">// LD_LIBRARY_PATH=../bin ./lesson_08</span>

<span class="comment">// On os x:</span>
<span class="comment">// g++ lesson_08*.cpp -g -I ../include -L ../bin -lHalide -o lesson_08</span>
<span class="comment">// DYLD_LIBRARY_PATH=../bin ./lesson_08</span>

<span class="preprocessor">#include &lt;Halide.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>

<span class="keyword">using namespace </span>Halide;

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
    <span class="comment">// First we&#39;ll declare some Vars to use below.</span>
    <a name="_a0"></a><a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);

    <span class="comment">// Let&#39;s examine various scheduling options for a simple two stage</span>
    <span class="comment">// pipeline. We&#39;ll start with the default schedule:</span>
    {
        <a name="_a1"></a><a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer(<span class="stringliteral">&quot;producer_default&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_default&quot;</span>);

        <span class="comment">// The first stage will be some simple pointwise math similar</span>
        <span class="comment">// to our familiar gradient function. The value at position x,</span>
        <span class="comment">// y is the sqrt of product of x and y.</span>
        producer(x, y) = <a name="a2"></a><a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(x * y);

        <span class="comment">// Now we&#39;ll add a second stage which adds together multiple</span>
        <span class="comment">// points in the first stage.</span>
        consumer(x, y) = (producer(x, y) +
                          producer(x, y+1) +
                          producer(x+1, y) +
                          producer(x+1, y+1));

        <span class="comment">// We&#39;ll turn on tracing for both functions.</span>
        consumer.<a name="a3"></a><a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();
        producer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        <span class="comment">// And evaluate it over a 5x5 box.</span>
        printf(<span class="stringliteral">&quot;\nEvaluating producer-consumer pipeline with default schedule\n&quot;</span>);
        consumer.<a name="a4"></a><a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        <span class="comment">// There were no messages about computing values of the</span>
        <span class="comment">// producer. This is because the default schedule fully</span>
        <span class="comment">// inlines &#39;producer&#39; into &#39;consumer&#39;. It is as if we had</span>
        <span class="comment">// written the following code instead:</span>

        <span class="comment">// consumer(x, y) = (sqrt(x * y) +</span>
        <span class="comment">//                   sqrt(x * (y + 1)) +</span>
        <span class="comment">//                   sqrt((x + 1) * y) +</span>
        <span class="comment">//                   sqrt((x + 1) * (y + 1)));</span>

        <span class="comment">// All calls to &#39;producer&#39; have been replaced with the body of</span>
        <span class="comment">// &#39;producer&#39;, with the arguments subtituted in for the</span>
        <span class="comment">// variables.</span>

        <span class="comment">// The equivalent C code is:</span>
        <span class="keywordtype">float</span> result[4][4];
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {
                result[y][x] = (<a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(x*y) +
                                <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(x*(y+1)) +
                                <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>((x+1)*y) +
                                <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>((x+1)*(y+1)));
            }
        }
        printf(<span class="stringliteral">&quot;\n&quot;</span>);
    }

    <span class="comment">// Next we&#39;ll examine the next simplest option - computing all</span>
    <span class="comment">// values required in the producer before computing any of the</span>
    <span class="comment">// consumer. We call this schedule &quot;root&quot;.</span>
    {
        <span class="comment">// Start with the same function definitions:</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer(<span class="stringliteral">&quot;producer_root&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_root&quot;</span>);
        producer(x, y) = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(x * y);
        consumer(x, y) = (producer(x, y) +
                          producer(x, y+1) +
                          producer(x+1, y) +
                          producer(x+1, y+1));

        <span class="comment">// Tell Halide to evaluate all of producer before any of consumer.</span>
        producer.<a name="a5"></a><a class="code" href="class_halide_1_1_func.html#a7f4db7e4884fe76399bf2a673567eab5" title="Compute all of this function once ahead of time.">compute_root</a>();

        <span class="comment">// Turn on tracing.</span>
        consumer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();
        producer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        <span class="comment">// Compile and run.</span>
        printf(<span class="stringliteral">&quot;\nEvaluating producer.compute_root()\n&quot;</span>);
        consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        <span class="comment">// Reading the output we can see that:</span>
        <span class="comment">// A) There were stores to producer.</span>
        <span class="comment">// B) They all happened before any stores to consumer.</span>


        <span class="comment">// Equivalent C:</span>

        <span class="keywordtype">float</span> result[4][4];

        <span class="comment">// Allocate some temporary storage for the producer.</span>
        <span class="keywordtype">float</span> producer_storage[5][5];

        <span class="comment">// Compute the producer.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 5; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 5; x++) {
                producer_storage[y][x] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(x * y);
            }
        }

        <span class="comment">// Compute the consumer. Skip the prints this time.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {
                result[y][x] = (producer_storage[y][x] +
                                producer_storage[y+1][x] +
                                producer_storage[y][x+1] +
                                producer_storage[y+1][x+1]);
            }
        }

        <span class="comment">// Note that consumer was evaluated over a 4x4 box, so Halide</span>
        <span class="comment">// automatically inferred that producer was needed over a 5x5</span>
        <span class="comment">// box. This is the same &#39;bounds inference&#39; logic we saw in</span>
        <span class="comment">// the previous lesson, where it was used to detect and avoid</span>
        <span class="comment">// out-of-bounds reads from an input image.</span>
    }

    <span class="comment">// Let&#39;s compare the two approaches above from a performance</span>
    <span class="comment">// perspective.</span>

    <span class="comment">// Full inlining (the default schedule):</span>
    <span class="comment">// - Temporary memory allocated: 0</span>
    <span class="comment">// - Loads: 0</span>
    <span class="comment">// - Stores: 16</span>
    <span class="comment">// - Calls to sqrt: 64</span>

    <span class="comment">// producer.compute_root():</span>
    <span class="comment">// - Temporary memory allocated: 25 floats</span>
    <span class="comment">// - Loads: 64</span>
    <span class="comment">// - Stores: 39</span>
    <span class="comment">// - Calls to sqrt: 25</span>

    <span class="comment">// There&#39;s a trade-off here. Full inlining used minimal temporary</span>
    <span class="comment">// memory and memory bandwidth, but did a whole bunch of redundant</span>
    <span class="comment">// expensive math (calling sqrt). It evaluated most points in</span>
    <span class="comment">// &#39;producer&#39; four times. The second schedule,</span>
    <span class="comment">// producer.compute_root(), did the mimimum number of calls to</span>
    <span class="comment">// sqrt, but used more temporary memory and more memory bandwidth.</span>

    <span class="comment">// In any given situation the correct choice can be difficult to</span>
    <span class="comment">// make. If you&#39;re memory-bandwidth limited, or don&#39;t have much</span>
    <span class="comment">// memory (e.g. because you&#39;re running on an old cell-phone), then</span>
    <span class="comment">// it can make sense to do redundant math. On the other hand, sqrt</span>
    <span class="comment">// is expensive, so if you&#39;re compute-limited then fewer calls to</span>
    <span class="comment">// sqrt will make your program faster. Adding vectorization or</span>
    <span class="comment">// multi-core parallelism tilts the scales in favor of doing</span>
    <span class="comment">// redundant work, because firing up multiple cpu cores increases</span>
    <span class="comment">// the amount of math you can do per second, but doesn&#39;t increase</span>
    <span class="comment">// your system memory bandwidth or capacity.</span>

    <span class="comment">// We can make choices in between full inlining and</span>
    <span class="comment">// compute_root. Next we&#39;ll alternate between computing the</span>
    <span class="comment">// producer and consumer on a per-scanline basis:</span>
    {
        <span class="comment">// Start with the same function definitions:</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer(<span class="stringliteral">&quot;producer_y&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_y&quot;</span>);
        producer(x, y) = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(x * y);
        consumer(x, y) = (producer(x, y) +
                          producer(x, y+1) +
                          producer(x+1, y) +
                          producer(x+1, y+1));

        <span class="comment">// Tell Halide to evaluate producer as needed per y coordinate</span>
        <span class="comment">// of the consumer:</span>
        producer.<a name="a6"></a><a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(consumer, y);

        <span class="comment">// This places the code that computes the producer just</span>
        <span class="comment">// *inside* the consumer&#39;s for loop over y, as in the</span>
        <span class="comment">// equivalent C below.</span>

        <span class="comment">// Turn on tracing.</span>
        producer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();
        consumer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        <span class="comment">// Compile and run.</span>
        printf(<span class="stringliteral">&quot;\nEvaluating producer.compute_at(consumer, y)\n&quot;</span>);
        consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        <span class="comment">// Reading the log you should see that producer and consumer</span>
        <span class="comment">// alternate on a per-scanline basis. Let&#39;s look at the</span>
        <span class="comment">// equivalent C:</span>

        <span class="keywordtype">float</span> result[4][4];

        <span class="comment">// There&#39;s an outer loop over scanlines of consumer:</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {

            <span class="comment">// Allocate space and compute enough of the producer to</span>
            <span class="comment">// satisfy this single scanline of the consumer. This</span>
            <span class="comment">// means a 5x2 box of the producer.</span>
            <span class="keywordtype">float</span> producer_storage[2][5];
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y; py &lt; y + 2; py++) {
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> px = 0; px &lt; 5; px++) {
                    producer_storage[py-y][px] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(px * py);
                }
            }

            <span class="comment">// Compute a scanline of the consumer.</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {
                result[y][x] = (producer_storage[0][x] +
                                producer_storage[1][x] +
                                producer_storage[0][x+1] +
                                producer_storage[1][x+1]);
            }
        }

        <span class="comment">// The performance characteristics of this strategy are in</span>
        <span class="comment">// between inlining and compute root. We still allocate some</span>
        <span class="comment">// temporary memory, but less that compute_root, and with</span>
        <span class="comment">// better locality (we load from it soon after writing to it,</span>
        <span class="comment">// so for larger images, values should still be in cache). We</span>
        <span class="comment">// still do some redundant work, but less than full inlining:</span>

        <span class="comment">// producer.compute_at(consumer, y):</span>
        <span class="comment">// - Temporary memory allocated: 10 floats</span>
        <span class="comment">// - Loads: 64</span>
        <span class="comment">// - Stores: 56</span>
        <span class="comment">// - Calls to sqrt: 40</span>
    }

    <span class="comment">// We could also say producer.compute_at(consumer, x), but this</span>
    <span class="comment">// would be very similar to full inlining (the default</span>
    <span class="comment">// schedule). Instead let&#39;s distinguish between the loop level at</span>
    <span class="comment">// which we allocate storage for producer, and the loop level at</span>
    <span class="comment">// which we actually compute it. This unlocks a few optimizations.</span>
    {
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer(<span class="stringliteral">&quot;producer_store_root_compute_y&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_store_root_compute_y&quot;</span>);
        producer(x, y) = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(x * y);
        consumer(x, y) = (producer(x, y) +
                          producer(x, y+1) +
                          producer(x+1, y) +
                          producer(x+1, y+1));


        <span class="comment">// Tell Halide to make a buffer to store all of producer at</span>
        <span class="comment">// the outermost level:</span>
        producer.<a name="a7"></a><a class="code" href="class_halide_1_1_func.html#a7048eaf680bc0c78961c0bef48d37f85" title="Equivalent to Func::store_at, but schedules storage outside the outermost loop.">store_root</a>();
        <span class="comment">// ... but compute it as needed per y coordinate of the</span>
        <span class="comment">// consumer.</span>
        producer.<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(consumer, y);

        producer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();
        consumer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        printf(<span class="stringliteral">&quot;\nEvaluating producer.store_root().compute_at(consumer, y)\n&quot;</span>);
        consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        <span class="comment">// Reading the log you should see that producer and consumer</span>
        <span class="comment">// again alternate on a per-scanline basis. It computes a 5x2</span>
        <span class="comment">// box of the producer to satisfy the first scanline of the</span>
        <span class="comment">// consumer, but after that it only computes a 5x1 box of the</span>
        <span class="comment">// output for each new scanline of the consumer!</span>
        <span class="comment">//</span>
        <span class="comment">// Halide has detected that for all scanlines except for the</span>
        <span class="comment">// first, it can reuse the values already sitting in the</span>
        <span class="comment">// buffer we&#39;ve allocated for producer. Let&#39;s look at the</span>
        <span class="comment">// equivalent C:</span>

        <span class="keywordtype">float</span> result[4][4];

        <span class="comment">// producer.store_root() implies that storage goes here:</span>
        <span class="keywordtype">float</span> producer_storage[5][5];

        <span class="comment">// There&#39;s an outer loop over scanlines of consumer:</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {

            <span class="comment">// Compute enough of the producer to satisfy this scanline</span>
            <span class="comment">// of the consumer.</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y; py &lt; y + 2; py++) {

                <span class="comment">// Skip over rows of producer that we&#39;ve already</span>
                <span class="comment">// computed in a previous iteration.</span>
                <span class="keywordflow">if</span> (y &gt; 0 &amp;&amp; py == y) <span class="keywordflow">continue</span>;

                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> px = 0; px &lt; 5; px++) {
                    producer_storage[py][px] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(px * py);
                }
            }

            <span class="comment">// Compute a scanline of the consumer.</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {
                result[y][x] = (producer_storage[y][x] +
                                producer_storage[y+1][x] +
                                producer_storage[y][x+1] +
                                producer_storage[y+1][x+1]);
            }
        }

        <span class="comment">// The performance characteristics of this strategy are pretty</span>
        <span class="comment">// good! The numbers are similar compute_root, except locality</span>
        <span class="comment">// is better. We&#39;re doing the minimum number of sqrt calls,</span>
        <span class="comment">// and we load values soon after they are stored, so we&#39;re</span>
        <span class="comment">// probably making good use of the cache:</span>

        <span class="comment">// producer.store_root().compute_at(consumer, y):</span>
        <span class="comment">// - Temporary memory allocated: 10 floats</span>
        <span class="comment">// - Loads: 64</span>
        <span class="comment">// - Stores: 39</span>
        <span class="comment">// - Calls to sqrt: 25</span>

        <span class="comment">// Note that my claimed amount of memory allocated doesn&#39;t</span>
        <span class="comment">// match the reference C code. Halide is performing one more</span>
        <span class="comment">// optimization under the hood. It folds the storage for the</span>
        <span class="comment">// producer down into a circular buffer of two</span>
        <span class="comment">// scanlines. Equivalent C would actually look like this:</span>

        {
            <span class="comment">// Actually store 2 scanlines instead of 5</span>
            <span class="keywordtype">float</span> producer_storage[2][5];
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y; py &lt; y + 2; py++) {
                    <span class="keywordflow">if</span> (y &gt; 0 &amp;&amp; py == y) <span class="keywordflow">continue</span>;
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> px = 0; px &lt; 5; px++) {
                        <span class="comment">// Stores to producer_storage have their y coordinate bit-masked.</span>
                        producer_storage[py &amp; 1][px] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(px * py);
                    }
                }

                <span class="comment">// Compute a scanline of the consumer.</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {
                    <span class="comment">// Loads from producer_storage have their y coordinate bit-masked.</span>
                    result[y][x] = (producer_storage[y &amp; 1][x] +
                                    producer_storage[(y+1) &amp; 1][x] +
                                    producer_storage[y &amp; 1][x+1] +
                                    producer_storage[(y+1) &amp; 1][x+1]);
                }
            }
        }
    }

    <span class="comment">// We can do even better, by leaving the storage outermost, but</span>
    <span class="comment">// moving the computation into the innermost loop:</span>
    {
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer(<span class="stringliteral">&quot;producer_store_root_compute_y&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_store_root_compute_y&quot;</span>);
        producer(x, y) = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(x * y);
        consumer(x, y) = (producer(x, y) +
                          producer(x, y+1) +
                          producer(x+1, y) +
                          producer(x+1, y+1));


        <span class="comment">// Store outermost, compute innermost.</span>
        producer.<a class="code" href="class_halide_1_1_func.html#a7048eaf680bc0c78961c0bef48d37f85" title="Equivalent to Func::store_at, but schedules storage outside the outermost loop.">store_root</a>().<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(consumer, x);

        producer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();
        consumer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        printf(<span class="stringliteral">&quot;\nEvaluating producer.store_root().compute_at(consumer, x)\n&quot;</span>);
        consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        <span class="comment">// Reading the log, you should see that producer and consumer</span>
        <span class="comment">// now alternate on a per-pixel basis. Here&#39;s the equivalent C:</span>

        <span class="keywordtype">float</span> result[4][4];

        <span class="comment">// producer.store_root() implies that storage goes here, but</span>
        <span class="comment">// we can fold it down into a circular buffer of two</span>
        <span class="comment">// scanlines:</span>
        <span class="keywordtype">float</span> producer_storage[2][5];

        <span class="comment">// For every pixel of the consumer:</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {

                <span class="comment">// Compute enough of the producer to satisfy this</span>
                <span class="comment">// pixel of the consumer, but skip values that we&#39;ve</span>
                <span class="comment">// already computed:</span>
                <span class="keywordflow">if</span> (y == 0 &amp;&amp; x == 0)
                    producer_storage[y &amp; 1][x] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(x*y);
                <span class="keywordflow">if</span> (y == 0)
                    producer_storage[y &amp; 1][x+1] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>((x+1)*y);
                <span class="keywordflow">if</span> (x == 0)
                    producer_storage[(y+1) &amp; 1][x] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(x*(y+1));
                producer_storage[(y+1) &amp; 1][x+1] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>((x+1)*(y+1));

                result[y][x] = (producer_storage[y &amp; 1][x] +
                                producer_storage[(y+1) &amp; 1][x] +
                                producer_storage[y &amp; 1][x+1] +
                                producer_storage[(y+1) &amp; 1][x+1]);
            }
        }

        <span class="comment">// The performance characteristics of this strategy are the</span>
        <span class="comment">// best so far. One of the four values of the producer we need</span>
        <span class="comment">// is probably still sitting in a register, so I won&#39;t count</span>
        <span class="comment">// it as a load:</span>
        <span class="comment">// producer.store_root().compute_at(consumer, x):</span>
        <span class="comment">// - Temporary memory allocated: 10 floats</span>
        <span class="comment">// - Loads: 48</span>
        <span class="comment">// - Stores: 56</span>
        <span class="comment">// - Calls to sqrt: 40</span>
    }

    <span class="comment">// So what&#39;s the catch? Why not always do</span>
    <span class="comment">// producer.store_root().compute_at(consumer, x) for this type of</span>
    <span class="comment">// code?</span>
    <span class="comment">//</span>
    <span class="comment">// The answer is parallelism. In both of the previous two</span>
    <span class="comment">// strategies we&#39;ve assumed that values computed on previous</span>
    <span class="comment">// iterations are lying around for us to reuse. This assumes that</span>
    <span class="comment">// previous values of x or y happened earlier in time and have</span>
    <span class="comment">// finished. This is not true if you parallelize or vectorize</span>
    <span class="comment">// either loop. Darn. If you parallelize, Halide won&#39;t inject the</span>
    <span class="comment">// optimizations that skip work already done if there&#39;s a parallel</span>
    <span class="comment">// loop in between the store_at level and the compute_at level,</span>
    <span class="comment">// and won&#39;t fold the storage down into a circular buffer either,</span>
    <span class="comment">// which makes our store_root pointless.</span>

    <span class="comment">// We&#39;re running out of options. We can make new ones by</span>
    <span class="comment">// splitting. We can store_at or compute_at at the natural</span>
    <span class="comment">// variables of the consumer (x and y), or we can split x or y</span>
    <span class="comment">// into new inner and outer sub-variables and then schedule with</span>
    <span class="comment">// respect to those. We&#39;ll use this to express fusion in tiles:</span>
    {
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer(<span class="stringliteral">&quot;producer_store_root_compute_y&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_store_root_compute_y&quot;</span>);
        producer(x, y) = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(x * y);
        consumer(x, y) = (producer(x, y) +
                          producer(x, y+1) +
                          producer(x+1, y) +
                          producer(x+1, y+1));


        <span class="comment">// Tile the consumer using 2x2 tiles.</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x_outer, y_outer, x_inner, y_inner;
        consumer.<a name="a8"></a><a class="code" href="class_halide_1_1_func.html#ab15001cd4af9e8c2808f45ff53b81582" title="Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi...">tile</a>(x, y, x_outer, y_outer, x_inner, y_inner, 2, 2);

        <span class="comment">// Compute the producer per tile of the consumer</span>
        producer.<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(consumer, x_outer);

        <span class="comment">// Notice that I wrote my schedule starting from the end of</span>
        <span class="comment">// the pipeline (the consumer). This is because the schedule</span>
        <span class="comment">// for the producer refers to x_outer, which we introduced</span>
        <span class="comment">// when we tiled the consumer. You can write it in the other</span>
        <span class="comment">// order, but it tends to be harder to read.</span>

        <span class="comment">// Turn on tracing.</span>
        producer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();
        consumer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        printf(<span class="stringliteral">&quot;\nEvaluating:\n&quot;</span>
               <span class="stringliteral">&quot;consumer.tile(x, y, x_outer, y_outer, x_inner, y_inner, 2, 2);\n&quot;</span>
               <span class="stringliteral">&quot;producer.compute_at(consumer, x_outer);\n&quot;</span>);
        consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        <span class="comment">// Reading the log, you should see that producer and consumer</span>
        <span class="comment">// now alternate on a per-tile basis. Here&#39;s the equivalent C:</span>

        <span class="keywordtype">float</span> result[4][4];

        <span class="comment">// For every tile of the consumer:</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_outer = 0; y_outer &lt; 2; y_outer++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 2; x_outer++) {
                <span class="comment">// Compute the x and y coords of the start of this tile.</span>
                <span class="keywordtype">int</span> x_base = x_outer*2;
                <span class="keywordtype">int</span> y_base = y_outer*2;

                <span class="comment">// Compute enough of producer to satisfy this tile. A</span>
                <span class="comment">// 2x2 tile of the consumer requires a 3x3 tile of the</span>
                <span class="comment">// producer.</span>
                <span class="keywordtype">float</span> producer_storage[3][3];
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y_base; py &lt; y_base + 3; py++) {
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> px = x_base; px &lt; x_base + 3; px++) {
                        producer_storage[py-y_base][px-x_base] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(px * py);
                    }
                }

                <span class="comment">// Compute this tile of the consumer</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_inner = 0; y_inner &lt; 2; y_inner++) {
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner = 0; x_inner &lt; 2; x_inner++) {
                        <span class="keywordtype">int</span> x = x_base + x_inner;
                        <span class="keywordtype">int</span> y = y_base + y_inner;
                        result[y][x] = (producer_storage[y - y_base][x - x_base] +
                                        producer_storage[y - y_base + 1][x - x_base] +
                                        producer_storage[y - y_base][x - x_base + 1] +
                                        producer_storage[y - y_base + 1][x - x_base + 1]);
                    }
                }
            }
        }

        <span class="comment">// Tiling can make sense for problems like this one with</span>
        <span class="comment">// stencils that reach outwards in x and y. Each tile can be</span>
        <span class="comment">// computed independently in parallel, and the redundant work</span>
        <span class="comment">// done by each tile isn&#39;t so bad once the tiles get large</span>
        <span class="comment">// enough.</span>
    }

    <span class="comment">// Let&#39;s try a mixed strategy that combines what we have done with</span>
    <span class="comment">// splitting, parallelizing, and vectorizing. This is one that</span>
    <span class="comment">// often works well in practice for large images. If you</span>
    <span class="comment">// understand this schedule, then you understand 95% of scheduling</span>
    <span class="comment">// in Halide.</span>
    {
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> producer(<span class="stringliteral">&quot;producer_mixed&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_mixed&quot;</span>);
        producer(x, y) = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de" title="Return the square root of a floating-point expression.">sqrt</a>(x * y);
        consumer(x, y) = (producer(x, y) +
                          producer(x, y+1) +
                          producer(x+1, y) +
                          producer(x+1, y+1));

        <span class="comment">// Split the y coordinate of the consumer into strips of 16 scanlines:</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> yo, yi;
        consumer.<a name="a9"></a><a class="code" href="class_halide_1_1_func.html#a52a4cace19fc024959cda3a7e82dd9f6" title="Split a dimension into inner and outer subdimensions with the given names, where the inner dimension ...">split</a>(y, yo, yi, 16);
        <span class="comment">// Compute the strips using a thread pool and a task queue.</span>
        consumer.<a name="a10"></a><a class="code" href="class_halide_1_1_func.html#aa0050c604179b43a8deb42b62dedd29d" title="Mark a dimension to be traversed in parallel.">parallel</a>(yo);
        <span class="comment">// Vectorize across x by a factor of four.</span>
        consumer.<a name="a11"></a><a class="code" href="class_halide_1_1_func.html#a7b1857a62deca8bc9a477c1b26720950" title="Mark a dimension to be computed all-at-once as a single vector.">vectorize</a>(x, 4);

        <span class="comment">// Now store the producer per-strip. This will be 17 scanlines</span>
        <span class="comment">// of the producer (16+1), but hopefully it will fold down</span>
        <span class="comment">// into a circular buffer of two scanlines:</span>
        producer.<a name="a12"></a><a class="code" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7" title="Allocate storage for this function within f&#39;s loop over var.">store_at</a>(consumer, yo);
        <span class="comment">// Within each strip, compute the producer per scanline of the</span>
        <span class="comment">// consumer, skipping work done on previous scanlines.</span>
        producer.<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(consumer, yi);
        <span class="comment">// Also vectorize the producer (because sqrt is vectorizable on x86 using SSE).</span>
        producer.<a class="code" href="class_halide_1_1_func.html#a7b1857a62deca8bc9a477c1b26720950" title="Mark a dimension to be computed all-at-once as a single vector.">vectorize</a>(x, 4);

        <span class="comment">// Let&#39;s leave tracing off this time, because we&#39;re going to</span>
        <span class="comment">// evaluate over a larger image.</span>
        <span class="comment">// consumer.trace_stores();</span>
        <span class="comment">// producer.trace_stores();</span>

        <a name="_a13"></a><a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;float&gt;</a> halide_result = consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(800, 600);

        <span class="comment">// Here&#39;s the equivalent (serial) C:</span>

        <span class="keywordtype">float</span> c_result[600][800];

        <span class="comment">// For every strip of 16 scanlines</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yo = 0; yo &lt; 600/16 + 1; yo++) { <span class="comment">// (this loop is parallel in the Halide version)</span>

            <span class="comment">// 16 doesn&#39;t divide 600, so push the last slice upwards to fit within [0, 599] (see lesson 05).</span>
            <span class="keywordtype">int</span> y_base = yo * 16;
            <span class="keywordflow">if</span> (y_base &gt; 600-16) y_base = 600-16;

            <span class="comment">// Allocate a two-scanline circular buffer for the producer</span>
            <span class="keywordtype">float</span> producer_storage[2][801];

            <span class="comment">// For every scanline in the strip of 16:</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yi = 0; yi &lt; 16; yi++) {
                <span class="keywordtype">int</span> y = y_base + yi;

                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y; py &lt; y+2; py++) {
                    <span class="comment">// Skip scanlines already computed *within this task*</span>
                    <span class="keywordflow">if</span> (yi &gt; 0 &amp;&amp; py == y) <span class="keywordflow">continue</span>;

                    <span class="comment">// Compute this scanline of the producer in 4-wide vectors</span>
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; 800/4 + 1; x_vec++) {
                        <span class="keywordtype">int</span> x_base = x_vec*4;
                        <span class="comment">// 4 doesn&#39;t divide 801, so push the last vector left (see lesson 05).</span>
                        <span class="keywordflow">if</span> (x_base &gt; 801 - 4) x_base = 801 - 4;
                        <span class="comment">// If you&#39;re on x86, Halide generates SSE code for this part:</span>
                        <span class="keywordtype">int</span> x[] = {x_base, x_base + 1, x_base + 2, x_base + 3};
                        <span class="keywordtype">float</span> <a name="a14"></a><a class="code" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829" title="Build small vectors of up to 6 elements.">vec</a>[4] = {sqrtf(x[0] * py), sqrtf(x[1] * py), sqrtf(x[2] * py), sqrtf(x[3] * py)};
                        producer_storage[py &amp; 1][x[0]] = vec[0];
                        producer_storage[py &amp; 1][x[1]] = vec[1];
                        producer_storage[py &amp; 1][x[2]] = vec[2];
                        producer_storage[py &amp; 1][x[3]] = vec[3];
                    }
                }

                <span class="comment">// Now compute consumer for this scanline:</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; 800/4; x_vec++) {
                    <span class="keywordtype">int</span> x_base = x_vec * 4;
                    <span class="comment">// Again, Halide&#39;s equivalent here uses SSE.</span>
                    <span class="keywordtype">int</span> x[] = {x_base, x_base + 1, x_base + 2, x_base + 3};
                    <span class="keywordtype">float</span> <a class="code" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829" title="Build small vectors of up to 6 elements.">vec</a>[] = {
                        (producer_storage[y &amp; 1][x[0]] +
                         producer_storage[(y+1) &amp; 1][x[0]] +
                         producer_storage[y &amp; 1][x[0]+1] +
                         producer_storage[(y+1) &amp; 1][x[0]+1]),
                        (producer_storage[y &amp; 1][x[1]] +
                         producer_storage[(y+1) &amp; 1][x[1]] +
                         producer_storage[y &amp; 1][x[1]+1] +
                         producer_storage[(y+1) &amp; 1][x[1]+1]),
                        (producer_storage[y &amp; 1][x[2]] +
                         producer_storage[(y+1) &amp; 1][x[2]] +
                         producer_storage[y &amp; 1][x[2]+1] +
                         producer_storage[(y+1) &amp; 1][x[2]+1]),
                        (producer_storage[y &amp; 1][x[3]] +
                         producer_storage[(y+1) &amp; 1][x[3]] +
                         producer_storage[y &amp; 1][x[3]+1] +
                         producer_storage[(y+1) &amp; 1][x[3]+1])};

                    c_result[y][x[0]] = vec[0];
                    c_result[y][x[1]] = vec[1];
                    c_result[y][x[2]] = vec[2];
                    c_result[y][x[3]] = vec[3];
                }

            }
        }
        <span class="comment">// Look on my code, ye mighty, and despair!</span>

        <span class="comment">// Let&#39;s check the C result against the Halide result. Doing</span>
        <span class="comment">// this I found several bugs in my C implementation, which</span>
        <span class="comment">// should tell you something.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 600; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 800; x++) {
                <span class="keywordtype">float</span> error = halide_result(x, y) - c_result[y][x];
                <span class="comment">// It&#39;s floating-point math, so we&#39;ll allow some slop:</span>
                <span class="keywordflow">if</span> (error &lt; -0.001f || error &gt; 0.001f) {
                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %f instead of %f\n&quot;</span>,
                           x, y, halide_result(x, y), c_result[y][x]);
                    <span class="keywordflow">return</span> -1;
                }
            }
        }

    }

    <span class="comment">// This stuff is hard. We ended up in a three-way trade-off</span>
    <span class="comment">// between memory bandwidth, redundant work, and</span>
    <span class="comment">// parallelism. Halide can&#39;t make the correct choice for you</span>
    <span class="comment">// automatically (sorry). Instead it tries to make it easier for</span>
    <span class="comment">// you to explore various options, without messing up your</span>
    <span class="comment">// program. In fact, Halide promises that scheduling calls like</span>
    <span class="comment">// compute_root won&#39;t change the meaning of your algorithm -- you</span>
    <span class="comment">// should get the same bits back no matter how you schedule</span>
    <span class="comment">// things.</span>

    <span class="comment">// So be empirical! Experiment with various schedules and keep a</span>
    <span class="comment">// log of performance. Form hypotheses and then try to prove</span>
    <span class="comment">// yourself wrong. Don&#39;t assume that you just need to vectorize</span>
    <span class="comment">// your code by a factor of four and run it on eight cores and</span>
    <span class="comment">// you&#39;ll get 32x faster. This almost never works. Modern systems</span>
    <span class="comment">// are complex enough that you can&#39;t predict performance reliably</span>
    <span class="comment">// without running your code.</span>

    <span class="comment">// We suggest you start by scheduling all of your non-trivial</span>
    <span class="comment">// stages compute_root, and then work from the end of the pipeline</span>
    <span class="comment">// upwards, inlining, parallelizing, and vectorizing each stage in</span>
    <span class="comment">// turn until you reach the top.</span>

    <span class="comment">// Halide is not just about vectorizing and parallelizing your</span>
    <span class="comment">// code. That&#39;s not enough to get you very far. Halide is about</span>
    <span class="comment">// giving you tools that help you quickly explore different</span>
    <span class="comment">// trade-offs between locality, redundant work, and parallelism,</span>
    <span class="comment">// without messing up the actual result you&#39;re trying to compute.</span>

    printf(<span class="stringliteral">&quot;Success!\n&quot;</span>);
    <span class="keywordflow">return</span> 0;
}
</pre></div> </div><!-- contents -->
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
