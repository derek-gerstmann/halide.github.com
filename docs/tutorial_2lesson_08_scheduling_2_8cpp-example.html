<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: tutorial/lesson_08_scheduling_2.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial_2lesson_08_scheduling_2_8cpp-example.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">tutorial/lesson_08_scheduling_2.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">// Halide tutorial lesson 8</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This lesson demonstrates how schedule multi-stage pipelines.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This lesson can be built by invoking the command:</span></div>
<div class="line"><span class="comment">//    make tutorial_lesson_08_scheduling_2</span></div>
<div class="line"><span class="comment">// in a shell with the current directory at the top of the halide source tree.</span></div>
<div class="line"><span class="comment">// Otherwise, see the platform-specific compiler invocations below.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// On linux, you can compile and run it like so:</span></div>
<div class="line"><span class="comment">// g++ lesson_08*.cpp -g -I ../include -L ../bin -lHalide -lpthread -ldl -o lesson_08</span></div>
<div class="line"><span class="comment">// LD_LIBRARY_PATH=../bin ./lesson_08</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// On os x:</span></div>
<div class="line"><span class="comment">// g++ lesson_08*.cpp -g -I ../include -L ../bin -lHalide -o lesson_08</span></div>
<div class="line"><span class="comment">// DYLD_LIBRARY_PATH=../bin ./lesson_08</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;Halide.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>Halide;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {</div>
<div class="line">    <span class="comment">// First we&#39;ll declare some Vars to use below.</span></div>
<div class="line">    <a name="_a0"></a><a class="code" href="class_halide_1_1_var.html">Var</a> x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Let&#39;s examine various scheduling options for a simple two stage</span></div>
<div class="line">    <span class="comment">// pipeline. We&#39;ll start with the default schedule:</span></div>
<div class="line">    {</div>
<div class="line">        <a name="_a1"></a><a class="code" href="class_halide_1_1_func.html">Func</a> producer(<span class="stringliteral">&quot;producer_default&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_default&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The first stage will be some simple pointwise math similar</span></div>
<div class="line">        <span class="comment">// to our familiar gradient function. The value at position x,</span></div>
<div class="line">        <span class="comment">// y is the sqrt of product of x and y.</span></div>
<div class="line">        producer(x, y) = <a name="a2"></a><a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(x * y);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Now we&#39;ll add a second stage which adds together multiple</span></div>
<div class="line">        <span class="comment">// points in the first stage.</span></div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y+1) +</div>
<div class="line">                          producer(x+1, y) +</div>
<div class="line">                          producer(x+1, y+1));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// We&#39;ll turn on tracing for both functions.</span></div>
<div class="line">        consumer.<a name="a3"></a><a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a>();</div>
<div class="line">        producer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a>();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// And evaluate it over a 5x5 box.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;\nEvaluating producer-consumer pipeline with default schedule\n&quot;</span>);</div>
<div class="line">        consumer.<a name="a4"></a><a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">realize</a>(4, 4);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// There were no messages about computing values of the</span></div>
<div class="line">        <span class="comment">// producer. This is because the default schedule fully</span></div>
<div class="line">        <span class="comment">// inlines &#39;producer&#39; into &#39;consumer&#39;. It is as if we had</span></div>
<div class="line">        <span class="comment">// written the following code instead:</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// consumer(x, y) = (sqrt(x * y) +</span></div>
<div class="line">        <span class="comment">//                   sqrt(x * (y + 1)) +</span></div>
<div class="line">        <span class="comment">//                   sqrt((x + 1) * y) +</span></div>
<div class="line">        <span class="comment">//                   sqrt((x + 1) * (y + 1)));</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// All calls to &#39;producer&#39; have been replaced with the body of</span></div>
<div class="line">        <span class="comment">// &#39;producer&#39;, with the arguments subtituted in for the</span></div>
<div class="line">        <span class="comment">// variables.</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// The equivalent C code is:</span></div>
<div class="line">        <span class="keywordtype">float</span> result[4][4];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                result[y][x] = (<a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(x*y) +</div>
<div class="line">                                <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(x*(y+1)) +</div>
<div class="line">                                <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>((x+1)*y) +</div>
<div class="line">                                <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>((x+1)*(y+1)));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Next we&#39;ll examine the next simplest option - computing all</span></div>
<div class="line">    <span class="comment">// values required in the producer before computing any of the</span></div>
<div class="line">    <span class="comment">// consumer. We call this schedule &quot;root&quot;.</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Start with the same function definitions:</span></div>
<div class="line">        <a class="code" href="class_halide_1_1_func.html">Func</a> producer(<span class="stringliteral">&quot;producer_root&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_root&quot;</span>);</div>
<div class="line">        producer(x, y) = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(x * y);</div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y+1) +</div>
<div class="line">                          producer(x+1, y) +</div>
<div class="line">                          producer(x+1, y+1));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Tell Halide to evaluate all of producer before any of consumer.</span></div>
<div class="line">        producer.<a name="a5"></a><a class="code" href="class_halide_1_1_func.html#a7f4db7e4884fe76399bf2a673567eab5">compute_root</a>();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Turn on tracing.</span></div>
<div class="line">        consumer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a>();</div>
<div class="line">        producer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a>();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Compile and run.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;\nEvaluating producer.compute_root()\n&quot;</span>);</div>
<div class="line">        consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">realize</a>(4, 4);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Reading the output we can see that:</span></div>
<div class="line">        <span class="comment">// A) There were stores to producer.</span></div>
<div class="line">        <span class="comment">// B) They all happened before any stores to consumer.</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Equivalent C:</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span> result[4][4];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Allocate some temporary storage for the producer.</span></div>
<div class="line">        <span class="keywordtype">float</span> producer_storage[5][5];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Compute the producer.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 5; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 5; x++) {</div>
<div class="line">                producer_storage[y][x] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(x * y);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Compute the consumer. Skip the prints this time.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                result[y][x] = (producer_storage[y][x] +</div>
<div class="line">                                producer_storage[y+1][x] +</div>
<div class="line">                                producer_storage[y][x+1] +</div>
<div class="line">                                producer_storage[y+1][x+1]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Note that consumer was evaluated over a 4x4 box, so Halide</span></div>
<div class="line">        <span class="comment">// automatically inferred that producer was needed over a 5x5</span></div>
<div class="line">        <span class="comment">// box. This is the same &#39;bounds inference&#39; logic we saw in</span></div>
<div class="line">        <span class="comment">// the previous lesson, where it was used to detect and avoid</span></div>
<div class="line">        <span class="comment">// out-of-bounds reads from an input image.</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Let&#39;s compare the two approaches above from a performance</span></div>
<div class="line">    <span class="comment">// perspective.</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Full inlining (the default schedule):</span></div>
<div class="line">    <span class="comment">// - Temporary memory allocated: 0</span></div>
<div class="line">    <span class="comment">// - Loads: 0</span></div>
<div class="line">    <span class="comment">// - Stores: 16</span></div>
<div class="line">    <span class="comment">// - Calls to sqrt: 64</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// producer.compute_root():</span></div>
<div class="line">    <span class="comment">// - Temporary memory allocated: 25 floats</span></div>
<div class="line">    <span class="comment">// - Loads: 64</span></div>
<div class="line">    <span class="comment">// - Stores: 39</span></div>
<div class="line">    <span class="comment">// - Calls to sqrt: 25</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// There&#39;s a trade-off here. Full inlining used minimal temporary</span></div>
<div class="line">    <span class="comment">// memory and memory bandwidth, but did a whole bunch of redundant</span></div>
<div class="line">    <span class="comment">// expensive math (calling sqrt). It evaluated most points in</span></div>
<div class="line">    <span class="comment">// &#39;producer&#39; four times. The second schedule,</span></div>
<div class="line">    <span class="comment">// producer.compute_root(), did the mimimum number of calls to</span></div>
<div class="line">    <span class="comment">// sqrt, but used more temporary memory and more memory bandwidth.</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// In any given situation the correct choice can be difficult to</span></div>
<div class="line">    <span class="comment">// make. If you&#39;re memory-bandwidth limited, or don&#39;t have much</span></div>
<div class="line">    <span class="comment">// memory (e.g. because you&#39;re running on an old cell-phone), then</span></div>
<div class="line">    <span class="comment">// it can make sense to do redundant math. On the other hand, sqrt</span></div>
<div class="line">    <span class="comment">// is expensive, so if you&#39;re compute-limited then fewer calls to</span></div>
<div class="line">    <span class="comment">// sqrt will make your program faster. Adding vectorization or</span></div>
<div class="line">    <span class="comment">// multi-core parallelism tilts the scales in favor of doing</span></div>
<div class="line">    <span class="comment">// redundant work, because firing up multiple cpu cores increases</span></div>
<div class="line">    <span class="comment">// the amount of math you can do per second, but doesn&#39;t increase</span></div>
<div class="line">    <span class="comment">// your system memory bandwidth or capacity.</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// We can make choices in between full inlining and</span></div>
<div class="line">    <span class="comment">// compute_root. Next we&#39;ll alternate between computing the</span></div>
<div class="line">    <span class="comment">// producer and consumer on a per-scanline basis:</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Start with the same function definitions:</span></div>
<div class="line">        <a class="code" href="class_halide_1_1_func.html">Func</a> producer(<span class="stringliteral">&quot;producer_y&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_y&quot;</span>);</div>
<div class="line">        producer(x, y) = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(x * y);</div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y+1) +</div>
<div class="line">                          producer(x+1, y) +</div>
<div class="line">                          producer(x+1, y+1));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Tell Halide to evaluate producer as needed per y coordinate</span></div>
<div class="line">        <span class="comment">// of the consumer:</span></div>
<div class="line">        producer.<a name="a6"></a><a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">compute_at</a>(consumer, y);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// This places the code that computes the producer just</span></div>
<div class="line">        <span class="comment">// *inside* the consumer&#39;s for loop over y, as in the</span></div>
<div class="line">        <span class="comment">// equivalent C below.</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Turn on tracing.</span></div>
<div class="line">        producer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a>();</div>
<div class="line">        consumer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a>();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Compile and run.</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;\nEvaluating producer.compute_at(consumer, y)\n&quot;</span>);</div>
<div class="line">        consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">realize</a>(4, 4);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Reading the log you should see that producer and consumer</span></div>
<div class="line">        <span class="comment">// alternate on a per-scanline basis. Let&#39;s look at the</span></div>
<div class="line">        <span class="comment">// equivalent C:</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span> result[4][4];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// There&#39;s an outer loop over scanlines of consumer:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Allocate space and compute enough of the producer to</span></div>
<div class="line">            <span class="comment">// satisfy this single scanline of the consumer. This</span></div>
<div class="line">            <span class="comment">// means a 5x2 box of the producer.</span></div>
<div class="line">            <span class="keywordtype">float</span> producer_storage[2][5];</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y; py &lt; y + 2; py++) {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> px = 0; px &lt; 5; px++) {</div>
<div class="line">                    producer_storage[py-y][px] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(px * py);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Compute a scanline of the consumer.</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                result[y][x] = (producer_storage[0][x] +</div>
<div class="line">                                producer_storage[1][x] +</div>
<div class="line">                                producer_storage[0][x+1] +</div>
<div class="line">                                producer_storage[1][x+1]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The performance characteristics of this strategy are in</span></div>
<div class="line">        <span class="comment">// between inlining and compute root. We still allocate some</span></div>
<div class="line">        <span class="comment">// temporary memory, but less that compute_root, and with</span></div>
<div class="line">        <span class="comment">// better locality (we load from it soon after writing to it,</span></div>
<div class="line">        <span class="comment">// so for larger images, values should still be in cache). We</span></div>
<div class="line">        <span class="comment">// still do some redundant work, but less than full inlining:</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// producer.compute_at(consumer, y):</span></div>
<div class="line">        <span class="comment">// - Temporary memory allocated: 10 floats</span></div>
<div class="line">        <span class="comment">// - Loads: 64</span></div>
<div class="line">        <span class="comment">// - Stores: 56</span></div>
<div class="line">        <span class="comment">// - Calls to sqrt: 40</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// We could also say producer.compute_at(consumer, x), but this</span></div>
<div class="line">    <span class="comment">// would be very similar to full inlining (the default</span></div>
<div class="line">    <span class="comment">// schedule). Instead let&#39;s distinguish between the loop level at</span></div>
<div class="line">    <span class="comment">// which we allocate storage for producer, and the loop level at</span></div>
<div class="line">    <span class="comment">// which we actually compute it. This unlocks a few optimizations.</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="class_halide_1_1_func.html">Func</a> producer(<span class="stringliteral">&quot;producer_store_root_compute_y&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_store_root_compute_y&quot;</span>);</div>
<div class="line">        producer(x, y) = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(x * y);</div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y+1) +</div>
<div class="line">                          producer(x+1, y) +</div>
<div class="line">                          producer(x+1, y+1));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Tell Halide to make a buffer to store all of producer at</span></div>
<div class="line">        <span class="comment">// the outermost level:</span></div>
<div class="line">        producer.<a name="a7"></a><a class="code" href="class_halide_1_1_func.html#a7048eaf680bc0c78961c0bef48d37f85">store_root</a>();</div>
<div class="line">        <span class="comment">// ... but compute it as needed per y coordinate of the</span></div>
<div class="line">        <span class="comment">// consumer.</span></div>
<div class="line">        producer.<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">compute_at</a>(consumer, y);</div>
<div class="line"></div>
<div class="line">        producer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a>();</div>
<div class="line">        consumer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a>();</div>
<div class="line"></div>
<div class="line">        printf(<span class="stringliteral">&quot;\nEvaluating producer.store_root().compute_at(consumer, y)\n&quot;</span>);</div>
<div class="line">        consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">realize</a>(4, 4);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Reading the log you should see that producer and consumer</span></div>
<div class="line">        <span class="comment">// again alternate on a per-scanline basis. It computes a 5x2</span></div>
<div class="line">        <span class="comment">// box of the producer to satisfy the first scanline of the</span></div>
<div class="line">        <span class="comment">// consumer, but after that it only computes a 5x1 box of the</span></div>
<div class="line">        <span class="comment">// output for each new scanline of the consumer!</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Halide has detected that for all scanlines except for the</span></div>
<div class="line">        <span class="comment">// first, it can reuse the values already sitting in the</span></div>
<div class="line">        <span class="comment">// buffer we&#39;ve allocated for producer. Let&#39;s look at the</span></div>
<div class="line">        <span class="comment">// equivalent C:</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span> result[4][4];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// producer.store_root() implies that storage goes here:</span></div>
<div class="line">        <span class="keywordtype">float</span> producer_storage[5][5];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// There&#39;s an outer loop over scanlines of consumer:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Compute enough of the producer to satisfy this scanline</span></div>
<div class="line">            <span class="comment">// of the consumer.</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y; py &lt; y + 2; py++) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Skip over rows of producer that we&#39;ve already</span></div>
<div class="line">                <span class="comment">// computed in a previous iteration.</span></div>
<div class="line">                <span class="keywordflow">if</span> (y &gt; 0 &amp;&amp; py == y) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> px = 0; px &lt; 5; px++) {</div>
<div class="line">                    producer_storage[py][px] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(px * py);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Compute a scanline of the consumer.</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                result[y][x] = (producer_storage[y][x] +</div>
<div class="line">                                producer_storage[y+1][x] +</div>
<div class="line">                                producer_storage[y][x+1] +</div>
<div class="line">                                producer_storage[y+1][x+1]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The performance characteristics of this strategy are pretty</span></div>
<div class="line">        <span class="comment">// good! The numbers are similar compute_root, except locality</span></div>
<div class="line">        <span class="comment">// is better. We&#39;re doing the minimum number of sqrt calls,</span></div>
<div class="line">        <span class="comment">// and we load values soon after they are stored, so we&#39;re</span></div>
<div class="line">        <span class="comment">// probably making good use of the cache:</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// producer.store_root().compute_at(consumer, y):</span></div>
<div class="line">        <span class="comment">// - Temporary memory allocated: 10 floats</span></div>
<div class="line">        <span class="comment">// - Loads: 64</span></div>
<div class="line">        <span class="comment">// - Stores: 39</span></div>
<div class="line">        <span class="comment">// - Calls to sqrt: 25</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Note that my claimed amount of memory allocated doesn&#39;t</span></div>
<div class="line">        <span class="comment">// match the reference C code. Halide is performing one more</span></div>
<div class="line">        <span class="comment">// optimization under the hood. It folds the storage for the</span></div>
<div class="line">        <span class="comment">// producer down into a circular buffer of two</span></div>
<div class="line">        <span class="comment">// scanlines. Equivalent C would actually look like this:</span></div>
<div class="line"></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Actually store 2 scanlines instead of 5</span></div>
<div class="line">            <span class="keywordtype">float</span> producer_storage[2][5];</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y; py &lt; y + 2; py++) {</div>
<div class="line">                    <span class="keywordflow">if</span> (y &gt; 0 &amp;&amp; py == y) <span class="keywordflow">continue</span>;</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> px = 0; px &lt; 5; px++) {</div>
<div class="line">                        <span class="comment">// Stores to producer_storage have their y coordinate bit-masked.</span></div>
<div class="line">                        producer_storage[py &amp; 1][px] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(px * py);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Compute a scanline of the consumer.</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line">                    <span class="comment">// Loads from producer_storage have their y coordinate bit-masked.</span></div>
<div class="line">                    result[y][x] = (producer_storage[y &amp; 1][x] +</div>
<div class="line">                                    producer_storage[(y+1) &amp; 1][x] +</div>
<div class="line">                                    producer_storage[y &amp; 1][x+1] +</div>
<div class="line">                                    producer_storage[(y+1) &amp; 1][x+1]);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// We can do even better, by leaving the storage outermost, but</span></div>
<div class="line">    <span class="comment">// moving the computation into the innermost loop:</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="class_halide_1_1_func.html">Func</a> producer(<span class="stringliteral">&quot;producer_store_root_compute_y&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_store_root_compute_y&quot;</span>);</div>
<div class="line">        producer(x, y) = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(x * y);</div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y+1) +</div>
<div class="line">                          producer(x+1, y) +</div>
<div class="line">                          producer(x+1, y+1));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Store outermost, compute innermost.</span></div>
<div class="line">        producer.<a class="code" href="class_halide_1_1_func.html#a7048eaf680bc0c78961c0bef48d37f85">store_root</a>().<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">compute_at</a>(consumer, x);</div>
<div class="line"></div>
<div class="line">        producer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a>();</div>
<div class="line">        consumer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a>();</div>
<div class="line"></div>
<div class="line">        printf(<span class="stringliteral">&quot;\nEvaluating producer.store_root().compute_at(consumer, x)\n&quot;</span>);</div>
<div class="line">        consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">realize</a>(4, 4);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Reading the log, you should see that producer and consumer</span></div>
<div class="line">        <span class="comment">// now alternate on a per-pixel basis. Here&#39;s the equivalent C:</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span> result[4][4];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// producer.store_root() implies that storage goes here, but</span></div>
<div class="line">        <span class="comment">// we can fold it down into a circular buffer of two</span></div>
<div class="line">        <span class="comment">// scanlines:</span></div>
<div class="line">        <span class="keywordtype">float</span> producer_storage[2][5];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// For every pixel of the consumer:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Compute enough of the producer to satisfy this</span></div>
<div class="line">                <span class="comment">// pixel of the consumer, but skip values that we&#39;ve</span></div>
<div class="line">                <span class="comment">// already computed:</span></div>
<div class="line">                <span class="keywordflow">if</span> (y == 0 &amp;&amp; x == 0)</div>
<div class="line">                    producer_storage[y &amp; 1][x] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(x*y);</div>
<div class="line">                <span class="keywordflow">if</span> (y == 0)</div>
<div class="line">                    producer_storage[y &amp; 1][x+1] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>((x+1)*y);</div>
<div class="line">                <span class="keywordflow">if</span> (x == 0)</div>
<div class="line">                    producer_storage[(y+1) &amp; 1][x] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(x*(y+1));</div>
<div class="line">                producer_storage[(y+1) &amp; 1][x+1] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>((x+1)*(y+1));</div>
<div class="line"></div>
<div class="line">                result[y][x] = (producer_storage[y &amp; 1][x] +</div>
<div class="line">                                producer_storage[(y+1) &amp; 1][x] +</div>
<div class="line">                                producer_storage[y &amp; 1][x+1] +</div>
<div class="line">                                producer_storage[(y+1) &amp; 1][x+1]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// The performance characteristics of this strategy are the</span></div>
<div class="line">        <span class="comment">// best so far. One of the four values of the producer we need</span></div>
<div class="line">        <span class="comment">// is probably still sitting in a register, so I won&#39;t count</span></div>
<div class="line">        <span class="comment">// it as a load:</span></div>
<div class="line">        <span class="comment">// producer.store_root().compute_at(consumer, x):</span></div>
<div class="line">        <span class="comment">// - Temporary memory allocated: 10 floats</span></div>
<div class="line">        <span class="comment">// - Loads: 48</span></div>
<div class="line">        <span class="comment">// - Stores: 56</span></div>
<div class="line">        <span class="comment">// - Calls to sqrt: 40</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// So what&#39;s the catch? Why not always do</span></div>
<div class="line">    <span class="comment">// producer.store_root().compute_at(consumer, x) for this type of</span></div>
<div class="line">    <span class="comment">// code?</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// The answer is parallelism. In both of the previous two</span></div>
<div class="line">    <span class="comment">// strategies we&#39;ve assumed that values computed on previous</span></div>
<div class="line">    <span class="comment">// iterations are lying around for us to reuse. This assumes that</span></div>
<div class="line">    <span class="comment">// previous values of x or y happened earlier in time and have</span></div>
<div class="line">    <span class="comment">// finished. This is not true if you parallelize or vectorize</span></div>
<div class="line">    <span class="comment">// either loop. Darn. If you parallelize, Halide won&#39;t inject the</span></div>
<div class="line">    <span class="comment">// optimizations that skip work already done if there&#39;s a parallel</span></div>
<div class="line">    <span class="comment">// loop in between the store_at level and the compute_at level,</span></div>
<div class="line">    <span class="comment">// and won&#39;t fold the storage down into a circular buffer either,</span></div>
<div class="line">    <span class="comment">// which makes our store_root pointless.</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// We&#39;re running out of options. We can make new ones by</span></div>
<div class="line">    <span class="comment">// splitting. We can store_at or compute_at at the natural</span></div>
<div class="line">    <span class="comment">// variables of the consumer (x and y), or we can split x or y</span></div>
<div class="line">    <span class="comment">// into new inner and outer sub-variables and then schedule with</span></div>
<div class="line">    <span class="comment">// respect to those. We&#39;ll use this to express fusion in tiles:</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="class_halide_1_1_func.html">Func</a> producer(<span class="stringliteral">&quot;producer_store_root_compute_y&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_store_root_compute_y&quot;</span>);</div>
<div class="line">        producer(x, y) = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(x * y);</div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y+1) +</div>
<div class="line">                          producer(x+1, y) +</div>
<div class="line">                          producer(x+1, y+1));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Tile the consumer using 2x2 tiles.</span></div>
<div class="line">        <a class="code" href="class_halide_1_1_var.html">Var</a> x_outer, y_outer, x_inner, y_inner;</div>
<div class="line">        consumer.<a name="a8"></a><a class="code" href="class_halide_1_1_func.html#ab15001cd4af9e8c2808f45ff53b81582">tile</a>(x, y, x_outer, y_outer, x_inner, y_inner, 2, 2);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Compute the producer per tile of the consumer</span></div>
<div class="line">        producer.<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">compute_at</a>(consumer, x_outer);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Notice that I wrote my schedule starting from the end of</span></div>
<div class="line">        <span class="comment">// the pipeline (the consumer). This is because the schedule</span></div>
<div class="line">        <span class="comment">// for the producer refers to x_outer, which we introduced</span></div>
<div class="line">        <span class="comment">// when we tiled the consumer. You can write it in the other</span></div>
<div class="line">        <span class="comment">// order, but it tends to be harder to read.</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Turn on tracing.</span></div>
<div class="line">        producer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a>();</div>
<div class="line">        consumer.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2">trace_stores</a>();</div>
<div class="line"></div>
<div class="line">        printf(<span class="stringliteral">&quot;\nEvaluating:\n&quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;consumer.tile(x, y, x_outer, y_outer, x_inner, y_inner, 2, 2);\n&quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;producer.compute_at(consumer, x_outer);\n&quot;</span>);</div>
<div class="line">        consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">realize</a>(4, 4);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Reading the log, you should see that producer and consumer</span></div>
<div class="line">        <span class="comment">// now alternate on a per-tile basis. Here&#39;s the equivalent C:</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span> result[4][4];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// For every tile of the consumer:</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_outer = 0; y_outer &lt; 2; y_outer++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 2; x_outer++) {</div>
<div class="line">                <span class="comment">// Compute the x and y coords of the start of this tile.</span></div>
<div class="line">                <span class="keywordtype">int</span> x_base = x_outer*2;</div>
<div class="line">                <span class="keywordtype">int</span> y_base = y_outer*2;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Compute enough of producer to satisfy this tile. A</span></div>
<div class="line">                <span class="comment">// 2x2 tile of the consumer requires a 3x3 tile of the</span></div>
<div class="line">                <span class="comment">// producer.</span></div>
<div class="line">                <span class="keywordtype">float</span> producer_storage[3][3];</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y_base; py &lt; y_base + 3; py++) {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> px = x_base; px &lt; x_base + 3; px++) {</div>
<div class="line">                        producer_storage[py-y_base][px-x_base] = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(px * py);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Compute this tile of the consumer</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_inner = 0; y_inner &lt; 2; y_inner++) {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner = 0; x_inner &lt; 2; x_inner++) {</div>
<div class="line">                        <span class="keywordtype">int</span> x = x_base + x_inner;</div>
<div class="line">                        <span class="keywordtype">int</span> y = y_base + y_inner;</div>
<div class="line">                        result[y][x] = (producer_storage[y - y_base][x - x_base] +</div>
<div class="line">                                        producer_storage[y - y_base + 1][x - x_base] +</div>
<div class="line">                                        producer_storage[y - y_base][x - x_base + 1] +</div>
<div class="line">                                        producer_storage[y - y_base + 1][x - x_base + 1]);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Tiling can make sense for problems like this one with</span></div>
<div class="line">        <span class="comment">// stencils that reach outwards in x and y. Each tile can be</span></div>
<div class="line">        <span class="comment">// computed independently in parallel, and the redundant work</span></div>
<div class="line">        <span class="comment">// done by each tile isn&#39;t so bad once the tiles get large</span></div>
<div class="line">        <span class="comment">// enough.</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Let&#39;s try a mixed strategy that combines what we have done with</span></div>
<div class="line">    <span class="comment">// splitting, parallelizing, and vectorizing. This is one that</span></div>
<div class="line">    <span class="comment">// often works well in practice for large images. If you</span></div>
<div class="line">    <span class="comment">// understand this schedule, then you understand 95% of scheduling</span></div>
<div class="line">    <span class="comment">// in Halide.</span></div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="class_halide_1_1_func.html">Func</a> producer(<span class="stringliteral">&quot;producer_mixed&quot;</span>), consumer(<span class="stringliteral">&quot;consumer_mixed&quot;</span>);</div>
<div class="line">        producer(x, y) = <a class="code" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">sqrt</a>(x * y);</div>
<div class="line">        consumer(x, y) = (producer(x, y) +</div>
<div class="line">                          producer(x, y+1) +</div>
<div class="line">                          producer(x+1, y) +</div>
<div class="line">                          producer(x+1, y+1));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Split the y coordinate of the consumer into strips of 16 scanlines:</span></div>
<div class="line">        <a class="code" href="class_halide_1_1_var.html">Var</a> yo, yi;</div>
<div class="line">        consumer.<a name="a9"></a><a class="code" href="class_halide_1_1_func.html#a52a4cace19fc024959cda3a7e82dd9f6">split</a>(y, yo, yi, 16);</div>
<div class="line">        <span class="comment">// Compute the strips using a thread pool and a task queue.</span></div>
<div class="line">        consumer.<a name="a10"></a><a class="code" href="class_halide_1_1_func.html#aa0050c604179b43a8deb42b62dedd29d">parallel</a>(yo);</div>
<div class="line">        <span class="comment">// Vectorize across x by a factor of four.</span></div>
<div class="line">        consumer.<a name="a11"></a><a class="code" href="class_halide_1_1_func.html#a7b1857a62deca8bc9a477c1b26720950">vectorize</a>(x, 4);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Now store the producer per-strip. This will be 17 scanlines</span></div>
<div class="line">        <span class="comment">// of the producer (16+1), but hopefully it will fold down</span></div>
<div class="line">        <span class="comment">// into a circular buffer of two scanlines:</span></div>
<div class="line">        producer.<a name="a12"></a><a class="code" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7">store_at</a>(consumer, yo);</div>
<div class="line">        <span class="comment">// Within each strip, compute the producer per scanline of the</span></div>
<div class="line">        <span class="comment">// consumer, skipping work done on previous scanlines.</span></div>
<div class="line">        producer.<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273">compute_at</a>(consumer, yi);</div>
<div class="line">        <span class="comment">// Also vectorize the producer (because sqrt is vectorizable on x86 using SSE).</span></div>
<div class="line">        producer.<a class="code" href="class_halide_1_1_func.html#a7b1857a62deca8bc9a477c1b26720950">vectorize</a>(x, 4);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Let&#39;s leave tracing off this time, because we&#39;re going to</span></div>
<div class="line">        <span class="comment">// evaluate over a larger image.</span></div>
<div class="line">        <span class="comment">// consumer.trace_stores();</span></div>
<div class="line">        <span class="comment">// producer.trace_stores();</span></div>
<div class="line"></div>
<div class="line">        <a name="_a13"></a><a class="code" href="class_halide_1_1_image.html">Image&lt;float&gt;</a> halide_result = consumer.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b">realize</a>(800, 600);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Here&#39;s the equivalent (serial) C:</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span> c_result[600][800];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// For every strip of 16 scanlines</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yo = 0; yo &lt; 600/16 + 1; yo++) { <span class="comment">// (this loop is parallel in the Halide version)</span></div>
<div class="line"></div>
<div class="line">            <span class="comment">// 16 doesn&#39;t divide 600, so push the last slice upwards to fit within [0, 599] (see lesson 05).</span></div>
<div class="line">            <span class="keywordtype">int</span> y_base = yo * 16;</div>
<div class="line">            <span class="keywordflow">if</span> (y_base &gt; 600-16) y_base = 600-16;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Allocate a two-scanline circular buffer for the producer</span></div>
<div class="line">            <span class="keywordtype">float</span> producer_storage[2][801];</div>
<div class="line"></div>
<div class="line">            <span class="comment">// For every scanline in the strip of 16:</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> yi = 0; yi &lt; 16; yi++) {</div>
<div class="line">                <span class="keywordtype">int</span> y = y_base + yi;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> py = y; py &lt; y+2; py++) {</div>
<div class="line">                    <span class="comment">// Skip scanlines already computed *within this task*</span></div>
<div class="line">                    <span class="keywordflow">if</span> (yi &gt; 0 &amp;&amp; py == y) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Compute this scanline of the producer in 4-wide vectors</span></div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; 800/4 + 1; x_vec++) {</div>
<div class="line">                        <span class="keywordtype">int</span> x_base = x_vec*4;</div>
<div class="line">                        <span class="comment">// 4 doesn&#39;t divide 801, so push the last vector left (see lesson 05).</span></div>
<div class="line">                        <span class="keywordflow">if</span> (x_base &gt; 801 - 4) x_base = 801 - 4;</div>
<div class="line">                        <span class="comment">// If you&#39;re on x86, Halide generates SSE code for this part:</span></div>
<div class="line">                        <span class="keywordtype">int</span> x[] = {x_base, x_base + 1, x_base + 2, x_base + 3};</div>
<div class="line">                        <span class="keywordtype">float</span> <a name="a14"></a><a class="code" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">vec</a>[4] = {sqrtf(x[0] * py), sqrtf(x[1] * py), sqrtf(x[2] * py), sqrtf(x[3] * py)};</div>
<div class="line">                        producer_storage[py &amp; 1][x[0]] = vec[0];</div>
<div class="line">                        producer_storage[py &amp; 1][x[1]] = vec[1];</div>
<div class="line">                        producer_storage[py &amp; 1][x[2]] = vec[2];</div>
<div class="line">                        producer_storage[py &amp; 1][x[3]] = vec[3];</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Now compute consumer for this scanline:</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_vec = 0; x_vec &lt; 800/4; x_vec++) {</div>
<div class="line">                    <span class="keywordtype">int</span> x_base = x_vec * 4;</div>
<div class="line">                    <span class="comment">// Again, Halide&#39;s equivalent here uses SSE.</span></div>
<div class="line">                    <span class="keywordtype">int</span> x[] = {x_base, x_base + 1, x_base + 2, x_base + 3};</div>
<div class="line">                    <span class="keywordtype">float</span> <a class="code" href="namespace_halide_1_1_internal.html#a1581b658edf919ea8aae58ad09b4f829">vec</a>[] = {</div>
<div class="line">                        (producer_storage[y &amp; 1][x[0]] +</div>
<div class="line">                         producer_storage[(y+1) &amp; 1][x[0]] +</div>
<div class="line">                         producer_storage[y &amp; 1][x[0]+1] +</div>
<div class="line">                         producer_storage[(y+1) &amp; 1][x[0]+1]),</div>
<div class="line">                        (producer_storage[y &amp; 1][x[1]] +</div>
<div class="line">                         producer_storage[(y+1) &amp; 1][x[1]] +</div>
<div class="line">                         producer_storage[y &amp; 1][x[1]+1] +</div>
<div class="line">                         producer_storage[(y+1) &amp; 1][x[1]+1]),</div>
<div class="line">                        (producer_storage[y &amp; 1][x[2]] +</div>
<div class="line">                         producer_storage[(y+1) &amp; 1][x[2]] +</div>
<div class="line">                         producer_storage[y &amp; 1][x[2]+1] +</div>
<div class="line">                         producer_storage[(y+1) &amp; 1][x[2]+1]),</div>
<div class="line">                        (producer_storage[y &amp; 1][x[3]] +</div>
<div class="line">                         producer_storage[(y+1) &amp; 1][x[3]] +</div>
<div class="line">                         producer_storage[y &amp; 1][x[3]+1] +</div>
<div class="line">                         producer_storage[(y+1) &amp; 1][x[3]+1])};</div>
<div class="line"></div>
<div class="line">                    c_result[y][x[0]] = vec[0];</div>
<div class="line">                    c_result[y][x[1]] = vec[1];</div>
<div class="line">                    c_result[y][x[2]] = vec[2];</div>
<div class="line">                    c_result[y][x[3]] = vec[3];</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Look on my code, ye mighty, and despair!</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// Let&#39;s check the C result against the Halide result. Doing</span></div>
<div class="line">        <span class="comment">// this I found several bugs in my C implementation, which</span></div>
<div class="line">        <span class="comment">// should tell you something.</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 600; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 800; x++) {</div>
<div class="line">                <span class="keywordtype">float</span> <a name="a15"></a><a class="code" href="namespace_halide_1_1_runtime_1_1_internal.html#aa0e2acd3d03af60f13a8e2332701ece9">error</a> = halide_result(x, y) - c_result[y][x];</div>
<div class="line">                <span class="comment">// It&#39;s floating-point math, so we&#39;ll allow some slop:</span></div>
<div class="line">                <span class="keywordflow">if</span> (error &lt; -0.001f || error &gt; 0.001f) {</div>
<div class="line">                    printf(<span class="stringliteral">&quot;halide_result(%d, %d) = %f instead of %f\n&quot;</span>,</div>
<div class="line">                           x, y, halide_result(x, y), c_result[y][x]);</div>
<div class="line">                    <span class="keywordflow">return</span> -1;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// This stuff is hard. We ended up in a three-way trade-off</span></div>
<div class="line">    <span class="comment">// between memory bandwidth, redundant work, and</span></div>
<div class="line">    <span class="comment">// parallelism. Halide can&#39;t make the correct choice for you</span></div>
<div class="line">    <span class="comment">// automatically (sorry). Instead it tries to make it easier for</span></div>
<div class="line">    <span class="comment">// you to explore various options, without messing up your</span></div>
<div class="line">    <span class="comment">// program. In fact, Halide promises that scheduling calls like</span></div>
<div class="line">    <span class="comment">// compute_root won&#39;t change the meaning of your algorithm -- you</span></div>
<div class="line">    <span class="comment">// should get the same bits back no matter how you schedule</span></div>
<div class="line">    <span class="comment">// things.</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// So be empirical! Experiment with various schedules and keep a</span></div>
<div class="line">    <span class="comment">// log of performance. Form hypotheses and then try to prove</span></div>
<div class="line">    <span class="comment">// yourself wrong. Don&#39;t assume that you just need to vectorize</span></div>
<div class="line">    <span class="comment">// your code by a factor of four and run it on eight cores and</span></div>
<div class="line">    <span class="comment">// you&#39;ll get 32x faster. This almost never works. Modern systems</span></div>
<div class="line">    <span class="comment">// are complex enough that you can&#39;t predict performance reliably</span></div>
<div class="line">    <span class="comment">// without running your code.</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// We suggest you start by scheduling all of your non-trivial</span></div>
<div class="line">    <span class="comment">// stages compute_root, and then work from the end of the pipeline</span></div>
<div class="line">    <span class="comment">// upwards, inlining, parallelizing, and vectorizing each stage in</span></div>
<div class="line">    <span class="comment">// turn until you reach the top.</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Halide is not just about vectorizing and parallelizing your</span></div>
<div class="line">    <span class="comment">// code. That&#39;s not enough to get you very far. Halide is about</span></div>
<div class="line">    <span class="comment">// giving you tools that help you quickly explore different</span></div>
<div class="line">    <span class="comment">// trade-offs between locality, redundant work, and parallelism,</span></div>
<div class="line">    <span class="comment">// without messing up the actual result you&#39;re trying to compute.</span></div>
<div class="line"></div>
<div class="line">    printf(<span class="stringliteral">&quot;Success!\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
