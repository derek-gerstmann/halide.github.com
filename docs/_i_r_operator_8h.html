<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: IROperator.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_i_r_operator_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">IROperator.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines various operator overloads and utility functions that make it more pleasant to work with <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> expressions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_i_r_8h_source.html">IR.h</a>&quot;</code><br/>
</div>
<p><a href="_i_r_operator_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr class="memdesc:namespace_halide"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines methods for solving equations. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Halide::Internal</a></td></tr>
<tr class="memdesc:namespace_halide_1_1_internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct used to detect if a type is a pointer. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab370d99a882a8163ae91d43b94d79d02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab370d99a882a8163ae91d43b94d79d02">Halide::Internal::is_const</a> (Expr e)</td></tr>
<tr class="memdesc:ab370d99a882a8163ae91d43b94d79d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants. ">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node. ">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same.  <a href="#ab370d99a882a8163ae91d43b94d79d02">More...</a><br/></td></tr>
<tr class="separator:ab370d99a882a8163ae91d43b94d79d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b709fdbc5a6944248187216b5df5b2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4b709fdbc5a6944248187216b5df5b2e">Halide::Internal::is_const</a> (Expr e, int v)</td></tr>
<tr class="memdesc:a4b709fdbc5a6944248187216b5df5b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;width&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same.  <a href="#a4b709fdbc5a6944248187216b5df5b2e">More...</a><br/></td></tr>
<tr class="separator:a4b709fdbc5a6944248187216b5df5b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b76ccfb1d4e7cc35ff65f15f9b0077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a68b76ccfb1d4e7cc35ff65f15f9b0077">Halide::Internal::as_const_int</a> (Expr e)</td></tr>
<tr class="memdesc:a68b76ccfb1d4e7cc35ff65f15f9b0077"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, return a pointer to its value.  <a href="#a68b76ccfb1d4e7cc35ff65f15f9b0077">More...</a><br/></td></tr>
<tr class="separator:a68b76ccfb1d4e7cc35ff65f15f9b0077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a9edb743eaf6d8074867314247a970"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af2a9edb743eaf6d8074867314247a970">Halide::Internal::as_const_float</a> (Expr e)</td></tr>
<tr class="memdesc:af2a9edb743eaf6d8074867314247a970"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, return a pointer to its value.  <a href="#af2a9edb743eaf6d8074867314247a970">More...</a><br/></td></tr>
<tr class="separator:af2a9edb743eaf6d8074867314247a970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154fb51a15d5c4b8ecf6f58f62ab9324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a154fb51a15d5c4b8ecf6f58f62ab9324">Halide::Internal::is_const_power_of_two_integer</a> (Expr e, int *bits)</td></tr>
<tr class="memdesc:a154fb51a15d5c4b8ecf6f58f62ab9324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a constant integer power of two.  <a href="#a154fb51a15d5c4b8ecf6f58f62ab9324">More...</a><br/></td></tr>
<tr class="separator:a154fb51a15d5c4b8ecf6f58f62ab9324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad050aaa17987fa4cbb8fd4d41c952e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad050aaa17987fa4cbb8fd4d41c952e04">Halide::Internal::is_positive_const</a> (Expr e)</td></tr>
<tr class="memdesc:ad050aaa17987fa4cbb8fd4d41c952e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression)  <a href="#ad050aaa17987fa4cbb8fd4d41c952e04">More...</a><br/></td></tr>
<tr class="separator:ad050aaa17987fa4cbb8fd4d41c952e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc39652dfc1d64fb82d02dc4064185d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#acc39652dfc1d64fb82d02dc4064185d7">Halide::Internal::is_negative_const</a> (Expr e)</td></tr>
<tr class="memdesc:acc39652dfc1d64fb82d02dc4064185d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression)  <a href="#acc39652dfc1d64fb82d02dc4064185d7">More...</a><br/></td></tr>
<tr class="separator:acc39652dfc1d64fb82d02dc4064185d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3da8f6192d557a4bd47cf244b79a9db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af3da8f6192d557a4bd47cf244b79a9db">Halide::Internal::is_negative_negatable_const</a> (Expr e)</td></tr>
<tr class="memdesc:af3da8f6192d557a4bd47cf244b79a9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) and is its negative value representable.  <a href="#af3da8f6192d557a4bd47cf244b79a9db">More...</a><br/></td></tr>
<tr class="separator:af3da8f6192d557a4bd47cf244b79a9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a521ef987e7964954b997e6dcc5e65b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1a521ef987e7964954b997e6dcc5e65b">Halide::Internal::is_zero</a> (Expr e)</td></tr>
<tr class="memdesc:a1a521ef987e7964954b997e6dcc5e65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression)  <a href="#a1a521ef987e7964954b997e6dcc5e65b">More...</a><br/></td></tr>
<tr class="separator:a1a521ef987e7964954b997e6dcc5e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940b37091a8f16bf1e4a78db7764274e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a940b37091a8f16bf1e4a78db7764274e">Halide::Internal::is_one</a> (Expr e)</td></tr>
<tr class="memdesc:a940b37091a8f16bf1e4a78db7764274e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression)  <a href="#a940b37091a8f16bf1e4a78db7764274e">More...</a><br/></td></tr>
<tr class="separator:a940b37091a8f16bf1e4a78db7764274e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeed2f66190d11ee6e56e4089a1f441b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abeed2f66190d11ee6e56e4089a1f441b">Halide::Internal::is_two</a> (Expr e)</td></tr>
<tr class="memdesc:abeed2f66190d11ee6e56e4089a1f441b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression)  <a href="#abeed2f66190d11ee6e56e4089a1f441b">More...</a><br/></td></tr>
<tr class="separator:abeed2f66190d11ee6e56e4089a1f441b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d7b687f4ac09ca9236cb1b8b82bb51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab2d7b687f4ac09ca9236cb1b8b82bb51">Halide::Internal::is_no_op</a> (Stmt s)</td></tr>
<tr class="memdesc:ab2d7b687f4ac09ca9236cb1b8b82bb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect. ">Evaluate</a> node of a constant)  <a href="#ab2d7b687f4ac09ca9236cb1b8b82bb51">More...</a><br/></td></tr>
<tr class="separator:ab2d7b687f4ac09ca9236cb1b8b82bb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225fbecd4560e77ea24cb16541fe6b15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a225fbecd4560e77ea24cb16541fe6b15">Halide::Internal::int_cast_constant</a> (Type t, int val)</td></tr>
<tr class="memdesc:a225fbecd4560e77ea24cb16541fe6b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an integer value, cast it into a designated integer type and return the bits as int.  <a href="#a225fbecd4560e77ea24cb16541fe6b15">More...</a><br/></td></tr>
<tr class="separator:a225fbecd4560e77ea24cb16541fe6b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48739c460778f7af77999cfd251d5af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab48739c460778f7af77999cfd251d5af">Halide::Internal::make_const</a> (Type t, int val)</td></tr>
<tr class="memdesc:ab48739c460778f7af77999cfd251d5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const of the given type.  <a href="#ab48739c460778f7af77999cfd251d5af">More...</a><br/></td></tr>
<tr class="separator:ab48739c460778f7af77999cfd251d5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e258c84149c36aad7d93cced54cd173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1e258c84149c36aad7d93cced54cd173">Halide::Internal::make_bool</a> (bool val, int width=1)</td></tr>
<tr class="memdesc:a1e258c84149c36aad7d93cced54cd173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean constant from a C++ boolean value.  <a href="#a1e258c84149c36aad7d93cced54cd173">More...</a><br/></td></tr>
<tr class="separator:a1e258c84149c36aad7d93cced54cd173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fedf535d58f8900f8b7c00aa15ece8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a57fedf535d58f8900f8b7c00aa15ece8">Halide::Internal::make_zero</a> (Type t)</td></tr>
<tr class="memdesc:a57fedf535d58f8900f8b7c00aa15ece8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of zero in the given type.  <a href="#a57fedf535d58f8900f8b7c00aa15ece8">More...</a><br/></td></tr>
<tr class="separator:a57fedf535d58f8900f8b7c00aa15ece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ace305dbdd7fed2cf9d5057d4c02067c9">Halide::Internal::make_one</a> (Type t)</td></tr>
<tr class="memdesc:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of one in the given type.  <a href="#ace305dbdd7fed2cf9d5057d4c02067c9">More...</a><br/></td></tr>
<tr class="separator:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc35f0dc3562ffb5bb777021679435e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afc35f0dc3562ffb5bb777021679435e2">Halide::Internal::make_two</a> (Type t)</td></tr>
<tr class="memdesc:afc35f0dc3562ffb5bb777021679435e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of two in the given type.  <a href="#afc35f0dc3562ffb5bb777021679435e2">More...</a><br/></td></tr>
<tr class="separator:afc35f0dc3562ffb5bb777021679435e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8e27a136a9facf0e97e6ac6bd71c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0f8e27a136a9facf0e97e6ac6bd71c23">Halide::Internal::const_true</a> (int width=1)</td></tr>
<tr class="memdesc:a0f8e27a136a9facf0e97e6ac6bd71c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean true.  <a href="#a0f8e27a136a9facf0e97e6ac6bd71c23">More...</a><br/></td></tr>
<tr class="separator:a0f8e27a136a9facf0e97e6ac6bd71c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5d4e90106e92aa21840547b6588eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6c5d4e90106e92aa21840547b6588eb3">Halide::Internal::const_false</a> (int width=1)</td></tr>
<tr class="memdesc:a6c5d4e90106e92aa21840547b6588eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean false.  <a href="#a6c5d4e90106e92aa21840547b6588eb3">More...</a><br/></td></tr>
<tr class="separator:a6c5d4e90106e92aa21840547b6588eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40a26aac941b763435e9915851cd073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types</a> (Expr &amp;a, Expr &amp;b)</td></tr>
<tr class="memdesc:ab40a26aac941b763435e9915851cd073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce the two expressions to have the same type, using C-style casting rules.  <a href="#ab40a26aac941b763435e9915851cd073">More...</a><br/></td></tr>
<tr class="separator:ab40a26aac941b763435e9915851cd073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5890bd4a8aae2f1f6a2c43496d8ddae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac5890bd4a8aae2f1f6a2c43496d8ddae">Halide::Internal::raise_to_integer_power</a> (Expr a, int b)</td></tr>
<tr class="memdesc:ac5890bd4a8aae2f1f6a2c43496d8ddae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise an expression to an integer power by repeatedly multiplying it by itself.  <a href="#ac5890bd4a8aae2f1f6a2c43496d8ddae">More...</a><br/></td></tr>
<tr class="separator:ac5890bd4a8aae2f1f6a2c43496d8ddae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c6da1a731c0804063458b531e8a849"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51c6da1a731c0804063458b531e8a849"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a51c6da1a731c0804063458b531e8a849">Halide::cast</a> (Expr a)</td></tr>
<tr class="memdesc:a51c6da1a731c0804063458b531e8a849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to the halide type corresponding to the C++ type T.  <a href="#a51c6da1a731c0804063458b531e8a849">More...</a><br/></td></tr>
<tr class="separator:a51c6da1a731c0804063458b531e8a849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ce0e6da961a52ace4b8fa8444fac20"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a69ce0e6da961a52ace4b8fa8444fac20">Halide::cast</a> (Type t, Expr a)</td></tr>
<tr class="memdesc:a69ce0e6da961a52ace4b8fa8444fac20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a new type.  <a href="#a69ce0e6da961a52ace4b8fa8444fac20">More...</a><br/></td></tr>
<tr class="separator:a69ce0e6da961a52ace4b8fa8444fac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db532b84ba55ff72555c4b427fc42bc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2db532b84ba55ff72555c4b427fc42bc">Halide::operator+</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a2db532b84ba55ff72555c4b427fc42bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a2db532b84ba55ff72555c4b427fc42bc">More...</a><br/></td></tr>
<tr class="separator:a2db532b84ba55ff72555c4b427fc42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd77e71422999076fa3339829ac8c30d"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acd77e71422999076fa3339829ac8c30d">Halide::operator+=</a> (Expr &amp;a, Expr b)</td></tr>
<tr class="memdesc:acd77e71422999076fa3339829ac8c30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the sum of two expressions, without changing its type.  <a href="#acd77e71422999076fa3339829ac8c30d">More...</a><br/></td></tr>
<tr class="separator:acd77e71422999076fa3339829ac8c30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f3eb27005363158ca0e934811c98ed"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a86f3eb27005363158ca0e934811c98ed">Halide::operator-</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a86f3eb27005363158ca0e934811c98ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a86f3eb27005363158ca0e934811c98ed">More...</a><br/></td></tr>
<tr class="separator:a86f3eb27005363158ca0e934811c98ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80881209a15ed749e168d6edbcb6f687"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a80881209a15ed749e168d6edbcb6f687">Halide::operator-</a> (Expr a)</td></tr>
<tr class="memdesc:a80881209a15ed749e168d6edbcb6f687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negative of the argument.  <a href="#a80881209a15ed749e168d6edbcb6f687">More...</a><br/></td></tr>
<tr class="separator:a80881209a15ed749e168d6edbcb6f687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94db82f1af5cd7492bb503c2238ade8a"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a94db82f1af5cd7492bb503c2238ade8a">Halide::operator-=</a> (Expr &amp;a, Expr b)</td></tr>
<tr class="memdesc:a94db82f1af5cd7492bb503c2238ade8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the difference of two expressions, without changing its type.  <a href="#a94db82f1af5cd7492bb503c2238ade8a">More...</a><br/></td></tr>
<tr class="separator:a94db82f1af5cd7492bb503c2238ade8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908c6748ab34a4a66274b196b6900af5"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a908c6748ab34a4a66274b196b6900af5">Halide::operator*</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a908c6748ab34a4a66274b196b6900af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a908c6748ab34a4a66274b196b6900af5">More...</a><br/></td></tr>
<tr class="separator:a908c6748ab34a4a66274b196b6900af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac0c84f284a38d6018e2d4e5d075c8b5b">Halide::operator*=</a> (Expr &amp;a, Expr b)</td></tr>
<tr class="memdesc:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the product of two expressions, without changing its type.  <a href="#ac0c84f284a38d6018e2d4e5d075c8b5b">More...</a><br/></td></tr>
<tr class="separator:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a73e12ddd6395e3a1c1286e2e3c51e675">Halide::operator/</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ratio of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a73e12ddd6395e3a1c1286e2e3c51e675">More...</a><br/></td></tr>
<tr class="separator:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0da6820c40a5911fb23d973283487f"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3c0da6820c40a5911fb23d973283487f">Halide::operator/=</a> (Expr &amp;a, Expr b)</td></tr>
<tr class="memdesc:a3c0da6820c40a5911fb23d973283487f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the ratio of two expressions, without changing its type.  <a href="#a3c0da6820c40a5911fb23d973283487f">More...</a><br/></td></tr>
<tr class="separator:a3c0da6820c40a5911fb23d973283487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc191ed3318e2072d18f42d11f5b01d4"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc191ed3318e2072d18f42d11f5b01d4">Halide::operator%</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abc191ed3318e2072d18f42d11f5b01d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument reduced modulo the second, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#abc191ed3318e2072d18f42d11f5b01d4">More...</a><br/></td></tr>
<tr class="separator:abc191ed3318e2072d18f42d11f5b01d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9105ae9f0995f450825e522170f5d1e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af9105ae9f0995f450825e522170f5d1e">Halide::operator&gt;</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:af9105ae9f0995f450825e522170f5d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#af9105ae9f0995f450825e522170f5d1e">More...</a><br/></td></tr>
<tr class="separator:af9105ae9f0995f450825e522170f5d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbad5ee20448455260670dec22c76a21"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abbad5ee20448455260670dec22c76a21">Halide::operator&lt;</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abbad5ee20448455260670dec22c76a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#abbad5ee20448455260670dec22c76a21">More...</a><br/></td></tr>
<tr class="separator:abbad5ee20448455260670dec22c76a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad297e6fa5deb0ba4e8ad7fe344629706">Halide::operator&lt;=</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#ad297e6fa5deb0ba4e8ad7fe344629706">More...</a><br/></td></tr>
<tr class="separator:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8f2e815b9cc7475802c0fb6a7e7ae6ae">Halide::operator&gt;=</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a8f2e815b9cc7475802c0fb6a7e7ae6ae">More...</a><br/></td></tr>
<tr class="separator:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abfbbb2e5820938f4d8f0a8b2324776df">Halide::operator==</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abfbbb2e5820938f4d8f0a8b2324776df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#abfbbb2e5820938f4d8f0a8b2324776df">More...</a><br/></td></tr>
<tr class="separator:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3d11c86964dbb2586103744cac1614"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d3d11c86964dbb2586103744cac1614">Halide::operator!=</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a8d3d11c86964dbb2586103744cac1614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is not equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a8d3d11c86964dbb2586103744cac1614">More...</a><br/></td></tr>
<tr class="separator:a8d3d11c86964dbb2586103744cac1614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df159d6ed5236cc8e02d04bf72be4f"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a02df159d6ed5236cc8e02d04bf72be4f">Halide::operator&amp;&amp;</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a02df159d6ed5236cc8e02d04bf72be4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical and of the two arguments.  <a href="#a02df159d6ed5236cc8e02d04bf72be4f">More...</a><br/></td></tr>
<tr class="separator:a02df159d6ed5236cc8e02d04bf72be4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3528931d7929d533103ada2badca092c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3528931d7929d533103ada2badca092c">Halide::operator||</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a3528931d7929d533103ada2badca092c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical or of the two arguments.  <a href="#a3528931d7929d533103ada2badca092c">More...</a><br/></td></tr>
<tr class="separator:a3528931d7929d533103ada2badca092c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb54256bfab344b6720775cf2e0936e0"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afb54256bfab344b6720775cf2e0936e0">Halide::operator!</a> (Expr a)</td></tr>
<tr class="memdesc:afb54256bfab344b6720775cf2e0936e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical not the argument.  <a href="#afb54256bfab344b6720775cf2e0936e0">More...</a><br/></td></tr>
<tr class="separator:afb54256bfab344b6720775cf2e0936e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec">Halide::max</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a9a00cabb9f57b4cf5d101b2af338f5ec">More...</a><br/></td></tr>
<tr class="separator:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b5db24ca379dda8241433c0014c940"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940">Halide::min</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a38b5db24ca379dda8241433c0014c940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a38b5db24ca379dda8241433c0014c940">More...</a><br/></td></tr>
<tr class="separator:a38b5db24ca379dda8241433c0014c940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fc11b69e1ae900cebae51c319a1caa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a41fc11b69e1ae900cebae51c319a1caa">Halide::clamp</a> (Expr a, Expr min_val, Expr max_val)</td></tr>
<tr class="memdesc:a41fc11b69e1ae900cebae51c319a1caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps an expression to lie within the given bounds.  <a href="#a41fc11b69e1ae900cebae51c319a1caa">More...</a><br/></td></tr>
<tr class="separator:a41fc11b69e1ae900cebae51c319a1caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae698f4bfd37d3d15cee4bf22c4627e0d">Halide::abs</a> (Expr a)</td></tr>
<tr class="memdesc:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a signed integer or floating-point expression.  <a href="#ae698f4bfd37d3d15cee4bf22c4627e0d">More...</a><br/></td></tr>
<tr class="separator:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d96f6e421c7a9a25f3d027283c7149d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d96f6e421c7a9a25f3d027283c7149d">Halide::absd</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a8d96f6e421c7a9a25f3d027283c7149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute difference between two values.  <a href="#a8d96f6e421c7a9a25f3d027283c7149d">More...</a><br/></td></tr>
<tr class="separator:a8d96f6e421c7a9a25f3d027283c7149d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6371892ae38e7eb681fd3f23945b06"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">Halide::select</a> (Expr condition, Expr true_value, Expr false_value)</td></tr>
<tr class="memdesc:a9d6371892ae38e7eb681fd3f23945b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression similar to the ternary operator in C, except that it always evaluates all arguments.  <a href="#a9d6371892ae38e7eb681fd3f23945b06">More...</a><br/></td></tr>
<tr class="separator:a9d6371892ae38e7eb681fd3f23945b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1fca22f79625765096133e39caee5e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">Halide::sin</a> (Expr x)</td></tr>
<tr class="memdesc:a5e1fca22f79625765096133e39caee5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of a floating-point expression.  <a href="#a5e1fca22f79625765096133e39caee5e">More...</a><br/></td></tr>
<tr class="separator:a5e1fca22f79625765096133e39caee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3bfc77a80e6b40a6c00899a8e2ad1f28">Halide::asin</a> (Expr x)</td></tr>
<tr class="memdesc:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arcsine of a floating-point expression.  <a href="#a3bfc77a80e6b40a6c00899a8e2ad1f28">More...</a><br/></td></tr>
<tr class="separator:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1ef33189b99c7b8bc73b5e10121834"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7e1ef33189b99c7b8bc73b5e10121834">Halide::cos</a> (Expr x)</td></tr>
<tr class="memdesc:a7e1ef33189b99c7b8bc73b5e10121834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of a floating-point expression.  <a href="#a7e1ef33189b99c7b8bc73b5e10121834">More...</a><br/></td></tr>
<tr class="separator:a7e1ef33189b99c7b8bc73b5e10121834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a64d3ef272e07177d95b624968951"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a722a64d3ef272e07177d95b624968951">Halide::acos</a> (Expr x)</td></tr>
<tr class="memdesc:a722a64d3ef272e07177d95b624968951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arccosine of a floating-point expression.  <a href="#a722a64d3ef272e07177d95b624968951">More...</a><br/></td></tr>
<tr class="separator:a722a64d3ef272e07177d95b624968951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18f43994d3cf73c20b7eb62b243076e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad18f43994d3cf73c20b7eb62b243076e">Halide::tan</a> (Expr x)</td></tr>
<tr class="memdesc:ad18f43994d3cf73c20b7eb62b243076e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of a floating-point expression.  <a href="#ad18f43994d3cf73c20b7eb62b243076e">More...</a><br/></td></tr>
<tr class="separator:ad18f43994d3cf73c20b7eb62b243076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3b0ec19519602bc880a1ae0236f1c3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe3b0ec19519602bc880a1ae0236f1c3">Halide::atan</a> (Expr x)</td></tr>
<tr class="memdesc:abe3b0ec19519602bc880a1ae0236f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arctangent of a floating-point expression.  <a href="#abe3b0ec19519602bc880a1ae0236f1c3">More...</a><br/></td></tr>
<tr class="separator:abe3b0ec19519602bc880a1ae0236f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5646de466ac31efd07ec5af1e4603cbf"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5646de466ac31efd07ec5af1e4603cbf">Halide::atan2</a> (Expr y, Expr x)</td></tr>
<tr class="memdesc:a5646de466ac31efd07ec5af1e4603cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angle of a floating-point gradient.  <a href="#a5646de466ac31efd07ec5af1e4603cbf">More...</a><br/></td></tr>
<tr class="separator:a5646de466ac31efd07ec5af1e4603cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe05bc670b713a278f8182457a750bd9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe05bc670b713a278f8182457a750bd9">Halide::sinh</a> (Expr x)</td></tr>
<tr class="memdesc:abe05bc670b713a278f8182457a750bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of a floating-point expression.  <a href="#abe05bc670b713a278f8182457a750bd9">More...</a><br/></td></tr>
<tr class="separator:abe05bc670b713a278f8182457a750bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">Halide::asinh</a> (Expr x)</td></tr>
<tr class="memdesc:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arcsinhe of a floating-point expression.  <a href="#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">More...</a><br/></td></tr>
<tr class="separator:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68aff5fc199ecbabe209ce32ec507292"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a68aff5fc199ecbabe209ce32ec507292">Halide::cosh</a> (Expr x)</td></tr>
<tr class="memdesc:a68aff5fc199ecbabe209ce32ec507292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of a floating-point expression.  <a href="#a68aff5fc199ecbabe209ce32ec507292">More...</a><br/></td></tr>
<tr class="separator:a68aff5fc199ecbabe209ce32ec507292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2ce048ac6f7c309d26c83fbc3132be2b">Halide::acosh</a> (Expr x)</td></tr>
<tr class="memdesc:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arccosine of a floating-point expression.  <a href="#a2ce048ac6f7c309d26c83fbc3132be2b">More...</a><br/></td></tr>
<tr class="separator:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb15a9760067c05d2e5a343f529188be"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acb15a9760067c05d2e5a343f529188be">Halide::tanh</a> (Expr x)</td></tr>
<tr class="memdesc:acb15a9760067c05d2e5a343f529188be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of a floating-point expression.  <a href="#acb15a9760067c05d2e5a343f529188be">More...</a><br/></td></tr>
<tr class="separator:acb15a9760067c05d2e5a343f529188be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd93e33e8d82be7cf9487e881d834ec9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acd93e33e8d82be7cf9487e881d834ec9">Halide::atanh</a> (Expr x)</td></tr>
<tr class="memdesc:acd93e33e8d82be7cf9487e881d834ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arctangent of a floating-point expression.  <a href="#acd93e33e8d82be7cf9487e881d834ec9">More...</a><br/></td></tr>
<tr class="separator:acd93e33e8d82be7cf9487e881d834ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7f08f13439b86581a47162e1a2d2de"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">Halide::sqrt</a> (Expr x)</td></tr>
<tr class="memdesc:abc7f08f13439b86581a47162e1a2d2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of a floating-point expression.  <a href="#abc7f08f13439b86581a47162e1a2d2de">More...</a><br/></td></tr>
<tr class="separator:abc7f08f13439b86581a47162e1a2d2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb75ff010919c00492e4f654a4d8f85"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4fb75ff010919c00492e4f654a4d8f85">Halide::hypot</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a4fb75ff010919c00492e4f654a4d8f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the sum of the squares of two floating-point expressions.  <a href="#a4fb75ff010919c00492e4f654a4d8f85">More...</a><br/></td></tr>
<tr class="separator:a4fb75ff010919c00492e4f654a4d8f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c6187068d6e839e548776dfa7dde3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a877c6187068d6e839e548776dfa7dde3">Halide::exp</a> (Expr x)</td></tr>
<tr class="memdesc:a877c6187068d6e839e548776dfa7dde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponential of a floating-point expression.  <a href="#a877c6187068d6e839e548776dfa7dde3">More...</a><br/></td></tr>
<tr class="separator:a877c6187068d6e839e548776dfa7dde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f1c38239e6e977fea90b94217499ae"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a02f1c38239e6e977fea90b94217499ae">Halide::log</a> (Expr x)</td></tr>
<tr class="memdesc:a02f1c38239e6e977fea90b94217499ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logarithm of a floating-point expression.  <a href="#a02f1c38239e6e977fea90b94217499ae">More...</a><br/></td></tr>
<tr class="separator:a02f1c38239e6e977fea90b94217499ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd83996070aa3e4bc3a102a654176fa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4dd83996070aa3e4bc3a102a654176fa">Halide::pow</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a4dd83996070aa3e4bc3a102a654176fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one floating point expression raised to the power of another.  <a href="#a4dd83996070aa3e4bc3a102a654176fa">More...</a><br/></td></tr>
<tr class="separator:a4dd83996070aa3e4bc3a102a654176fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a80df08887f9457c9bffc349f834ce1"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a80df08887f9457c9bffc349f834ce1">Halide::erf</a> (Expr x)</td></tr>
<tr class="memdesc:a9a80df08887f9457c9bffc349f834ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the error function erf.  <a href="#a9a80df08887f9457c9bffc349f834ce1">More...</a><br/></td></tr>
<tr class="separator:a9a80df08887f9457c9bffc349f834ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df3f02c28d9710c836194f5b2e9e8c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7df3f02c28d9710c836194f5b2e9e8c7">Halide::fast_log</a> (Expr x)</td></tr>
<tr class="memdesc:a7df3f02c28d9710c836194f5b2e9e8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable log for Float(32).  <a href="#a7df3f02c28d9710c836194f5b2e9e8c7">More...</a><br/></td></tr>
<tr class="separator:a7df3f02c28d9710c836194f5b2e9e8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df130f96d92c066478cd28148d8af53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5df130f96d92c066478cd28148d8af53">Halide::fast_exp</a> (Expr x)</td></tr>
<tr class="memdesc:a5df130f96d92c066478cd28148d8af53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable exp for Float(32).  <a href="#a5df130f96d92c066478cd28148d8af53">More...</a><br/></td></tr>
<tr class="separator:a5df130f96d92c066478cd28148d8af53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958457cd688f84d583779e649c9e52e6"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a958457cd688f84d583779e649c9e52e6">Halide::fast_pow</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a958457cd688f84d583779e649c9e52e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable pow for Float(32).  <a href="#a958457cd688f84d583779e649c9e52e6">More...</a><br/></td></tr>
<tr class="separator:a958457cd688f84d583779e649c9e52e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343eac4b4aa329e52c7cbf8167902696"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a343eac4b4aa329e52c7cbf8167902696">Halide::fast_inverse</a> (Expr x)</td></tr>
<tr class="memdesc:a343eac4b4aa329e52c7cbf8167902696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate inverse for Float(32).  <a href="#a343eac4b4aa329e52c7cbf8167902696">More...</a><br/></td></tr>
<tr class="separator:a343eac4b4aa329e52c7cbf8167902696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4424b070b363f53107a6c2705bbe50b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad4424b070b363f53107a6c2705bbe50b">Halide::fast_inverse_sqrt</a> (Expr x)</td></tr>
<tr class="memdesc:ad4424b070b363f53107a6c2705bbe50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate inverse square root for Float(32).  <a href="#ad4424b070b363f53107a6c2705bbe50b">More...</a><br/></td></tr>
<tr class="separator:ad4424b070b363f53107a6c2705bbe50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed670387016322f8db2b7abdecdc0e4c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed670387016322f8db2b7abdecdc0e4c">Halide::floor</a> (Expr x)</td></tr>
<tr class="memdesc:aed670387016322f8db2b7abdecdc0e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest whole number less than or equal to a floating-point expression.  <a href="#aed670387016322f8db2b7abdecdc0e4c">More...</a><br/></td></tr>
<tr class="separator:aed670387016322f8db2b7abdecdc0e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070dde32195d1ae83082c15fd11d5d90"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a070dde32195d1ae83082c15fd11d5d90">Halide::ceil</a> (Expr x)</td></tr>
<tr class="memdesc:a070dde32195d1ae83082c15fd11d5d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least whole number greater than or equal to a floating-point expression.  <a href="#a070dde32195d1ae83082c15fd11d5d90">More...</a><br/></td></tr>
<tr class="separator:a070dde32195d1ae83082c15fd11d5d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2090a77072af682d9e2daea086d2fe"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d2090a77072af682d9e2daea086d2fe">Halide::round</a> (Expr x)</td></tr>
<tr class="memdesc:a9d2090a77072af682d9e2daea086d2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the whole number closest to a floating-point expression.  <a href="#a9d2090a77072af682d9e2daea086d2fe">More...</a><br/></td></tr>
<tr class="separator:a9d2090a77072af682d9e2daea086d2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287f93889910a28197d2a1631486a433"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a287f93889910a28197d2a1631486a433">Halide::trunc</a> (Expr x)</td></tr>
<tr class="memdesc:a287f93889910a28197d2a1631486a433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the integer part of a floating-point expression.  <a href="#a287f93889910a28197d2a1631486a433">More...</a><br/></td></tr>
<tr class="separator:a287f93889910a28197d2a1631486a433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71c5b6b09e0f679724ccfb95515b338"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab71c5b6b09e0f679724ccfb95515b338">Halide::is_nan</a> (Expr x)</td></tr>
<tr class="memdesc:ab71c5b6b09e0f679724ccfb95515b338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the argument is a Not a Number (NaN).  <a href="#ab71c5b6b09e0f679724ccfb95515b338">More...</a><br/></td></tr>
<tr class="separator:ab71c5b6b09e0f679724ccfb95515b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fd83b219755aef0e53062cffc111bc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a57fd83b219755aef0e53062cffc111bc">Halide::fract</a> (Expr x)</td></tr>
<tr class="memdesc:a57fd83b219755aef0e53062cffc111bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fractional part of a floating-point expression.  <a href="#a57fd83b219755aef0e53062cffc111bc">More...</a><br/></td></tr>
<tr class="separator:a57fd83b219755aef0e53062cffc111bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0f13f0a9e97bf7673ca5a8e04b1bd9a9">Halide::reinterpret</a> (Type t, Expr e)</td></tr>
<tr class="memdesc:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret the bits of one value as another type.  <a href="#a0f13f0a9e97bf7673ca5a8e04b1bd9a9">More...</a><br/></td></tr>
<tr class="separator:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2012c20f1666555e7a229c9db1b64091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2012c20f1666555e7a229c9db1b64091"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2012c20f1666555e7a229c9db1b64091">Halide::reinterpret</a> (Expr e)</td></tr>
<tr class="separator:a2012c20f1666555e7a229c9db1b64091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec8e49b0b42230077ee6bdca669d299"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4ec8e49b0b42230077ee6bdca669d299">Halide::operator&amp;</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a4ec8e49b0b42230077ee6bdca669d299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise and of two expressions (which need not have the same type).  <a href="#a4ec8e49b0b42230077ee6bdca669d299">More...</a><br/></td></tr>
<tr class="separator:a4ec8e49b0b42230077ee6bdca669d299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8bec8d2f6194f4db7b88e554173f05"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe8bec8d2f6194f4db7b88e554173f05">Halide::operator|</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:abe8bec8d2f6194f4db7b88e554173f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise or of two expressions (which need not have the same type).  <a href="#abe8bec8d2f6194f4db7b88e554173f05">More...</a><br/></td></tr>
<tr class="separator:abe8bec8d2f6194f4db7b88e554173f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdde4dd479f4eb59631e09148897ad2a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afdde4dd479f4eb59631e09148897ad2a">Halide::operator^</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:afdde4dd479f4eb59631e09148897ad2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise exclusive or of two expressions (which need not have the same type).  <a href="#afdde4dd479f4eb59631e09148897ad2a">More...</a><br/></td></tr>
<tr class="separator:afdde4dd479f4eb59631e09148897ad2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c07e39289b14103ccd45ee31630a3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afc9c07e39289b14103ccd45ee31630a3">Halide::operator~</a> (Expr x)</td></tr>
<tr class="memdesc:afc9c07e39289b14103ccd45ee31630a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise not of an expression.  <a href="#afc9c07e39289b14103ccd45ee31630a3">More...</a><br/></td></tr>
<tr class="separator:afc9c07e39289b14103ccd45ee31630a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39865d2369d130f6c8e435c860cafb14"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a39865d2369d130f6c8e435c860cafb14">Halide::operator&lt;&lt;</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a39865d2369d130f6c8e435c860cafb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value left.  <a href="#a39865d2369d130f6c8e435c860cafb14">More...</a><br/></td></tr>
<tr class="separator:a39865d2369d130f6c8e435c860cafb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0615561baf45c3d84e7d36c77204ee3d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0615561baf45c3d84e7d36c77204ee3d">Halide::operator&gt;&gt;</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a0615561baf45c3d84e7d36c77204ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value right.  <a href="#a0615561baf45c3d84e7d36c77204ee3d">More...</a><br/></td></tr>
<tr class="separator:a0615561baf45c3d84e7d36c77204ee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55158f5f229510194c425dfae256d530"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">Halide::lerp</a> (Expr zero_val, Expr one_val, Expr weight)</td></tr>
<tr class="memdesc:a55158f5f229510194c425dfae256d530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolate between the two values according to a weight.  <a href="#a55158f5f229510194c425dfae256d530">More...</a><br/></td></tr>
<tr class="separator:a55158f5f229510194c425dfae256d530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dd5e65a4c167c112de447c628c099a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a41dd5e65a4c167c112de447c628c099a">Halide::popcount</a> (Expr x)</td></tr>
<tr class="memdesc:a41dd5e65a4c167c112de447c628c099a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of set bits in an expression.  <a href="#a41dd5e65a4c167c112de447c628c099a">More...</a><br/></td></tr>
<tr class="separator:a41dd5e65a4c167c112de447c628c099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e39642cc99af99045ec5f424cde8709"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0e39642cc99af99045ec5f424cde8709">Halide::count_leading_zeros</a> (Expr x)</td></tr>
<tr class="memdesc:a0e39642cc99af99045ec5f424cde8709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of leading zero bits in an expression.  <a href="#a0e39642cc99af99045ec5f424cde8709">More...</a><br/></td></tr>
<tr class="separator:a0e39642cc99af99045ec5f424cde8709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0042ff9c2283a15cda1a1e72de460ad"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa0042ff9c2283a15cda1a1e72de460ad">Halide::count_trailing_zeros</a> (Expr x)</td></tr>
<tr class="memdesc:aa0042ff9c2283a15cda1a1e72de460ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of trailing zero bits in an expression.  <a href="#aa0042ff9c2283a15cda1a1e72de460ad">More...</a><br/></td></tr>
<tr class="separator:aa0042ff9c2283a15cda1a1e72de460ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bd57263c72c6712b643ab6486ed026"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">Halide::random_float</a> (Expr seed=Expr())</td></tr>
<tr class="memdesc:a59bd57263c72c6712b643ab6486ed026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed float in the half-open interval [0.0f, 1.0f).  <a href="#a59bd57263c72c6712b643ab6486ed026">More...</a><br/></td></tr>
<tr class="separator:a59bd57263c72c6712b643ab6486ed026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed5b59d6a43446e311633912427b2b3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aaed5b59d6a43446e311633912427b2b3">Halide::random_int</a> (Expr seed=Expr())</td></tr>
<tr class="memdesc:aaed5b59d6a43446e311633912427b2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed 32-bit integer.  <a href="#aaed5b59d6a43446e311633912427b2b3">More...</a><br/></td></tr>
<tr class="separator:aaed5b59d6a43446e311633912427b2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b821cbe0e228fd5036e9fb1ed693184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7b821cbe0e228fd5036e9fb1ed693184">Halide::Internal::collect_print_args</a> (std::vector&lt; Expr &gt; &amp;args)</td></tr>
<tr class="separator:a7b821cbe0e228fd5036e9fb1ed693184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9982063c270fa6105ff9b344b5fe3942"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9982063c270fa6105ff9b344b5fe3942"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a9982063c270fa6105ff9b344b5fe3942">Halide::Internal::collect_print_args</a> (std::vector&lt; Expr &gt; &amp;args, const char *arg, Args...more_args)</td></tr>
<tr class="separator:a9982063c270fa6105ff9b344b5fe3942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb289be45f3b43a85bd2e06597b45d28"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abb289be45f3b43a85bd2e06597b45d28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abb289be45f3b43a85bd2e06597b45d28">Halide::Internal::collect_print_args</a> (std::vector&lt; Expr &gt; &amp;args, Expr arg, Args...more_args)</td></tr>
<tr class="separator:abb289be45f3b43a85bd2e06597b45d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9389bcacbed602df70eae94826312e03"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9389bcacbed602df70eae94826312e03">Halide::undef</a> (Type t)</td></tr>
<tr class="memdesc:a9389bcacbed602df70eae94826312e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an undef value of the given type.  <a href="#a9389bcacbed602df70eae94826312e03">More...</a><br/></td></tr>
<tr class="separator:a9389bcacbed602df70eae94826312e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f29c5417077b940483e88cc9c1c74b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f29c5417077b940483e88cc9c1c74b2"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4f29c5417077b940483e88cc9c1c74b2">Halide::undef</a> ()</td></tr>
<tr class="separator:a4f29c5417077b940483e88cc9c1c74b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764">Halide::likely</a> (Expr e)</td></tr>
<tr class="memdesc:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expressions tagged with this intrinsic are considered to be part of the steady state of some loop with a nasty beginning and end (e.g.  <a href="#afbf18e1b8bab056f8f8e8f1af8cbd764">More...</a><br/></td></tr>
<tr class="separator:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f84a0040711a023783268f1213caa3e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f84a0040711a023783268f1213caa3e"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8f84a0040711a023783268f1213caa3e">Halide::Internal::scalar_to_constant_expr</a> (T value)</td></tr>
<tr class="memdesc:a8f84a0040711a023783268f1213caa3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a scalar constant, return an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that represents it.  <a href="#a8f84a0040711a023783268f1213caa3e">More...</a><br/></td></tr>
<tr class="separator:a8f84a0040711a023783268f1213caa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40117c4a26ac5f612f075a99b5c87207"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a40117c4a26ac5f612f075a99b5c87207"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a40117c4a26ac5f612f075a99b5c87207">Halide::Internal::scalar_to_constant_expr</a> (float f32)</td></tr>
<tr class="separator:a40117c4a26ac5f612f075a99b5c87207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c1973a3b52e6908d939810844d8405"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab5c1973a3b52e6908d939810844d8405"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab5c1973a3b52e6908d939810844d8405">Halide::Internal::scalar_to_constant_expr</a> (double f64)</td></tr>
<tr class="separator:ab5c1973a3b52e6908d939810844d8405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14a81e0ff39d55ece7cc41600486337"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac14a81e0ff39d55ece7cc41600486337"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac14a81e0ff39d55ece7cc41600486337">Halide::Internal::scalar_to_constant_expr</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> i)</td></tr>
<tr class="separator:ac14a81e0ff39d55ece7cc41600486337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7e626d2cf8d0e105f2d7e9b80b5d70"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3b7e626d2cf8d0e105f2d7e9b80b5d70"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3b7e626d2cf8d0e105f2d7e9b80b5d70">Halide::Internal::scalar_to_constant_expr</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> u)</td></tr>
<tr class="separator:a3b7e626d2cf8d0e105f2d7e9b80b5d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69be35df1689b43027589dad39bb47da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69be35df1689b43027589dad39bb47da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a69be35df1689b43027589dad39bb47da">Halide::Internal::scalar_from_constant_expr</a> (Expr e, T *value)</td></tr>
<tr class="memdesc:a69be35df1689b43027589dad39bb47da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> produced by scalar_to_constant_expr&lt;T&gt;, extract the constant value of type T and return true.  <a href="#a69be35df1689b43027589dad39bb47da">More...</a><br/></td></tr>
<tr class="separator:a69be35df1689b43027589dad39bb47da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af36627bf7242718b1c73214296dc9090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af36627bf7242718b1c73214296dc9090">Halide::Internal::halide_log</a> (Expr a)</td></tr>
<tr class="memdesc:af36627bf7242718b1c73214296dc9090"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s vectorizable transcendentals.  <a href="#af36627bf7242718b1c73214296dc9090">More...</a><br/></td></tr>
<tr class="separator:af36627bf7242718b1c73214296dc9090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5688772a963296ea52d2bd9ac5913e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5688772a963296ea52d2bd9ac5913e79">Halide::Internal::halide_exp</a> (Expr a)</td></tr>
<tr class="memdesc:a5688772a963296ea52d2bd9ac5913e79"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s vectorizable transcendentals.  <a href="#a5688772a963296ea52d2bd9ac5913e79">More...</a><br/></td></tr>
<tr class="separator:a5688772a963296ea52d2bd9ac5913e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d36eef829f9c1e2d6aaf9218b2e0e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d36eef829f9c1e2d6aaf9218b2e0e66">Halide::Internal::halide_erf</a> (Expr a)</td></tr>
<tr class="memdesc:a3d36eef829f9c1e2d6aaf9218b2e0e66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s vectorizable transcendentals.  <a href="#a3d36eef829f9c1e2d6aaf9218b2e0e66">More...</a><br/></td></tr>
<tr class="separator:a3d36eef829f9c1e2d6aaf9218b2e0e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae1900511e3091424d6d19a0d603dadf0"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae1900511e3091424d6d19a0d603dadf0">Halide::select</a> (Expr c1, Expr v1, Expr c2, Expr v2, Expr default_val)</td></tr>
<tr class="memdesc:ae1900511e3091424d6d19a0d603dadf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#ae1900511e3091424d6d19a0d603dadf0">More...</a><br/></td></tr>
<tr class="separator:ae1900511e3091424d6d19a0d603dadf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0bf94c96070c9b106c6c6408fc6156"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aad0bf94c96070c9b106c6c6408fc6156">Halide::select</a> (Expr c1, Expr v1, Expr c2, Expr v2, Expr c3, Expr v3, Expr default_val)</td></tr>
<tr class="memdesc:aad0bf94c96070c9b106c6c6408fc6156"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#aad0bf94c96070c9b106c6c6408fc6156">More...</a><br/></td></tr>
<tr class="separator:aad0bf94c96070c9b106c6c6408fc6156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8fa9965b4ef3bf72a2e3633b12b9e3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aeb8fa9965b4ef3bf72a2e3633b12b9e3">Halide::select</a> (Expr c1, Expr v1, Expr c2, Expr v2, Expr c3, Expr v3, Expr c4, Expr v4, Expr default_val)</td></tr>
<tr class="memdesc:aeb8fa9965b4ef3bf72a2e3633b12b9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#aeb8fa9965b4ef3bf72a2e3633b12b9e3">More...</a><br/></td></tr>
<tr class="separator:aeb8fa9965b4ef3bf72a2e3633b12b9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a49177bcb9cb40c5f481e7087d9f72"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab1a49177bcb9cb40c5f481e7087d9f72">Halide::select</a> (Expr c1, Expr v1, Expr c2, Expr v2, Expr c3, Expr v3, Expr c4, Expr v4, Expr c5, Expr v5, Expr default_val)</td></tr>
<tr class="memdesc:ab1a49177bcb9cb40c5f481e7087d9f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#ab1a49177bcb9cb40c5f481e7087d9f72">More...</a><br/></td></tr>
<tr class="separator:ab1a49177bcb9cb40c5f481e7087d9f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a47e5c5ecf7b044dab0f974dc24a043"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5a47e5c5ecf7b044dab0f974dc24a043">Halide::select</a> (Expr c1, Expr v1, Expr c2, Expr v2, Expr c3, Expr v3, Expr c4, Expr v4, Expr c5, Expr v5, Expr c6, Expr v6, Expr default_val)</td></tr>
<tr class="memdesc:a5a47e5c5ecf7b044dab0f974dc24a043"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#a5a47e5c5ecf7b044dab0f974dc24a043">More...</a><br/></td></tr>
<tr class="separator:a5a47e5c5ecf7b044dab0f974dc24a043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addef8a58fdaf0c263e2e0d45458e0af9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#addef8a58fdaf0c263e2e0d45458e0af9">Halide::select</a> (Expr c1, Expr v1, Expr c2, Expr v2, Expr c3, Expr v3, Expr c4, Expr v4, Expr c5, Expr v5, Expr c6, Expr v6, Expr c7, Expr v7, Expr default_val)</td></tr>
<tr class="memdesc:addef8a58fdaf0c263e2e0d45458e0af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#addef8a58fdaf0c263e2e0d45458e0af9">More...</a><br/></td></tr>
<tr class="separator:addef8a58fdaf0c263e2e0d45458e0af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d20138fa0526da4dbbfc1b1b59371c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a22d20138fa0526da4dbbfc1b1b59371c">Halide::select</a> (Expr c1, Expr v1, Expr c2, Expr v2, Expr c3, Expr v3, Expr c4, Expr v4, Expr c5, Expr v5, Expr c6, Expr v6, Expr c7, Expr v7, Expr c8, Expr v8, Expr default_val)</td></tr>
<tr class="memdesc:a22d20138fa0526da4dbbfc1b1b59371c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#a22d20138fa0526da4dbbfc1b1b59371c">More...</a><br/></td></tr>
<tr class="separator:a22d20138fa0526da4dbbfc1b1b59371c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ca1bfac3b49e9ed6705da557f52c9d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a37ca1bfac3b49e9ed6705da557f52c9d">Halide::select</a> (Expr c1, Expr v1, Expr c2, Expr v2, Expr c3, Expr v3, Expr c4, Expr v4, Expr c5, Expr v5, Expr c6, Expr v6, Expr c7, Expr v7, Expr c8, Expr v8, Expr c9, Expr v9, Expr default_val)</td></tr>
<tr class="memdesc:a37ca1bfac3b49e9ed6705da557f52c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#a37ca1bfac3b49e9ed6705da557f52c9d">More...</a><br/></td></tr>
<tr class="separator:a37ca1bfac3b49e9ed6705da557f52c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9746d55ef95c2dd61350c69f0e5c5792"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9746d55ef95c2dd61350c69f0e5c5792">Halide::select</a> (Expr c1, Expr v1, Expr c2, Expr v2, Expr c3, Expr v3, Expr c4, Expr v4, Expr c5, Expr v5, Expr c6, Expr v6, Expr c7, Expr v7, Expr c8, Expr v8, Expr c9, Expr v9, Expr c10, Expr v10, Expr default_val)</td></tr>
<tr class="memdesc:a9746d55ef95c2dd61350c69f0e5c5792"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#a9746d55ef95c2dd61350c69f0e5c5792">More...</a><br/></td></tr>
<tr class="separator:a9746d55ef95c2dd61350c69f0e5c5792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab9255b9f7b5c046d86588a9a157a6e8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab9255b9f7b5c046d86588a9a157a6e8d">Halide::print</a> (const std::vector&lt; Expr &gt; &amp;values)</td></tr>
<tr class="memdesc:ab9255b9f7b5c046d86588a9a157a6e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints out its value whenever it is evaluated.  <a href="#ab9255b9f7b5c046d86588a9a157a6e8d">More...</a><br/></td></tr>
<tr class="separator:ab9255b9f7b5c046d86588a9a157a6e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8758515155309d9f2370ae4b2e9665"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aeb8758515155309d9f2370ae4b2e9665"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aeb8758515155309d9f2370ae4b2e9665">Halide::print</a> (Expr a, Args...args)</td></tr>
<tr class="memdesc:aeb8758515155309d9f2370ae4b2e9665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints out its value whenever it is evaluated.  <a href="#aeb8758515155309d9f2370ae4b2e9665">More...</a><br/></td></tr>
<tr class="separator:aeb8758515155309d9f2370ae4b2e9665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5196456d46ad1c58095aea036b2a740c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5196456d46ad1c58095aea036b2a740c">Halide::print_when</a> (Expr condition, const std::vector&lt; Expr &gt; &amp;values)</td></tr>
<tr class="memdesc:a5196456d46ad1c58095aea036b2a740c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints whenever it is evaluated, provided that the condition is true.  <a href="#a5196456d46ad1c58095aea036b2a740c">More...</a><br/></td></tr>
<tr class="separator:a5196456d46ad1c58095aea036b2a740c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab127f9210b8a9e121eb44c921475b29a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab127f9210b8a9e121eb44c921475b29a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab127f9210b8a9e121eb44c921475b29a">Halide::print_when</a> (Expr condition, Expr a, Args...args)</td></tr>
<tr class="memdesc:ab127f9210b8a9e121eb44c921475b29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints whenever it is evaluated, provided that the condition is true.  <a href="#ab127f9210b8a9e121eb44c921475b29a">More...</a><br/></td></tr>
<tr class="separator:ab127f9210b8a9e121eb44c921475b29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a565353875dc8c5c2ba41046679d6dacc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a565353875dc8c5c2ba41046679d6dacc">Halide::memoize_tag</a> (Expr result, const std::vector&lt; Expr &gt; &amp;cache_key_values)</td></tr>
<tr class="memdesc:a565353875dc8c5c2ba41046679d6dacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the values used in the memoization cache key for memoize.  <a href="#a565353875dc8c5c2ba41046679d6dacc">More...</a><br/></td></tr>
<tr class="separator:a565353875dc8c5c2ba41046679d6dacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeb91fa3045dfba9643ea7deabff8c7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a5eeb91fa3045dfba9643ea7deabff8c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5eeb91fa3045dfba9643ea7deabff8c7">Halide::memoize_tag</a> (Expr result, Args...args)</td></tr>
<tr class="memdesc:a5eeb91fa3045dfba9643ea7deabff8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the values used in the memoization cache key for memoize.  <a href="#a5eeb91fa3045dfba9643ea7deabff8c7">More...</a><br/></td></tr>
<tr class="separator:a5eeb91fa3045dfba9643ea7deabff8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines various operator overloads and utility functions that make it more pleasant to work with <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> expressions. </p>

<p>Definition in file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_i_r_operator_8h.html">IROperator.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
