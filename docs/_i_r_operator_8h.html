<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: IROperator.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_i_r_operator_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">IROperator.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines various operator overloads and utility functions that make it more pleasant to work with <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> expressions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;atomic&gt;</code><br />
<code>#include &quot;<a class="el" href="_i_r_8h_source.html">IR.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_util_8h_source.html">Util.h</a>&quot;</code><br />
</div>
<p><a href="_i_r_operator_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_builder.html">Halide::Internal::BufferBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A builder to help create Exprs representing <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> structs (e.g.  <a href="struct_halide_1_1_internal_1_1_buffer_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr class="memdesc:namespace_halide"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines methods for manipulating and analyzing boolean expressions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Halide::Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3b273e981bcb24e47d4caa6fedae915e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3b273e981bcb24e47d4caa6fedae915e">Halide::Internal::is_const</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a3b273e981bcb24e47d4caa6fedae915e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants. ">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node. ">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same.  <a href="namespace_halide_1_1_internal.html#a3b273e981bcb24e47d4caa6fedae915e">More...</a><br /></td></tr>
<tr class="separator:a3b273e981bcb24e47d4caa6fedae915e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a68b513d87c82d69c37b2fcdfa569f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3a68b513d87c82d69c37b2fcdfa569f7">Halide::Internal::is_const</a> (const Expr &amp;e, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> v)</td></tr>
<tr class="memdesc:a3a68b513d87c82d69c37b2fcdfa569f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same.  <a href="namespace_halide_1_1_internal.html#a3a68b513d87c82d69c37b2fcdfa569f7">More...</a><br /></td></tr>
<tr class="separator:a3a68b513d87c82d69c37b2fcdfa569f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a19986908fcd0930f725ebfbe588db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a19a19986908fcd0930f725ebfbe588db">Halide::Internal::as_const_int</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a19a19986908fcd0930f725ebfbe588db"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, return a pointer to its value.  <a href="namespace_halide_1_1_internal.html#a19a19986908fcd0930f725ebfbe588db">More...</a><br /></td></tr>
<tr class="separator:a19a19986908fcd0930f725ebfbe588db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2adc6efa53c904db49c8d4635ba8cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4f2adc6efa53c904db49c8d4635ba8cb">Halide::Internal::as_const_uint</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a4f2adc6efa53c904db49c8d4635ba8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants. ">UIntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants. ">UIntImm</a>, return a pointer to its value.  <a href="namespace_halide_1_1_internal.html#a4f2adc6efa53c904db49c8d4635ba8cb">More...</a><br /></td></tr>
<tr class="separator:a4f2adc6efa53c904db49c8d4635ba8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42b3768e59c07a9feacdb678cef447f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae42b3768e59c07a9feacdb678cef447f">Halide::Internal::as_const_float</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:ae42b3768e59c07a9feacdb678cef447f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, return a pointer to its value.  <a href="namespace_halide_1_1_internal.html#ae42b3768e59c07a9feacdb678cef447f">More...</a><br /></td></tr>
<tr class="separator:ae42b3768e59c07a9feacdb678cef447f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1960f97f81097b2a4d05e33f6b1401c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae1960f97f81097b2a4d05e33f6b1401c">Halide::Internal::is_const_power_of_two_integer</a> (const Expr &amp;e, int *bits)</td></tr>
<tr class="memdesc:ae1960f97f81097b2a4d05e33f6b1401c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a constant integer power of two.  <a href="namespace_halide_1_1_internal.html#ae1960f97f81097b2a4d05e33f6b1401c">More...</a><br /></td></tr>
<tr class="separator:ae1960f97f81097b2a4d05e33f6b1401c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55afaabbe30211d488e6265082954418"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a55afaabbe30211d488e6265082954418">Halide::Internal::is_positive_const</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a55afaabbe30211d488e6265082954418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#a55afaabbe30211d488e6265082954418">More...</a><br /></td></tr>
<tr class="separator:a55afaabbe30211d488e6265082954418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afededda187ca1272ce7601cd203655b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afededda187ca1272ce7601cd203655b5">Halide::Internal::is_negative_const</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:afededda187ca1272ce7601cd203655b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#afededda187ca1272ce7601cd203655b5">More...</a><br /></td></tr>
<tr class="separator:afededda187ca1272ce7601cd203655b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76f2083acfd430d702cbcb56d7449d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af76f2083acfd430d702cbcb56d7449d5">Halide::Internal::is_negative_negatable_const</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:af76f2083acfd430d702cbcb56d7449d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) and is its negative value representable.  <a href="namespace_halide_1_1_internal.html#af76f2083acfd430d702cbcb56d7449d5">More...</a><br /></td></tr>
<tr class="separator:af76f2083acfd430d702cbcb56d7449d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dece8e3fd3bddffb6d259111e039be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a09dece8e3fd3bddffb6d259111e039be">Halide::Internal::is_undef</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a09dece8e3fd3bddffb6d259111e039be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an undef.  <a href="namespace_halide_1_1_internal.html#a09dece8e3fd3bddffb6d259111e039be">More...</a><br /></td></tr>
<tr class="separator:a09dece8e3fd3bddffb6d259111e039be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70dc736a1e1bc4dd11f46c3d924cd1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad70dc736a1e1bc4dd11f46c3d924cd1b">Halide::Internal::is_zero</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:ad70dc736a1e1bc4dd11f46c3d924cd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#ad70dc736a1e1bc4dd11f46c3d924cd1b">More...</a><br /></td></tr>
<tr class="separator:ad70dc736a1e1bc4dd11f46c3d924cd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc566f33cca32a1efc9029fee06ae9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4bc566f33cca32a1efc9029fee06ae9d">Halide::Internal::is_one</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a4bc566f33cca32a1efc9029fee06ae9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#a4bc566f33cca32a1efc9029fee06ae9d">More...</a><br /></td></tr>
<tr class="separator:a4bc566f33cca32a1efc9029fee06ae9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9da208b635428d09b93492d7362a036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae9da208b635428d09b93492d7362a036">Halide::Internal::is_two</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:ae9da208b635428d09b93492d7362a036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression)  <a href="namespace_halide_1_1_internal.html#ae9da208b635428d09b93492d7362a036">More...</a><br /></td></tr>
<tr class="separator:ae9da208b635428d09b93492d7362a036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf4c706f372d401a85a2b8899b9735c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4cf4c706f372d401a85a2b8899b9735c">Halide::Internal::is_no_op</a> (const Stmt &amp;s)</td></tr>
<tr class="memdesc:a4cf4c706f372d401a85a2b8899b9735c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect. ">Evaluate</a> node of a constant)  <a href="namespace_halide_1_1_internal.html#a4cf4c706f372d401a85a2b8899b9735c">More...</a><br /></td></tr>
<tr class="separator:a4cf4c706f372d401a85a2b8899b9735c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8325254f314a3811cc5ebebf4497466d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a8325254f314a3811cc5ebebf4497466d">Halide::Internal::is_pure</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a8325254f314a3811cc5ebebf4497466d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the expression 1) Take on the same value no matter where it appears in a <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>, and 2) Evaluating it has no side-effects.  <a href="namespace_halide_1_1_internal.html#a8325254f314a3811cc5ebebf4497466d">More...</a><br /></td></tr>
<tr class="separator:a8325254f314a3811cc5ebebf4497466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f0a20e311c0982fb73a04c84a6bf3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a75f0a20e311c0982fb73a04c84a6bf3c">Halide::Internal::check_representable</a> (Type t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:a75f0a20e311c0982fb73a04c84a6bf3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a constant value can be correctly represented as the given type.  <a href="namespace_halide_1_1_internal.html#a75f0a20e311c0982fb73a04c84a6bf3c">More...</a><br /></td></tr>
<tr class="separator:a75f0a20e311c0982fb73a04c84a6bf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ddf42fd8c32b453ea049bc176ea3a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a90ddf42fd8c32b453ea049bc176ea3a2">Halide::Internal::make_bool</a> (bool val, int lanes=1)</td></tr>
<tr class="memdesc:a90ddf42fd8c32b453ea049bc176ea3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean constant from a C++ boolean value.  <a href="namespace_halide_1_1_internal.html#a90ddf42fd8c32b453ea049bc176ea3a2">More...</a><br /></td></tr>
<tr class="separator:a90ddf42fd8c32b453ea049bc176ea3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fedf535d58f8900f8b7c00aa15ece8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a57fedf535d58f8900f8b7c00aa15ece8">Halide::Internal::make_zero</a> (Type t)</td></tr>
<tr class="memdesc:a57fedf535d58f8900f8b7c00aa15ece8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of zero in the given type.  <a href="namespace_halide_1_1_internal.html#a57fedf535d58f8900f8b7c00aa15ece8">More...</a><br /></td></tr>
<tr class="separator:a57fedf535d58f8900f8b7c00aa15ece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ace305dbdd7fed2cf9d5057d4c02067c9">Halide::Internal::make_one</a> (Type t)</td></tr>
<tr class="memdesc:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of one in the given type.  <a href="namespace_halide_1_1_internal.html#ace305dbdd7fed2cf9d5057d4c02067c9">More...</a><br /></td></tr>
<tr class="separator:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc35f0dc3562ffb5bb777021679435e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afc35f0dc3562ffb5bb777021679435e2">Halide::Internal::make_two</a> (Type t)</td></tr>
<tr class="memdesc:afc35f0dc3562ffb5bb777021679435e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of two in the given type.  <a href="namespace_halide_1_1_internal.html#afc35f0dc3562ffb5bb777021679435e2">More...</a><br /></td></tr>
<tr class="separator:afc35f0dc3562ffb5bb777021679435e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baf8e1371967a473027d673c6d48286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7baf8e1371967a473027d673c6d48286">Halide::Internal::const_true</a> (int lanes=1)</td></tr>
<tr class="memdesc:a7baf8e1371967a473027d673c6d48286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean true.  <a href="namespace_halide_1_1_internal.html#a7baf8e1371967a473027d673c6d48286">More...</a><br /></td></tr>
<tr class="separator:a7baf8e1371967a473027d673c6d48286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455bb5e473e0686b5b027a51228c1af4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a455bb5e473e0686b5b027a51228c1af4">Halide::Internal::const_false</a> (int lanes=1)</td></tr>
<tr class="memdesc:a455bb5e473e0686b5b027a51228c1af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean false.  <a href="namespace_halide_1_1_internal.html#a455bb5e473e0686b5b027a51228c1af4">More...</a><br /></td></tr>
<tr class="separator:a455bb5e473e0686b5b027a51228c1af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c1bdedbb2a1cfb7aef147bf26998cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af2c1bdedbb2a1cfb7aef147bf26998cc">Halide::Internal::lossless_cast</a> (Type t, Expr e)</td></tr>
<tr class="memdesc:af2c1bdedbb2a1cfb7aef147bf26998cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to cast an expression to a smaller type while provably not losing information.  <a href="namespace_halide_1_1_internal.html#af2c1bdedbb2a1cfb7aef147bf26998cc">More...</a><br /></td></tr>
<tr class="separator:af2c1bdedbb2a1cfb7aef147bf26998cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40a26aac941b763435e9915851cd073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types</a> (Expr &amp;a, Expr &amp;b)</td></tr>
<tr class="memdesc:ab40a26aac941b763435e9915851cd073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce the two expressions to have the same type, using C-style casting rules.  <a href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">More...</a><br /></td></tr>
<tr class="separator:ab40a26aac941b763435e9915851cd073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff271995b6126896f73a7211f8a1ce06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aff271995b6126896f73a7211f8a1ce06">Halide::Internal::raise_to_integer_power</a> (Expr a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:aff271995b6126896f73a7211f8a1ce06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise an expression to an integer power by repeatedly multiplying it by itself.  <a href="namespace_halide_1_1_internal.html#aff271995b6126896f73a7211f8a1ce06">More...</a><br /></td></tr>
<tr class="separator:aff271995b6126896f73a7211f8a1ce06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e118a634944f8286bb127887d902c26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1e118a634944f8286bb127887d902c26">Halide::Internal::split_into_ands</a> (const Expr &amp;cond, std::vector&lt; Expr &gt; &amp;result)</td></tr>
<tr class="memdesc:a1e118a634944f8286bb127887d902c26"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> a boolean condition into vector of ANDs.  <a href="namespace_halide_1_1_internal.html#a1e118a634944f8286bb127887d902c26">More...</a><br /></td></tr>
<tr class="separator:a1e118a634944f8286bb127887d902c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4093d5c88fc8306429ca00725dbabbd"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ac4093d5c88fc8306429ca00725dbabbd">Halide::Internal::strided_ramp_base</a> (Expr e, int stride=1)</td></tr>
<tr class="memdesc:ac4093d5c88fc8306429ca00725dbabbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">If e is a ramp expression with stride, default 1, return the base, otherwise undefined.  <a href="namespace_halide_1_1_internal.html#ac4093d5c88fc8306429ca00725dbabbd">More...</a><br /></td></tr>
<tr class="separator:ac4093d5c88fc8306429ca00725dbabbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c6da1a731c0804063458b531e8a849"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51c6da1a731c0804063458b531e8a849"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a51c6da1a731c0804063458b531e8a849">Halide::cast</a> (Expr a)</td></tr>
<tr class="memdesc:a51c6da1a731c0804063458b531e8a849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to the halide type corresponding to the C++ type T.  <a href="namespace_halide.html#a51c6da1a731c0804063458b531e8a849">More...</a><br /></td></tr>
<tr class="separator:a51c6da1a731c0804063458b531e8a849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ce0e6da961a52ace4b8fa8444fac20"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a69ce0e6da961a52ace4b8fa8444fac20">Halide::cast</a> (Type t, Expr a)</td></tr>
<tr class="memdesc:a69ce0e6da961a52ace4b8fa8444fac20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a new type.  <a href="namespace_halide.html#a69ce0e6da961a52ace4b8fa8444fac20">More...</a><br /></td></tr>
<tr class="separator:a69ce0e6da961a52ace4b8fa8444fac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db532b84ba55ff72555c4b427fc42bc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2db532b84ba55ff72555c4b427fc42bc">Halide::operator+</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a2db532b84ba55ff72555c4b427fc42bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#a2db532b84ba55ff72555c4b427fc42bc">More...</a><br /></td></tr>
<tr class="separator:a2db532b84ba55ff72555c4b427fc42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3528931d7929d533103ada2badca092c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3528931d7929d533103ada2badca092c">Halide::operator||</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a3528931d7929d533103ada2badca092c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical or of the two arguments.  <a href="namespace_halide.html#a3528931d7929d533103ada2badca092c">More...</a><br /></td></tr>
<tr class="separator:a3528931d7929d533103ada2badca092c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb54256bfab344b6720775cf2e0936e0"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afb54256bfab344b6720775cf2e0936e0">Halide::operator!</a> (Expr a)</td></tr>
<tr class="memdesc:afb54256bfab344b6720775cf2e0936e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical not the argument.  <a href="namespace_halide.html#afb54256bfab344b6720775cf2e0936e0">More...</a><br /></td></tr>
<tr class="separator:afb54256bfab344b6720775cf2e0936e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec">Halide::max</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec">More...</a><br /></td></tr>
<tr class="separator:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d007e9eff86b8854b12840303294b9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a65d007e9eff86b8854b12840303294b9">Halide::max</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a65d007e9eff86b8854b12840303294b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of an expression and a constant integer.  <a href="namespace_halide.html#a65d007e9eff86b8854b12840303294b9">More...</a><br /></td></tr>
<tr class="separator:a65d007e9eff86b8854b12840303294b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7950ad100fb78022bf9c49003d6ccc19"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7950ad100fb78022bf9c49003d6ccc19">Halide::max</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a7950ad100fb78022bf9c49003d6ccc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of a constant integer and an expression.  <a href="namespace_halide.html#a7950ad100fb78022bf9c49003d6ccc19">More...</a><br /></td></tr>
<tr class="separator:a7950ad100fb78022bf9c49003d6ccc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30475861d1493c3353e62ec77a3b516"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad30475861d1493c3353e62ec77a3b516">Halide::max</a> (float a, Expr b)</td></tr>
<tr class="separator:ad30475861d1493c3353e62ec77a3b516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba49d8dff61c221859c462054375258"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7ba49d8dff61c221859c462054375258">Halide::max</a> (Expr a, float b)</td></tr>
<tr class="separator:a7ba49d8dff61c221859c462054375258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99177e0cee9a2b4b1f3fc52c1699d942"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename... Rest, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Rest... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a99177e0cee9a2b4b1f3fc52c1699d942"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a99177e0cee9a2b4b1f3fc52c1699d942">Halide::max</a> (A &amp;&amp;a, B &amp;&amp;b, C &amp;&amp;c, Rest &amp;&amp;... rest)</td></tr>
<tr class="memdesc:a99177e0cee9a2b4b1f3fc52c1699d942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of an expressions vector, after doing any necessary type coersion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#a99177e0cee9a2b4b1f3fc52c1699d942">More...</a><br /></td></tr>
<tr class="separator:a99177e0cee9a2b4b1f3fc52c1699d942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b5db24ca379dda8241433c0014c940"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940">Halide::min</a> (Expr a, Expr b)</td></tr>
<tr class="separator:a38b5db24ca379dda8241433c0014c940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade891378c7247910129a61258cf00a56"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ade891378c7247910129a61258cf00a56">Halide::min</a> (Expr a, int b)</td></tr>
<tr class="memdesc:ade891378c7247910129a61258cf00a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of an expression and a constant integer.  <a href="namespace_halide.html#ade891378c7247910129a61258cf00a56">More...</a><br /></td></tr>
<tr class="separator:ade891378c7247910129a61258cf00a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af2f7c75c30e16933e0e0f1a89b6a07"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1af2f7c75c30e16933e0e0f1a89b6a07">Halide::min</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a1af2f7c75c30e16933e0e0f1a89b6a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of a constant integer and an expression.  <a href="namespace_halide.html#a1af2f7c75c30e16933e0e0f1a89b6a07">More...</a><br /></td></tr>
<tr class="separator:a1af2f7c75c30e16933e0e0f1a89b6a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f42d034894ac2f27a09f73627437a0"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a79f42d034894ac2f27a09f73627437a0">Halide::min</a> (float a, Expr b)</td></tr>
<tr class="separator:a79f42d034894ac2f27a09f73627437a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e4e576c9e0ca6588c3e5bc54856589"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a68e4e576c9e0ca6588c3e5bc54856589">Halide::min</a> (Expr a, float b)</td></tr>
<tr class="separator:a68e4e576c9e0ca6588c3e5bc54856589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49a392928bbf123359375b3f108631a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename... Rest, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Rest... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa49a392928bbf123359375b3f108631a"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa49a392928bbf123359375b3f108631a">Halide::min</a> (A &amp;&amp;a, B &amp;&amp;b, C &amp;&amp;c, Rest &amp;&amp;... rest)</td></tr>
<tr class="memdesc:aa49a392928bbf123359375b3f108631a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of an expressions vector, after doing any necessary type coersion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#aa49a392928bbf123359375b3f108631a">More...</a><br /></td></tr>
<tr class="separator:aa49a392928bbf123359375b3f108631a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fc11b69e1ae900cebae51c319a1caa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a41fc11b69e1ae900cebae51c319a1caa">Halide::clamp</a> (Expr a, Expr min_val, Expr max_val)</td></tr>
<tr class="memdesc:a41fc11b69e1ae900cebae51c319a1caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps an expression to lie within the given bounds.  <a href="namespace_halide.html#a41fc11b69e1ae900cebae51c319a1caa">More...</a><br /></td></tr>
<tr class="separator:a41fc11b69e1ae900cebae51c319a1caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae698f4bfd37d3d15cee4bf22c4627e0d">Halide::abs</a> (Expr a)</td></tr>
<tr class="memdesc:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a signed integer or floating-point expression.  <a href="namespace_halide.html#ae698f4bfd37d3d15cee4bf22c4627e0d">More...</a><br /></td></tr>
<tr class="separator:ae698f4bfd37d3d15cee4bf22c4627e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d96f6e421c7a9a25f3d027283c7149d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d96f6e421c7a9a25f3d027283c7149d">Halide::absd</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a8d96f6e421c7a9a25f3d027283c7149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute difference between two values.  <a href="namespace_halide.html#a8d96f6e421c7a9a25f3d027283c7149d">More...</a><br /></td></tr>
<tr class="separator:a8d96f6e421c7a9a25f3d027283c7149d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6371892ae38e7eb681fd3f23945b06"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">Halide::select</a> (Expr condition, Expr true_value, Expr false_value)</td></tr>
<tr class="memdesc:a9d6371892ae38e7eb681fd3f23945b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression similar to the ternary operator in C, except that it always evaluates all arguments.  <a href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">More...</a><br /></td></tr>
<tr class="separator:a9d6371892ae38e7eb681fd3f23945b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab424bc4f6a19ef454f7c8541b2d8c890"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Args... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab424bc4f6a19ef454f7c8541b2d8c890"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab424bc4f6a19ef454f7c8541b2d8c890">Halide::select</a> (Expr c0, Expr v0, Expr c1, Expr v1, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab424bc4f6a19ef454f7c8541b2d8c890"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="namespace_halide.html#ab424bc4f6a19ef454f7c8541b2d8c890">More...</a><br /></td></tr>
<tr class="separator:ab424bc4f6a19ef454f7c8541b2d8c890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1fca22f79625765096133e39caee5e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">Halide::sin</a> (Expr x)</td></tr>
<tr class="memdesc:a5e1fca22f79625765096133e39caee5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of a floating-point expression.  <a href="namespace_halide.html#a5e1fca22f79625765096133e39caee5e">More...</a><br /></td></tr>
<tr class="separator:a5e1fca22f79625765096133e39caee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3bfc77a80e6b40a6c00899a8e2ad1f28">Halide::asin</a> (Expr x)</td></tr>
<tr class="memdesc:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arcsine of a floating-point expression.  <a href="namespace_halide.html#a3bfc77a80e6b40a6c00899a8e2ad1f28">More...</a><br /></td></tr>
<tr class="separator:a3bfc77a80e6b40a6c00899a8e2ad1f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1ef33189b99c7b8bc73b5e10121834"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7e1ef33189b99c7b8bc73b5e10121834">Halide::cos</a> (Expr x)</td></tr>
<tr class="memdesc:a7e1ef33189b99c7b8bc73b5e10121834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of a floating-point expression.  <a href="namespace_halide.html#a7e1ef33189b99c7b8bc73b5e10121834">More...</a><br /></td></tr>
<tr class="separator:a7e1ef33189b99c7b8bc73b5e10121834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a64d3ef272e07177d95b624968951"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a722a64d3ef272e07177d95b624968951">Halide::acos</a> (Expr x)</td></tr>
<tr class="memdesc:a722a64d3ef272e07177d95b624968951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arccosine of a floating-point expression.  <a href="namespace_halide.html#a722a64d3ef272e07177d95b624968951">More...</a><br /></td></tr>
<tr class="separator:a722a64d3ef272e07177d95b624968951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18f43994d3cf73c20b7eb62b243076e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad18f43994d3cf73c20b7eb62b243076e">Halide::tan</a> (Expr x)</td></tr>
<tr class="memdesc:ad18f43994d3cf73c20b7eb62b243076e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of a floating-point expression.  <a href="namespace_halide.html#ad18f43994d3cf73c20b7eb62b243076e">More...</a><br /></td></tr>
<tr class="separator:ad18f43994d3cf73c20b7eb62b243076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3b0ec19519602bc880a1ae0236f1c3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe3b0ec19519602bc880a1ae0236f1c3">Halide::atan</a> (Expr x)</td></tr>
<tr class="memdesc:abe3b0ec19519602bc880a1ae0236f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arctangent of a floating-point expression.  <a href="namespace_halide.html#abe3b0ec19519602bc880a1ae0236f1c3">More...</a><br /></td></tr>
<tr class="separator:abe3b0ec19519602bc880a1ae0236f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5646de466ac31efd07ec5af1e4603cbf"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5646de466ac31efd07ec5af1e4603cbf">Halide::atan2</a> (Expr y, Expr x)</td></tr>
<tr class="memdesc:a5646de466ac31efd07ec5af1e4603cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angle of a floating-point gradient.  <a href="namespace_halide.html#a5646de466ac31efd07ec5af1e4603cbf">More...</a><br /></td></tr>
<tr class="separator:a5646de466ac31efd07ec5af1e4603cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe05bc670b713a278f8182457a750bd9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe05bc670b713a278f8182457a750bd9">Halide::sinh</a> (Expr x)</td></tr>
<tr class="memdesc:abe05bc670b713a278f8182457a750bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of a floating-point expression.  <a href="namespace_halide.html#abe05bc670b713a278f8182457a750bd9">More...</a><br /></td></tr>
<tr class="separator:abe05bc670b713a278f8182457a750bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">Halide::asinh</a> (Expr x)</td></tr>
<tr class="memdesc:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arcsinhe of a floating-point expression.  <a href="namespace_halide.html#abb5d3eac37ebfab1c8a2abf7ab1ebfaa">More...</a><br /></td></tr>
<tr class="separator:abb5d3eac37ebfab1c8a2abf7ab1ebfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68aff5fc199ecbabe209ce32ec507292"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a68aff5fc199ecbabe209ce32ec507292">Halide::cosh</a> (Expr x)</td></tr>
<tr class="memdesc:a68aff5fc199ecbabe209ce32ec507292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of a floating-point expression.  <a href="namespace_halide.html#a68aff5fc199ecbabe209ce32ec507292">More...</a><br /></td></tr>
<tr class="separator:a68aff5fc199ecbabe209ce32ec507292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2ce048ac6f7c309d26c83fbc3132be2b">Halide::acosh</a> (Expr x)</td></tr>
<tr class="memdesc:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arccosine of a floating-point expression.  <a href="namespace_halide.html#a2ce048ac6f7c309d26c83fbc3132be2b">More...</a><br /></td></tr>
<tr class="separator:a2ce048ac6f7c309d26c83fbc3132be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb15a9760067c05d2e5a343f529188be"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acb15a9760067c05d2e5a343f529188be">Halide::tanh</a> (Expr x)</td></tr>
<tr class="memdesc:acb15a9760067c05d2e5a343f529188be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of a floating-point expression.  <a href="namespace_halide.html#acb15a9760067c05d2e5a343f529188be">More...</a><br /></td></tr>
<tr class="separator:acb15a9760067c05d2e5a343f529188be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd93e33e8d82be7cf9487e881d834ec9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acd93e33e8d82be7cf9487e881d834ec9">Halide::atanh</a> (Expr x)</td></tr>
<tr class="memdesc:acd93e33e8d82be7cf9487e881d834ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arctangent of a floating-point expression.  <a href="namespace_halide.html#acd93e33e8d82be7cf9487e881d834ec9">More...</a><br /></td></tr>
<tr class="separator:acd93e33e8d82be7cf9487e881d834ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7f08f13439b86581a47162e1a2d2de"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">Halide::sqrt</a> (Expr x)</td></tr>
<tr class="memdesc:abc7f08f13439b86581a47162e1a2d2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of a floating-point expression.  <a href="namespace_halide.html#abc7f08f13439b86581a47162e1a2d2de">More...</a><br /></td></tr>
<tr class="separator:abc7f08f13439b86581a47162e1a2d2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb75ff010919c00492e4f654a4d8f85"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4fb75ff010919c00492e4f654a4d8f85">Halide::hypot</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a4fb75ff010919c00492e4f654a4d8f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the sum of the squares of two floating-point expressions.  <a href="namespace_halide.html#a4fb75ff010919c00492e4f654a4d8f85">More...</a><br /></td></tr>
<tr class="separator:a4fb75ff010919c00492e4f654a4d8f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c6187068d6e839e548776dfa7dde3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a877c6187068d6e839e548776dfa7dde3">Halide::exp</a> (Expr x)</td></tr>
<tr class="memdesc:a877c6187068d6e839e548776dfa7dde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponential of a floating-point expression.  <a href="namespace_halide.html#a877c6187068d6e839e548776dfa7dde3">More...</a><br /></td></tr>
<tr class="separator:a877c6187068d6e839e548776dfa7dde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f1c38239e6e977fea90b94217499ae"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a02f1c38239e6e977fea90b94217499ae">Halide::log</a> (Expr x)</td></tr>
<tr class="memdesc:a02f1c38239e6e977fea90b94217499ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logarithm of a floating-point expression.  <a href="namespace_halide.html#a02f1c38239e6e977fea90b94217499ae">More...</a><br /></td></tr>
<tr class="separator:a02f1c38239e6e977fea90b94217499ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd83996070aa3e4bc3a102a654176fa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4dd83996070aa3e4bc3a102a654176fa">Halide::pow</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a4dd83996070aa3e4bc3a102a654176fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one floating point expression raised to the power of another.  <a href="namespace_halide.html#a4dd83996070aa3e4bc3a102a654176fa">More...</a><br /></td></tr>
<tr class="separator:a4dd83996070aa3e4bc3a102a654176fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a80df08887f9457c9bffc349f834ce1"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a80df08887f9457c9bffc349f834ce1">Halide::erf</a> (Expr x)</td></tr>
<tr class="memdesc:a9a80df08887f9457c9bffc349f834ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the error function erf.  <a href="namespace_halide.html#a9a80df08887f9457c9bffc349f834ce1">More...</a><br /></td></tr>
<tr class="separator:a9a80df08887f9457c9bffc349f834ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df3f02c28d9710c836194f5b2e9e8c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7df3f02c28d9710c836194f5b2e9e8c7">Halide::fast_log</a> (Expr x)</td></tr>
<tr class="memdesc:a7df3f02c28d9710c836194f5b2e9e8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable log for Float(32).  <a href="namespace_halide.html#a7df3f02c28d9710c836194f5b2e9e8c7">More...</a><br /></td></tr>
<tr class="separator:a7df3f02c28d9710c836194f5b2e9e8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df130f96d92c066478cd28148d8af53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5df130f96d92c066478cd28148d8af53">Halide::fast_exp</a> (Expr x)</td></tr>
<tr class="memdesc:a5df130f96d92c066478cd28148d8af53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable exp for Float(32).  <a href="namespace_halide.html#a5df130f96d92c066478cd28148d8af53">More...</a><br /></td></tr>
<tr class="separator:a5df130f96d92c066478cd28148d8af53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958457cd688f84d583779e649c9e52e6"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a958457cd688f84d583779e649c9e52e6">Halide::fast_pow</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a958457cd688f84d583779e649c9e52e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable pow for Float(32).  <a href="namespace_halide.html#a958457cd688f84d583779e649c9e52e6">More...</a><br /></td></tr>
<tr class="separator:a958457cd688f84d583779e649c9e52e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343eac4b4aa329e52c7cbf8167902696"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a343eac4b4aa329e52c7cbf8167902696">Halide::fast_inverse</a> (Expr x)</td></tr>
<tr class="memdesc:a343eac4b4aa329e52c7cbf8167902696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate inverse for Float(32).  <a href="namespace_halide.html#a343eac4b4aa329e52c7cbf8167902696">More...</a><br /></td></tr>
<tr class="separator:a343eac4b4aa329e52c7cbf8167902696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4424b070b363f53107a6c2705bbe50b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad4424b070b363f53107a6c2705bbe50b">Halide::fast_inverse_sqrt</a> (Expr x)</td></tr>
<tr class="memdesc:ad4424b070b363f53107a6c2705bbe50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate inverse square root for Float(32).  <a href="namespace_halide.html#ad4424b070b363f53107a6c2705bbe50b">More...</a><br /></td></tr>
<tr class="separator:ad4424b070b363f53107a6c2705bbe50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed670387016322f8db2b7abdecdc0e4c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed670387016322f8db2b7abdecdc0e4c">Halide::floor</a> (Expr x)</td></tr>
<tr class="memdesc:aed670387016322f8db2b7abdecdc0e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest whole number less than or equal to a floating-point expression.  <a href="namespace_halide.html#aed670387016322f8db2b7abdecdc0e4c">More...</a><br /></td></tr>
<tr class="separator:aed670387016322f8db2b7abdecdc0e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070dde32195d1ae83082c15fd11d5d90"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a070dde32195d1ae83082c15fd11d5d90">Halide::ceil</a> (Expr x)</td></tr>
<tr class="memdesc:a070dde32195d1ae83082c15fd11d5d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least whole number greater than or equal to a floating-point expression.  <a href="namespace_halide.html#a070dde32195d1ae83082c15fd11d5d90">More...</a><br /></td></tr>
<tr class="separator:a070dde32195d1ae83082c15fd11d5d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2090a77072af682d9e2daea086d2fe"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d2090a77072af682d9e2daea086d2fe">Halide::round</a> (Expr x)</td></tr>
<tr class="memdesc:a9d2090a77072af682d9e2daea086d2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the whole number closest to a floating-point expression.  <a href="namespace_halide.html#a9d2090a77072af682d9e2daea086d2fe">More...</a><br /></td></tr>
<tr class="separator:a9d2090a77072af682d9e2daea086d2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287f93889910a28197d2a1631486a433"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a287f93889910a28197d2a1631486a433">Halide::trunc</a> (Expr x)</td></tr>
<tr class="memdesc:a287f93889910a28197d2a1631486a433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the integer part of a floating-point expression.  <a href="namespace_halide.html#a287f93889910a28197d2a1631486a433">More...</a><br /></td></tr>
<tr class="separator:a287f93889910a28197d2a1631486a433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71c5b6b09e0f679724ccfb95515b338"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab71c5b6b09e0f679724ccfb95515b338">Halide::is_nan</a> (Expr x)</td></tr>
<tr class="memdesc:ab71c5b6b09e0f679724ccfb95515b338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the argument is a Not a Number (NaN).  <a href="namespace_halide.html#ab71c5b6b09e0f679724ccfb95515b338">More...</a><br /></td></tr>
<tr class="separator:ab71c5b6b09e0f679724ccfb95515b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fd83b219755aef0e53062cffc111bc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a57fd83b219755aef0e53062cffc111bc">Halide::fract</a> (Expr x)</td></tr>
<tr class="memdesc:a57fd83b219755aef0e53062cffc111bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fractional part of a floating-point expression.  <a href="namespace_halide.html#a57fd83b219755aef0e53062cffc111bc">More...</a><br /></td></tr>
<tr class="separator:a57fd83b219755aef0e53062cffc111bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0f13f0a9e97bf7673ca5a8e04b1bd9a9">Halide::reinterpret</a> (Type t, Expr e)</td></tr>
<tr class="memdesc:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret the bits of one value as another type.  <a href="namespace_halide.html#a0f13f0a9e97bf7673ca5a8e04b1bd9a9">More...</a><br /></td></tr>
<tr class="separator:a0f13f0a9e97bf7673ca5a8e04b1bd9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2012c20f1666555e7a229c9db1b64091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2012c20f1666555e7a229c9db1b64091"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2012c20f1666555e7a229c9db1b64091">Halide::reinterpret</a> (Expr e)</td></tr>
<tr class="separator:a2012c20f1666555e7a229c9db1b64091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae940ea712708be3fa5136f71dcf5ab4f"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae940ea712708be3fa5136f71dcf5ab4f">Halide::operator &amp;</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:ae940ea712708be3fa5136f71dcf5ab4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise and of two expressions (which need not have the same type).  <a href="namespace_halide.html#ae940ea712708be3fa5136f71dcf5ab4f">More...</a><br /></td></tr>
<tr class="separator:ae940ea712708be3fa5136f71dcf5ab4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8bec8d2f6194f4db7b88e554173f05"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe8bec8d2f6194f4db7b88e554173f05">Halide::operator|</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:abe8bec8d2f6194f4db7b88e554173f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise or of two expressions (which need not have the same type).  <a href="namespace_halide.html#abe8bec8d2f6194f4db7b88e554173f05">More...</a><br /></td></tr>
<tr class="separator:abe8bec8d2f6194f4db7b88e554173f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdde4dd479f4eb59631e09148897ad2a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afdde4dd479f4eb59631e09148897ad2a">Halide::operator^</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:afdde4dd479f4eb59631e09148897ad2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise exclusive or of two expressions (which need not have the same type).  <a href="namespace_halide.html#afdde4dd479f4eb59631e09148897ad2a">More...</a><br /></td></tr>
<tr class="separator:afdde4dd479f4eb59631e09148897ad2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c07e39289b14103ccd45ee31630a3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afc9c07e39289b14103ccd45ee31630a3">Halide::operator~</a> (Expr x)</td></tr>
<tr class="memdesc:afc9c07e39289b14103ccd45ee31630a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise not of an expression.  <a href="namespace_halide.html#afc9c07e39289b14103ccd45ee31630a3">More...</a><br /></td></tr>
<tr class="separator:afc9c07e39289b14103ccd45ee31630a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55158f5f229510194c425dfae256d530"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">Halide::lerp</a> (Expr zero_val, Expr one_val, Expr weight)</td></tr>
<tr class="memdesc:a55158f5f229510194c425dfae256d530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolate between the two values according to a weight.  <a href="namespace_halide.html#a55158f5f229510194c425dfae256d530">More...</a><br /></td></tr>
<tr class="separator:a55158f5f229510194c425dfae256d530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dd5e65a4c167c112de447c628c099a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a41dd5e65a4c167c112de447c628c099a">Halide::popcount</a> (Expr x)</td></tr>
<tr class="memdesc:a41dd5e65a4c167c112de447c628c099a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of set bits in an expression.  <a href="namespace_halide.html#a41dd5e65a4c167c112de447c628c099a">More...</a><br /></td></tr>
<tr class="separator:a41dd5e65a4c167c112de447c628c099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e39642cc99af99045ec5f424cde8709"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0e39642cc99af99045ec5f424cde8709">Halide::count_leading_zeros</a> (Expr x)</td></tr>
<tr class="memdesc:a0e39642cc99af99045ec5f424cde8709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of leading zero bits in an expression.  <a href="namespace_halide.html#a0e39642cc99af99045ec5f424cde8709">More...</a><br /></td></tr>
<tr class="separator:a0e39642cc99af99045ec5f424cde8709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0042ff9c2283a15cda1a1e72de460ad"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa0042ff9c2283a15cda1a1e72de460ad">Halide::count_trailing_zeros</a> (Expr x)</td></tr>
<tr class="memdesc:aa0042ff9c2283a15cda1a1e72de460ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of trailing zero bits in an expression.  <a href="namespace_halide.html#aa0042ff9c2283a15cda1a1e72de460ad">More...</a><br /></td></tr>
<tr class="separator:aa0042ff9c2283a15cda1a1e72de460ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6e12242ab5a192bdaa953510ae95bf"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed6e12242ab5a192bdaa953510ae95bf">Halide::div_round_to_zero</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:aed6e12242ab5a192bdaa953510ae95bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide two integers, rounding towards zero.  <a href="namespace_halide.html#aed6e12242ab5a192bdaa953510ae95bf">More...</a><br /></td></tr>
<tr class="separator:aed6e12242ab5a192bdaa953510ae95bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0456fd6414e279eb3afdecf53eb8af8"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab0456fd6414e279eb3afdecf53eb8af8">Halide::mod_round_to_zero</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:ab0456fd6414e279eb3afdecf53eb8af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the remainder of dividing two integers, when division is rounding toward zero.  <a href="namespace_halide.html#ab0456fd6414e279eb3afdecf53eb8af8">More...</a><br /></td></tr>
<tr class="separator:ab0456fd6414e279eb3afdecf53eb8af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bd57263c72c6712b643ab6486ed026"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">Halide::random_float</a> (Expr seed=Expr())</td></tr>
<tr class="memdesc:a59bd57263c72c6712b643ab6486ed026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed float in the half-open interval [0.0f, 1.0f).  <a href="namespace_halide.html#a59bd57263c72c6712b643ab6486ed026">More...</a><br /></td></tr>
<tr class="separator:a59bd57263c72c6712b643ab6486ed026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160cd421537be8b4cd44fc32958604c2"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a160cd421537be8b4cd44fc32958604c2">Halide::random_uint</a> (Expr seed=Expr())</td></tr>
<tr class="memdesc:a160cd421537be8b4cd44fc32958604c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed unsigned 32-bit integer.  <a href="namespace_halide.html#a160cd421537be8b4cd44fc32958604c2">More...</a><br /></td></tr>
<tr class="separator:a160cd421537be8b4cd44fc32958604c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed5b59d6a43446e311633912427b2b3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aaed5b59d6a43446e311633912427b2b3">Halide::random_int</a> (Expr seed=Expr())</td></tr>
<tr class="memdesc:aaed5b59d6a43446e311633912427b2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed 32-bit integer.  <a href="namespace_halide.html#aaed5b59d6a43446e311633912427b2b3">More...</a><br /></td></tr>
<tr class="separator:aaed5b59d6a43446e311633912427b2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b821cbe0e228fd5036e9fb1ed693184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7b821cbe0e228fd5036e9fb1ed693184">Halide::Internal::collect_print_args</a> (std::vector&lt; Expr &gt; &amp;args)</td></tr>
<tr class="separator:a7b821cbe0e228fd5036e9fb1ed693184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85c82a3d8448b8a55c90a6b69f7c29d"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:ae85c82a3d8448b8a55c90a6b69f7c29d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae85c82a3d8448b8a55c90a6b69f7c29d">Halide::Internal::collect_print_args</a> (std::vector&lt; Expr &gt; &amp;args, const char *arg, Args &amp;&amp;... more_args)</td></tr>
<tr class="separator:ae85c82a3d8448b8a55c90a6b69f7c29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c0a2ed9a4dd0f391bbcbb83d4c3b63"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a07c0a2ed9a4dd0f391bbcbb83d4c3b63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a07c0a2ed9a4dd0f391bbcbb83d4c3b63">Halide::Internal::collect_print_args</a> (std::vector&lt; Expr &gt; &amp;args, Expr arg, Args &amp;&amp;... more_args)</td></tr>
<tr class="separator:a07c0a2ed9a4dd0f391bbcbb83d4c3b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9389bcacbed602df70eae94826312e03"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9389bcacbed602df70eae94826312e03">Halide::undef</a> (Type t)</td></tr>
<tr class="memdesc:a9389bcacbed602df70eae94826312e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an undef value of the given type.  <a href="namespace_halide.html#a9389bcacbed602df70eae94826312e03">More...</a><br /></td></tr>
<tr class="separator:a9389bcacbed602df70eae94826312e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f29c5417077b940483e88cc9c1c74b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f29c5417077b940483e88cc9c1c74b2"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4f29c5417077b940483e88cc9c1c74b2">Halide::undef</a> ()</td></tr>
<tr class="separator:a4f29c5417077b940483e88cc9c1c74b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3a61c8b563a85ef94a175bcb35dee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abc3a61c8b563a85ef94a175bcb35dee2">Halide::Internal::memoize_tag_helper</a> (Expr result, const std::vector&lt; Expr &gt; &amp;cache_key_values)</td></tr>
<tr class="separator:abc3a61c8b563a85ef94a175bcb35dee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764">Halide::likely</a> (Expr e)</td></tr>
<tr class="memdesc:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expressions tagged with this intrinsic are considered to be part of the steady state of some loop with a nasty beginning and end (e.g.  <a href="namespace_halide.html#afbf18e1b8bab056f8f8e8f1af8cbd764">More...</a><br /></td></tr>
<tr class="separator:afbf18e1b8bab056f8f8e8f1af8cbd764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3a484f14e9bdf4c7b4e16d74fe11ab"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab">Halide::likely_if_innermost</a> (Expr e)</td></tr>
<tr class="memdesc:acc3a484f14e9bdf4c7b4e16d74fe11ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.  <a href="namespace_halide.html#acc3a484f14e9bdf4c7b4e16d74fe11ab">More...</a><br /></td></tr>
<tr class="separator:acc3a484f14e9bdf4c7b4e16d74fe11ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a635db3b781aded60c79533001b9e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57a635db3b781aded60c79533001b9e1"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a57a635db3b781aded60c79533001b9e1">Halide::saturating_cast</a> (Expr e)</td></tr>
<tr class="memdesc:a57a635db3b781aded60c79533001b9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to the halide type corresponding to the C++ type T clamping to the minimum and maximum values of the result type.  <a href="namespace_halide.html#a57a635db3b781aded60c79533001b9e1">More...</a><br /></td></tr>
<tr class="separator:a57a635db3b781aded60c79533001b9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae901c705ecd11c61727b8360f655b905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae901c705ecd11c61727b8360f655b905">Halide::saturating_cast</a> (Type t, Expr e)</td></tr>
<tr class="memdesc:ae901c705ecd11c61727b8360f655b905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a new type, clamping to the minimum and maximum values of the result type.  <a href="namespace_halide.html#ae901c705ecd11c61727b8360f655b905">More...</a><br /></td></tr>
<tr class="separator:ae901c705ecd11c61727b8360f655b905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aff2e2c3b53edabca8089670422959e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:aff2e2c3b53edabca8089670422959e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">More...</a><br /></td></tr>
<tr class="separator:aff2e2c3b53edabca8089670422959e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4212797e9dcc4a1a3577c6e6475832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7e4212797e9dcc4a1a3577c6e6475832">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val)</td></tr>
<tr class="memdesc:a7e4212797e9dcc4a1a3577c6e6475832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#a7e4212797e9dcc4a1a3577c6e6475832">More...</a><br /></td></tr>
<tr class="separator:a7e4212797e9dcc4a1a3577c6e6475832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ec777cbfe66e5a592adf1eea14ec64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab4ec777cbfe66e5a592adf1eea14ec64">Halide::Internal::make_const</a> (Type t, double val)</td></tr>
<tr class="memdesc:ab4ec777cbfe66e5a592adf1eea14ec64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#ab4ec777cbfe66e5a592adf1eea14ec64">More...</a><br /></td></tr>
<tr class="separator:ab4ec777cbfe66e5a592adf1eea14ec64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaae8ca905f0ce9cde74cc0897a61c4e7">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> val)</td></tr>
<tr class="memdesc:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#aaae8ca905f0ce9cde74cc0897a61c4e7">More...</a><br /></td></tr>
<tr class="separator:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b64c00a450c92807011cdc02f8b29b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a70b64c00a450c92807011cdc02f8b29b">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> val)</td></tr>
<tr class="memdesc:a70b64c00a450c92807011cdc02f8b29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#a70b64c00a450c92807011cdc02f8b29b">More...</a><br /></td></tr>
<tr class="separator:a70b64c00a450c92807011cdc02f8b29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df9ef655a78f9fb233fa0322525496c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4df9ef655a78f9fb233fa0322525496c">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#ac124c451b40871e78c16cb36581022ae">int16_t</a> val)</td></tr>
<tr class="memdesc:a4df9ef655a78f9fb233fa0322525496c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#a4df9ef655a78f9fb233fa0322525496c">More...</a><br /></td></tr>
<tr class="separator:a4df9ef655a78f9fb233fa0322525496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af14e2dade91eb04482b4b5ffdfc920dd">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a> val)</td></tr>
<tr class="memdesc:af14e2dade91eb04482b4b5ffdfc920dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#af14e2dade91eb04482b4b5ffdfc920dd">More...</a><br /></td></tr>
<tr class="separator:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5231b80b8e1a7904cdd4fcac7b89a98d">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#acfd957407fbe865fe77f6fdf86818f5e">int8_t</a> val)</td></tr>
<tr class="memdesc:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#a5231b80b8e1a7904cdd4fcac7b89a98d">More...</a><br /></td></tr>
<tr class="separator:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae9a1ece36d20a64a59c92bf7f8c4e9aa">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> val)</td></tr>
<tr class="memdesc:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#ae9a1ece36d20a64a59c92bf7f8c4e9aa">More...</a><br /></td></tr>
<tr class="separator:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#addbd965eccbcfc1f5b80eaa0607f698c">Halide::Internal::make_const</a> (Type t, bool val)</td></tr>
<tr class="memdesc:addbd965eccbcfc1f5b80eaa0607f698c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#addbd965eccbcfc1f5b80eaa0607f698c">More...</a><br /></td></tr>
<tr class="separator:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90929bcfb18413ffd527152bb8580de"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa90929bcfb18413ffd527152bb8580de">Halide::Internal::make_const</a> (Type t, float val)</td></tr>
<tr class="memdesc:aa90929bcfb18413ffd527152bb8580de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#aa90929bcfb18413ffd527152bb8580de">More...</a><br /></td></tr>
<tr class="separator:aa90929bcfb18413ffd527152bb8580de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592ef00a06a1d8f017b48359099c16d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6592ef00a06a1d8f017b48359099c16d">Halide::Internal::make_const</a> (Type t, float16_t val)</td></tr>
<tr class="memdesc:a6592ef00a06a1d8f017b48359099c16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="namespace_halide_1_1_internal.html#a6592ef00a06a1d8f017b48359099c16d">More...</a><br /></td></tr>
<tr class="separator:a6592ef00a06a1d8f017b48359099c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af36627bf7242718b1c73214296dc9090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af36627bf7242718b1c73214296dc9090">Halide::Internal::halide_log</a> (Expr a)</td></tr>
<tr class="memdesc:af36627bf7242718b1c73214296dc9090"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals.  <a href="namespace_halide_1_1_internal.html#af36627bf7242718b1c73214296dc9090">More...</a><br /></td></tr>
<tr class="separator:af36627bf7242718b1c73214296dc9090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5688772a963296ea52d2bd9ac5913e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5688772a963296ea52d2bd9ac5913e79">Halide::Internal::halide_exp</a> (Expr a)</td></tr>
<tr class="memdesc:a5688772a963296ea52d2bd9ac5913e79"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals.  <a href="namespace_halide_1_1_internal.html#a5688772a963296ea52d2bd9ac5913e79">More...</a><br /></td></tr>
<tr class="separator:a5688772a963296ea52d2bd9ac5913e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d36eef829f9c1e2d6aaf9218b2e0e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3d36eef829f9c1e2d6aaf9218b2e0e66">Halide::Internal::halide_erf</a> (Expr a)</td></tr>
<tr class="memdesc:a3d36eef829f9c1e2d6aaf9218b2e0e66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals.  <a href="namespace_halide_1_1_internal.html#a3d36eef829f9c1e2d6aaf9218b2e0e66">More...</a><br /></td></tr>
<tr class="separator:a3d36eef829f9c1e2d6aaf9218b2e0e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a28d7f25e89e1f74d7d76e370161f7358"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a28d7f25e89e1f74d7d76e370161f7358">Halide::operator+</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a28d7f25e89e1f74d7d76e370161f7358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an expression and a constant integer.  <a href="namespace_halide.html#a28d7f25e89e1f74d7d76e370161f7358">More...</a><br /></td></tr>
<tr class="separator:a28d7f25e89e1f74d7d76e370161f7358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95625f031290fffefab2365275c4981f"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a95625f031290fffefab2365275c4981f">Halide::operator+</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a95625f031290fffefab2365275c4981f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constant integer and an expression.  <a href="namespace_halide.html#a95625f031290fffefab2365275c4981f">More...</a><br /></td></tr>
<tr class="separator:a95625f031290fffefab2365275c4981f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd77e71422999076fa3339829ac8c30d"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#acd77e71422999076fa3339829ac8c30d">Halide::operator+=</a> (Expr &amp;a, Expr b)</td></tr>
<tr class="memdesc:acd77e71422999076fa3339829ac8c30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the sum of two expressions, without changing its type.  <a href="namespace_halide.html#acd77e71422999076fa3339829ac8c30d">More...</a><br /></td></tr>
<tr class="separator:acd77e71422999076fa3339829ac8c30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f3eb27005363158ca0e934811c98ed"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a86f3eb27005363158ca0e934811c98ed">Halide::operator-</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a86f3eb27005363158ca0e934811c98ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#a86f3eb27005363158ca0e934811c98ed">More...</a><br /></td></tr>
<tr class="separator:a86f3eb27005363158ca0e934811c98ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065c7f5ec94e00c50ce57e0acd336eaa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a065c7f5ec94e00c50ce57e0acd336eaa">Halide::operator-</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a065c7f5ec94e00c50ce57e0acd336eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a constant integer from an expression.  <a href="namespace_halide.html#a065c7f5ec94e00c50ce57e0acd336eaa">More...</a><br /></td></tr>
<tr class="separator:a065c7f5ec94e00c50ce57e0acd336eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929a86c18d4952daa3d1bad7b2b448fc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a929a86c18d4952daa3d1bad7b2b448fc">Halide::operator-</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a929a86c18d4952daa3d1bad7b2b448fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts an expression from a constant integer.  <a href="namespace_halide.html#a929a86c18d4952daa3d1bad7b2b448fc">More...</a><br /></td></tr>
<tr class="separator:a929a86c18d4952daa3d1bad7b2b448fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80881209a15ed749e168d6edbcb6f687"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a80881209a15ed749e168d6edbcb6f687">Halide::operator-</a> (Expr a)</td></tr>
<tr class="memdesc:a80881209a15ed749e168d6edbcb6f687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negative of the argument.  <a href="namespace_halide.html#a80881209a15ed749e168d6edbcb6f687">More...</a><br /></td></tr>
<tr class="separator:a80881209a15ed749e168d6edbcb6f687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94db82f1af5cd7492bb503c2238ade8a"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a94db82f1af5cd7492bb503c2238ade8a">Halide::operator-=</a> (Expr &amp;a, Expr b)</td></tr>
<tr class="memdesc:a94db82f1af5cd7492bb503c2238ade8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the difference of two expressions, without changing its type.  <a href="namespace_halide.html#a94db82f1af5cd7492bb503c2238ade8a">More...</a><br /></td></tr>
<tr class="separator:a94db82f1af5cd7492bb503c2238ade8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908c6748ab34a4a66274b196b6900af5"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a908c6748ab34a4a66274b196b6900af5">Halide::operator*</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a908c6748ab34a4a66274b196b6900af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#a908c6748ab34a4a66274b196b6900af5">More...</a><br /></td></tr>
<tr class="separator:a908c6748ab34a4a66274b196b6900af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a62e39c7b218f40a143d8caf4121e3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a64a62e39c7b218f40a143d8caf4121e3">Halide::operator*</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a64a62e39c7b218f40a143d8caf4121e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an expression and a constant integer.  <a href="namespace_halide.html#a64a62e39c7b218f40a143d8caf4121e3">More...</a><br /></td></tr>
<tr class="separator:a64a62e39c7b218f40a143d8caf4121e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe93ddfca97d22f96789eea9b8c5d355"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe93ddfca97d22f96789eea9b8c5d355">Halide::operator*</a> (int a, Expr b)</td></tr>
<tr class="memdesc:abe93ddfca97d22f96789eea9b8c5d355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a constant integer and an expression.  <a href="namespace_halide.html#abe93ddfca97d22f96789eea9b8c5d355">More...</a><br /></td></tr>
<tr class="separator:abe93ddfca97d22f96789eea9b8c5d355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac0c84f284a38d6018e2d4e5d075c8b5b">Halide::operator*=</a> (Expr &amp;a, Expr b)</td></tr>
<tr class="memdesc:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the product of two expressions, without changing its type.  <a href="namespace_halide.html#ac0c84f284a38d6018e2d4e5d075c8b5b">More...</a><br /></td></tr>
<tr class="separator:ac0c84f284a38d6018e2d4e5d075c8b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a73e12ddd6395e3a1c1286e2e3c51e675">Halide::operator/</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ratio of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#a73e12ddd6395e3a1c1286e2e3c51e675">More...</a><br /></td></tr>
<tr class="separator:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0da6820c40a5911fb23d973283487f"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3c0da6820c40a5911fb23d973283487f">Halide::operator/=</a> (Expr &amp;a, Expr b)</td></tr>
<tr class="memdesc:a3c0da6820c40a5911fb23d973283487f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the ratio of two expressions, without changing its type.  <a href="namespace_halide.html#a3c0da6820c40a5911fb23d973283487f">More...</a><br /></td></tr>
<tr class="separator:a3c0da6820c40a5911fb23d973283487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfc6078f426cdc7e80fe36681d01e5e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1dfc6078f426cdc7e80fe36681d01e5e">Halide::operator/</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a1dfc6078f426cdc7e80fe36681d01e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides an expression by a constant integer.  <a href="namespace_halide.html#a1dfc6078f426cdc7e80fe36681d01e5e">More...</a><br /></td></tr>
<tr class="separator:a1dfc6078f426cdc7e80fe36681d01e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8351f5d64c664ba9d65178161e1937db"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8351f5d64c664ba9d65178161e1937db">Halide::operator/</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a8351f5d64c664ba9d65178161e1937db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides a constant integer by an expression.  <a href="namespace_halide.html#a8351f5d64c664ba9d65178161e1937db">More...</a><br /></td></tr>
<tr class="separator:a8351f5d64c664ba9d65178161e1937db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc191ed3318e2072d18f42d11f5b01d4"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc191ed3318e2072d18f42d11f5b01d4">Halide::operator%</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abc191ed3318e2072d18f42d11f5b01d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument reduced modulo the second, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#abc191ed3318e2072d18f42d11f5b01d4">More...</a><br /></td></tr>
<tr class="separator:abc191ed3318e2072d18f42d11f5b01d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ba15c22ee9addfc1b08fd6642d2c4d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a63ba15c22ee9addfc1b08fd6642d2c4d">Halide::operator%</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a63ba15c22ee9addfc1b08fd6642d2c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mods an expression by a constant integer.  <a href="namespace_halide.html#a63ba15c22ee9addfc1b08fd6642d2c4d">More...</a><br /></td></tr>
<tr class="separator:a63ba15c22ee9addfc1b08fd6642d2c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5726a49d7bfaec36cbaca2a5004ddc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed5726a49d7bfaec36cbaca2a5004ddc">Halide::operator%</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:aed5726a49d7bfaec36cbaca2a5004ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mods a constant integer by an expression.  <a href="namespace_halide.html#aed5726a49d7bfaec36cbaca2a5004ddc">More...</a><br /></td></tr>
<tr class="separator:aed5726a49d7bfaec36cbaca2a5004ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9105ae9f0995f450825e522170f5d1e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af9105ae9f0995f450825e522170f5d1e">Halide::operator&gt;</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:af9105ae9f0995f450825e522170f5d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#af9105ae9f0995f450825e522170f5d1e">More...</a><br /></td></tr>
<tr class="separator:af9105ae9f0995f450825e522170f5d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014703a60d365b71dee6def5cb7a6f2c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a014703a60d365b71dee6def5cb7a6f2c">Halide::operator&gt;</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a014703a60d365b71dee6def5cb7a6f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is greater than a constant integer.  <a href="namespace_halide.html#a014703a60d365b71dee6def5cb7a6f2c">More...</a><br /></td></tr>
<tr class="separator:a014703a60d365b71dee6def5cb7a6f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af05e2a8405c578614399da8ffba005"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4af05e2a8405c578614399da8ffba005">Halide::operator&gt;</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a4af05e2a8405c578614399da8ffba005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is greater than an expression.  <a href="namespace_halide.html#a4af05e2a8405c578614399da8ffba005">More...</a><br /></td></tr>
<tr class="separator:a4af05e2a8405c578614399da8ffba005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbad5ee20448455260670dec22c76a21"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abbad5ee20448455260670dec22c76a21">Halide::operator&lt;</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abbad5ee20448455260670dec22c76a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#abbad5ee20448455260670dec22c76a21">More...</a><br /></td></tr>
<tr class="separator:abbad5ee20448455260670dec22c76a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b253d012615166e933d5b39d0bc83fc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8b253d012615166e933d5b39d0bc83fc">Halide::operator&lt;</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a8b253d012615166e933d5b39d0bc83fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is less than a constant integer.  <a href="namespace_halide.html#a8b253d012615166e933d5b39d0bc83fc">More...</a><br /></td></tr>
<tr class="separator:a8b253d012615166e933d5b39d0bc83fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee20253bf83a4cdd89537cc6e8161524"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aee20253bf83a4cdd89537cc6e8161524">Halide::operator&lt;</a> (int a, Expr b)</td></tr>
<tr class="memdesc:aee20253bf83a4cdd89537cc6e8161524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is less than an expression.  <a href="namespace_halide.html#aee20253bf83a4cdd89537cc6e8161524">More...</a><br /></td></tr>
<tr class="separator:aee20253bf83a4cdd89537cc6e8161524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad297e6fa5deb0ba4e8ad7fe344629706">Halide::operator&lt;=</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#ad297e6fa5deb0ba4e8ad7fe344629706">More...</a><br /></td></tr>
<tr class="separator:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0616c33325d7b8ee67a4e2e305f5f375"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0616c33325d7b8ee67a4e2e305f5f375">Halide::operator&lt;=</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a0616c33325d7b8ee67a4e2e305f5f375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is less than or equal to a constant integer.  <a href="namespace_halide.html#a0616c33325d7b8ee67a4e2e305f5f375">More...</a><br /></td></tr>
<tr class="separator:a0616c33325d7b8ee67a4e2e305f5f375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b263f999854f1e7e1ee8602998bb016"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6b263f999854f1e7e1ee8602998bb016">Halide::operator&lt;=</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a6b263f999854f1e7e1ee8602998bb016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is less than or equal to an expression.  <a href="namespace_halide.html#a6b263f999854f1e7e1ee8602998bb016">More...</a><br /></td></tr>
<tr class="separator:a6b263f999854f1e7e1ee8602998bb016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8f2e815b9cc7475802c0fb6a7e7ae6ae">Halide::operator&gt;=</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#a8f2e815b9cc7475802c0fb6a7e7ae6ae">More...</a><br /></td></tr>
<tr class="separator:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef09f94b08df76f8bf1601f129d4251"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6ef09f94b08df76f8bf1601f129d4251">Halide::operator&gt;=</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a6ef09f94b08df76f8bf1601f129d4251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is greater than or equal to a constant integer.  <a href="namespace_halide.html#a6ef09f94b08df76f8bf1601f129d4251">More...</a><br /></td></tr>
<tr class="separator:a6ef09f94b08df76f8bf1601f129d4251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb8d069599b7e8df16e35cf3a9d54d4"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4bb8d069599b7e8df16e35cf3a9d54d4">Halide::operator&gt;=</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a4bb8d069599b7e8df16e35cf3a9d54d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is greater than or equal to an expression.  <a href="namespace_halide.html#a4bb8d069599b7e8df16e35cf3a9d54d4">More...</a><br /></td></tr>
<tr class="separator:a4bb8d069599b7e8df16e35cf3a9d54d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abfbbb2e5820938f4d8f0a8b2324776df">Halide::operator==</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abfbbb2e5820938f4d8f0a8b2324776df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#abfbbb2e5820938f4d8f0a8b2324776df">More...</a><br /></td></tr>
<tr class="separator:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3fdd8106c4413b0606a5cb73d3ec1c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#adc3fdd8106c4413b0606a5cb73d3ec1c">Halide::operator==</a> (Expr a, int b)</td></tr>
<tr class="memdesc:adc3fdd8106c4413b0606a5cb73d3ec1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is equal to a constant integer.  <a href="namespace_halide.html#adc3fdd8106c4413b0606a5cb73d3ec1c">More...</a><br /></td></tr>
<tr class="separator:adc3fdd8106c4413b0606a5cb73d3ec1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115d4df85c9d3b9e9221f0c62c765858"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a115d4df85c9d3b9e9221f0c62c765858">Halide::operator==</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a115d4df85c9d3b9e9221f0c62c765858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is equal to an expression.  <a href="namespace_halide.html#a115d4df85c9d3b9e9221f0c62c765858">More...</a><br /></td></tr>
<tr class="separator:a115d4df85c9d3b9e9221f0c62c765858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3d11c86964dbb2586103744cac1614"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d3d11c86964dbb2586103744cac1614">Halide::operator!=</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a8d3d11c86964dbb2586103744cac1614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is not equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="namespace_halide.html#a8d3d11c86964dbb2586103744cac1614">More...</a><br /></td></tr>
<tr class="separator:a8d3d11c86964dbb2586103744cac1614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dbd0c68dfe117d2d1351d8f86cae4f"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a59dbd0c68dfe117d2d1351d8f86cae4f">Halide::operator!=</a> (Expr a, int b)</td></tr>
<tr class="memdesc:a59dbd0c68dfe117d2d1351d8f86cae4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is not equal to a constant integer.  <a href="namespace_halide.html#a59dbd0c68dfe117d2d1351d8f86cae4f">More...</a><br /></td></tr>
<tr class="separator:a59dbd0c68dfe117d2d1351d8f86cae4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c1c720efb61b649e495eac92c0c6eb"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a82c1c720efb61b649e495eac92c0c6eb">Halide::operator!=</a> (int a, Expr b)</td></tr>
<tr class="memdesc:a82c1c720efb61b649e495eac92c0c6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is not equal to an expression.  <a href="namespace_halide.html#a82c1c720efb61b649e495eac92c0c6eb">More...</a><br /></td></tr>
<tr class="separator:a82c1c720efb61b649e495eac92c0c6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82895c36bf02ecc66bf3d01a1b56d829"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a82895c36bf02ecc66bf3d01a1b56d829">Halide::operator &amp;&amp;</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a82895c36bf02ecc66bf3d01a1b56d829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical and of the two arguments.  <a href="namespace_halide.html#a82895c36bf02ecc66bf3d01a1b56d829">More...</a><br /></td></tr>
<tr class="separator:a82895c36bf02ecc66bf3d01a1b56d829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0f5352376a5831a2267bc2e73a3810"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc0f5352376a5831a2267bc2e73a3810">Halide::operator &amp;&amp;</a> (const Expr &amp;a, bool b)</td></tr>
<tr class="memdesc:abc0f5352376a5831a2267bc2e73a3810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> and a bool.  <a href="namespace_halide.html#abc0f5352376a5831a2267bc2e73a3810">More...</a><br /></td></tr>
<tr class="separator:abc0f5352376a5831a2267bc2e73a3810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f537d7495434290855b37a5317293b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a22f537d7495434290855b37a5317293b">Halide::operator &amp;&amp;</a> (bool a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a22f537d7495434290855b37a5317293b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an expression and a constant integer.  <a href="namespace_halide.html#a22f537d7495434290855b37a5317293b">More...</a><br /></td></tr>
<tr class="separator:a22f537d7495434290855b37a5317293b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa362c4a270ad2ddf71774a3024f1888b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa362c4a270ad2ddf71774a3024f1888b">Halide::operator||</a> (const Expr &amp;a, bool b)</td></tr>
<tr class="memdesc:aa362c4a270ad2ddf71774a3024f1888b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> and a bool.  <a href="namespace_halide.html#aa362c4a270ad2ddf71774a3024f1888b">More...</a><br /></td></tr>
<tr class="separator:aa362c4a270ad2ddf71774a3024f1888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a23781fff687cbb3e44eff7d2c1561"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a68a23781fff687cbb3e44eff7d2c1561">Halide::operator||</a> (bool a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a68a23781fff687cbb3e44eff7d2c1561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> and a bool.  <a href="namespace_halide.html#a68a23781fff687cbb3e44eff7d2c1561">More...</a><br /></td></tr>
<tr class="separator:a68a23781fff687cbb3e44eff7d2c1561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8d830f627b9fd99f8845dadcde7b0dd1"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d830f627b9fd99f8845dadcde7b0dd1">Halide::operator+</a> (Expr a, float b)</td></tr>
<tr class="memdesc:a8d830f627b9fd99f8845dadcde7b0dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a8d830f627b9fd99f8845dadcde7b0dd1">More...</a><br /></td></tr>
<tr class="separator:a8d830f627b9fd99f8845dadcde7b0dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704b7b04f00436d90aad52a74a230181"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a704b7b04f00436d90aad52a74a230181">Halide::operator+</a> (float a, Expr b)</td></tr>
<tr class="memdesc:a704b7b04f00436d90aad52a74a230181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a704b7b04f00436d90aad52a74a230181">More...</a><br /></td></tr>
<tr class="separator:a704b7b04f00436d90aad52a74a230181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb362e84f0a152acd46b3ab42da29b9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aacb362e84f0a152acd46b3ab42da29b9">Halide::operator-</a> (Expr a, float b)</td></tr>
<tr class="memdesc:aacb362e84f0a152acd46b3ab42da29b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#aacb362e84f0a152acd46b3ab42da29b9">More...</a><br /></td></tr>
<tr class="separator:aacb362e84f0a152acd46b3ab42da29b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d01cda7bea93467113a5d32b00467a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a47d01cda7bea93467113a5d32b00467a">Halide::operator-</a> (float a, Expr b)</td></tr>
<tr class="memdesc:a47d01cda7bea93467113a5d32b00467a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a47d01cda7bea93467113a5d32b00467a">More...</a><br /></td></tr>
<tr class="separator:a47d01cda7bea93467113a5d32b00467a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585ccd78b6034d015358838478f4147b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a585ccd78b6034d015358838478f4147b">Halide::operator*</a> (Expr a, float b)</td></tr>
<tr class="memdesc:a585ccd78b6034d015358838478f4147b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a585ccd78b6034d015358838478f4147b">More...</a><br /></td></tr>
<tr class="separator:a585ccd78b6034d015358838478f4147b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96077a9c1ec602e9196f7fe0a6dec2bf"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a96077a9c1ec602e9196f7fe0a6dec2bf">Halide::operator*</a> (float a, Expr b)</td></tr>
<tr class="memdesc:a96077a9c1ec602e9196f7fe0a6dec2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a96077a9c1ec602e9196f7fe0a6dec2bf">More...</a><br /></td></tr>
<tr class="separator:a96077a9c1ec602e9196f7fe0a6dec2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dce878e2e6156e9e9ec00f240c3de3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a77dce878e2e6156e9e9ec00f240c3de3">Halide::operator/</a> (Expr a, float b)</td></tr>
<tr class="memdesc:a77dce878e2e6156e9e9ec00f240c3de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a77dce878e2e6156e9e9ec00f240c3de3">More...</a><br /></td></tr>
<tr class="separator:a77dce878e2e6156e9e9ec00f240c3de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c179840fe2018ea7106e3c7305516b6"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2c179840fe2018ea7106e3c7305516b6">Halide::operator/</a> (float a, Expr b)</td></tr>
<tr class="memdesc:a2c179840fe2018ea7106e3c7305516b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a2c179840fe2018ea7106e3c7305516b6">More...</a><br /></td></tr>
<tr class="separator:a2c179840fe2018ea7106e3c7305516b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7ffb094c58badc44f353a94681dbfe"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a7ffb094c58badc44f353a94681dbfe">Halide::operator%</a> (Expr a, float b)</td></tr>
<tr class="memdesc:a9a7ffb094c58badc44f353a94681dbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a9a7ffb094c58badc44f353a94681dbfe">More...</a><br /></td></tr>
<tr class="separator:a9a7ffb094c58badc44f353a94681dbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced81e366b73b3c1503905f0c594c516"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aced81e366b73b3c1503905f0c594c516">Halide::operator%</a> (float a, Expr b)</td></tr>
<tr class="memdesc:aced81e366b73b3c1503905f0c594c516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#aced81e366b73b3c1503905f0c594c516">More...</a><br /></td></tr>
<tr class="separator:aced81e366b73b3c1503905f0c594c516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb3edae8f6879c195ad373c0d7a7b86"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3fb3edae8f6879c195ad373c0d7a7b86">Halide::operator&gt;</a> (Expr a, float b)</td></tr>
<tr class="memdesc:a3fb3edae8f6879c195ad373c0d7a7b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a3fb3edae8f6879c195ad373c0d7a7b86">More...</a><br /></td></tr>
<tr class="separator:a3fb3edae8f6879c195ad373c0d7a7b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe14360d4dab7d8119572f3aefdbbb25"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe14360d4dab7d8119572f3aefdbbb25">Halide::operator&gt;</a> (float a, Expr b)</td></tr>
<tr class="memdesc:abe14360d4dab7d8119572f3aefdbbb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#abe14360d4dab7d8119572f3aefdbbb25">More...</a><br /></td></tr>
<tr class="separator:abe14360d4dab7d8119572f3aefdbbb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5730454f894a93bebbaf72dbc714e1"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4e5730454f894a93bebbaf72dbc714e1">Halide::operator&lt;</a> (Expr a, float b)</td></tr>
<tr class="memdesc:a4e5730454f894a93bebbaf72dbc714e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a4e5730454f894a93bebbaf72dbc714e1">More...</a><br /></td></tr>
<tr class="separator:a4e5730454f894a93bebbaf72dbc714e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dd5b9660e5510cc23bbf8fa8e5f4b7"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a47dd5b9660e5510cc23bbf8fa8e5f4b7">Halide::operator&lt;</a> (float a, Expr b)</td></tr>
<tr class="memdesc:a47dd5b9660e5510cc23bbf8fa8e5f4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a47dd5b9660e5510cc23bbf8fa8e5f4b7">More...</a><br /></td></tr>
<tr class="separator:a47dd5b9660e5510cc23bbf8fa8e5f4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070410b979a0b62fdb67d6f13fbdc1d4"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a070410b979a0b62fdb67d6f13fbdc1d4">Halide::operator&gt;=</a> (Expr a, float b)</td></tr>
<tr class="memdesc:a070410b979a0b62fdb67d6f13fbdc1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a070410b979a0b62fdb67d6f13fbdc1d4">More...</a><br /></td></tr>
<tr class="separator:a070410b979a0b62fdb67d6f13fbdc1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2e1d96814511a965a43e835947966e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4d2e1d96814511a965a43e835947966e">Halide::operator&gt;=</a> (float a, Expr b)</td></tr>
<tr class="memdesc:a4d2e1d96814511a965a43e835947966e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a4d2e1d96814511a965a43e835947966e">More...</a><br /></td></tr>
<tr class="separator:a4d2e1d96814511a965a43e835947966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab944b1232804900cdde74619fbfeda68"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab944b1232804900cdde74619fbfeda68">Halide::operator&lt;=</a> (Expr a, float b)</td></tr>
<tr class="memdesc:ab944b1232804900cdde74619fbfeda68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#ab944b1232804900cdde74619fbfeda68">More...</a><br /></td></tr>
<tr class="separator:ab944b1232804900cdde74619fbfeda68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc2ce1a66bdb1877f337436295cfc90"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5fc2ce1a66bdb1877f337436295cfc90">Halide::operator&lt;=</a> (float a, Expr b)</td></tr>
<tr class="memdesc:a5fc2ce1a66bdb1877f337436295cfc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a5fc2ce1a66bdb1877f337436295cfc90">More...</a><br /></td></tr>
<tr class="separator:a5fc2ce1a66bdb1877f337436295cfc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506ebe338276d9e91223e9f7f57eaa46"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a506ebe338276d9e91223e9f7f57eaa46">Halide::operator==</a> (Expr a, float b)</td></tr>
<tr class="memdesc:a506ebe338276d9e91223e9f7f57eaa46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#a506ebe338276d9e91223e9f7f57eaa46">More...</a><br /></td></tr>
<tr class="separator:a506ebe338276d9e91223e9f7f57eaa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54bb0b329c0bb93eb19a2dc3a4e2285"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae54bb0b329c0bb93eb19a2dc3a4e2285">Halide::operator==</a> (float a, Expr b)</td></tr>
<tr class="memdesc:ae54bb0b329c0bb93eb19a2dc3a4e2285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#ae54bb0b329c0bb93eb19a2dc3a4e2285">More...</a><br /></td></tr>
<tr class="separator:ae54bb0b329c0bb93eb19a2dc3a4e2285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf32c2846c632946f95a2ea9f60da704"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abf32c2846c632946f95a2ea9f60da704">Halide::operator!=</a> (Expr a, float b)</td></tr>
<tr class="memdesc:abf32c2846c632946f95a2ea9f60da704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#abf32c2846c632946f95a2ea9f60da704">More...</a><br /></td></tr>
<tr class="separator:abf32c2846c632946f95a2ea9f60da704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60a387c587e80408e8fa8b63bfb7cdb"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af60a387c587e80408e8fa8b63bfb7cdb">Halide::operator!=</a> (float a, Expr b)</td></tr>
<tr class="memdesc:af60a387c587e80408e8fa8b63bfb7cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="namespace_halide.html#af60a387c587e80408e8fa8b63bfb7cdb">More...</a><br /></td></tr>
<tr class="separator:af60a387c587e80408e8fa8b63bfb7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a39865d2369d130f6c8e435c860cafb14"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a39865d2369d130f6c8e435c860cafb14">Halide::operator&lt;&lt;</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a39865d2369d130f6c8e435c860cafb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value left.  <a href="namespace_halide.html#a39865d2369d130f6c8e435c860cafb14">More...</a><br /></td></tr>
<tr class="separator:a39865d2369d130f6c8e435c860cafb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bce43f9178ddb2fda8f1ef8c5755384"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9bce43f9178ddb2fda8f1ef8c5755384">Halide::operator&lt;&lt;</a> (Expr x, int y)</td></tr>
<tr class="memdesc:a9bce43f9178ddb2fda8f1ef8c5755384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value left.  <a href="namespace_halide.html#a9bce43f9178ddb2fda8f1ef8c5755384">More...</a><br /></td></tr>
<tr class="separator:a9bce43f9178ddb2fda8f1ef8c5755384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e38fc05007e6858197263d13420f88"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a65e38fc05007e6858197263d13420f88">Halide::operator&lt;&lt;</a> (int x, Expr y)</td></tr>
<tr class="memdesc:a65e38fc05007e6858197263d13420f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value left.  <a href="namespace_halide.html#a65e38fc05007e6858197263d13420f88">More...</a><br /></td></tr>
<tr class="separator:a65e38fc05007e6858197263d13420f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0615561baf45c3d84e7d36c77204ee3d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0615561baf45c3d84e7d36c77204ee3d">Halide::operator&gt;&gt;</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a0615561baf45c3d84e7d36c77204ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value right.  <a href="namespace_halide.html#a0615561baf45c3d84e7d36c77204ee3d">More...</a><br /></td></tr>
<tr class="separator:a0615561baf45c3d84e7d36c77204ee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e7223753c831bcb54d39bbdf40733d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab8e7223753c831bcb54d39bbdf40733d">Halide::operator&gt;&gt;</a> (Expr x, int y)</td></tr>
<tr class="memdesc:ab8e7223753c831bcb54d39bbdf40733d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value right.  <a href="namespace_halide.html#ab8e7223753c831bcb54d39bbdf40733d">More...</a><br /></td></tr>
<tr class="separator:ab8e7223753c831bcb54d39bbdf40733d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675c340fc68c38bd4267dfecdc026f25"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a675c340fc68c38bd4267dfecdc026f25">Halide::operator&gt;&gt;</a> (int x, Expr y)</td></tr>
<tr class="memdesc:a675c340fc68c38bd4267dfecdc026f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value right.  <a href="namespace_halide.html#a675c340fc68c38bd4267dfecdc026f25">More...</a><br /></td></tr>
<tr class="separator:a675c340fc68c38bd4267dfecdc026f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab9255b9f7b5c046d86588a9a157a6e8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab9255b9f7b5c046d86588a9a157a6e8d">Halide::print</a> (const std::vector&lt; Expr &gt; &amp;values)</td></tr>
<tr class="memdesc:ab9255b9f7b5c046d86588a9a157a6e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints out its value whenever it is evaluated.  <a href="namespace_halide.html#ab9255b9f7b5c046d86588a9a157a6e8d">More...</a><br /></td></tr>
<tr class="separator:ab9255b9f7b5c046d86588a9a157a6e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e525d598ff7e97f41cbc8f6412fab5"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae3e525d598ff7e97f41cbc8f6412fab5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae3e525d598ff7e97f41cbc8f6412fab5">Halide::print</a> (Expr a, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae3e525d598ff7e97f41cbc8f6412fab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints out its value whenever it is evaluated.  <a href="namespace_halide.html#ae3e525d598ff7e97f41cbc8f6412fab5">More...</a><br /></td></tr>
<tr class="separator:ae3e525d598ff7e97f41cbc8f6412fab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5196456d46ad1c58095aea036b2a740c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5196456d46ad1c58095aea036b2a740c">Halide::print_when</a> (Expr condition, const std::vector&lt; Expr &gt; &amp;values)</td></tr>
<tr class="memdesc:a5196456d46ad1c58095aea036b2a740c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints whenever it is evaluated, provided that the condition is true.  <a href="namespace_halide.html#a5196456d46ad1c58095aea036b2a740c">More...</a><br /></td></tr>
<tr class="separator:a5196456d46ad1c58095aea036b2a740c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefa21e3ff37dd2bd66776aeea1b5008"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:aaefa21e3ff37dd2bd66776aeea1b5008"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aaefa21e3ff37dd2bd66776aeea1b5008">Halide::print_when</a> (Expr condition, Expr a, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aaefa21e3ff37dd2bd66776aeea1b5008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints whenever it is evaluated, provided that the condition is true.  <a href="namespace_halide.html#aaefa21e3ff37dd2bd66776aeea1b5008">More...</a><br /></td></tr>
<tr class="separator:aaefa21e3ff37dd2bd66776aeea1b5008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6fd1f8aa318e05558f743889d6236296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6fd1f8aa318e05558f743889d6236296">Halide::require</a> (Expr condition, const std::vector&lt; Expr &gt; &amp;values)</td></tr>
<tr class="memdesc:a6fd1f8aa318e05558f743889d6236296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that that guarantees a precondition.  <a href="namespace_halide.html#a6fd1f8aa318e05558f743889d6236296">More...</a><br /></td></tr>
<tr class="separator:a6fd1f8aa318e05558f743889d6236296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea2bf51ff6f9c7c235474bf477c6e59"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a5ea2bf51ff6f9c7c235474bf477c6e59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5ea2bf51ff6f9c7c235474bf477c6e59">Halide::require</a> (Expr condition, Expr value, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5ea2bf51ff6f9c7c235474bf477c6e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that that guarantees a precondition.  <a href="namespace_halide.html#a5ea2bf51ff6f9c7c235474bf477c6e59">More...</a><br /></td></tr>
<tr class="separator:a5ea2bf51ff6f9c7c235474bf477c6e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab3feac10053138f814c4ae2ce4d919d1"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:ab3feac10053138f814c4ae2ce4d919d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab3feac10053138f814c4ae2ce4d919d1">Halide::memoize_tag</a> (Expr result, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab3feac10053138f814c4ae2ce4d919d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the values used in the memoization cache key for memoize.  <a href="namespace_halide.html#ab3feac10053138f814c4ae2ce4d919d1">More...</a><br /></td></tr>
<tr class="separator:ab3feac10053138f814c4ae2ce4d919d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines various operator overloads and utility functions that make it more pleasant to work with <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> expressions. </p>

<p class="definition">Definition in file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_i_r_operator_8h.html">IROperator.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
