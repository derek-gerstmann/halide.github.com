<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: IROperator.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_i_r_operator_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">IROperator.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines various operator overloads and utility functions that make it more pleasant to work with <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> expressions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;atomic&gt;</code><br/>
<code>#include &quot;<a class="el" href="_i_r_8h_source.html">IR.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="_util_8h_source.html">Util.h</a>&quot;</code><br/>
</div>
<p><a href="_i_r_operator_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_buffer_builder.html">Halide::Internal::BufferBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A builder to help create Exprs representing <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> structs (e.g.  <a href="struct_halide_1_1_internal_1_1_buffer_builder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr class="memdesc:namespace_halide"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines methods for manipulating and analyzing boolean expressions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Halide::Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3b273e981bcb24e47d4caa6fedae915e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3b273e981bcb24e47d4caa6fedae915e">Halide::Internal::is_const</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a3b273e981bcb24e47d4caa6fedae915e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression either an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, a <a class="el" href="struct_halide_1_1_internal_1_1_string_imm.html" title="String constants. ">StringImm</a>, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a> of the same, or a <a class="el" href="struct_halide_1_1_internal_1_1_ramp.html" title="A linear ramp vector node. ">Ramp</a> or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same.  <a href="#a3b273e981bcb24e47d4caa6fedae915e">More...</a><br/></td></tr>
<tr class="separator:a3b273e981bcb24e47d4caa6fedae915e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a68b513d87c82d69c37b2fcdfa569f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3a68b513d87c82d69c37b2fcdfa569f7">Halide::Internal::is_const</a> (const Expr &amp;e, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> v)</td></tr>
<tr class="memdesc:a3a68b513d87c82d69c37b2fcdfa569f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> of a particular value, or a <a class="el" href="struct_halide_1_1_internal_1_1_cast.html" title="The actual IR nodes begin here. ">Cast</a>, or <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of the same.  <a href="#a3a68b513d87c82d69c37b2fcdfa569f7">More...</a><br/></td></tr>
<tr class="separator:a3a68b513d87c82d69c37b2fcdfa569f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a19986908fcd0930f725ebfbe588db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a19a19986908fcd0930f725ebfbe588db">Halide::Internal::as_const_int</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a19a19986908fcd0930f725ebfbe588db"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of an <a class="el" href="struct_halide_1_1_internal_1_1_int_imm.html" title="Integer constants. ">IntImm</a>, return a pointer to its value.  <a href="#a19a19986908fcd0930f725ebfbe588db">More...</a><br/></td></tr>
<tr class="separator:a19a19986908fcd0930f725ebfbe588db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2adc6efa53c904db49c8d4635ba8cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4f2adc6efa53c904db49c8d4635ba8cb">Halide::Internal::as_const_uint</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a4f2adc6efa53c904db49c8d4635ba8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants. ">UIntImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_u_int_imm.html" title="Unsigned integer constants. ">UIntImm</a>, return a pointer to its value.  <a href="#a4f2adc6efa53c904db49c8d4635ba8cb">More...</a><br/></td></tr>
<tr class="separator:a4f2adc6efa53c904db49c8d4635ba8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42b3768e59c07a9feacdb678cef447f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae42b3768e59c07a9feacdb678cef447f">Halide::Internal::as_const_float</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:ae42b3768e59c07a9feacdb678cef447f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If an expression is a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a> or a <a class="el" href="struct_halide_1_1_internal_1_1_broadcast.html" title="A vector with &#39;lanes&#39; elements, in which every element is &#39;value&#39;. ">Broadcast</a> of a <a class="el" href="struct_halide_1_1_internal_1_1_float_imm.html" title="Floating point constants. ">FloatImm</a>, return a pointer to its value.  <a href="#ae42b3768e59c07a9feacdb678cef447f">More...</a><br/></td></tr>
<tr class="separator:ae42b3768e59c07a9feacdb678cef447f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1960f97f81097b2a4d05e33f6b1401c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae1960f97f81097b2a4d05e33f6b1401c">Halide::Internal::is_const_power_of_two_integer</a> (const Expr &amp;e, int *bits)</td></tr>
<tr class="memdesc:ae1960f97f81097b2a4d05e33f6b1401c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a constant integer power of two.  <a href="#ae1960f97f81097b2a4d05e33f6b1401c">More...</a><br/></td></tr>
<tr class="separator:ae1960f97f81097b2a4d05e33f6b1401c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55afaabbe30211d488e6265082954418"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a55afaabbe30211d488e6265082954418">Halide::Internal::is_positive_const</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a55afaabbe30211d488e6265082954418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly greater than zero (in all lanes, if a vector expression)  <a href="#a55afaabbe30211d488e6265082954418">More...</a><br/></td></tr>
<tr class="separator:a55afaabbe30211d488e6265082954418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afededda187ca1272ce7601cd203655b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afededda187ca1272ce7601cd203655b5">Halide::Internal::is_negative_const</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:afededda187ca1272ce7601cd203655b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression)  <a href="#afededda187ca1272ce7601cd203655b5">More...</a><br/></td></tr>
<tr class="separator:afededda187ca1272ce7601cd203655b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76f2083acfd430d702cbcb56d7449d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af76f2083acfd430d702cbcb56d7449d5">Halide::Internal::is_negative_negatable_const</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:af76f2083acfd430d702cbcb56d7449d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also strictly less than zero (in all lanes, if a vector expression) and is its negative value representable.  <a href="#af76f2083acfd430d702cbcb56d7449d5">More...</a><br/></td></tr>
<tr class="separator:af76f2083acfd430d702cbcb56d7449d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dece8e3fd3bddffb6d259111e039be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a09dece8e3fd3bddffb6d259111e039be">Halide::Internal::is_undef</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a09dece8e3fd3bddffb6d259111e039be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression an undef.  <a href="#a09dece8e3fd3bddffb6d259111e039be">More...</a><br/></td></tr>
<tr class="separator:a09dece8e3fd3bddffb6d259111e039be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70dc736a1e1bc4dd11f46c3d924cd1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad70dc736a1e1bc4dd11f46c3d924cd1b">Halide::Internal::is_zero</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:ad70dc736a1e1bc4dd11f46c3d924cd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to zero (in all lanes, if a vector expression)  <a href="#ad70dc736a1e1bc4dd11f46c3d924cd1b">More...</a><br/></td></tr>
<tr class="separator:ad70dc736a1e1bc4dd11f46c3d924cd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc566f33cca32a1efc9029fee06ae9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4bc566f33cca32a1efc9029fee06ae9d">Halide::Internal::is_one</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a4bc566f33cca32a1efc9029fee06ae9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to one (in all lanes, if a vector expression)  <a href="#a4bc566f33cca32a1efc9029fee06ae9d">More...</a><br/></td></tr>
<tr class="separator:a4bc566f33cca32a1efc9029fee06ae9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9da208b635428d09b93492d7362a036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae9da208b635428d09b93492d7362a036">Halide::Internal::is_two</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:ae9da208b635428d09b93492d7362a036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the expression a const (as defined by is_const), and also equal to two (in all lanes, if a vector expression)  <a href="#ae9da208b635428d09b93492d7362a036">More...</a><br/></td></tr>
<tr class="separator:ae9da208b635428d09b93492d7362a036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf4c706f372d401a85a2b8899b9735c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4cf4c706f372d401a85a2b8899b9735c">Halide::Internal::is_no_op</a> (const Stmt &amp;s)</td></tr>
<tr class="memdesc:a4cf4c706f372d401a85a2b8899b9735c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the statement a no-op (which we represent as either an undefined <a class="el" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node. ">Stmt</a>, or as an <a class="el" href="struct_halide_1_1_internal_1_1_evaluate.html" title="Evaluate and discard an expression, presumably because it has some side-effect. ">Evaluate</a> node of a constant)  <a href="#a4cf4c706f372d401a85a2b8899b9735c">More...</a><br/></td></tr>
<tr class="separator:a4cf4c706f372d401a85a2b8899b9735c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f0a20e311c0982fb73a04c84a6bf3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a75f0a20e311c0982fb73a04c84a6bf3c">Halide::Internal::check_representable</a> (Type t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:a75f0a20e311c0982fb73a04c84a6bf3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a constant value can be correctly represented as the given type.  <a href="#a75f0a20e311c0982fb73a04c84a6bf3c">More...</a><br/></td></tr>
<tr class="separator:a75f0a20e311c0982fb73a04c84a6bf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ddf42fd8c32b453ea049bc176ea3a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a90ddf42fd8c32b453ea049bc176ea3a2">Halide::Internal::make_bool</a> (bool val, int lanes=1)</td></tr>
<tr class="memdesc:a90ddf42fd8c32b453ea049bc176ea3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a boolean constant from a C++ boolean value.  <a href="#a90ddf42fd8c32b453ea049bc176ea3a2">More...</a><br/></td></tr>
<tr class="separator:a90ddf42fd8c32b453ea049bc176ea3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fedf535d58f8900f8b7c00aa15ece8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a57fedf535d58f8900f8b7c00aa15ece8">Halide::Internal::make_zero</a> (Type t)</td></tr>
<tr class="memdesc:a57fedf535d58f8900f8b7c00aa15ece8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of zero in the given type.  <a href="#a57fedf535d58f8900f8b7c00aa15ece8">More...</a><br/></td></tr>
<tr class="separator:a57fedf535d58f8900f8b7c00aa15ece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ace305dbdd7fed2cf9d5057d4c02067c9">Halide::Internal::make_one</a> (Type t)</td></tr>
<tr class="memdesc:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of one in the given type.  <a href="#ace305dbdd7fed2cf9d5057d4c02067c9">More...</a><br/></td></tr>
<tr class="separator:ace305dbdd7fed2cf9d5057d4c02067c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc35f0dc3562ffb5bb777021679435e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#afc35f0dc3562ffb5bb777021679435e2">Halide::Internal::make_two</a> (Type t)</td></tr>
<tr class="memdesc:afc35f0dc3562ffb5bb777021679435e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the representation of two in the given type.  <a href="#afc35f0dc3562ffb5bb777021679435e2">More...</a><br/></td></tr>
<tr class="separator:afc35f0dc3562ffb5bb777021679435e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baf8e1371967a473027d673c6d48286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7baf8e1371967a473027d673c6d48286">Halide::Internal::const_true</a> (int lanes=1)</td></tr>
<tr class="memdesc:a7baf8e1371967a473027d673c6d48286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean true.  <a href="#a7baf8e1371967a473027d673c6d48286">More...</a><br/></td></tr>
<tr class="separator:a7baf8e1371967a473027d673c6d48286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455bb5e473e0686b5b027a51228c1af4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a455bb5e473e0686b5b027a51228c1af4">Halide::Internal::const_false</a> (int lanes=1)</td></tr>
<tr class="memdesc:a455bb5e473e0686b5b027a51228c1af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the constant boolean false.  <a href="#a455bb5e473e0686b5b027a51228c1af4">More...</a><br/></td></tr>
<tr class="separator:a455bb5e473e0686b5b027a51228c1af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791ad839fd91fa58b3c260b27be378be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a791ad839fd91fa58b3c260b27be378be">Halide::Internal::lossless_cast</a> (Type t, const Expr &amp;e)</td></tr>
<tr class="memdesc:a791ad839fd91fa58b3c260b27be378be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to cast an expression to a smaller type while provably not losing information.  <a href="#a791ad839fd91fa58b3c260b27be378be">More...</a><br/></td></tr>
<tr class="separator:a791ad839fd91fa58b3c260b27be378be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40a26aac941b763435e9915851cd073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Halide::Internal::match_types</a> (Expr &amp;a, Expr &amp;b)</td></tr>
<tr class="memdesc:ab40a26aac941b763435e9915851cd073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coerce the two expressions to have the same type, using C-style casting rules.  <a href="#ab40a26aac941b763435e9915851cd073">More...</a><br/></td></tr>
<tr class="separator:ab40a26aac941b763435e9915851cd073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7806bd8b912244542092d89b042f89a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7806bd8b912244542092d89b042f89a1">Halide::Internal::raise_to_integer_power</a> (const Expr &amp;a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b)</td></tr>
<tr class="memdesc:a7806bd8b912244542092d89b042f89a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise an expression to an integer power by repeatedly multiplying it by itself.  <a href="#a7806bd8b912244542092d89b042f89a1">More...</a><br/></td></tr>
<tr class="separator:a7806bd8b912244542092d89b042f89a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e118a634944f8286bb127887d902c26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1e118a634944f8286bb127887d902c26">Halide::Internal::split_into_ands</a> (const Expr &amp;cond, std::vector&lt; Expr &gt; &amp;result)</td></tr>
<tr class="memdesc:a1e118a634944f8286bb127887d902c26"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> a boolean condition into vector of ANDs.  <a href="#a1e118a634944f8286bb127887d902c26">More...</a><br/></td></tr>
<tr class="separator:a1e118a634944f8286bb127887d902c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e0f9bc767a073b8d23a4e6e310743a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a32e0f9bc767a073b8d23a4e6e310743a"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a32e0f9bc767a073b8d23a4e6e310743a">Halide::cast</a> (const Expr &amp;a)</td></tr>
<tr class="memdesc:a32e0f9bc767a073b8d23a4e6e310743a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to the halide type corresponding to the C++ type T.  <a href="#a32e0f9bc767a073b8d23a4e6e310743a">More...</a><br/></td></tr>
<tr class="separator:a32e0f9bc767a073b8d23a4e6e310743a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e54349ba8f18939b53d62e3ab16b15"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a81e54349ba8f18939b53d62e3ab16b15">Halide::cast</a> (Type t, const Expr &amp;a)</td></tr>
<tr class="memdesc:a81e54349ba8f18939b53d62e3ab16b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a new type.  <a href="#a81e54349ba8f18939b53d62e3ab16b15">More...</a><br/></td></tr>
<tr class="separator:a81e54349ba8f18939b53d62e3ab16b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db532b84ba55ff72555c4b427fc42bc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2db532b84ba55ff72555c4b427fc42bc">Halide::operator+</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a2db532b84ba55ff72555c4b427fc42bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a2db532b84ba55ff72555c4b427fc42bc">More...</a><br/></td></tr>
<tr class="separator:a2db532b84ba55ff72555c4b427fc42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3528931d7929d533103ada2badca092c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3528931d7929d533103ada2badca092c">Halide::operator||</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a3528931d7929d533103ada2badca092c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical or of the two arguments.  <a href="#a3528931d7929d533103ada2badca092c">More...</a><br/></td></tr>
<tr class="separator:a3528931d7929d533103ada2badca092c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33932cc875af3f36c5a98d7ca0dc204"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae33932cc875af3f36c5a98d7ca0dc204">Halide::operator!</a> (const Expr &amp;a)</td></tr>
<tr class="memdesc:ae33932cc875af3f36c5a98d7ca0dc204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical not the argument.  <a href="#ae33932cc875af3f36c5a98d7ca0dc204">More...</a><br/></td></tr>
<tr class="separator:ae33932cc875af3f36c5a98d7ca0dc204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a00cabb9f57b4cf5d101b2af338f5ec">Halide::max</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of the two arguments, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a9a00cabb9f57b4cf5d101b2af338f5ec">More...</a><br/></td></tr>
<tr class="separator:a9a00cabb9f57b4cf5d101b2af338f5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06295f379cf1fcd53e32764da3c63e42"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a06295f379cf1fcd53e32764da3c63e42">Halide::max</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a06295f379cf1fcd53e32764da3c63e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of an expression and a constant integer.  <a href="#a06295f379cf1fcd53e32764da3c63e42">More...</a><br/></td></tr>
<tr class="separator:a06295f379cf1fcd53e32764da3c63e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0d5d5b8b084b9bfedca2fc2c45cb9d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9c0d5d5b8b084b9bfedca2fc2c45cb9d">Halide::max</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a9c0d5d5b8b084b9bfedca2fc2c45cb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of a constant integer and an expression.  <a href="#a9c0d5d5b8b084b9bfedca2fc2c45cb9d">More...</a><br/></td></tr>
<tr class="separator:a9c0d5d5b8b084b9bfedca2fc2c45cb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69800ea539b08ccb15f49fbde6e56b8"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad69800ea539b08ccb15f49fbde6e56b8">Halide::max</a> (float a, const Expr &amp;b)</td></tr>
<tr class="separator:ad69800ea539b08ccb15f49fbde6e56b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3ea3402b51f8c0a702989504bd0fe0"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed3ea3402b51f8c0a702989504bd0fe0">Halide::max</a> (const Expr &amp;a, float b)</td></tr>
<tr class="separator:aed3ea3402b51f8c0a702989504bd0fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c91d2ad600665a46fda07c789efb25"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename... Rest, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Rest...&gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a85c91d2ad600665a46fda07c789efb25"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a85c91d2ad600665a46fda07c789efb25">Halide::max</a> (const A &amp;a, const B &amp;b, const C &amp;c, Rest &amp;&amp;...rest)</td></tr>
<tr class="memdesc:a85c91d2ad600665a46fda07c789efb25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the greater of an expressions vector, after doing any necessary type coersion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a85c91d2ad600665a46fda07c789efb25">More...</a><br/></td></tr>
<tr class="separator:a85c91d2ad600665a46fda07c789efb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b5db24ca379dda8241433c0014c940"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940">Halide::min</a> (Expr a, Expr b)</td></tr>
<tr class="separator:a38b5db24ca379dda8241433c0014c940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7bc96972ff65f8d834750f58cfe55b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8c7bc96972ff65f8d834750f58cfe55b">Halide::min</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a8c7bc96972ff65f8d834750f58cfe55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of an expression and a constant integer.  <a href="#a8c7bc96972ff65f8d834750f58cfe55b">More...</a><br/></td></tr>
<tr class="separator:a8c7bc96972ff65f8d834750f58cfe55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe10cd358d1740b01ad9eb0ebdaa857"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6fe10cd358d1740b01ad9eb0ebdaa857">Halide::min</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a6fe10cd358d1740b01ad9eb0ebdaa857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of a constant integer and an expression.  <a href="#a6fe10cd358d1740b01ad9eb0ebdaa857">More...</a><br/></td></tr>
<tr class="separator:a6fe10cd358d1740b01ad9eb0ebdaa857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ef4eafdd6d1476bce6fc1224fab39c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a96ef4eafdd6d1476bce6fc1224fab39c">Halide::min</a> (float a, const Expr &amp;b)</td></tr>
<tr class="separator:a96ef4eafdd6d1476bce6fc1224fab39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8170f9a194d6baf176d0c065e16ff956"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8170f9a194d6baf176d0c065e16ff956">Halide::min</a> (const Expr &amp;a, float b)</td></tr>
<tr class="separator:a8170f9a194d6baf176d0c065e16ff956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fed9cb5923d0111ccde75d4c973e124"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , typename C , typename... Rest, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Rest...&gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0fed9cb5923d0111ccde75d4c973e124"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0fed9cb5923d0111ccde75d4c973e124">Halide::min</a> (const A &amp;a, const B &amp;b, const C &amp;c, Rest &amp;&amp;...rest)</td></tr>
<tr class="memdesc:a0fed9cb5923d0111ccde75d4c973e124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression representing the lesser of an expressions vector, after doing any necessary type coersion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a0fed9cb5923d0111ccde75d4c973e124">More...</a><br/></td></tr>
<tr class="separator:a0fed9cb5923d0111ccde75d4c973e124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4080260a6e5e58124584d4929e57f2"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7f4080260a6e5e58124584d4929e57f2">Halide::clamp</a> (const Expr &amp;a, const Expr &amp;min_val, const Expr &amp;max_val)</td></tr>
<tr class="memdesc:a7f4080260a6e5e58124584d4929e57f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamps an expression to lie within the given bounds.  <a href="#a7f4080260a6e5e58124584d4929e57f2">More...</a><br/></td></tr>
<tr class="separator:a7f4080260a6e5e58124584d4929e57f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ecee3d4476e1110f3d0c34615db505"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a49ecee3d4476e1110f3d0c34615db505">Halide::abs</a> (const Expr &amp;a)</td></tr>
<tr class="memdesc:a49ecee3d4476e1110f3d0c34615db505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a signed integer or floating-point expression.  <a href="#a49ecee3d4476e1110f3d0c34615db505">More...</a><br/></td></tr>
<tr class="separator:a49ecee3d4476e1110f3d0c34615db505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d96f6e421c7a9a25f3d027283c7149d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d96f6e421c7a9a25f3d027283c7149d">Halide::absd</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a8d96f6e421c7a9a25f3d027283c7149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute difference between two values.  <a href="#a8d96f6e421c7a9a25f3d027283c7149d">More...</a><br/></td></tr>
<tr class="separator:a8d96f6e421c7a9a25f3d027283c7149d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6371892ae38e7eb681fd3f23945b06"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d6371892ae38e7eb681fd3f23945b06">Halide::select</a> (Expr condition, Expr true_value, Expr false_value)</td></tr>
<tr class="memdesc:a9d6371892ae38e7eb681fd3f23945b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an expression similar to the ternary operator in C, except that it always evaluates all arguments.  <a href="#a9d6371892ae38e7eb681fd3f23945b06">More...</a><br/></td></tr>
<tr class="separator:a9d6371892ae38e7eb681fd3f23945b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3122ac0d61fae507cc1d9ecd31a629f9"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Args...&gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3122ac0d61fae507cc1d9ecd31a629f9"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3122ac0d61fae507cc1d9ecd31a629f9">Halide::select</a> (const Expr &amp;c0, const Expr &amp;v0, const Expr &amp;c1, const Expr &amp;v1, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3122ac0d61fae507cc1d9ecd31a629f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-way variant of select similar to a switch statement in C, which can accept multiple conditions and values in pairs.  <a href="#a3122ac0d61fae507cc1d9ecd31a629f9">More...</a><br/></td></tr>
<tr class="separator:a3122ac0d61fae507cc1d9ecd31a629f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c9606de2699bc3b86f5839ad28fcc3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a84c9606de2699bc3b86f5839ad28fcc3">Halide::sin</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a84c9606de2699bc3b86f5839ad28fcc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of a floating-point expression.  <a href="#a84c9606de2699bc3b86f5839ad28fcc3">More...</a><br/></td></tr>
<tr class="separator:a84c9606de2699bc3b86f5839ad28fcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58238b4347136f6b74ab39528eee6271"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a58238b4347136f6b74ab39528eee6271">Halide::asin</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a58238b4347136f6b74ab39528eee6271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arcsine of a floating-point expression.  <a href="#a58238b4347136f6b74ab39528eee6271">More...</a><br/></td></tr>
<tr class="separator:a58238b4347136f6b74ab39528eee6271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac35f2180ac4e3267980fc215a66e7a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9ac35f2180ac4e3267980fc215a66e7a">Halide::cos</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a9ac35f2180ac4e3267980fc215a66e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of a floating-point expression.  <a href="#a9ac35f2180ac4e3267980fc215a66e7a">More...</a><br/></td></tr>
<tr class="separator:a9ac35f2180ac4e3267980fc215a66e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b073483ac152928127e9ff458ac247f"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8b073483ac152928127e9ff458ac247f">Halide::acos</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a8b073483ac152928127e9ff458ac247f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arccosine of a floating-point expression.  <a href="#a8b073483ac152928127e9ff458ac247f">More...</a><br/></td></tr>
<tr class="separator:a8b073483ac152928127e9ff458ac247f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c953a41d998a436f01c465fd16fdb41"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a2c953a41d998a436f01c465fd16fdb41">Halide::tan</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a2c953a41d998a436f01c465fd16fdb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of a floating-point expression.  <a href="#a2c953a41d998a436f01c465fd16fdb41">More...</a><br/></td></tr>
<tr class="separator:a2c953a41d998a436f01c465fd16fdb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57a12d04f648533aeec7339a21c73fd"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab57a12d04f648533aeec7339a21c73fd">Halide::atan</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:ab57a12d04f648533aeec7339a21c73fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arctangent of a floating-point expression.  <a href="#ab57a12d04f648533aeec7339a21c73fd">More...</a><br/></td></tr>
<tr class="separator:ab57a12d04f648533aeec7339a21c73fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5646de466ac31efd07ec5af1e4603cbf"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5646de466ac31efd07ec5af1e4603cbf">Halide::atan2</a> (Expr y, Expr x)</td></tr>
<tr class="memdesc:a5646de466ac31efd07ec5af1e4603cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the angle of a floating-point gradient.  <a href="#a5646de466ac31efd07ec5af1e4603cbf">More...</a><br/></td></tr>
<tr class="separator:a5646de466ac31efd07ec5af1e4603cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5853ea534fcf1914febf0d38b98e5b45"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5853ea534fcf1914febf0d38b98e5b45">Halide::sinh</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a5853ea534fcf1914febf0d38b98e5b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of a floating-point expression.  <a href="#a5853ea534fcf1914febf0d38b98e5b45">More...</a><br/></td></tr>
<tr class="separator:a5853ea534fcf1914febf0d38b98e5b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c8c54d38513c055be9f89b00b7c5cf"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab4c8c54d38513c055be9f89b00b7c5cf">Halide::asinh</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:ab4c8c54d38513c055be9f89b00b7c5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arcsinhe of a floating-point expression.  <a href="#ab4c8c54d38513c055be9f89b00b7c5cf">More...</a><br/></td></tr>
<tr class="separator:ab4c8c54d38513c055be9f89b00b7c5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfebf86d79f889d6490acc581a81beb"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#addfebf86d79f889d6490acc581a81beb">Halide::cosh</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:addfebf86d79f889d6490acc581a81beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of a floating-point expression.  <a href="#addfebf86d79f889d6490acc581a81beb">More...</a><br/></td></tr>
<tr class="separator:addfebf86d79f889d6490acc581a81beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1accccb8c2fc690468873a61d810746"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af1accccb8c2fc690468873a61d810746">Halide::acosh</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:af1accccb8c2fc690468873a61d810746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arccosine of a floating-point expression.  <a href="#af1accccb8c2fc690468873a61d810746">More...</a><br/></td></tr>
<tr class="separator:af1accccb8c2fc690468873a61d810746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8d49869f61ee8df5016216076d6f76"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc8d49869f61ee8df5016216076d6f76">Halide::tanh</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:abc8d49869f61ee8df5016216076d6f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of a floating-point expression.  <a href="#abc8d49869f61ee8df5016216076d6f76">More...</a><br/></td></tr>
<tr class="separator:abc8d49869f61ee8df5016216076d6f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd4128d3fd23fd6acaa272b9936c78b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8dd4128d3fd23fd6acaa272b9936c78b">Halide::atanh</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a8dd4128d3fd23fd6acaa272b9936c78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arctangent of a floating-point expression.  <a href="#a8dd4128d3fd23fd6acaa272b9936c78b">More...</a><br/></td></tr>
<tr class="separator:a8dd4128d3fd23fd6acaa272b9936c78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcddcb085754268ee16c0bef9a4da5b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a6bcddcb085754268ee16c0bef9a4da5b">Halide::sqrt</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a6bcddcb085754268ee16c0bef9a4da5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of a floating-point expression.  <a href="#a6bcddcb085754268ee16c0bef9a4da5b">More...</a><br/></td></tr>
<tr class="separator:a6bcddcb085754268ee16c0bef9a4da5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410c523b5f2f78733ca45d946a9ededb"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a410c523b5f2f78733ca45d946a9ededb">Halide::hypot</a> (const Expr &amp;x, const Expr &amp;y)</td></tr>
<tr class="memdesc:a410c523b5f2f78733ca45d946a9ededb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the sum of the squares of two floating-point expressions.  <a href="#a410c523b5f2f78733ca45d946a9ededb">More...</a><br/></td></tr>
<tr class="separator:a410c523b5f2f78733ca45d946a9ededb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb480bb85c86899c69956c3cc94b99b4"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aeb480bb85c86899c69956c3cc94b99b4">Halide::exp</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:aeb480bb85c86899c69956c3cc94b99b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponential of a floating-point expression.  <a href="#aeb480bb85c86899c69956c3cc94b99b4">More...</a><br/></td></tr>
<tr class="separator:aeb480bb85c86899c69956c3cc94b99b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25367f7ad616db9fcaabfb9897965007"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a25367f7ad616db9fcaabfb9897965007">Halide::log</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a25367f7ad616db9fcaabfb9897965007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logarithm of a floating-point expression.  <a href="#a25367f7ad616db9fcaabfb9897965007">More...</a><br/></td></tr>
<tr class="separator:a25367f7ad616db9fcaabfb9897965007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd83996070aa3e4bc3a102a654176fa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4dd83996070aa3e4bc3a102a654176fa">Halide::pow</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a4dd83996070aa3e4bc3a102a654176fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one floating point expression raised to the power of another.  <a href="#a4dd83996070aa3e4bc3a102a654176fa">More...</a><br/></td></tr>
<tr class="separator:a4dd83996070aa3e4bc3a102a654176fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc3e2a1e80bd2b512b38aa87aa91f9e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afcc3e2a1e80bd2b512b38aa87aa91f9e">Halide::erf</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:afcc3e2a1e80bd2b512b38aa87aa91f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the error function erf.  <a href="#afcc3e2a1e80bd2b512b38aa87aa91f9e">More...</a><br/></td></tr>
<tr class="separator:afcc3e2a1e80bd2b512b38aa87aa91f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac44eabecaebfbb5d9deaa72b392a23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0ac44eabecaebfbb5d9deaa72b392a23">Halide::fast_log</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a0ac44eabecaebfbb5d9deaa72b392a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable log for Float(32).  <a href="#a0ac44eabecaebfbb5d9deaa72b392a23">More...</a><br/></td></tr>
<tr class="separator:a0ac44eabecaebfbb5d9deaa72b392a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82745154d8ada93e8a02fdf01e82d0d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a82745154d8ada93e8a02fdf01e82d0d0">Halide::fast_exp</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a82745154d8ada93e8a02fdf01e82d0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable exp for Float(32).  <a href="#a82745154d8ada93e8a02fdf01e82d0d0">More...</a><br/></td></tr>
<tr class="separator:a82745154d8ada93e8a02fdf01e82d0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958457cd688f84d583779e649c9e52e6"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a958457cd688f84d583779e649c9e52e6">Halide::fast_pow</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a958457cd688f84d583779e649c9e52e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate cleanly vectorizable pow for Float(32).  <a href="#a958457cd688f84d583779e649c9e52e6">More...</a><br/></td></tr>
<tr class="separator:a958457cd688f84d583779e649c9e52e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a46cc3af832aa53d260aaad14b4f41"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac3a46cc3af832aa53d260aaad14b4f41">Halide::fast_inverse</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:ac3a46cc3af832aa53d260aaad14b4f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate inverse for Float(32).  <a href="#ac3a46cc3af832aa53d260aaad14b4f41">More...</a><br/></td></tr>
<tr class="separator:ac3a46cc3af832aa53d260aaad14b4f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1925249eb381d5359921b9f0edecb5cb"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1925249eb381d5359921b9f0edecb5cb">Halide::fast_inverse_sqrt</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a1925249eb381d5359921b9f0edecb5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast approximate inverse square root for Float(32).  <a href="#a1925249eb381d5359921b9f0edecb5cb">More...</a><br/></td></tr>
<tr class="separator:a1925249eb381d5359921b9f0edecb5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9c338f7cd169dfc4063275bafa81c7"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3f9c338f7cd169dfc4063275bafa81c7">Halide::floor</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a3f9c338f7cd169dfc4063275bafa81c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest whole number less than or equal to a floating-point expression.  <a href="#a3f9c338f7cd169dfc4063275bafa81c7">More...</a><br/></td></tr>
<tr class="separator:a3f9c338f7cd169dfc4063275bafa81c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2db0cd0e1fbfc37929e84d33e915667"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af2db0cd0e1fbfc37929e84d33e915667">Halide::ceil</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:af2db0cd0e1fbfc37929e84d33e915667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least whole number greater than or equal to a floating-point expression.  <a href="#af2db0cd0e1fbfc37929e84d33e915667">More...</a><br/></td></tr>
<tr class="separator:af2db0cd0e1fbfc37929e84d33e915667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41b2087a30c1486e61d1ef41243baf0"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad41b2087a30c1486e61d1ef41243baf0">Halide::round</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:ad41b2087a30c1486e61d1ef41243baf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the whole number closest to a floating-point expression.  <a href="#ad41b2087a30c1486e61d1ef41243baf0">More...</a><br/></td></tr>
<tr class="separator:ad41b2087a30c1486e61d1ef41243baf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419e6dc454d1d5a9f28b87e3eb4be564"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a419e6dc454d1d5a9f28b87e3eb4be564">Halide::trunc</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a419e6dc454d1d5a9f28b87e3eb4be564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the integer part of a floating-point expression.  <a href="#a419e6dc454d1d5a9f28b87e3eb4be564">More...</a><br/></td></tr>
<tr class="separator:a419e6dc454d1d5a9f28b87e3eb4be564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198a4c3df413461e30d9021d2d1d6953"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a198a4c3df413461e30d9021d2d1d6953">Halide::is_nan</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a198a4c3df413461e30d9021d2d1d6953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the argument is a Not a Number (NaN).  <a href="#a198a4c3df413461e30d9021d2d1d6953">More...</a><br/></td></tr>
<tr class="separator:a198a4c3df413461e30d9021d2d1d6953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e72ac620ae5d7944f8b15244ec5e32"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a18e72ac620ae5d7944f8b15244ec5e32">Halide::fract</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a18e72ac620ae5d7944f8b15244ec5e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fractional part of a floating-point expression.  <a href="#a18e72ac620ae5d7944f8b15244ec5e32">More...</a><br/></td></tr>
<tr class="separator:a18e72ac620ae5d7944f8b15244ec5e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b947ea4091789b5dfdef16c393c944"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a75b947ea4091789b5dfdef16c393c944">Halide::reinterpret</a> (Type t, const Expr &amp;e)</td></tr>
<tr class="memdesc:a75b947ea4091789b5dfdef16c393c944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinterpret the bits of one value as another type.  <a href="#a75b947ea4091789b5dfdef16c393c944">More...</a><br/></td></tr>
<tr class="separator:a75b947ea4091789b5dfdef16c393c944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec84788cec2cdd957cf5f50b479174d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec84788cec2cdd957cf5f50b479174d1"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aec84788cec2cdd957cf5f50b479174d1">Halide::reinterpret</a> (const Expr &amp;e)</td></tr>
<tr class="separator:aec84788cec2cdd957cf5f50b479174d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec8e49b0b42230077ee6bdca669d299"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4ec8e49b0b42230077ee6bdca669d299">Halide::operator&amp;</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a4ec8e49b0b42230077ee6bdca669d299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise and of two expressions (which need not have the same type).  <a href="#a4ec8e49b0b42230077ee6bdca669d299">More...</a><br/></td></tr>
<tr class="separator:a4ec8e49b0b42230077ee6bdca669d299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8bec8d2f6194f4db7b88e554173f05"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abe8bec8d2f6194f4db7b88e554173f05">Halide::operator|</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:abe8bec8d2f6194f4db7b88e554173f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise or of two expressions (which need not have the same type).  <a href="#abe8bec8d2f6194f4db7b88e554173f05">More...</a><br/></td></tr>
<tr class="separator:abe8bec8d2f6194f4db7b88e554173f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdde4dd479f4eb59631e09148897ad2a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#afdde4dd479f4eb59631e09148897ad2a">Halide::operator^</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:afdde4dd479f4eb59631e09148897ad2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise exclusive or of two expressions (which need not have the same type).  <a href="#afdde4dd479f4eb59631e09148897ad2a">More...</a><br/></td></tr>
<tr class="separator:afdde4dd479f4eb59631e09148897ad2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3f63c9386ddcbf3fd50efd74e76197"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aaa3f63c9386ddcbf3fd50efd74e76197">Halide::operator~</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:aaa3f63c9386ddcbf3fd50efd74e76197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bitwise not of an expression.  <a href="#aaa3f63c9386ddcbf3fd50efd74e76197">More...</a><br/></td></tr>
<tr class="separator:aaa3f63c9386ddcbf3fd50efd74e76197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55158f5f229510194c425dfae256d530"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a55158f5f229510194c425dfae256d530">Halide::lerp</a> (Expr zero_val, Expr one_val, Expr weight)</td></tr>
<tr class="memdesc:a55158f5f229510194c425dfae256d530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolate between the two values according to a weight.  <a href="#a55158f5f229510194c425dfae256d530">More...</a><br/></td></tr>
<tr class="separator:a55158f5f229510194c425dfae256d530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333301d1027a9ce80e5aaf4dd2d012de"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a333301d1027a9ce80e5aaf4dd2d012de">Halide::popcount</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a333301d1027a9ce80e5aaf4dd2d012de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of set bits in an expression.  <a href="#a333301d1027a9ce80e5aaf4dd2d012de">More...</a><br/></td></tr>
<tr class="separator:a333301d1027a9ce80e5aaf4dd2d012de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86cce05d686ab4194e7617051d6a0d6"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa86cce05d686ab4194e7617051d6a0d6">Halide::count_leading_zeros</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:aa86cce05d686ab4194e7617051d6a0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of leading zero bits in an expression.  <a href="#aa86cce05d686ab4194e7617051d6a0d6">More...</a><br/></td></tr>
<tr class="separator:aa86cce05d686ab4194e7617051d6a0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1a18676ae8f9a8f6ed1d69c7f36a34"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0d1a18676ae8f9a8f6ed1d69c7f36a34">Halide::count_trailing_zeros</a> (const Expr &amp;x)</td></tr>
<tr class="memdesc:a0d1a18676ae8f9a8f6ed1d69c7f36a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of trailing zero bits in an expression.  <a href="#a0d1a18676ae8f9a8f6ed1d69c7f36a34">More...</a><br/></td></tr>
<tr class="separator:a0d1a18676ae8f9a8f6ed1d69c7f36a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6e12242ab5a192bdaa953510ae95bf"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed6e12242ab5a192bdaa953510ae95bf">Halide::div_round_to_zero</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:aed6e12242ab5a192bdaa953510ae95bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide two integers, rounding towards zero.  <a href="#aed6e12242ab5a192bdaa953510ae95bf">More...</a><br/></td></tr>
<tr class="separator:aed6e12242ab5a192bdaa953510ae95bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0456fd6414e279eb3afdecf53eb8af8"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab0456fd6414e279eb3afdecf53eb8af8">Halide::mod_round_to_zero</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:ab0456fd6414e279eb3afdecf53eb8af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the remainder of dividing two integers, when division is rounding toward zero.  <a href="#ab0456fd6414e279eb3afdecf53eb8af8">More...</a><br/></td></tr>
<tr class="separator:ab0456fd6414e279eb3afdecf53eb8af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9976936558b192883919774b25ede17"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa9976936558b192883919774b25ede17">Halide::random_float</a> (const Expr &amp;seed=Expr())</td></tr>
<tr class="memdesc:aa9976936558b192883919774b25ede17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed float in the half-open interval [0.0f, 1.0f).  <a href="#aa9976936558b192883919774b25ede17">More...</a><br/></td></tr>
<tr class="separator:aa9976936558b192883919774b25ede17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eac10fd97e575926efd462316a768a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a99eac10fd97e575926efd462316a768a">Halide::random_uint</a> (const Expr &amp;seed=Expr())</td></tr>
<tr class="memdesc:a99eac10fd97e575926efd462316a768a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed unsigned 32-bit integer.  <a href="#a99eac10fd97e575926efd462316a768a">More...</a><br/></td></tr>
<tr class="separator:a99eac10fd97e575926efd462316a768a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e461f1b1b8cd7d2e0d4f857356f0a8"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a11e461f1b1b8cd7d2e0d4f857356f0a8">Halide::random_int</a> (const Expr &amp;seed=Expr())</td></tr>
<tr class="memdesc:a11e461f1b1b8cd7d2e0d4f857356f0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random variable representing a uniformly distributed 32-bit integer.  <a href="#a11e461f1b1b8cd7d2e0d4f857356f0a8">More...</a><br/></td></tr>
<tr class="separator:a11e461f1b1b8cd7d2e0d4f857356f0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b821cbe0e228fd5036e9fb1ed693184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7b821cbe0e228fd5036e9fb1ed693184">Halide::Internal::collect_print_args</a> (std::vector&lt; Expr &gt; &amp;args)</td></tr>
<tr class="separator:a7b821cbe0e228fd5036e9fb1ed693184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa081b03ea688ae0e09ac4c5d77aff33b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa081b03ea688ae0e09ac4c5d77aff33b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa081b03ea688ae0e09ac4c5d77aff33b">Halide::Internal::collect_print_args</a> (std::vector&lt; Expr &gt; &amp;args, const char *arg, Args &amp;&amp;...more_args)</td></tr>
<tr class="separator:aa081b03ea688ae0e09ac4c5d77aff33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8ac0286e5c5add6c18d4b57bdf7f80"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abb8ac0286e5c5add6c18d4b57bdf7f80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#abb8ac0286e5c5add6c18d4b57bdf7f80">Halide::Internal::collect_print_args</a> (std::vector&lt; Expr &gt; &amp;args, const Expr &amp;arg, Args &amp;&amp;...more_args)</td></tr>
<tr class="separator:abb8ac0286e5c5add6c18d4b57bdf7f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9389bcacbed602df70eae94826312e03"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9389bcacbed602df70eae94826312e03">Halide::undef</a> (Type t)</td></tr>
<tr class="memdesc:a9389bcacbed602df70eae94826312e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an undef value of the given type.  <a href="#a9389bcacbed602df70eae94826312e03">More...</a><br/></td></tr>
<tr class="separator:a9389bcacbed602df70eae94826312e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f29c5417077b940483e88cc9c1c74b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4f29c5417077b940483e88cc9c1c74b2"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4f29c5417077b940483e88cc9c1c74b2">Halide::undef</a> ()</td></tr>
<tr class="separator:a4f29c5417077b940483e88cc9c1c74b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3342e1e6061bdbc8d0df9fa791b7a83b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a3342e1e6061bdbc8d0df9fa791b7a83b">Halide::Internal::memoize_tag_helper</a> (const Expr &amp;result, const std::vector&lt; Expr &gt; &amp;cache_key_values)</td></tr>
<tr class="separator:a3342e1e6061bdbc8d0df9fa791b7a83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4fe67cf4bedf2d2c7aaffb1d9f8a26"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9f4fe67cf4bedf2d2c7aaffb1d9f8a26">Halide::likely</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a9f4fe67cf4bedf2d2c7aaffb1d9f8a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expressions tagged with this intrinsic are considered to be part of the steady state of some loop with a nasty beginning and end (e.g.  <a href="#a9f4fe67cf4bedf2d2c7aaffb1d9f8a26">More...</a><br/></td></tr>
<tr class="separator:a9f4fe67cf4bedf2d2c7aaffb1d9f8a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882f4e18f4d3f1de65033f5a2e1aaf2e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a882f4e18f4d3f1de65033f5a2e1aaf2e">Halide::likely_if_innermost</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a882f4e18f4d3f1de65033f5a2e1aaf2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to likely, but only triggers a loop partitioning if found in an innermost loop.  <a href="#a882f4e18f4d3f1de65033f5a2e1aaf2e">More...</a><br/></td></tr>
<tr class="separator:a882f4e18f4d3f1de65033f5a2e1aaf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531125d95b59aa46fa75316c823a4011"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a531125d95b59aa46fa75316c823a4011"><td class="memTemplItemLeft" align="right" valign="top">Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a531125d95b59aa46fa75316c823a4011">Halide::saturating_cast</a> (const Expr &amp;e)</td></tr>
<tr class="memdesc:a531125d95b59aa46fa75316c823a4011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to the halide type corresponding to the C++ type T clamping to the minimum and maximum values of the result type.  <a href="#a531125d95b59aa46fa75316c823a4011">More...</a><br/></td></tr>
<tr class="separator:a531125d95b59aa46fa75316c823a4011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae901c705ecd11c61727b8360f655b905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae901c705ecd11c61727b8360f655b905">Halide::saturating_cast</a> (Type t, Expr e)</td></tr>
<tr class="memdesc:ae901c705ecd11c61727b8360f655b905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a new type, clamping to the minimum and maximum values of the result type.  <a href="#ae901c705ecd11c61727b8360f655b905">More...</a><br/></td></tr>
<tr class="separator:ae901c705ecd11c61727b8360f655b905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aff2e2c3b53edabca8089670422959e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aff2e2c3b53edabca8089670422959e18">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> val)</td></tr>
<tr class="memdesc:aff2e2c3b53edabca8089670422959e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#aff2e2c3b53edabca8089670422959e18">More...</a><br/></td></tr>
<tr class="separator:aff2e2c3b53edabca8089670422959e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4212797e9dcc4a1a3577c6e6475832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a7e4212797e9dcc4a1a3577c6e6475832">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> val)</td></tr>
<tr class="memdesc:a7e4212797e9dcc4a1a3577c6e6475832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a7e4212797e9dcc4a1a3577c6e6475832">More...</a><br/></td></tr>
<tr class="separator:a7e4212797e9dcc4a1a3577c6e6475832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ec777cbfe66e5a592adf1eea14ec64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ab4ec777cbfe66e5a592adf1eea14ec64">Halide::Internal::make_const</a> (Type t, double val)</td></tr>
<tr class="memdesc:ab4ec777cbfe66e5a592adf1eea14ec64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#ab4ec777cbfe66e5a592adf1eea14ec64">More...</a><br/></td></tr>
<tr class="separator:ab4ec777cbfe66e5a592adf1eea14ec64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aaae8ca905f0ce9cde74cc0897a61c4e7">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> val)</td></tr>
<tr class="memdesc:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#aaae8ca905f0ce9cde74cc0897a61c4e7">More...</a><br/></td></tr>
<tr class="separator:aaae8ca905f0ce9cde74cc0897a61c4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b64c00a450c92807011cdc02f8b29b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a70b64c00a450c92807011cdc02f8b29b">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> val)</td></tr>
<tr class="memdesc:a70b64c00a450c92807011cdc02f8b29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a70b64c00a450c92807011cdc02f8b29b">More...</a><br/></td></tr>
<tr class="separator:a70b64c00a450c92807011cdc02f8b29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df9ef655a78f9fb233fa0322525496c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a4df9ef655a78f9fb233fa0322525496c">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#ac124c451b40871e78c16cb36581022ae">int16_t</a> val)</td></tr>
<tr class="memdesc:a4df9ef655a78f9fb233fa0322525496c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a4df9ef655a78f9fb233fa0322525496c">More...</a><br/></td></tr>
<tr class="separator:a4df9ef655a78f9fb233fa0322525496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#af14e2dade91eb04482b4b5ffdfc920dd">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a84a4932f569742629ef4f07564b74de9">uint16_t</a> val)</td></tr>
<tr class="memdesc:af14e2dade91eb04482b4b5ffdfc920dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#af14e2dade91eb04482b4b5ffdfc920dd">More...</a><br/></td></tr>
<tr class="separator:af14e2dade91eb04482b4b5ffdfc920dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a5231b80b8e1a7904cdd4fcac7b89a98d">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#acfd957407fbe865fe77f6fdf86818f5e">int8_t</a> val)</td></tr>
<tr class="memdesc:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a5231b80b8e1a7904cdd4fcac7b89a98d">More...</a><br/></td></tr>
<tr class="separator:a5231b80b8e1a7904cdd4fcac7b89a98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ae9a1ece36d20a64a59c92bf7f8c4e9aa">Halide::Internal::make_const</a> (Type t, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> val)</td></tr>
<tr class="memdesc:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#ae9a1ece36d20a64a59c92bf7f8c4e9aa">More...</a><br/></td></tr>
<tr class="separator:ae9a1ece36d20a64a59c92bf7f8c4e9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#addbd965eccbcfc1f5b80eaa0607f698c">Halide::Internal::make_const</a> (Type t, bool val)</td></tr>
<tr class="memdesc:addbd965eccbcfc1f5b80eaa0607f698c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#addbd965eccbcfc1f5b80eaa0607f698c">More...</a><br/></td></tr>
<tr class="separator:addbd965eccbcfc1f5b80eaa0607f698c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90929bcfb18413ffd527152bb8580de"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#aa90929bcfb18413ffd527152bb8580de">Halide::Internal::make_const</a> (Type t, float val)</td></tr>
<tr class="memdesc:aa90929bcfb18413ffd527152bb8580de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#aa90929bcfb18413ffd527152bb8580de">More...</a><br/></td></tr>
<tr class="separator:aa90929bcfb18413ffd527152bb8580de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592ef00a06a1d8f017b48359099c16d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a6592ef00a06a1d8f017b48359099c16d">Halide::Internal::make_const</a> (Type t, float16_t val)</td></tr>
<tr class="memdesc:a6592ef00a06a1d8f017b48359099c16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an immediate of the given type from any numeric C++ type.  <a href="#a6592ef00a06a1d8f017b48359099c16d">More...</a><br/></td></tr>
<tr class="separator:a6592ef00a06a1d8f017b48359099c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0ac59a183030cc11800cf2ebcf192093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a0ac59a183030cc11800cf2ebcf192093">Halide::Internal::halide_log</a> (const Expr &amp;a)</td></tr>
<tr class="memdesc:a0ac59a183030cc11800cf2ebcf192093"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals.  <a href="#a0ac59a183030cc11800cf2ebcf192093">More...</a><br/></td></tr>
<tr class="separator:a0ac59a183030cc11800cf2ebcf192093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad998a858166866466126d50e6ed579db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad998a858166866466126d50e6ed579db">Halide::Internal::halide_exp</a> (const Expr &amp;a)</td></tr>
<tr class="memdesc:ad998a858166866466126d50e6ed579db"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals.  <a href="#ad998a858166866466126d50e6ed579db">More...</a><br/></td></tr>
<tr class="separator:ad998a858166866466126d50e6ed579db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace49e66a1e7cf9f4d509a2eaaf79ab0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ace49e66a1e7cf9f4d509a2eaaf79ab0a">Halide::Internal::halide_erf</a> (const Expr &amp;a)</td></tr>
<tr class="memdesc:ace49e66a1e7cf9f4d509a2eaaf79ab0a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a>'s vectorizable transcendentals.  <a href="#ace49e66a1e7cf9f4d509a2eaaf79ab0a">More...</a><br/></td></tr>
<tr class="separator:ace49e66a1e7cf9f4d509a2eaaf79ab0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af96d00d3063817189a942d9b20c0bba7"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af96d00d3063817189a942d9b20c0bba7">Halide::operator+</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:af96d00d3063817189a942d9b20c0bba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an expression and a constant integer.  <a href="#af96d00d3063817189a942d9b20c0bba7">More...</a><br/></td></tr>
<tr class="separator:af96d00d3063817189a942d9b20c0bba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44320dce088e37d192d298583710aa9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad44320dce088e37d192d298583710aa9">Halide::operator+</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:ad44320dce088e37d192d298583710aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constant integer and an expression.  <a href="#ad44320dce088e37d192d298583710aa9">More...</a><br/></td></tr>
<tr class="separator:ad44320dce088e37d192d298583710aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68271e379833d837454bbfb77d400dd6"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a68271e379833d837454bbfb77d400dd6">Halide::operator+=</a> (Expr &amp;a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a68271e379833d837454bbfb77d400dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the sum of two expressions, without changing its type.  <a href="#a68271e379833d837454bbfb77d400dd6">More...</a><br/></td></tr>
<tr class="separator:a68271e379833d837454bbfb77d400dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f3eb27005363158ca0e934811c98ed"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a86f3eb27005363158ca0e934811c98ed">Halide::operator-</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a86f3eb27005363158ca0e934811c98ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a86f3eb27005363158ca0e934811c98ed">More...</a><br/></td></tr>
<tr class="separator:a86f3eb27005363158ca0e934811c98ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec092538145160679bb8ee938a236bb"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7ec092538145160679bb8ee938a236bb">Halide::operator-</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a7ec092538145160679bb8ee938a236bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a constant integer from an expression.  <a href="#a7ec092538145160679bb8ee938a236bb">More...</a><br/></td></tr>
<tr class="separator:a7ec092538145160679bb8ee938a236bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5421f4d6b614e93aa0e99e850d4c62fc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5421f4d6b614e93aa0e99e850d4c62fc">Halide::operator-</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a5421f4d6b614e93aa0e99e850d4c62fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts an expression from a constant integer.  <a href="#a5421f4d6b614e93aa0e99e850d4c62fc">More...</a><br/></td></tr>
<tr class="separator:a5421f4d6b614e93aa0e99e850d4c62fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3705bdc0737ed9741372d3b10cfc99"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a3705bdc0737ed9741372d3b10cfc99">Halide::operator-</a> (const Expr &amp;a)</td></tr>
<tr class="memdesc:a9a3705bdc0737ed9741372d3b10cfc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negative of the argument.  <a href="#a9a3705bdc0737ed9741372d3b10cfc99">More...</a><br/></td></tr>
<tr class="separator:a9a3705bdc0737ed9741372d3b10cfc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd9675106bf625b230c608d0f96cbbb"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#accd9675106bf625b230c608d0f96cbbb">Halide::operator-=</a> (Expr &amp;a, const Expr &amp;b)</td></tr>
<tr class="memdesc:accd9675106bf625b230c608d0f96cbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the difference of two expressions, without changing its type.  <a href="#accd9675106bf625b230c608d0f96cbbb">More...</a><br/></td></tr>
<tr class="separator:accd9675106bf625b230c608d0f96cbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908c6748ab34a4a66274b196b6900af5"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a908c6748ab34a4a66274b196b6900af5">Halide::operator*</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a908c6748ab34a4a66274b196b6900af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a908c6748ab34a4a66274b196b6900af5">More...</a><br/></td></tr>
<tr class="separator:a908c6748ab34a4a66274b196b6900af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a62e39c7b218f40a143d8caf4121e3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a64a62e39c7b218f40a143d8caf4121e3">Halide::operator*</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a64a62e39c7b218f40a143d8caf4121e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an expression and a constant integer.  <a href="#a64a62e39c7b218f40a143d8caf4121e3">More...</a><br/></td></tr>
<tr class="separator:a64a62e39c7b218f40a143d8caf4121e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88c550972b22570a091c503a0a3e55d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab88c550972b22570a091c503a0a3e55d">Halide::operator*</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:ab88c550972b22570a091c503a0a3e55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a constant integer and an expression.  <a href="#ab88c550972b22570a091c503a0a3e55d">More...</a><br/></td></tr>
<tr class="separator:ab88c550972b22570a091c503a0a3e55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a762226b403dc8e5babbd3c1abbcb5"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a54a762226b403dc8e5babbd3c1abbcb5">Halide::operator*=</a> (Expr &amp;a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a54a762226b403dc8e5babbd3c1abbcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the product of two expressions, without changing its type.  <a href="#a54a762226b403dc8e5babbd3c1abbcb5">More...</a><br/></td></tr>
<tr class="separator:a54a762226b403dc8e5babbd3c1abbcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a73e12ddd6395e3a1c1286e2e3c51e675">Halide::operator/</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ratio of two expressions, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a73e12ddd6395e3a1c1286e2e3c51e675">More...</a><br/></td></tr>
<tr class="separator:a73e12ddd6395e3a1c1286e2e3c51e675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9020fc4d1f72b02a72c29cb194c0a971"><td class="memItemLeft" align="right" valign="top">Expr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9020fc4d1f72b02a72c29cb194c0a971">Halide::operator/=</a> (Expr &amp;a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a9020fc4d1f72b02a72c29cb194c0a971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the first expression to be the ratio of two expressions, without changing its type.  <a href="#a9020fc4d1f72b02a72c29cb194c0a971">More...</a><br/></td></tr>
<tr class="separator:a9020fc4d1f72b02a72c29cb194c0a971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b46ceb896f15e54e7235a7e88824e7"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac4b46ceb896f15e54e7235a7e88824e7">Halide::operator/</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:ac4b46ceb896f15e54e7235a7e88824e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides an expression by a constant integer.  <a href="#ac4b46ceb896f15e54e7235a7e88824e7">More...</a><br/></td></tr>
<tr class="separator:ac4b46ceb896f15e54e7235a7e88824e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5af2c0952b56b148c8d722b5c72e53b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa5af2c0952b56b148c8d722b5c72e53b">Halide::operator/</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:aa5af2c0952b56b148c8d722b5c72e53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides a constant integer by an expression.  <a href="#aa5af2c0952b56b148c8d722b5c72e53b">More...</a><br/></td></tr>
<tr class="separator:aa5af2c0952b56b148c8d722b5c72e53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc191ed3318e2072d18f42d11f5b01d4"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abc191ed3318e2072d18f42d11f5b01d4">Halide::operator%</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abc191ed3318e2072d18f42d11f5b01d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument reduced modulo the second, doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#abc191ed3318e2072d18f42d11f5b01d4">More...</a><br/></td></tr>
<tr class="separator:abc191ed3318e2072d18f42d11f5b01d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1407d07ccaa519c88ae0a0fecfc585d3"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1407d07ccaa519c88ae0a0fecfc585d3">Halide::operator%</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a1407d07ccaa519c88ae0a0fecfc585d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mods an expression by a constant integer.  <a href="#a1407d07ccaa519c88ae0a0fecfc585d3">More...</a><br/></td></tr>
<tr class="separator:a1407d07ccaa519c88ae0a0fecfc585d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5726a49d7bfaec36cbaca2a5004ddc"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aed5726a49d7bfaec36cbaca2a5004ddc">Halide::operator%</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:aed5726a49d7bfaec36cbaca2a5004ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mods a constant integer by an expression.  <a href="#aed5726a49d7bfaec36cbaca2a5004ddc">More...</a><br/></td></tr>
<tr class="separator:aed5726a49d7bfaec36cbaca2a5004ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9105ae9f0995f450825e522170f5d1e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af9105ae9f0995f450825e522170f5d1e">Halide::operator&gt;</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:af9105ae9f0995f450825e522170f5d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#af9105ae9f0995f450825e522170f5d1e">More...</a><br/></td></tr>
<tr class="separator:af9105ae9f0995f450825e522170f5d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ee53e7c20d686622a1de2b2e85c7e9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a11ee53e7c20d686622a1de2b2e85c7e9">Halide::operator&gt;</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a11ee53e7c20d686622a1de2b2e85c7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is greater than a constant integer.  <a href="#a11ee53e7c20d686622a1de2b2e85c7e9">More...</a><br/></td></tr>
<tr class="separator:a11ee53e7c20d686622a1de2b2e85c7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78846911fcacf88548dd1379728ffbc6"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a78846911fcacf88548dd1379728ffbc6">Halide::operator&gt;</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a78846911fcacf88548dd1379728ffbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is greater than an expression.  <a href="#a78846911fcacf88548dd1379728ffbc6">More...</a><br/></td></tr>
<tr class="separator:a78846911fcacf88548dd1379728ffbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbad5ee20448455260670dec22c76a21"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abbad5ee20448455260670dec22c76a21">Halide::operator&lt;</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abbad5ee20448455260670dec22c76a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#abbad5ee20448455260670dec22c76a21">More...</a><br/></td></tr>
<tr class="separator:abbad5ee20448455260670dec22c76a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476f89d47c1727ea5490e00b78343a05"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a476f89d47c1727ea5490e00b78343a05">Halide::operator&lt;</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a476f89d47c1727ea5490e00b78343a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is less than a constant integer.  <a href="#a476f89d47c1727ea5490e00b78343a05">More...</a><br/></td></tr>
<tr class="separator:a476f89d47c1727ea5490e00b78343a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab735e98d4a2f77cb67aad27e0d8b7415"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab735e98d4a2f77cb67aad27e0d8b7415">Halide::operator&lt;</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:ab735e98d4a2f77cb67aad27e0d8b7415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is less than an expression.  <a href="#ab735e98d4a2f77cb67aad27e0d8b7415">More...</a><br/></td></tr>
<tr class="separator:ab735e98d4a2f77cb67aad27e0d8b7415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad297e6fa5deb0ba4e8ad7fe344629706">Halide::operator&lt;=</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is less than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#ad297e6fa5deb0ba4e8ad7fe344629706">More...</a><br/></td></tr>
<tr class="separator:ad297e6fa5deb0ba4e8ad7fe344629706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4258718a2221d5b7b5593f57485cb4ba"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4258718a2221d5b7b5593f57485cb4ba">Halide::operator&lt;=</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a4258718a2221d5b7b5593f57485cb4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is less than or equal to a constant integer.  <a href="#a4258718a2221d5b7b5593f57485cb4ba">More...</a><br/></td></tr>
<tr class="separator:a4258718a2221d5b7b5593f57485cb4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab805d7e9dd2a9061ffeefae6b6c2d506"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab805d7e9dd2a9061ffeefae6b6c2d506">Halide::operator&lt;=</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:ab805d7e9dd2a9061ffeefae6b6c2d506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is less than or equal to an expression.  <a href="#ab805d7e9dd2a9061ffeefae6b6c2d506">More...</a><br/></td></tr>
<tr class="separator:ab805d7e9dd2a9061ffeefae6b6c2d506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8f2e815b9cc7475802c0fb6a7e7ae6ae">Halide::operator&gt;=</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is greater than or equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a8f2e815b9cc7475802c0fb6a7e7ae6ae">More...</a><br/></td></tr>
<tr class="separator:a8f2e815b9cc7475802c0fb6a7e7ae6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc55d0783c46ace37a0b413d82dd100"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9fc55d0783c46ace37a0b413d82dd100">Halide::operator&gt;=</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a9fc55d0783c46ace37a0b413d82dd100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is greater than or equal to a constant integer.  <a href="#a9fc55d0783c46ace37a0b413d82dd100">More...</a><br/></td></tr>
<tr class="separator:a9fc55d0783c46ace37a0b413d82dd100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977de0ab82ad7e0ac7d4c6321554d6c9"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a977de0ab82ad7e0ac7d4c6321554d6c9">Halide::operator&gt;=</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a977de0ab82ad7e0ac7d4c6321554d6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is greater than or equal to an expression.  <a href="#a977de0ab82ad7e0ac7d4c6321554d6c9">More...</a><br/></td></tr>
<tr class="separator:a977de0ab82ad7e0ac7d4c6321554d6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abfbbb2e5820938f4d8f0a8b2324776df">Halide::operator==</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:abfbbb2e5820938f4d8f0a8b2324776df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#abfbbb2e5820938f4d8f0a8b2324776df">More...</a><br/></td></tr>
<tr class="separator:abfbbb2e5820938f4d8f0a8b2324776df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1912cec1a901275d8c047daa5b3ba731"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a1912cec1a901275d8c047daa5b3ba731">Halide::operator==</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a1912cec1a901275d8c047daa5b3ba731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is equal to a constant integer.  <a href="#a1912cec1a901275d8c047daa5b3ba731">More...</a><br/></td></tr>
<tr class="separator:a1912cec1a901275d8c047daa5b3ba731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74920ea4bf924202745669447a8a97ce"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a74920ea4bf924202745669447a8a97ce">Halide::operator==</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a74920ea4bf924202745669447a8a97ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is equal to an expression.  <a href="#a74920ea4bf924202745669447a8a97ce">More...</a><br/></td></tr>
<tr class="separator:a74920ea4bf924202745669447a8a97ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3d11c86964dbb2586103744cac1614"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8d3d11c86964dbb2586103744cac1614">Halide::operator!=</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a8d3d11c86964dbb2586103744cac1614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether the first argument is not equal to the second, after doing any necessary type coercion using <a class="el" href="namespace_halide_1_1_internal.html#ab40a26aac941b763435e9915851cd073">Internal::match_types</a>.  <a href="#a8d3d11c86964dbb2586103744cac1614">More...</a><br/></td></tr>
<tr class="separator:a8d3d11c86964dbb2586103744cac1614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99758b0c2c281af30636590e59d49e25"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a99758b0c2c281af30636590e59d49e25">Halide::operator!=</a> (const Expr &amp;a, int b)</td></tr>
<tr class="memdesc:a99758b0c2c281af30636590e59d49e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether an expression is not equal to a constant integer.  <a href="#a99758b0c2c281af30636590e59d49e25">More...</a><br/></td></tr>
<tr class="separator:a99758b0c2c281af30636590e59d49e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37046e3ff33026d40087d1a226eba901"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a37046e3ff33026d40087d1a226eba901">Halide::operator!=</a> (int a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a37046e3ff33026d40087d1a226eba901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a boolean expression that tests whether a constant integer is not equal to an expression.  <a href="#a37046e3ff33026d40087d1a226eba901">More...</a><br/></td></tr>
<tr class="separator:a37046e3ff33026d40087d1a226eba901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df159d6ed5236cc8e02d04bf72be4f"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a02df159d6ed5236cc8e02d04bf72be4f">Halide::operator&amp;&amp;</a> (Expr a, Expr b)</td></tr>
<tr class="memdesc:a02df159d6ed5236cc8e02d04bf72be4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logical and of the two arguments.  <a href="#a02df159d6ed5236cc8e02d04bf72be4f">More...</a><br/></td></tr>
<tr class="separator:a02df159d6ed5236cc8e02d04bf72be4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacad90a5a6d0d28775434cdf7b331213"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aacad90a5a6d0d28775434cdf7b331213">Halide::operator&amp;&amp;</a> (const Expr &amp;a, bool b)</td></tr>
<tr class="memdesc:aacad90a5a6d0d28775434cdf7b331213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical and of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> and a bool.  <a href="#aacad90a5a6d0d28775434cdf7b331213">More...</a><br/></td></tr>
<tr class="separator:aacad90a5a6d0d28775434cdf7b331213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e47ee1696f22e28dd5f6b9480a48ff"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa4e47ee1696f22e28dd5f6b9480a48ff">Halide::operator&amp;&amp;</a> (bool a, const Expr &amp;b)</td></tr>
<tr class="memdesc:aa4e47ee1696f22e28dd5f6b9480a48ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an expression and a constant integer.  <a href="#aa4e47ee1696f22e28dd5f6b9480a48ff">More...</a><br/></td></tr>
<tr class="separator:aa4e47ee1696f22e28dd5f6b9480a48ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa362c4a270ad2ddf71774a3024f1888b"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aa362c4a270ad2ddf71774a3024f1888b">Halide::operator||</a> (const Expr &amp;a, bool b)</td></tr>
<tr class="memdesc:aa362c4a270ad2ddf71774a3024f1888b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> and a bool.  <a href="#aa362c4a270ad2ddf71774a3024f1888b">More...</a><br/></td></tr>
<tr class="separator:aa362c4a270ad2ddf71774a3024f1888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a23781fff687cbb3e44eff7d2c1561"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a68a23781fff687cbb3e44eff7d2c1561">Halide::operator||</a> (bool a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a68a23781fff687cbb3e44eff7d2c1561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical or of an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> and a bool.  <a href="#a68a23781fff687cbb3e44eff7d2c1561">More...</a><br/></td></tr>
<tr class="separator:a68a23781fff687cbb3e44eff7d2c1561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abff3c9173726441fd40c0d1e659392be"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abff3c9173726441fd40c0d1e659392be">Halide::operator+</a> (const Expr &amp;a, float b)</td></tr>
<tr class="memdesc:abff3c9173726441fd40c0d1e659392be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#abff3c9173726441fd40c0d1e659392be">More...</a><br/></td></tr>
<tr class="separator:abff3c9173726441fd40c0d1e659392be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca38c46115d1794e6decf4925cc8148"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7ca38c46115d1794e6decf4925cc8148">Halide::operator+</a> (float a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a7ca38c46115d1794e6decf4925cc8148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a7ca38c46115d1794e6decf4925cc8148">More...</a><br/></td></tr>
<tr class="separator:a7ca38c46115d1794e6decf4925cc8148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678af722e318f2c5535d8fb119aac6c8"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a678af722e318f2c5535d8fb119aac6c8">Halide::operator-</a> (const Expr &amp;a, float b)</td></tr>
<tr class="memdesc:a678af722e318f2c5535d8fb119aac6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a678af722e318f2c5535d8fb119aac6c8">More...</a><br/></td></tr>
<tr class="separator:a678af722e318f2c5535d8fb119aac6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c68b2353d955f363da388277ffa93a4"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5c68b2353d955f363da388277ffa93a4">Halide::operator-</a> (float a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a5c68b2353d955f363da388277ffa93a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a5c68b2353d955f363da388277ffa93a4">More...</a><br/></td></tr>
<tr class="separator:a5c68b2353d955f363da388277ffa93a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5164dcfc47e952013aa463d1c66ebe36"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5164dcfc47e952013aa463d1c66ebe36">Halide::operator*</a> (const Expr &amp;a, float b)</td></tr>
<tr class="memdesc:a5164dcfc47e952013aa463d1c66ebe36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a5164dcfc47e952013aa463d1c66ebe36">More...</a><br/></td></tr>
<tr class="separator:a5164dcfc47e952013aa463d1c66ebe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80af5f0cff1b49ccb887c1fd09ecf752"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a80af5f0cff1b49ccb887c1fd09ecf752">Halide::operator*</a> (float a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a80af5f0cff1b49ccb887c1fd09ecf752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a80af5f0cff1b49ccb887c1fd09ecf752">More...</a><br/></td></tr>
<tr class="separator:a80af5f0cff1b49ccb887c1fd09ecf752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a587de26e3cfa87aec837f6c1569acb"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9a587de26e3cfa87aec837f6c1569acb">Halide::operator/</a> (const Expr &amp;a, float b)</td></tr>
<tr class="memdesc:a9a587de26e3cfa87aec837f6c1569acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a9a587de26e3cfa87aec837f6c1569acb">More...</a><br/></td></tr>
<tr class="separator:a9a587de26e3cfa87aec837f6c1569acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82972f5c2a0aa1991a48f8d01d5b12a"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab82972f5c2a0aa1991a48f8d01d5b12a">Halide::operator/</a> (float a, const Expr &amp;b)</td></tr>
<tr class="memdesc:ab82972f5c2a0aa1991a48f8d01d5b12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#ab82972f5c2a0aa1991a48f8d01d5b12a">More...</a><br/></td></tr>
<tr class="separator:ab82972f5c2a0aa1991a48f8d01d5b12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14d0202812878be5e9a72ea9d07c78e"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ad14d0202812878be5e9a72ea9d07c78e">Halide::operator%</a> (const Expr &amp;a, float b)</td></tr>
<tr class="memdesc:ad14d0202812878be5e9a72ea9d07c78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#ad14d0202812878be5e9a72ea9d07c78e">More...</a><br/></td></tr>
<tr class="separator:ad14d0202812878be5e9a72ea9d07c78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9159a0edf53cf79bbf455aac754ce60c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9159a0edf53cf79bbf455aac754ce60c">Halide::operator%</a> (float a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a9159a0edf53cf79bbf455aac754ce60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a9159a0edf53cf79bbf455aac754ce60c">More...</a><br/></td></tr>
<tr class="separator:a9159a0edf53cf79bbf455aac754ce60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8424b9c7be3f9dd966d48ecfeebb89d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab8424b9c7be3f9dd966d48ecfeebb89d">Halide::operator&gt;</a> (const Expr &amp;a, float b)</td></tr>
<tr class="memdesc:ab8424b9c7be3f9dd966d48ecfeebb89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#ab8424b9c7be3f9dd966d48ecfeebb89d">More...</a><br/></td></tr>
<tr class="separator:ab8424b9c7be3f9dd966d48ecfeebb89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef14bde72871e618d4a002020ccb5fab"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aef14bde72871e618d4a002020ccb5fab">Halide::operator&gt;</a> (float a, const Expr &amp;b)</td></tr>
<tr class="memdesc:aef14bde72871e618d4a002020ccb5fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#aef14bde72871e618d4a002020ccb5fab">More...</a><br/></td></tr>
<tr class="separator:aef14bde72871e618d4a002020ccb5fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d359771316778cb92740a807c147efe"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9d359771316778cb92740a807c147efe">Halide::operator&lt;</a> (const Expr &amp;a, float b)</td></tr>
<tr class="memdesc:a9d359771316778cb92740a807c147efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a9d359771316778cb92740a807c147efe">More...</a><br/></td></tr>
<tr class="separator:a9d359771316778cb92740a807c147efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec032819a3e9c233c7a9bf3879bf147"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5ec032819a3e9c233c7a9bf3879bf147">Halide::operator&lt;</a> (float a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a5ec032819a3e9c233c7a9bf3879bf147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a5ec032819a3e9c233c7a9bf3879bf147">More...</a><br/></td></tr>
<tr class="separator:a5ec032819a3e9c233c7a9bf3879bf147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccdb81e9527cecb8af1f209355bba48"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a8ccdb81e9527cecb8af1f209355bba48">Halide::operator&gt;=</a> (const Expr &amp;a, float b)</td></tr>
<tr class="memdesc:a8ccdb81e9527cecb8af1f209355bba48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a8ccdb81e9527cecb8af1f209355bba48">More...</a><br/></td></tr>
<tr class="separator:a8ccdb81e9527cecb8af1f209355bba48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e43796c400ada146ee37eb063cf50f"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a56e43796c400ada146ee37eb063cf50f">Halide::operator&gt;=</a> (float a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a56e43796c400ada146ee37eb063cf50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a56e43796c400ada146ee37eb063cf50f">More...</a><br/></td></tr>
<tr class="separator:a56e43796c400ada146ee37eb063cf50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204ceb62d79d9807da2fcb4ef142c451"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a204ceb62d79d9807da2fcb4ef142c451">Halide::operator&lt;=</a> (const Expr &amp;a, float b)</td></tr>
<tr class="memdesc:a204ceb62d79d9807da2fcb4ef142c451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a204ceb62d79d9807da2fcb4ef142c451">More...</a><br/></td></tr>
<tr class="separator:a204ceb62d79d9807da2fcb4ef142c451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e76cf385a40d59d3dcc8799449fc23c"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a9e76cf385a40d59d3dcc8799449fc23c">Halide::operator&lt;=</a> (float a, const Expr &amp;b)</td></tr>
<tr class="memdesc:a9e76cf385a40d59d3dcc8799449fc23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a9e76cf385a40d59d3dcc8799449fc23c">More...</a><br/></td></tr>
<tr class="separator:a9e76cf385a40d59d3dcc8799449fc23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45a7ad03b493874388699d30f856233"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ae45a7ad03b493874388699d30f856233">Halide::operator==</a> (const Expr &amp;a, float b)</td></tr>
<tr class="memdesc:ae45a7ad03b493874388699d30f856233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#ae45a7ad03b493874388699d30f856233">More...</a><br/></td></tr>
<tr class="separator:ae45a7ad03b493874388699d30f856233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93245ce51aa668adac92f52a409e7c0"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#af93245ce51aa668adac92f52a409e7c0">Halide::operator==</a> (float a, const Expr &amp;b)</td></tr>
<tr class="memdesc:af93245ce51aa668adac92f52a409e7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#af93245ce51aa668adac92f52a409e7c0">More...</a><br/></td></tr>
<tr class="separator:af93245ce51aa668adac92f52a409e7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323ff155ab1eec37e44862bc9002b4cf"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a323ff155ab1eec37e44862bc9002b4cf">Halide::operator!=</a> (const Expr &amp;a, float b)</td></tr>
<tr class="memdesc:a323ff155ab1eec37e44862bc9002b4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#a323ff155ab1eec37e44862bc9002b4cf">More...</a><br/></td></tr>
<tr class="separator:a323ff155ab1eec37e44862bc9002b4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad1141775e41998a734252970a6d018"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#adad1141775e41998a734252970a6d018">Halide::operator!=</a> (float a, const Expr &amp;b)</td></tr>
<tr class="memdesc:adad1141775e41998a734252970a6d018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operators on floats treats those floats as Exprs.  <a href="#adad1141775e41998a734252970a6d018">More...</a><br/></td></tr>
<tr class="separator:adad1141775e41998a734252970a6d018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a39865d2369d130f6c8e435c860cafb14"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a39865d2369d130f6c8e435c860cafb14">Halide::operator&lt;&lt;</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a39865d2369d130f6c8e435c860cafb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value left.  <a href="#a39865d2369d130f6c8e435c860cafb14">More...</a><br/></td></tr>
<tr class="separator:a39865d2369d130f6c8e435c860cafb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b7aa4561df5353b123cde2a69cdd14"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a33b7aa4561df5353b123cde2a69cdd14">Halide::operator&lt;&lt;</a> (const Expr &amp;x, int y)</td></tr>
<tr class="memdesc:a33b7aa4561df5353b123cde2a69cdd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value left.  <a href="#a33b7aa4561df5353b123cde2a69cdd14">More...</a><br/></td></tr>
<tr class="separator:a33b7aa4561df5353b123cde2a69cdd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf0aa69fb7ea96ea332d64ef8992b62"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#abaf0aa69fb7ea96ea332d64ef8992b62">Halide::operator&lt;&lt;</a> (int x, const Expr &amp;y)</td></tr>
<tr class="memdesc:abaf0aa69fb7ea96ea332d64ef8992b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value left.  <a href="#abaf0aa69fb7ea96ea332d64ef8992b62">More...</a><br/></td></tr>
<tr class="separator:abaf0aa69fb7ea96ea332d64ef8992b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0615561baf45c3d84e7d36c77204ee3d"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a0615561baf45c3d84e7d36c77204ee3d">Halide::operator&gt;&gt;</a> (Expr x, Expr y)</td></tr>
<tr class="memdesc:a0615561baf45c3d84e7d36c77204ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value right.  <a href="#a0615561baf45c3d84e7d36c77204ee3d">More...</a><br/></td></tr>
<tr class="separator:a0615561baf45c3d84e7d36c77204ee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7980d79e65179127ed028dd9ec0014e5"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a7980d79e65179127ed028dd9ec0014e5">Halide::operator&gt;&gt;</a> (const Expr &amp;x, int y)</td></tr>
<tr class="memdesc:a7980d79e65179127ed028dd9ec0014e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value right.  <a href="#a7980d79e65179127ed028dd9ec0014e5">More...</a><br/></td></tr>
<tr class="separator:a7980d79e65179127ed028dd9ec0014e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7f5ab9b91a1305977461a8a7468890"><td class="memItemLeft" align="right" valign="top">Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a4c7f5ab9b91a1305977461a8a7468890">Halide::operator&gt;&gt;</a> (int x, const Expr &amp;y)</td></tr>
<tr class="memdesc:a4c7f5ab9b91a1305977461a8a7468890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the bits of an integer value right.  <a href="#a4c7f5ab9b91a1305977461a8a7468890">More...</a><br/></td></tr>
<tr class="separator:a4c7f5ab9b91a1305977461a8a7468890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab9255b9f7b5c046d86588a9a157a6e8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ab9255b9f7b5c046d86588a9a157a6e8d">Halide::print</a> (const std::vector&lt; Expr &gt; &amp;values)</td></tr>
<tr class="memdesc:ab9255b9f7b5c046d86588a9a157a6e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints out its value whenever it is evaluated.  <a href="#ab9255b9f7b5c046d86588a9a157a6e8d">More...</a><br/></td></tr>
<tr class="separator:ab9255b9f7b5c046d86588a9a157a6e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb69e70a9da82729cec47dde5bd2281"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:affb69e70a9da82729cec47dde5bd2281"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#affb69e70a9da82729cec47dde5bd2281">Halide::print</a> (const Expr &amp;a, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:affb69e70a9da82729cec47dde5bd2281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints out its value whenever it is evaluated.  <a href="#affb69e70a9da82729cec47dde5bd2281">More...</a><br/></td></tr>
<tr class="separator:affb69e70a9da82729cec47dde5bd2281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5a55b9b30d6f19c3b699b5308a1e15fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a5a55b9b30d6f19c3b699b5308a1e15fd">Halide::print_when</a> (const Expr &amp;condition, const std::vector&lt; Expr &gt; &amp;values)</td></tr>
<tr class="memdesc:a5a55b9b30d6f19c3b699b5308a1e15fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints whenever it is evaluated, provided that the condition is true.  <a href="#a5a55b9b30d6f19c3b699b5308a1e15fd">More...</a><br/></td></tr>
<tr class="separator:a5a55b9b30d6f19c3b699b5308a1e15fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d60a557b0ebdb246400410eadcc9c44"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3d60a557b0ebdb246400410eadcc9c44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#a3d60a557b0ebdb246400410eadcc9c44">Halide::print_when</a> (const Expr &amp;condition, const Expr &amp;a, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3d60a557b0ebdb246400410eadcc9c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that prints whenever it is evaluated, provided that the condition is true.  <a href="#a3d60a557b0ebdb246400410eadcc9c44">More...</a><br/></td></tr>
<tr class="separator:a3d60a557b0ebdb246400410eadcc9c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aaae7edaa63f7191418f5b79902ac3b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html#aaae7edaa63f7191418f5b79902ac3b3f">Halide::require</a> (const Expr &amp;condition, const std::vector&lt; Expr &gt; &amp;values)</td></tr>
<tr class="memdesc:aaae7edaa63f7191418f5b79902ac3b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that that guarantees a precondition.  <a href="#aaae7edaa63f7191418f5b79902ac3b3f">More...</a><br/></td></tr>
<tr class="separator:aaae7edaa63f7191418f5b79902ac3b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada57ca4b2324c01837b6d9640c144545"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ada57ca4b2324c01837b6d9640c144545"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ada57ca4b2324c01837b6d9640c144545">Halide::require</a> (const Expr &amp;condition, const Expr &amp;value, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ada57ca4b2324c01837b6d9640c144545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> that that guarantees a precondition.  <a href="#ada57ca4b2324c01837b6d9640c144545">More...</a><br/></td></tr>
<tr class="separator:ada57ca4b2324c01837b6d9640c144545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac9b077496dda407db5c945bacab1412f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac9b077496dda407db5c945bacab1412f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Expr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide.html#ac9b077496dda407db5c945bacab1412f">Halide::memoize_tag</a> (const Expr &amp;result, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ac9b077496dda407db5c945bacab1412f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the values used in the memoization cache key for memoize.  <a href="#ac9b077496dda407db5c945bacab1412f">More...</a><br/></td></tr>
<tr class="separator:ac9b077496dda407db5c945bacab1412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines various operator overloads and utility functions that make it more pleasant to work with <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> expressions. </p>

<p>Definition in file <a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_i_r_operator_8h.html">IROperator.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
