<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: Halide::Pipeline Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_halide_1_1_pipeline.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_halide_1_1_pipeline-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Pipeline Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class representing a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> pipeline.  
 <a href="class_halide_1_1_pipeline.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_pipeline_8h_source.html">Pipeline.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad3a73ba5260a331ebe69f1160565e216"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#ad3a73ba5260a331ebe69f1160565e216">Pipeline</a> ()</td></tr>
<tr class="memdesc:ad3a73ba5260a331ebe69f1160565e216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an undefined <a class="el" href="class_halide_1_1_pipeline.html" title="A class representing a Halide pipeline. ">Pipeline</a> object.  <a href="#ad3a73ba5260a331ebe69f1160565e216">More...</a><br/></td></tr>
<tr class="separator:ad3a73ba5260a331ebe69f1160565e216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ebee365c875e14d359f43fe4b01201"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a27ebee365c875e14d359f43fe4b01201">Pipeline</a> (<a class="el" href="class_halide_1_1_func.html">Func</a> output)</td></tr>
<tr class="memdesc:a27ebee365c875e14d359f43fe4b01201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a pipeline that computes the given <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>.  <a href="#a27ebee365c875e14d359f43fe4b01201">More...</a><br/></td></tr>
<tr class="separator:a27ebee365c875e14d359f43fe4b01201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba0264c7234cd6f93da4c2925a37f17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a6ba0264c7234cd6f93da4c2925a37f17">Pipeline</a> (const std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt; &amp;<a class="el" href="class_halide_1_1_pipeline.html#a4e53e2d0a31656a6bfe4566b9b0a2d2a">outputs</a>)</td></tr>
<tr class="memdesc:a6ba0264c7234cd6f93da4c2925a37f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a pipeline that computes the givens Funcs as outputs.  <a href="#a6ba0264c7234cd6f93da4c2925a37f17">More...</a><br/></td></tr>
<tr class="separator:a6ba0264c7234cd6f93da4c2925a37f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e53e2d0a31656a6bfe4566b9b0a2d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a4e53e2d0a31656a6bfe4566b9b0a2d2a">outputs</a> ()</td></tr>
<tr class="memdesc:a4e53e2d0a31656a6bfe4566b9b0a2d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Funcs this pipeline outputs.  <a href="#a4e53e2d0a31656a6bfe4566b9b0a2d2a">More...</a><br/></td></tr>
<tr class="separator:a4e53e2d0a31656a6bfe4566b9b0a2d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843143791d80f6a5ed896997bf020956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a843143791d80f6a5ed896997bf020956">compile_to</a> (const <a class="el" href="struct_halide_1_1_outputs.html">Outputs</a> &amp;output_files, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;args, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target)</td></tr>
<tr class="memdesc:a843143791d80f6a5ed896997bf020956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile and generate multiple target files with single call.  <a href="#a843143791d80f6a5ed896997bf020956">More...</a><br/></td></tr>
<tr class="separator:a843143791d80f6a5ed896997bf020956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4000b0a6f1379102cbdc653c1e248ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#af4000b0a6f1379102cbdc653c1e248ac">compile_to_bitcode</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;args, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:af4000b0a6f1379102cbdc653c1e248ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile a pipeline to llvm bitcode, with the given filename (which should probably end in .bc), type signature, and C function name.  <a href="#af4000b0a6f1379102cbdc653c1e248ac">More...</a><br/></td></tr>
<tr class="separator:af4000b0a6f1379102cbdc653c1e248ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb5e45dff8885d8a2f5cce230b413ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#adfb5e45dff8885d8a2f5cce230b413ac">compile_to_object</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:adfb5e45dff8885d8a2f5cce230b413ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile a pipeline with multiple output functions to an object file, with the given filename (which should probably end in .o or .obj), type signature, and C function name (which defaults to the same name as this halide function.  <a href="#adfb5e45dff8885d8a2f5cce230b413ac">More...</a><br/></td></tr>
<tr class="separator:adfb5e45dff8885d8a2f5cce230b413ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799b36dbc5870c420c3eb520e1563e45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a799b36dbc5870c420c3eb520e1563e45">compile_to_header</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:a799b36dbc5870c420c3eb520e1563e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a header file with the given filename for a pipeline.  <a href="#a799b36dbc5870c420c3eb520e1563e45">More...</a><br/></td></tr>
<tr class="separator:a799b36dbc5870c420c3eb520e1563e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a378edc39dbddcd5ee2d2066c23634e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a4a378edc39dbddcd5ee2d2066c23634e">compile_to_assembly</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;args, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:a4a378edc39dbddcd5ee2d2066c23634e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile a pipeline to text assembly equivalent to the object file generated by compile_to_object.  <a href="#a4a378edc39dbddcd5ee2d2066c23634e">More...</a><br/></td></tr>
<tr class="separator:a4a378edc39dbddcd5ee2d2066c23634e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593443b92ea30120608a362c17ece2a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a593443b92ea30120608a362c17ece2a8">compile_to_c</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:a593443b92ea30120608a362c17ece2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statically compile a pipeline to C source code.  <a href="#a593443b92ea30120608a362c17ece2a8">More...</a><br/></td></tr>
<tr class="separator:a593443b92ea30120608a362c17ece2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8dd786dccde3aeea03aab4186472b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#add8dd786dccde3aeea03aab4186472b2">compile_to_lowered_stmt</a> (const std::string &amp;filename, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;args, <a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a> fmt=<a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:add8dd786dccde3aeea03aab4186472b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out an internal representation of lowered code.  <a href="#add8dd786dccde3aeea03aab4186472b2">More...</a><br/></td></tr>
<tr class="separator:add8dd786dccde3aeea03aab4186472b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e39f724335f9ed97e34483f4278b531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a2e39f724335f9ed97e34483f4278b531">print_loop_nest</a> ()</td></tr>
<tr class="memdesc:a2e39f724335f9ed97e34483f4278b531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out the loop nests specified by the schedule for this <a class="el" href="class_halide_1_1_pipeline.html" title="A class representing a Halide pipeline. ">Pipeline</a>'s Funcs.  <a href="#a2e39f724335f9ed97e34483f4278b531">More...</a><br/></td></tr>
<tr class="separator:a2e39f724335f9ed97e34483f4278b531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcd4e36d0524a0d5016e9da80ef8bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a0fcd4e36d0524a0d5016e9da80ef8bf9">compile_to_file</a> (const std::string &amp;filename_prefix, const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;args, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:a0fcd4e36d0524a0d5016e9da80ef8bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile to object file and header pair, with the given arguments.  <a href="#a0fcd4e36d0524a0d5016e9da80ef8bf9">More...</a><br/></td></tr>
<tr class="separator:a0fcd4e36d0524a0d5016e9da80ef8bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1785f26f6a7c7f45fed5fb9d0d1da3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_module.html">Module</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#ad1785f26f6a7c7f45fed5fb9d0d1da3e">compile_to_module</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;args, const std::string &amp;fn_name, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>())</td></tr>
<tr class="memdesc:ad1785f26f6a7c7f45fed5fb9d0d1da3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an internal representation of lowered code as a self contained <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> suitable for further compilation.  <a href="#ad1785f26f6a7c7f45fed5fb9d0d1da3e">More...</a><br/></td></tr>
<tr class="separator:ad1785f26f6a7c7f45fed5fb9d0d1da3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91263db90573c67fd6a98fe2086a3939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a91263db90573c67fd6a98fe2086a3939">compile_jit</a> (const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>())</td></tr>
<tr class="memdesc:a91263db90573c67fd6a98fe2086a3939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eagerly jit compile the function to machine code.  <a href="#a91263db90573c67fd6a98fe2086a3939">More...</a><br/></td></tr>
<tr class="separator:a91263db90573c67fd6a98fe2086a3939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3617530adceff913a0127d61ad66466e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a3617530adceff913a0127d61ad66466e">set_error_handler</a> (void(*handler)(void *, const char *))</td></tr>
<tr class="memdesc:a3617530adceff913a0127d61ad66466e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the error handler function that be called in the case of runtime errors during halide pipelines.  <a href="#a3617530adceff913a0127d61ad66466e">More...</a><br/></td></tr>
<tr class="separator:a3617530adceff913a0127d61ad66466e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a1ab306e1059c5d4746968c0a8035f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a19a1ab306e1059c5d4746968c0a8035f">set_custom_allocator</a> (void *(*<a class="el" href="runtime__internal_8h.html#a1c8580582aae58105f16108d4ec89e9a">malloc</a>)(void *, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>), void(*<a class="el" href="runtime__internal_8h.html#af07d89f5ceaea0c7c8252cc41fd75f37">free</a>)(void *, void *))</td></tr>
<tr class="separator:a19a1ab306e1059c5d4746968c0a8035f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee0e19413d082928e6a647f581efdf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#aeee0e19413d082928e6a647f581efdf7">set_custom_do_task</a> (int(*custom_do_task)(void *, int(*)(void *, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *), int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *))</td></tr>
<tr class="memdesc:aeee0e19413d082928e6a647f581efdf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom task handler to be called by the parallel for loop.  <a href="#aeee0e19413d082928e6a647f581efdf7">More...</a><br/></td></tr>
<tr class="separator:aeee0e19413d082928e6a647f581efdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2c996fe2ba083972d91d2393461ea1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a0c2c996fe2ba083972d91d2393461ea1">set_custom_do_par_for</a> (int(*custom_do_par_for)(void *, int(*)(void *, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *), int, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *))</td></tr>
<tr class="memdesc:a0c2c996fe2ba083972d91d2393461ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a custom parallel for loop launcher.  <a href="#a0c2c996fe2ba083972d91d2393461ea1">More...</a><br/></td></tr>
<tr class="separator:a0c2c996fe2ba083972d91d2393461ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295c988571c212dda45aa9448f2c1192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a295c988571c212dda45aa9448f2c1192">set_custom_trace</a> (int(*trace_fn)(void *, const <a class="el" href="structhalide__trace__event.html">halide_trace_event</a> *))</td></tr>
<tr class="memdesc:a295c988571c212dda45aa9448f2c1192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set custom routines to call when tracing is enabled.  <a href="#a295c988571c212dda45aa9448f2c1192">More...</a><br/></td></tr>
<tr class="separator:a295c988571c212dda45aa9448f2c1192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba003ee8ff1fd65fd866d6ccbfec613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a4ba003ee8ff1fd65fd866d6ccbfec613">set_custom_print</a> (void(*handler)(void *, const char *))</td></tr>
<tr class="memdesc:a4ba003ee8ff1fd65fd866d6ccbfec613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the function called to print messages from the runtime.  <a href="#a4ba003ee8ff1fd65fd866d6ccbfec613">More...</a><br/></td></tr>
<tr class="separator:a4ba003ee8ff1fd65fd866d6ccbfec613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91badb15852fc2eeaeba7cee3dc13377"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a91badb15852fc2eeaeba7cee3dc13377">set_jit_externs</a> (const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_j_i_t_extern.html">JITExtern</a> &gt; &amp;externs)</td></tr>
<tr class="memdesc:a91badb15852fc2eeaeba7cee3dc13377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a set of external C functions or Funcs to satisfy dependencies introduced by HalideExtern and define_extern mechanisms.  <a href="#a91badb15852fc2eeaeba7cee3dc13377">More...</a><br/></td></tr>
<tr class="separator:a91badb15852fc2eeaeba7cee3dc13377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b072e73bbcb9f0178f97f787d426ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::map<br class="typebreak"/>
&lt; std::string, <a class="el" href="struct_halide_1_1_j_i_t_extern.html">JITExtern</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#ad1b072e73bbcb9f0178f97f787d426ee">get_jit_externs</a> ()</td></tr>
<tr class="memdesc:ad1b072e73bbcb9f0178f97f787d426ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the map of previously installed externs.  <a href="#ad1b072e73bbcb9f0178f97f787d426ee">More...</a><br/></td></tr>
<tr class="separator:ad1b072e73bbcb9f0178f97f787d426ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0b4ee338780db27d4bac4a1eeff64b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <br class="typebreak"/>
<a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_handlers.html">Internal::JITHandlers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#adc0b4ee338780db27d4bac4a1eeff64b">jit_handlers</a> ()</td></tr>
<tr class="memdesc:adc0b4ee338780db27d4bac4a1eeff64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a struct containing the currently set custom functions used by JIT.  <a href="#adc0b4ee338780db27d4bac4a1eeff64b">More...</a><br/></td></tr>
<tr class="separator:adc0b4ee338780db27d4bac4a1eeff64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25d5deb7a3cebbbe45ca05044dabecd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af25d5deb7a3cebbbe45ca05044dabecd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#af25d5deb7a3cebbbe45ca05044dabecd">add_custom_lowering_pass</a> (T *pass)</td></tr>
<tr class="memdesc:af25d5deb7a3cebbbe45ca05044dabecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a custom pass to be used during lowering.  <a href="#af25d5deb7a3cebbbe45ca05044dabecd">More...</a><br/></td></tr>
<tr class="separator:af25d5deb7a3cebbbe45ca05044dabecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746005c1f3818923647c8089c920cf55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a746005c1f3818923647c8089c920cf55">add_custom_lowering_pass</a> (<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">Internal::IRMutator</a> *pass, void(*deleter)(<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">Internal::IRMutator</a> *))</td></tr>
<tr class="memdesc:a746005c1f3818923647c8089c920cf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a custom pass to be used during lowering, with the function that will be called to delete it also passed in.  <a href="#a746005c1f3818923647c8089c920cf55">More...</a><br/></td></tr>
<tr class="separator:a746005c1f3818923647c8089c920cf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3088a7ff87602e19f354fc9a28c727c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a3088a7ff87602e19f354fc9a28c727c6">clear_custom_lowering_passes</a> ()</td></tr>
<tr class="memdesc:a3088a7ff87602e19f354fc9a28c727c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all previously-set custom lowering passes.  <a href="#a3088a7ff87602e19f354fc9a28c727c6">More...</a><br/></td></tr>
<tr class="separator:a3088a7ff87602e19f354fc9a28c727c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173fdaf866f329dbc29074a9fa7e28e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::vector<br class="typebreak"/>
&lt; <a class="el" href="struct_halide_1_1_custom_lowering_pass.html">CustomLoweringPass</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a173fdaf866f329dbc29074a9fa7e28e3">custom_lowering_passes</a> ()</td></tr>
<tr class="memdesc:a173fdaf866f329dbc29074a9fa7e28e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the custom lowering passes.  <a href="#a173fdaf866f329dbc29074a9fa7e28e3">More...</a><br/></td></tr>
<tr class="separator:a173fdaf866f329dbc29074a9fa7e28e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a50b42de4840d03e0dbb72ccc19302"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#ae5a50b42de4840d03e0dbb72ccc19302">infer_arguments</a> ()</td></tr>
<tr class="memdesc:ae5a50b42de4840d03e0dbb72ccc19302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the arguments to the <a class="el" href="class_halide_1_1_pipeline.html" title="A class representing a Halide pipeline. ">Pipeline</a>, sorted into a canonical order: all buffers (sorted alphabetically by name), followed by all non-buffers (sorted alphabetically by name).  <a href="#ae5a50b42de4840d03e0dbb72ccc19302">More...</a><br/></td></tr>
<tr class="separator:ae5a50b42de4840d03e0dbb72ccc19302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fbe5e7cb2cf3f9cf157b37c968ba61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a71fbe5e7cb2cf3f9cf157b37c968ba61">defined</a> () const </td></tr>
<tr class="memdesc:a71fbe5e7cb2cf3f9cf157b37c968ba61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this pipeline object is defined.  <a href="#a71fbe5e7cb2cf3f9cf157b37c968ba61">More...</a><br/></td></tr>
<tr class="separator:a71fbe5e7cb2cf3f9cf157b37c968ba61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506dbff346dd064b927fbcf3af52725d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a506dbff346dd064b927fbcf3af52725d">invalidate_cache</a> ()</td></tr>
<tr class="memdesc:a506dbff346dd064b927fbcf3af52725d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate any internal cached state, e.g.  <a href="#a506dbff346dd064b927fbcf3af52725d">More...</a><br/></td></tr>
<tr class="separator:a506dbff346dd064b927fbcf3af52725d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2f0131e4dce2dbf9932c9e406a747b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a2f0131e4dce2dbf9932c9e406a747b3c">realize</a> (std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &gt; sizes, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="struct_halide_1_1_target.html">Target</a>())</td></tr>
<tr class="separator:a2f0131e4dce2dbf9932c9e406a747b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77b4a14078788b050717cc4c4e3f412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#ad77b4a14078788b050717cc4c4e3f412">realize</a> (int x_size, int y_size, int z_size, int w_size, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="struct_halide_1_1_target.html">Target</a>())</td></tr>
<tr class="separator:ad77b4a14078788b050717cc4c4e3f412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776eeb8aeea26f0b8b70a91fd9d6c24e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a776eeb8aeea26f0b8b70a91fd9d6c24e">realize</a> (int x_size, int y_size, int z_size, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="struct_halide_1_1_target.html">Target</a>())</td></tr>
<tr class="separator:a776eeb8aeea26f0b8b70a91fd9d6c24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6629e592e2d836b59e222dc35e554b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#aed6629e592e2d836b59e222dc35e554b">realize</a> (int x_size, int y_size, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="struct_halide_1_1_target.html">Target</a>())</td></tr>
<tr class="separator:aed6629e592e2d836b59e222dc35e554b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b50bab03a37a0716d025dac9502dd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a87b50bab03a37a0716d025dac9502dd1">realize</a> (int x_size=0, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="struct_halide_1_1_target.html">Target</a>())</td></tr>
<tr class="separator:a87b50bab03a37a0716d025dac9502dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aac17c684607dc5dee271019a3659b40a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#aac17c684607dc5dee271019a3659b40a">realize</a> (<a class="el" href="class_halide_1_1_realization.html">Realization</a> <a class="el" href="runtime__internal_8h.html#a961c13eb7fcda15b167b953cac1ab3ec">dst</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="struct_halide_1_1_target.html">Target</a>())</td></tr>
<tr class="memdesc:aac17c684607dc5dee271019a3659b40a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function into an existing allocated buffer or buffers.  <a href="#aac17c684607dc5dee271019a3659b40a">More...</a><br/></td></tr>
<tr class="separator:aac17c684607dc5dee271019a3659b40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2fc2649e7753b1eff82f95ba3a36f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#aec2fc2649e7753b1eff82f95ba3a36f8">realize</a> (<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> <a class="el" href="runtime__internal_8h.html#a961c13eb7fcda15b167b953cac1ab3ec">dst</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="struct_halide_1_1_target.html">Target</a>())</td></tr>
<tr class="memdesc:aec2fc2649e7753b1eff82f95ba3a36f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function into an existing allocated buffer or buffers.  <a href="#aec2fc2649e7753b1eff82f95ba3a36f8">More...</a><br/></td></tr>
<tr class="separator:aec2fc2649e7753b1eff82f95ba3a36f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf2995d95108a2bd7e7cf8ab54efe45"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bf2995d95108a2bd7e7cf8ab54efe45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a0bf2995d95108a2bd7e7cf8ab54efe45">realize</a> (<a class="el" href="class_halide_1_1_image.html">Image</a>&lt; T &gt; <a class="el" href="runtime__internal_8h.html#a961c13eb7fcda15b167b953cac1ab3ec">dst</a>, const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;target=<a class="el" href="struct_halide_1_1_target.html">Target</a>())</td></tr>
<tr class="memdesc:a0bf2995d95108a2bd7e7cf8ab54efe45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate this function into an existing allocated buffer or buffers.  <a href="#a0bf2995d95108a2bd7e7cf8ab54efe45">More...</a><br/></td></tr>
<tr class="separator:a0bf2995d95108a2bd7e7cf8ab54efe45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a55be371d5d44ca549cc1bc57ecb849a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a55be371d5d44ca549cc1bc57ecb849a0">infer_input_bounds</a> (int x_size=0, int y_size=0, int z_size=0, int w_size=0)</td></tr>
<tr class="memdesc:a55be371d5d44ca549cc1bc57ecb849a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given size of output, or a given set of output buffers, determine the bounds required of all unbound ImageParams referenced.  <a href="#a55be371d5d44ca549cc1bc57ecb849a0">More...</a><br/></td></tr>
<tr class="separator:a55be371d5d44ca549cc1bc57ecb849a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c8aa83dfbf7d2792d0893af8ecf712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#a78c8aa83dfbf7d2792d0893af8ecf712">infer_input_bounds</a> (<a class="el" href="class_halide_1_1_realization.html">Realization</a> <a class="el" href="runtime__internal_8h.html#a961c13eb7fcda15b167b953cac1ab3ec">dst</a>)</td></tr>
<tr class="memdesc:a78c8aa83dfbf7d2792d0893af8ecf712"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given size of output, or a given set of output buffers, determine the bounds required of all unbound ImageParams referenced.  <a href="#a78c8aa83dfbf7d2792d0893af8ecf712">More...</a><br/></td></tr>
<tr class="separator:a78c8aa83dfbf7d2792d0893af8ecf712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16be8371089923cbb1c92a017d0ac52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_pipeline.html#aa16be8371089923cbb1c92a017d0ac52">infer_input_bounds</a> (<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> <a class="el" href="runtime__internal_8h.html#a961c13eb7fcda15b167b953cac1ab3ec">dst</a>)</td></tr>
<tr class="memdesc:aa16be8371089923cbb1c92a017d0ac52"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given size of output, or a given set of output buffers, determine the bounds required of all unbound ImageParams referenced.  <a href="#aa16be8371089923cbb1c92a017d0ac52">More...</a><br/></td></tr>
<tr class="separator:aa16be8371089923cbb1c92a017d0ac52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class representing a <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> pipeline. </p>
<p>Constructed from the <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> or Funcs that it outputs. </p>

<p>Definition at line <a class="el" href="_pipeline_8h_source.html#l00097">97</a> of file <a class="el" href="_pipeline_8h_source.html">Pipeline.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad3a73ba5260a331ebe69f1160565e216"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Pipeline::Pipeline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an undefined <a class="el" href="class_halide_1_1_pipeline.html" title="A class representing a Halide pipeline. ">Pipeline</a> object. </p>

</div>
</div>
<a class="anchor" id="a27ebee365c875e14d359f43fe4b01201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Pipeline::Pipeline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a pipeline that computes the given <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>. </p>
<p>Schedules the <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> compute_root(). </p>

</div>
</div>
<a class="anchor" id="a6ba0264c7234cd6f93da4c2925a37f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Pipeline::Pipeline </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_halide_1_1_func.html">Func</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a pipeline that computes the givens Funcs as outputs. </p>
<p>Schedules the Funcs compute_root(). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4e53e2d0a31656a6bfe4566b9b0a2d2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;<a class="el" href="class_halide_1_1_func.html">Func</a>&gt; Halide::Pipeline::outputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Funcs this pipeline outputs. </p>

</div>
</div>
<a class="anchor" id="a843143791d80f6a5ed896997bf020956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::compile_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_outputs.html">Outputs</a> &amp;&#160;</td>
          <td class="paramname"><em>output_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile and generate multiple target files with single call. </p>
<p>Deduces target files based on filenames specified in output_files struct. </p>

</div>
</div>
<a class="anchor" id="af4000b0a6f1379102cbdc653c1e248ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::compile_to_bitcode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile a pipeline to llvm bitcode, with the given filename (which should probably end in .bc), type signature, and C function name. </p>
<p>If you're compiling a pipeline with a single output <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>, see also <a class="el" href="class_halide_1_1_func.html#ac96e9e315c41de06dd8447ebc3f39643" title="Statically compile this function to llvm bitcode, with the given filename (which should probably end ...">Func::compile_to_bitcode</a>. </p>

</div>
</div>
<a class="anchor" id="adfb5e45dff8885d8a2f5cce230b413ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::compile_to_object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile a pipeline with multiple output functions to an object file, with the given filename (which should probably end in .o or .obj), type signature, and C function name (which defaults to the same name as this halide function. </p>
<p>You probably don't want to use this directly; call compile_to_file instead. </p>

</div>
</div>
<a class="anchor" id="a799b36dbc5870c420c3eb520e1563e45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::compile_to_header </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a header file with the given filename for a pipeline. </p>
<p>The header will define a function with the type signature given by the second argument, and a name given by the third. You don't actually have to have defined any of these functions yet to call this. You probably don't want to use this directly; call compile_to_file instead. </p>

</div>
</div>
<a class="anchor" id="a4a378edc39dbddcd5ee2d2066c23634e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::compile_to_assembly </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile a pipeline to text assembly equivalent to the object file generated by compile_to_object. </p>
<p>This is useful for checking what <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a> is producing without having to disassemble anything, or if you need to feed the assembly into some custom toolchain to produce an object file. </p>

</div>
</div>
<a class="anchor" id="a593443b92ea30120608a362c17ece2a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::compile_to_c </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statically compile a pipeline to C source code. </p>
<p>This is useful for providing fallback code paths that will compile on many platforms. Vectorization will fail, and parallelization will produce serial code. </p>

</div>
</div>
<a class="anchor" id="add8dd786dccde3aeea03aab4186472b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::compile_to_lowered_stmt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56">StmtOutputFormat</a>&#160;</td>
          <td class="paramname"><em>fmt</em> = <code><a class="el" href="namespace_halide.html#ad1953af304956bd6a5d0bd780b135f56a1941ee057d1e57015bf2838a63556b91">Text</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write out an internal representation of lowered code. </p>
<p>Useful for analyzing and debugging scheduling. Can emit html or plain text. </p>

</div>
</div>
<a class="anchor" id="a2e39f724335f9ed97e34483f4278b531"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::print_loop_nest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write out the loop nests specified by the schedule for this <a class="el" href="class_halide_1_1_pipeline.html" title="A class representing a Halide pipeline. ">Pipeline</a>'s Funcs. </p>
<p>Helpful for understanding what a schedule is doing. </p>

</div>
</div>
<a class="anchor" id="a0fcd4e36d0524a0d5016e9da80ef8bf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::compile_to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile to object file and header pair, with the given arguments. </p>
<p>Also names the C function to match the filename argument. </p>

</div>
</div>
<a class="anchor" id="ad1785f26f6a7c7f45fed5fb9d0d1da3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_module.html">Module</a> Halide::Pipeline::compile_to_module </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_argument.html">Argument</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd">get_target_from_environment</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an internal representation of lowered code as a self contained <a class="el" href="class_halide_1_1_module.html" title="A halide module. ">Module</a> suitable for further compilation. </p>

</div>
</div>
<a class="anchor" id="a91263db90573c67fd6a98fe2086a3939"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void* Halide::Pipeline::compile_jit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37">get_jit_target_from_environment</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eagerly jit compile the function to machine code. </p>
<p>This normally happens on the first call to realize. If you're running your halide pipeline inside time-sensitive code and wish to avoid including the time taken to compile a pipeline, then you can call this ahead of time. Returns the raw function pointer to the compiled pipeline. Default is to use the <a class="el" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for. ">Target</a> returned from <a class="el" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation. ">Halide::get_jit_target_from_environment()</a> </p>

</div>
</div>
<a class="anchor" id="a3617530adceff913a0127d61ad66466e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::set_error_handler </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *, const char *)&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the error handler function that be called in the case of runtime errors during halide pipelines. </p>
<p>If you are compiling statically, you can also just define your own function with signature </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> <a class="code" href="_halide_runtime_8h.html#aea28d04de54b94f0dd6ada140b7734d8">halide_error</a>(<span class="keywordtype">void</span> *user_context, <span class="keyword">const</span> <span class="keywordtype">char</span> *);</div>
</div><!-- fragment --><p> This will clobber <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s version. </p>

</div>
</div>
<a class="anchor" id="a19a1ab306e1059c5d4746968c0a8035f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::set_custom_allocator </td>
          <td>(</td>
          <td class="paramtype">void *(*)(void *, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)&#160;</td>
          <td class="paramname"><em>malloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>free</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeee0e19413d082928e6a647f581efdf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::set_custom_do_task </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *, int(*)(void *, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *), int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)&#160;</td>
          <td class="paramname"><em>custom_do_task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a custom task handler to be called by the parallel for loop. </p>
<p>It is useful to set this if you want to do some additional bookkeeping at the granularity of parallel tasks. The default implementation does this: </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span> halide_do_task(<span class="keywordtype">void</span> *user_context,</div>
<div class="line">                              <span class="keywordtype">int</span> (*f)(<span class="keywordtype">void</span> *, <span class="keywordtype">int</span>, <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *),</div>
<div class="line">                              <span class="keywordtype">int</span> idx, <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *state) {</div>
<div class="line">    <span class="keywordflow">return</span> f(user_context, idx, state);</div>
<div class="line">}</div>
</div><!-- fragment --><p> If you are statically compiling, you can also just define your own version of the above function, and it will clobber <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s version.</p>
<p>If you're trying to use a custom parallel runtime, you probably don't want to call this. See instead <a class="el" href="class_halide_1_1_func.html#afd38942fde8f87b6851d47bf99513ba1">Func::set_custom_do_par_for</a> . </p>

</div>
</div>
<a class="anchor" id="a0c2c996fe2ba083972d91d2393461ea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::set_custom_do_par_for </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *, int(*)(void *, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *), int, int, <a class="el" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *)&#160;</td>
          <td class="paramname"><em>custom_do_par_for</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a custom parallel for loop launcher. </p>
<p>Useful if your app already manages a thread pool. The default implementation is equivalent to this: </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span> <a class="code" href="_halide_runtime_8h.html#a05193f80c8fc7df76ceadd82c4ce7b56">halide_do_par_for</a>(<span class="keywordtype">void</span> *user_context,</div>
<div class="line">                                 <span class="keywordtype">int</span> (*f)(<span class="keywordtype">void</span> *, <span class="keywordtype">int</span>, <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *),</div>
<div class="line">                                 <span class="keywordtype">int</span> min, <span class="keywordtype">int</span> extent, <a class="code" href="runtime__internal_8h.html#a5f44f30d12f5ed554d1bdb9825df6137">uint8_t</a> *state) {</div>
<div class="line">    <span class="keywordtype">int</span> exit_status = 0;</div>
<div class="line">    parallel <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = min; idx &lt; min+extent; idx++) {</div>
<div class="line">        <span class="keywordtype">int</span> job_status = halide_do_task(user_context, f, idx, state);</div>
<div class="line">        <span class="keywordflow">if</span> (job_status) exit_status = job_status;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> exit_status;</div>
<div class="line">}</div>
</div><!-- fragment --><p>However, notwithstanding the above example code, if one task fails, we may skip over other tasks, and if two tasks return different error codes, we may select one arbitrarily to return.</p>
<p>If you are statically compiling, you can also just define your own version of the above function, and it will clobber <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s version. </p>

</div>
</div>
<a class="anchor" id="a295c988571c212dda45aa9448f2c1192"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::set_custom_trace </td>
          <td>(</td>
          <td class="paramtype">int(*)(void *, const <a class="el" href="structhalide__trace__event.html">halide_trace_event</a> *)&#160;</td>
          <td class="paramname"><em>trace_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set custom routines to call when tracing is enabled. </p>
<p>Call this on the output <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> of your pipeline. This then sets custom routines for the entire pipeline, not just calls to this <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a>.</p>
<p>If you are statically compiling, you can also just define your own versions of the tracing functions (see <a class="el" href="_halide_runtime_8h.html" title="Set a custom malloc and free for halide to use. ">HalideRuntime.h</a>), and they will clobber <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s versions. </p>

</div>
</div>
<a class="anchor" id="a4ba003ee8ff1fd65fd866d6ccbfec613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::set_custom_print </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *, const char *)&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the function called to print messages from the runtime. </p>
<p>If you are compiling statically, you can also just define your own function with signature </p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> <a class="code" href="_halide_runtime_8h.html#a96fe1dd85166a7f0da1b8f82f734296a">halide_print</a>(<span class="keywordtype">void</span> *user_context, <span class="keyword">const</span> <span class="keywordtype">char</span> *);</div>
</div><!-- fragment --><p> This will clobber <a class="el" href="namespace_halide.html" title="Defines methods for solving equations. ">Halide</a>'s version. </p>

</div>
</div>
<a class="anchor" id="a91badb15852fc2eeaeba7cee3dc13377"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::set_jit_externs </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, <a class="el" href="struct_halide_1_1_j_i_t_extern.html">JITExtern</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>externs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install a set of external C functions or Funcs to satisfy dependencies introduced by HalideExtern and define_extern mechanisms. </p>
<p>These will be used by calls to realize, infer_bounds, and compile_jit. </p>

</div>
</div>
<a class="anchor" id="ad1b072e73bbcb9f0178f97f787d426ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::map&lt;std::string, <a class="el" href="struct_halide_1_1_j_i_t_extern.html">JITExtern</a>&gt;&amp; Halide::Pipeline::get_jit_externs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the map of previously installed externs. </p>
<p>Is an empty map unless set otherwise. </p>

</div>
</div>
<a class="anchor" id="adc0b4ee338780db27d4bac4a1eeff64b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="struct_halide_1_1_internal_1_1_j_i_t_handlers.html">Internal::JITHandlers</a>&amp; Halide::Pipeline::jit_handlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a struct containing the currently set custom functions used by JIT. </p>

</div>
</div>
<a class="anchor" id="af25d5deb7a3cebbbe45ca05044dabecd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Pipeline::add_custom_lowering_pass </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a custom pass to be used during lowering. </p>
<p>It is run after all other lowering passes. Can be used to verify properties of the lowered Stmt, instrument it with extra code, or otherwise modify it. The <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> takes ownership of the pass, and will call delete on it when the <a class="el" href="class_halide_1_1_func.html" title="A halide function. ">Func</a> goes out of scope. So don't pass a stack object, or share pass instances between multiple Funcs. </p>

<p>Definition at line <a class="el" href="_pipeline_8h_source.html#l00333">333</a> of file <a class="el" href="_pipeline_8h_source.html">Pipeline.h</a>.</p>

</div>
</div>
<a class="anchor" id="a746005c1f3818923647c8089c920cf55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::add_custom_lowering_pass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">Internal::IRMutator</a> *&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">Internal::IRMutator</a> *)&#160;</td>
          <td class="paramname"><em>deleter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a custom pass to be used during lowering, with the function that will be called to delete it also passed in. </p>
<p>Set it to NULL if you wish to retain ownership of the object. </p>

</div>
</div>
<a class="anchor" id="a3088a7ff87602e19f354fc9a28c727c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::clear_custom_lowering_passes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all previously-set custom lowering passes. </p>

</div>
</div>
<a class="anchor" id="a173fdaf866f329dbc29074a9fa7e28e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::vector&lt;<a class="el" href="struct_halide_1_1_custom_lowering_pass.html">CustomLoweringPass</a>&gt;&amp; Halide::Pipeline::custom_lowering_passes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the custom lowering passes. </p>

</div>
</div>
<a class="anchor" id="a2f0131e4dce2dbf9932c9e406a747b3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a> Halide::Pipeline::realize </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="runtime__internal_8h.html#a5de3601dbc6acc46bb8a0d9bc84dff5b">int32_t</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="struct_halide_1_1_target.html">Target</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="_pipeline_8h_source.html#l00377">realize()</a>.</p>

</div>
</div>
<a class="anchor" id="ad77b4a14078788b050717cc4c4e3f412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a> Halide::Pipeline::realize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="struct_halide_1_1_target.html">Target</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a776eeb8aeea26f0b8b70a91fd9d6c24e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a> Halide::Pipeline::realize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="struct_halide_1_1_target.html">Target</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aed6629e592e2d836b59e222dc35e554b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a> Halide::Pipeline::realize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="struct_halide_1_1_target.html">Target</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a87b50bab03a37a0716d025dac9502dd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_realization.html">Realization</a> Halide::Pipeline::realize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="struct_halide_1_1_target.html">Target</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aac17c684607dc5dee271019a3659b40a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::realize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="struct_halide_1_1_target.html">Target</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate this function into an existing allocated buffer or buffers. </p>
<p>If the buffer is also one of the arguments to the function, strange things may happen, as the pipeline isn't necessarily safe to run in-place. If you pass multiple buffers, they must have matching sizes. </p>

</div>
</div>
<a class="anchor" id="aec2fc2649e7753b1eff82f95ba3a36f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::realize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="struct_halide_1_1_target.html">Target</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate this function into an existing allocated buffer or buffers. </p>
<p>If the buffer is also one of the arguments to the function, strange things may happen, as the pipeline isn't necessarily safe to run in-place. If you pass multiple buffers, they must have matching sizes. </p>

</div>
</div>
<a class="anchor" id="a0bf2995d95108a2bd7e7cf8ab54efe45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> void Halide::Pipeline::realize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_image.html">Image</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_target.html">Target</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em> = <code><a class="el" href="struct_halide_1_1_target.html">Target</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate this function into an existing allocated buffer or buffers. </p>
<p>If the buffer is also one of the arguments to the function, strange things may happen, as the pipeline isn't necessarily safe to run in-place. If you pass multiple buffers, they must have matching sizes. </p>

<p>Definition at line <a class="el" href="_pipeline_8h_source.html#l00377">377</a> of file <a class="el" href="_pipeline_8h_source.html">Pipeline.h</a>.</p>

<p>References <a class="el" href="class_halide_1_1_image_base.html#a5bbd5216ab692601e742e258ea93a6a0">Halide::ImageBase::copy_to_host()</a>, and <a class="el" href="class_halide_1_1_pipeline.html#a2f0131e4dce2dbf9932c9e406a747b3c">realize()</a>.</p>

</div>
</div>
<a class="anchor" id="a55be371d5d44ca549cc1bc57ecb849a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::infer_input_bounds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a given size of output, or a given set of output buffers, determine the bounds required of all unbound ImageParams referenced. </p>
<p>Communicates the result by allocating new buffers of the appropriate size and binding them to the unbound ImageParams. </p>

</div>
</div>
<a class="anchor" id="a78c8aa83dfbf7d2792d0893af8ecf712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::infer_input_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_realization.html">Realization</a>&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a given size of output, or a given set of output buffers, determine the bounds required of all unbound ImageParams referenced. </p>
<p>Communicates the result by allocating new buffers of the appropriate size and binding them to the unbound ImageParams. </p>

</div>
</div>
<a class="anchor" id="aa16be8371089923cbb1c92a017d0ac52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::infer_input_bounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a given size of output, or a given set of output buffers, determine the bounds required of all unbound ImageParams referenced. </p>
<p>Communicates the result by allocating new buffers of the appropriate size and binding them to the unbound ImageParams. </p>

</div>
</div>
<a class="anchor" id="ae5a50b42de4840d03e0dbb72ccc19302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;<a class="el" href="struct_halide_1_1_argument.html">Argument</a>&gt; Halide::Pipeline::infer_arguments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the arguments to the <a class="el" href="class_halide_1_1_pipeline.html" title="A class representing a Halide pipeline. ">Pipeline</a>, sorted into a canonical order: all buffers (sorted alphabetically by name), followed by all non-buffers (sorted alphabetically by name). </p>
<p>This lets you write things like: </p>
<div class="fragment"><div class="line">pipeline.compile_to_assembly(<span class="stringliteral">&quot;/dev/stdout&quot;</span>, pipeline.infer_arguments());</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a71fbe5e7cb2cf3f9cf157b37c968ba61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Pipeline::defined </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if this pipeline object is defined. </p>
<p>That is, does it have any outputs? </p>

</div>
</div>
<a class="anchor" id="a506dbff346dd064b927fbcf3af52725d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Pipeline::invalidate_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate any internal cached state, e.g. </p>
<p>because Funcs have been rescheduled. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_pipeline_8h_source.html">Pipeline.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="class_halide_1_1_pipeline.html">Pipeline</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
