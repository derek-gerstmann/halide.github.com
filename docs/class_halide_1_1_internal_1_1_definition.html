<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: Halide::Internal::Definition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_halide_1_1_internal_1_1_definition.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_halide_1_1_internal_1_1_definition-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Internal::Definition Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition which can either represent a init or an update definition.  
 <a href="class_halide_1_1_internal_1_1_definition.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_definition_8h_source.html">Definition.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae5f7151aa60de3e8f721a13cf4ff32f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ae5f7151aa60de3e8f721a13cf4ff32f1">Definition</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; DefinitionContents &gt; &amp;)</td></tr>
<tr class="memdesc:ae5f7151aa60de3e8f721a13cf4ff32f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a> from an existing DefinitionContents pointer.  <a href="#ae5f7151aa60de3e8f721a13cf4ff32f1">More...</a><br/></td></tr>
<tr class="separator:ae5f7151aa60de3e8f721a13cf4ff32f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2e64336569e24182f6815eec96b9d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ada2e64336569e24182f6815eec96b9d4">Definition</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;<a class="el" href="class_halide_1_1_internal_1_1_definition.html#a5ced0baf1a003071dc5b9a831a35b140">args</a>, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;<a class="el" href="class_halide_1_1_internal_1_1_definition.html#ab2d0bc4bcc056d8dea11c105e49bee57">values</a>, const <a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a> &amp;rdom, bool <a class="el" href="class_halide_1_1_internal_1_1_definition.html#a2a6a0d7d6784ee363b9c37b2a0dc3e86">is_init</a>)</td></tr>
<tr class="memdesc:ada2e64336569e24182f6815eec96b9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a> with the supplied args, values, and reduction domain.  <a href="#ada2e64336569e24182f6815eec96b9d4">More...</a><br/></td></tr>
<tr class="separator:ada2e64336569e24182f6815eec96b9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f7dc66f19ed397731906b960804071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aa7f7dc66f19ed397731906b960804071">Definition</a> ()</td></tr>
<tr class="memdesc:aa7f7dc66f19ed397731906b960804071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a>.  <a href="#aa7f7dc66f19ed397731906b960804071">More...</a><br/></td></tr>
<tr class="separator:aa7f7dc66f19ed397731906b960804071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5a31a914f5474cd51f932a26f3f5e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ace5a31a914f5474cd51f932a26f3f5e1">deep_copy</a> (std::map&lt; <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; FunctionContents &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; FunctionContents &gt;&gt; &amp;copied_map) const </td></tr>
<tr class="memdesc:ace5a31a914f5474cd51f932a26f3f5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deep copy of this <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a>.  <a href="#ace5a31a914f5474cd51f932a26f3f5e1">More...</a><br/></td></tr>
<tr class="separator:ace5a31a914f5474cd51f932a26f3f5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec621677ca750b7ee30386daab35bca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a0ec621677ca750b7ee30386daab35bca">same_as</a> (const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;other) const </td></tr>
<tr class="memdesc:a0ec621677ca750b7ee30386daab35bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality of identity.  <a href="#a0ec621677ca750b7ee30386daab35bca">More...</a><br/></td></tr>
<tr class="separator:a0ec621677ca750b7ee30386daab35bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6a0d7d6784ee363b9c37b2a0dc3e86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a2a6a0d7d6784ee363b9c37b2a0dc3e86">is_init</a> () const </td></tr>
<tr class="memdesc:a2a6a0d7d6784ee363b9c37b2a0dc3e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an init definition; otherwise it's an update definition.  <a href="#a2a6a0d7d6784ee363b9c37b2a0dc3e86">More...</a><br/></td></tr>
<tr class="separator:a2a6a0d7d6784ee363b9c37b2a0dc3e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ed05b0f55a778eb6ff0cc5edfc247c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a13ed05b0f55a778eb6ff0cc5edfc247c">accept</a> (<a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a> *) const </td></tr>
<tr class="memdesc:a13ed05b0f55a778eb6ff0cc5edfc247c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR. ">IRVisitor</a> through to all Exprs referenced in the definition.  <a href="#a13ed05b0f55a778eb6ff0cc5edfc247c">More...</a><br/></td></tr>
<tr class="separator:a13ed05b0f55a778eb6ff0cc5edfc247c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de7f4d76339d93b4338c1ed48fb75f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a6de7f4d76339d93b4338c1ed48fb75f3">mutate</a> (<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> *)</td></tr>
<tr class="memdesc:a6de7f4d76339d93b4338c1ed48fb75f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html" title="A base class for passes over the IR which modify it (e.g. ">IRMutator</a> through to all Exprs referenced in the definition.  <a href="#a6de7f4d76339d93b4338c1ed48fb75f3">More...</a><br/></td></tr>
<tr class="separator:a6de7f4d76339d93b4338c1ed48fb75f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604294afe2ce5ea320b43039928d2510"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a604294afe2ce5ea320b43039928d2510">split_predicate</a> () const </td></tr>
<tr class="memdesc:a604294afe2ce5ea320b43039928d2510"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> predicate into vector of ANDs.  <a href="#a604294afe2ce5ea320b43039928d2510">More...</a><br/></td></tr>
<tr class="separator:a604294afe2ce5ea320b43039928d2510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5ced0baf1a003071dc5b9a831a35b140"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a5ced0baf1a003071dc5b9a831a35b140">args</a> () const </td></tr>
<tr class="memdesc:a5ced0baf1a003071dc5b9a831a35b140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) arguments (left-hand-side) of the definition.  <a href="#a5ced0baf1a003071dc5b9a831a35b140">More...</a><br/></td></tr>
<tr class="separator:a5ced0baf1a003071dc5b9a831a35b140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4875343613fadef83aeae524512fe5e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ad4875343613fadef83aeae524512fe5e">args</a> ()</td></tr>
<tr class="memdesc:ad4875343613fadef83aeae524512fe5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) arguments (left-hand-side) of the definition.  <a href="#ad4875343613fadef83aeae524512fe5e">More...</a><br/></td></tr>
<tr class="separator:ad4875343613fadef83aeae524512fe5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab2d0bc4bcc056d8dea11c105e49bee57"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ab2d0bc4bcc056d8dea11c105e49bee57">values</a> () const </td></tr>
<tr class="memdesc:ab2d0bc4bcc056d8dea11c105e49bee57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) right-hand-side of the definition.  <a href="#ab2d0bc4bcc056d8dea11c105e49bee57">More...</a><br/></td></tr>
<tr class="separator:ab2d0bc4bcc056d8dea11c105e49bee57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dafa96f3f679c0cb44d9448d83d5e06"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a9dafa96f3f679c0cb44d9448d83d5e06">values</a> ()</td></tr>
<tr class="memdesc:a9dafa96f3f679c0cb44d9448d83d5e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) right-hand-side of the definition.  <a href="#a9dafa96f3f679c0cb44d9448d83d5e06">More...</a><br/></td></tr>
<tr class="separator:a9dafa96f3f679c0cb44d9448d83d5e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa60fa1dcd23a3f1449bfcdbce0453ebf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aa60fa1dcd23a3f1449bfcdbce0453ebf">predicate</a> () const </td></tr>
<tr class="memdesc:aa60fa1dcd23a3f1449bfcdbce0453ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the predicate on the definition.  <a href="#aa60fa1dcd23a3f1449bfcdbce0453ebf">More...</a><br/></td></tr>
<tr class="separator:aa60fa1dcd23a3f1449bfcdbce0453ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa364f6c2b3aa0f2fd031b48b52566168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aa364f6c2b3aa0f2fd031b48b52566168">predicate</a> ()</td></tr>
<tr class="memdesc:aa364f6c2b3aa0f2fd031b48b52566168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the predicate on the definition.  <a href="#aa364f6c2b3aa0f2fd031b48b52566168">More...</a><br/></td></tr>
<tr class="separator:aa364f6c2b3aa0f2fd031b48b52566168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a109966779391f8778119e5ed69443613"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_halide_1_1_internal_1_1_schedule.html">Schedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a109966779391f8778119e5ed69443613">schedule</a> () const </td></tr>
<tr class="memdesc:a109966779391f8778119e5ed69443613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) schedule associated with this definition.  <a href="#a109966779391f8778119e5ed69443613">More...</a><br/></td></tr>
<tr class="separator:a109966779391f8778119e5ed69443613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d111c429d82e91e4c4786d0fe6fe1b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_internal_1_1_schedule.html">Schedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a6d111c429d82e91e4c4786d0fe6fe1b6">schedule</a> ()</td></tr>
<tr class="memdesc:a6d111c429d82e91e4c4786d0fe6fe1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) schedule associated with this definition.  <a href="#a6d111c429d82e91e4c4786d0fe6fe1b6">More...</a><br/></td></tr>
<tr class="separator:a6d111c429d82e91e4c4786d0fe6fe1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a59f789bada5353773f07c1adbe891c09"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; <a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a59f789bada5353773f07c1adbe891c09">specializations</a> () const </td></tr>
<tr class="memdesc:a59f789bada5353773f07c1adbe891c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may create several specialized versions of a func with different schedules.  <a href="#a59f789bada5353773f07c1adbe891c09">More...</a><br/></td></tr>
<tr class="separator:a59f789bada5353773f07c1adbe891c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48069f34b6ce2c3e8c9cc7b23bbf1af"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aa48069f34b6ce2c3e8c9cc7b23bbf1af">specializations</a> ()</td></tr>
<tr class="memdesc:aa48069f34b6ce2c3e8c9cc7b23bbf1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may create several specialized versions of a func with different schedules.  <a href="#aa48069f34b6ce2c3e8c9cc7b23bbf1af">More...</a><br/></td></tr>
<tr class="separator:aa48069f34b6ce2c3e8c9cc7b23bbf1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeceee5e0023aaa27c790d07d2fbe9543"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aeceee5e0023aaa27c790d07d2fbe9543">add_specialization</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition)</td></tr>
<tr class="memdesc:aeceee5e0023aaa27c790d07d2fbe9543"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may create several specialized versions of a func with different schedules.  <a href="#aeceee5e0023aaa27c790d07d2fbe9543">More...</a><br/></td></tr>
<tr class="separator:aeceee5e0023aaa27c790d07d2fbe9543"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition which can either represent a init or an update definition. </p>
<p>A function may have different definitions due to specialization, which are stored in 'specializations' (<a class="el" href="struct_halide_1_1_internal_1_1_not.html" title="Logical not - true if the expression false. ">Not</a> possible from the front-end, but some scheduling directives may potentially cause this divergence to occur). Although init definition may have multiple values (RHS) per specialization, it must have the same LHS (i.e. same pure dimension variables). The update definition, on the other hand, may have different LHS/RHS per specialization. Note that, while the <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> in LHS/RHS may be different across specializations, they must have the same number of dimensions and the same pure dimensions. </p>

<p>Definition at line <a class="el" href="_definition_8h_source.html#l00038">38</a> of file <a class="el" href="_definition_8h_source.html">Definition.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae5f7151aa60de3e8f721a13cf4ff32f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Internal::Definition::Definition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; DefinitionContents &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a> from an existing DefinitionContents pointer. </p>
<p>Must be non-null </p>

</div>
</div>
<a class="anchor" id="ada2e64336569e24182f6815eec96b9d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Internal::Definition::Definition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a> &amp;&#160;</td>
          <td class="paramname"><em>rdom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a> with the supplied args, values, and reduction domain. </p>

</div>
</div>
<a class="anchor" id="aa7f7dc66f19ed397731906b960804071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Internal::Definition::Definition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a>. </p>
<p>By default, it is a init definition. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ace5a31a914f5474cd51f932a26f3f5e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> Halide::Internal::Definition::deep_copy </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; FunctionContents &gt;, <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; FunctionContents &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>copied_map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a deep copy of this <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a>. </p>
<p>It recursively deep copies all called functions, schedules, and reduction domains. This method takes a map of &lt;old FunctionContents, deep-copied version&gt; as input and would use the deep-copied FunctionContents from the map if exists instead of creating a new deep-copy to avoid creating deep-copies of the same FunctionContents multiple times. </p>

</div>
</div>
<a class="anchor" id="a0ec621677ca750b7ee30386daab35bca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Definition::same_as </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality of identity. </p>

<p>Definition at line <a class="el" href="_definition_8h_source.html#l00064">64</a> of file <a class="el" href="_definition_8h_source.html">Definition.h</a>.</p>

<p>References <a class="el" href="_intrusive_ptr_8h_source.html#l00145">Halide::Internal::IntrusivePtr&lt; T &gt;::same_as()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a6a0d7d6784ee363b9c37b2a0dc3e86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Definition::is_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this an init definition; otherwise it's an update definition. </p>

</div>
</div>
<a class="anchor" id="a13ed05b0f55a778eb6ff0cc5edfc247c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Definition::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR. ">IRVisitor</a> through to all Exprs referenced in the definition. </p>

</div>
</div>
<a class="anchor" id="a6de7f4d76339d93b4338c1ed48fb75f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Internal::Definition::mutate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html">IRMutator</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator.html" title="A base class for passes over the IR which modify it (e.g. ">IRMutator</a> through to all Exprs referenced in the definition. </p>

</div>
</div>
<a class="anchor" id="a5ced0baf1a003071dc5b9a831a35b140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; Halide::Internal::Definition::args </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) arguments (left-hand-side) of the definition. </p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l00064">Halide::Stage::Stage()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4875343613fadef83aeae524512fe5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; Halide::Internal::Definition::args </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) arguments (left-hand-side) of the definition. </p>

</div>
</div>
<a class="anchor" id="ab2d0bc4bcc056d8dea11c105e49bee57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; Halide::Internal::Definition::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) right-hand-side of the definition. </p>

</div>
</div>
<a class="anchor" id="a9dafa96f3f679c0cb44d9448d83d5e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; Halide::Internal::Definition::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) right-hand-side of the definition. </p>

</div>
</div>
<a class="anchor" id="aa60fa1dcd23a3f1449bfcdbce0453ebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::Internal::Definition::predicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the predicate on the definition. </p>

</div>
</div>
<a class="anchor" id="aa364f6c2b3aa0f2fd031b48b52566168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::Internal::Definition::predicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the predicate on the definition. </p>

</div>
</div>
<a class="anchor" id="a604294afe2ce5ea320b43039928d2510"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; Halide::Internal::Definition::split_predicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> predicate into vector of ANDs. </p>
<p>If there is no predicate (i.e. this definition is always valid), this returns an empty vector. </p>

</div>
</div>
<a class="anchor" id="a109966779391f8778119e5ed69443613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_halide_1_1_internal_1_1_schedule.html">Schedule</a>&amp; Halide::Internal::Definition::schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) schedule associated with this definition. </p>

<p>Referenced by <a class="el" href="_func_8h_source.html#l00086">Halide::Stage::get_schedule()</a>, and <a class="el" href="_func_8h_source.html#l00064">Halide::Stage::Stage()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d111c429d82e91e4c4786d0fe6fe1b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_internal_1_1_schedule.html">Schedule</a>&amp; Halide::Internal::Definition::schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) schedule associated with this definition. </p>

</div>
</div>
<a class="anchor" id="a59f789bada5353773f07c1adbe891c09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a>&gt;&amp; Halide::Internal::Definition::specializations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You may create several specialized versions of a func with different schedules. </p>
<p>They trigger when the condition is true. See <a class="el" href="class_halide_1_1_func.html#aa4053da66218dfd7769ea4d974e252b5">Func::specialize</a> </p>

</div>
</div>
<a class="anchor" id="aa48069f34b6ce2c3e8c9cc7b23bbf1af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a>&gt;&amp; Halide::Internal::Definition::specializations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You may create several specialized versions of a func with different schedules. </p>
<p>They trigger when the condition is true. See <a class="el" href="class_halide_1_1_func.html#aa4053da66218dfd7769ea4d974e252b5">Func::specialize</a> </p>

</div>
</div>
<a class="anchor" id="aeceee5e0023aaa27c790d07d2fbe9543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a>&amp; Halide::Internal::Definition::add_specialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You may create several specialized versions of a func with different schedules. </p>
<p>They trigger when the condition is true. See <a class="el" href="class_halide_1_1_func.html#aa4053da66218dfd7769ea4d974e252b5">Func::specialize</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_definition_8h_source.html">Definition.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li><li class="navelem"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
