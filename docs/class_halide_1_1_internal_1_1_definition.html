<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Internal::Definition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_halide_1_1_internal_1_1_definition.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_halide_1_1_internal_1_1_definition-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Internal::Definition Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition which can either represent a init or an update definition.  
 <a href="class_halide_1_1_internal_1_1_definition.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_definition_8h_source.html">Definition.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae5f7151aa60de3e8f721a13cf4ff32f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ae5f7151aa60de3e8f721a13cf4ff32f1">Definition</a> (const <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; DefinitionContents &gt; &amp;)</td></tr>
<tr class="memdesc:ae5f7151aa60de3e8f721a13cf4ff32f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a> from an existing DefinitionContents pointer.  <a href="#ae5f7151aa60de3e8f721a13cf4ff32f1">More...</a><br /></td></tr>
<tr class="separator:ae5f7151aa60de3e8f721a13cf4ff32f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2e64336569e24182f6815eec96b9d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ada2e64336569e24182f6815eec96b9d4">Definition</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;<a class="el" href="class_halide_1_1_internal_1_1_definition.html#adc9147319148acacb3a10e04ce8039b0">args</a>, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;<a class="el" href="class_halide_1_1_internal_1_1_definition.html#ae4bf72bbabeab90237bd21b70b17ac50">values</a>, const <a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a> &amp;rdom, bool <a class="el" href="class_halide_1_1_internal_1_1_definition.html#a72a98a7daac21adf216c40d9e4c09928">is_init</a>)</td></tr>
<tr class="memdesc:ada2e64336569e24182f6815eec96b9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a> with the supplied args, values, and reduction domain.  <a href="#ada2e64336569e24182f6815eec96b9d4">More...</a><br /></td></tr>
<tr class="separator:ada2e64336569e24182f6815eec96b9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f7dc66f19ed397731906b960804071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aa7f7dc66f19ed397731906b960804071">Definition</a> ()</td></tr>
<tr class="memdesc:aa7f7dc66f19ed397731906b960804071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a>.  <a href="#aa7f7dc66f19ed397731906b960804071">More...</a><br /></td></tr>
<tr class="separator:aa7f7dc66f19ed397731906b960804071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4293f54f6d799bf72514f337095356d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a4293f54f6d799bf72514f337095356d1">get_copy</a> () const</td></tr>
<tr class="memdesc:a4293f54f6d799bf72514f337095356d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of this <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a>.  <a href="#a4293f54f6d799bf72514f337095356d1">More...</a><br /></td></tr>
<tr class="separator:a4293f54f6d799bf72514f337095356d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240ca6e22ff4a6796240659f1cd58196"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a240ca6e22ff4a6796240659f1cd58196">same_as</a> (const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;other) const</td></tr>
<tr class="memdesc:a240ca6e22ff4a6796240659f1cd58196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality of identity.  <a href="#a240ca6e22ff4a6796240659f1cd58196">More...</a><br /></td></tr>
<tr class="separator:a240ca6e22ff4a6796240659f1cd58196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a98a7daac21adf216c40d9e4c09928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a72a98a7daac21adf216c40d9e4c09928">is_init</a> () const</td></tr>
<tr class="memdesc:a72a98a7daac21adf216c40d9e4c09928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an init definition; otherwise it's an update definition.  <a href="#a72a98a7daac21adf216c40d9e4c09928">More...</a><br /></td></tr>
<tr class="separator:a72a98a7daac21adf216c40d9e4c09928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df172c5c0ff110119daf24f8a74637a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a8df172c5c0ff110119daf24f8a74637a">accept</a> (<a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a> *) const</td></tr>
<tr class="memdesc:a8df172c5c0ff110119daf24f8a74637a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR. ">IRVisitor</a> through to all Exprs referenced in the definition.  <a href="#a8df172c5c0ff110119daf24f8a74637a">More...</a><br /></td></tr>
<tr class="separator:a8df172c5c0ff110119daf24f8a74637a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a039ce896f57d800140da107def8122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a9a039ce896f57d800140da107def8122">mutate</a> (<a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html">IRMutator2</a> *)</td></tr>
<tr class="memdesc:a9a039ce896f57d800140da107def8122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html" title="A base class for passes over the IR which modify it (e.g. ">IRMutator2</a> through to all Exprs referenced in the definition.  <a href="#a9a039ce896f57d800140da107def8122">More...</a><br /></td></tr>
<tr class="separator:a9a039ce896f57d800140da107def8122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52e5cadac66b996685c774c8713e92a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ac52e5cadac66b996685c774c8713e92a">split_predicate</a> () const</td></tr>
<tr class="memdesc:ac52e5cadac66b996685c774c8713e92a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> predicate into vector of ANDs.  <a href="#ac52e5cadac66b996685c774c8713e92a">More...</a><br /></td></tr>
<tr class="separator:ac52e5cadac66b996685c774c8713e92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adc9147319148acacb3a10e04ce8039b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#adc9147319148acacb3a10e04ce8039b0">args</a> () const</td></tr>
<tr class="memdesc:adc9147319148acacb3a10e04ce8039b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) arguments (left-hand-side) of the definition.  <a href="#adc9147319148acacb3a10e04ce8039b0">More...</a><br /></td></tr>
<tr class="separator:adc9147319148acacb3a10e04ce8039b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab183925095510816930580beb77032ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ab183925095510816930580beb77032ed">args</a> ()</td></tr>
<tr class="memdesc:ab183925095510816930580beb77032ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) arguments (left-hand-side) of the definition.  <a href="#ab183925095510816930580beb77032ed">More...</a><br /></td></tr>
<tr class="separator:ab183925095510816930580beb77032ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae4bf72bbabeab90237bd21b70b17ac50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#ae4bf72bbabeab90237bd21b70b17ac50">values</a> () const</td></tr>
<tr class="memdesc:ae4bf72bbabeab90237bd21b70b17ac50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) right-hand-side of the definition.  <a href="#ae4bf72bbabeab90237bd21b70b17ac50">More...</a><br /></td></tr>
<tr class="separator:ae4bf72bbabeab90237bd21b70b17ac50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8173f999d279d7ca829d117227dee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a2c8173f999d279d7ca829d117227dee7">values</a> ()</td></tr>
<tr class="memdesc:a2c8173f999d279d7ca829d117227dee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) right-hand-side of the definition.  <a href="#a2c8173f999d279d7ca829d117227dee7">More...</a><br /></td></tr>
<tr class="separator:a2c8173f999d279d7ca829d117227dee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a436011aafffe372fae84ebef3ed49075"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a436011aafffe372fae84ebef3ed49075">predicate</a> () const</td></tr>
<tr class="memdesc:a436011aafffe372fae84ebef3ed49075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the predicate on the definition.  <a href="#a436011aafffe372fae84ebef3ed49075">More...</a><br /></td></tr>
<tr class="separator:a436011aafffe372fae84ebef3ed49075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a05478059eba2e79d085137b2343522"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a4a05478059eba2e79d085137b2343522">predicate</a> ()</td></tr>
<tr class="memdesc:a4a05478059eba2e79d085137b2343522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the predicate on the definition.  <a href="#a4a05478059eba2e79d085137b2343522">More...</a><br /></td></tr>
<tr class="separator:a4a05478059eba2e79d085137b2343522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a33e263c6d6086b113afb3ecb6ec21c79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a33e263c6d6086b113afb3ecb6ec21c79">schedule</a> () const</td></tr>
<tr class="memdesc:a33e263c6d6086b113afb3ecb6ec21c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) stage-specific schedule associated with this definition.  <a href="#a33e263c6d6086b113afb3ecb6ec21c79">More...</a><br /></td></tr>
<tr class="separator:a33e263c6d6086b113afb3ecb6ec21c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d5f7272b8bf653a09d612b851f0466"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a09d5f7272b8bf653a09d612b851f0466">schedule</a> ()</td></tr>
<tr class="memdesc:a09d5f7272b8bf653a09d612b851f0466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default (no-specialization) stage-specific schedule associated with this definition.  <a href="#a09d5f7272b8bf653a09d612b851f0466">More...</a><br /></td></tr>
<tr class="separator:a09d5f7272b8bf653a09d612b851f0466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a99a849d602bf5d675161fa1d8382eb7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a99a849d602bf5d675161fa1d8382eb7b">specializations</a> () const</td></tr>
<tr class="memdesc:a99a849d602bf5d675161fa1d8382eb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may create several specialized versions of a func with different stage-specific schedules.  <a href="#a99a849d602bf5d675161fa1d8382eb7b">More...</a><br /></td></tr>
<tr class="separator:a99a849d602bf5d675161fa1d8382eb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9494e471be4f44e86dbbda9542c79a54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt; <a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#a9494e471be4f44e86dbbda9542c79a54">specializations</a> ()</td></tr>
<tr class="memdesc:a9494e471be4f44e86dbbda9542c79a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may create several specialized versions of a func with different stage-specific schedules.  <a href="#a9494e471be4f44e86dbbda9542c79a54">More...</a><br /></td></tr>
<tr class="separator:a9494e471be4f44e86dbbda9542c79a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f81223fbb379d15c27b2fdafb47824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_internal_1_1_definition.html#aa7f81223fbb379d15c27b2fdafb47824">add_specialization</a> (<a class="el" href="struct_halide_1_1_expr.html">Expr</a> condition)</td></tr>
<tr class="memdesc:aa7f81223fbb379d15c27b2fdafb47824"><td class="mdescLeft">&#160;</td><td class="mdescRight">You may create several specialized versions of a func with different stage-specific schedules.  <a href="#aa7f81223fbb379d15c27b2fdafb47824">More...</a><br /></td></tr>
<tr class="separator:aa7f81223fbb379d15c27b2fdafb47824"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function. ">Function</a> definition which can either represent a init or an update definition. </p>
<p>A function may have different definitions due to specialization, which are stored in 'specializations' (<a class="el" href="struct_halide_1_1_internal_1_1_not.html" title="Logical not - true if the expression false. ">Not</a> possible from the front-end, but some scheduling directives may potentially cause this divergence to occur). Although init definition may have multiple values (RHS) per specialization, it must have the same LHS (i.e. same pure dimension variables). The update definition, on the other hand, may have different LHS/RHS per specialization. Note that, while the <a class="el" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax. ">Expr</a> in LHS/RHS may be different across specializations, they must have the same number of dimensions and the same pure dimensions. </p>

<p class="definition">Definition at line <a class="el" href="_definition_8h_source.html#l00038">38</a> of file <a class="el" href="_definition_8h_source.html">Definition.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae5f7151aa60de3e8f721a13cf4ff32f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f7151aa60de3e8f721a13cf4ff32f1">&#9670;&nbsp;</a></span>Definition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Internal::Definition::Definition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_internal_1_1_intrusive_ptr.html">IntrusivePtr</a>&lt; DefinitionContents &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a> from an existing DefinitionContents pointer. </p>
<p>Must be non-null </p>

</div>
</div>
<a id="ada2e64336569e24182f6815eec96b9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2e64336569e24182f6815eec96b9d4">&#9670;&nbsp;</a></span>Definition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Internal::Definition::Definition </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_reduction_domain.html">ReductionDomain</a> &amp;&#160;</td>
          <td class="paramname"><em>rdom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a> with the supplied args, values, and reduction domain. </p>

</div>
</div>
<a id="aa7f7dc66f19ed397731906b960804071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f7dc66f19ed397731906b960804071">&#9670;&nbsp;</a></span>Definition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Halide::Internal::Definition::Definition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a>. </p>
<p>By default, it is a init definition. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4293f54f6d799bf72514f337095356d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4293f54f6d799bf72514f337095356d1">&#9670;&nbsp;</a></span>get_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> Halide::Internal::Definition::get_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of this <a class="el" href="class_halide_1_1_internal_1_1_definition.html" title="A Function definition which can either represent a init or an update definition. ">Definition</a>. </p>

</div>
</div>
<a id="a240ca6e22ff4a6796240659f1cd58196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240ca6e22ff4a6796240659f1cd58196">&#9670;&nbsp;</a></span>same_as()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Halide::Internal::Definition::same_as </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality of identity. </p>

<p class="definition">Definition at line <a class="el" href="_definition_8h_source.html#l00057">57</a> of file <a class="el" href="_definition_8h_source.html">Definition.h</a>.</p>

<p class="reference">References <a class="el" href="_util_8h_source.html#l00030">EXPORT</a>, and <a class="el" href="_intrusive_ptr_8h_source.html#l00145">Halide::Internal::IntrusivePtr&lt; T &gt;::same_as()</a>.</p>

</div>
</div>
<a id="a72a98a7daac21adf216c40d9e4c09928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a98a7daac21adf216c40d9e4c09928">&#9670;&nbsp;</a></span>is_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> bool Halide::Internal::Definition::is_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this an init definition; otherwise it's an update definition. </p>

</div>
</div>
<a id="a8df172c5c0ff110119daf24f8a74637a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df172c5c0ff110119daf24f8a74637a">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::Definition::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html">IRVisitor</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_visitor.html" title="A base class for algorithms that need to recursively walk over the IR. ">IRVisitor</a> through to all Exprs referenced in the definition. </p>

</div>
</div>
<a id="a9a039ce896f57d800140da107def8122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a039ce896f57d800140da107def8122">&#9670;&nbsp;</a></span>mutate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void Halide::Internal::Definition::mutate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html">IRMutator2</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass an <a class="el" href="class_halide_1_1_internal_1_1_i_r_mutator2.html" title="A base class for passes over the IR which modify it (e.g. ">IRMutator2</a> through to all Exprs referenced in the definition. </p>

</div>
</div>
<a id="adc9147319148acacb3a10e04ce8039b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9147319148acacb3a10e04ce8039b0">&#9670;&nbsp;</a></span>args() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; Halide::Internal::Definition::args </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) arguments (left-hand-side) of the definition. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l00070">Halide::Stage::Stage()</a>.</p>

</div>
</div>
<a id="ab183925095510816930580beb77032ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab183925095510816930580beb77032ed">&#9670;&nbsp;</a></span>args() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; Halide::Internal::Definition::args </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) arguments (left-hand-side) of the definition. </p>

</div>
</div>
<a id="ae4bf72bbabeab90237bd21b70b17ac50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bf72bbabeab90237bd21b70b17ac50">&#9670;&nbsp;</a></span>values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; Halide::Internal::Definition::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) right-hand-side of the definition. </p>

</div>
</div>
<a id="a2c8173f999d279d7ca829d117227dee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8173f999d279d7ca829d117227dee7">&#9670;&nbsp;</a></span>values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt;&amp; Halide::Internal::Definition::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) right-hand-side of the definition. </p>

</div>
</div>
<a id="a436011aafffe372fae84ebef3ed49075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436011aafffe372fae84ebef3ed49075">&#9670;&nbsp;</a></span>predicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::Internal::Definition::predicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the predicate on the definition. </p>

</div>
</div>
<a id="a4a05478059eba2e79d085137b2343522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a05478059eba2e79d085137b2343522">&#9670;&nbsp;</a></span>predicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="struct_halide_1_1_expr.html">Expr</a>&amp; Halide::Internal::Definition::predicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the predicate on the definition. </p>

</div>
</div>
<a id="ac52e5cadac66b996685c774c8713e92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52e5cadac66b996685c774c8713e92a">&#9670;&nbsp;</a></span>split_predicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;<a class="el" href="struct_halide_1_1_expr.html">Expr</a>&gt; Halide::Internal::Definition::split_predicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_halide_1_1_internal_1_1_split.html">Split</a> predicate into vector of ANDs. </p>
<p>If there is no predicate (i.e. this definition is always valid), this returns an empty vector. </p>

</div>
</div>
<a id="a33e263c6d6086b113afb3ecb6ec21c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e263c6d6086b113afb3ecb6ec21c79">&#9670;&nbsp;</a></span>schedule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a>&amp; Halide::Internal::Definition::schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) stage-specific schedule associated with this definition. </p>

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l00091">Halide::Stage::get_schedule()</a>, and <a class="el" href="_func_8h_source.html#l00070">Halide::Stage::Stage()</a>.</p>

</div>
</div>
<a id="a09d5f7272b8bf653a09d612b851f0466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d5f7272b8bf653a09d612b851f0466">&#9670;&nbsp;</a></span>schedule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">StageSchedule</a>&amp; Halide::Internal::Definition::schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default (no-specialization) stage-specific schedule associated with this definition. </p>

</div>
</div>
<a id="a99a849d602bf5d675161fa1d8382eb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a849d602bf5d675161fa1d8382eb7b">&#9670;&nbsp;</a></span>specializations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a>&gt;&amp; Halide::Internal::Definition::specializations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You may create several specialized versions of a func with different stage-specific schedules. </p>
<p>They trigger when the condition is true. See <a class="el" href="class_halide_1_1_func.html#aa4053da66218dfd7769ea4d974e252b5">Func::specialize</a> </p>

</div>
</div>
<a id="a9494e471be4f44e86dbbda9542c79a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9494e471be4f44e86dbbda9542c79a54">&#9670;&nbsp;</a></span>specializations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;<a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a>&gt;&amp; Halide::Internal::Definition::specializations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You may create several specialized versions of a func with different stage-specific schedules. </p>
<p>They trigger when the condition is true. See <a class="el" href="class_halide_1_1_func.html#aa4053da66218dfd7769ea4d974e252b5">Func::specialize</a> </p>

</div>
</div>
<a id="aa7f81223fbb379d15c27b2fdafb47824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f81223fbb379d15c27b2fdafb47824">&#9670;&nbsp;</a></span>add_specialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> const <a class="el" href="struct_halide_1_1_internal_1_1_specialization.html">Specialization</a>&amp; Halide::Internal::Definition::add_specialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>You may create several specialized versions of a func with different stage-specific schedules. </p>
<p>They trigger when the condition is true. See <a class="el" href="class_halide_1_1_func.html#aa4053da66218dfd7769ea4d974e252b5">Func::specialize</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_definition_8h_source.html">Definition.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_internal.html">Internal</a></li><li class="navelem"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Definition</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
