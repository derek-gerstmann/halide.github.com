<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Halide: BoundaryConditions.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_boundary_conditions_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BoundaryConditions.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Support for imposing boundary conditions on Halide::Funcs.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;utility&gt;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
<code>#include &quot;<a class="el" href="_func_8h_source.html">Func.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="_i_r_8h_source.html">IR.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="_util_8h_source.html">Util.h</a>&quot;</code><br/>
</div>
<p><a href="_boundary_conditions_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html">Halide::BoundaryConditions</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>namespace to hold functions for imposing boundary conditions on <a class="el" href="namespace_halide.html">Halide</a> Funcs. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html">Halide::BoundaryConditions::Internal</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const Func &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html#a72afc90ec442417063c57e86a026ef6d">Halide::BoundaryConditions::Internal::func_like_to_func</a> (const Func &amp;func)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html#a0fcb54fabb83dbd2b7ac895a18065324">Halide::BoundaryConditions::Internal::func_like_to_func</a> (T func_like)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8e9c2da541218897745d9e9c0cddc8b5">Halide::BoundaryConditions::constant_exterior</a> (const Func &amp;source, Expr value, const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a8e9c2da541218897745d9e9c0cddc8b5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a512a3c08519c723659107821c61a0e8e">Halide::BoundaryConditions::constant_exterior</a> (T func_like, Expr value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a512a3c08519c723659107821c61a0e8e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a3494490c65e4c166ad8c8ac2448826b6">Halide::BoundaryConditions::constant_exterior</a> (T func_like, Expr value, Expr min0, Expr extent0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a3494490c65e4c166ad8c8ac2448826b6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a72fcf28c5f020f3c4a7243da08229fee">Halide::BoundaryConditions::constant_exterior</a> (T func_like, Expr value, Expr min0, Expr extent0, Expr min1, Expr extent1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a72fcf28c5f020f3c4a7243da08229fee"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a98e4ccc1fc43f95a2429bddcd135af93">Halide::BoundaryConditions::constant_exterior</a> (T func_like, Expr value, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a98e4ccc1fc43f95a2429bddcd135af93"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a0ed2c1c99a56efdf55e743ffee0a944e">Halide::BoundaryConditions::constant_exterior</a> (T func_like, Expr value, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a0ed2c1c99a56efdf55e743ffee0a944e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a21f73b3931776fae35272b5ecb81d334">Halide::BoundaryConditions::constant_exterior</a> (T func_like, Expr value, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a21f73b3931776fae35272b5ecb81d334"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2902d989503f56800196282a956f2d2a">Halide::BoundaryConditions::constant_exterior</a> (T func_like, Expr value, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4, Expr min5, Expr extent5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="#a2902d989503f56800196282a956f2d2a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2432026c4f3e024c2f0082e700bef4f2">Halide::BoundaryConditions::repeat_edge</a> (const Func &amp;source, const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#a2432026c4f3e024c2f0082e700bef4f2"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#aa5497265a7aa443a6ba8bb6f8843ec57">Halide::BoundaryConditions::repeat_edge</a> (T func_like)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#aa5497265a7aa443a6ba8bb6f8843ec57"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#afffb3729f3334a6d64c2c2441ee20dd8">Halide::BoundaryConditions::repeat_edge</a> (T func_like, Expr min0, Expr extent0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#afffb3729f3334a6d64c2c2441ee20dd8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a528e3317346e9a642014614e9ca2d3f1">Halide::BoundaryConditions::repeat_edge</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#a528e3317346e9a642014614e9ca2d3f1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a7c3e4c6bf9cbac6ddd7256a3b44aebfb">Halide::BoundaryConditions::repeat_edge</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#a7c3e4c6bf9cbac6ddd7256a3b44aebfb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a69c4ae257ac89aa24d57b7ecea607f49">Halide::BoundaryConditions::repeat_edge</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#a69c4ae257ac89aa24d57b7ecea607f49"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9eaa40a7033f44978af8f317fb9e26c6">Halide::BoundaryConditions::repeat_edge</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#a9eaa40a7033f44978af8f317fb9e26c6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#adb99ec97e80ae6479c91214c71fe44f9">Halide::BoundaryConditions::repeat_edge</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4, Expr min5, Expr extent5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="#adb99ec97e80ae6479c91214c71fe44f9"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8472a03bc5d5b544c259c928270481e4">Halide::BoundaryConditions::repeat_image</a> (const Func &amp;source, const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a8472a03bc5d5b544c259c928270481e4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a21dacea6046923b92ce184a68549b535">Halide::BoundaryConditions::repeat_image</a> (T func_like)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a21dacea6046923b92ce184a68549b535"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad5c6c95b4a8479ddcf5135eae5811408">Halide::BoundaryConditions::repeat_image</a> (T func_like, Expr min0, Expr extent0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#ad5c6c95b4a8479ddcf5135eae5811408"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#af340aa63c121d7d13690d04c2c43fa64">Halide::BoundaryConditions::repeat_image</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#af340aa63c121d7d13690d04c2c43fa64"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a6a610ed59bbf566f756120db995c7fb8">Halide::BoundaryConditions::repeat_image</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a6a610ed59bbf566f756120db995c7fb8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a47459c33ac4f55bd21a9fc054ec4f1cc">Halide::BoundaryConditions::repeat_image</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a47459c33ac4f55bd21a9fc054ec4f1cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a2c078e41888357be879f3511cb02cf3a">Halide::BoundaryConditions::repeat_image</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a2c078e41888357be879f3511cb02cf3a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#adfef8f9357c1c5e71c77d34f95b2fbb8">Halide::BoundaryConditions::repeat_image</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4, Expr min5, Expr extent5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#adfef8f9357c1c5e71c77d34f95b2fbb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9d0cea1519a98d7983d754323250bd95">Halide::BoundaryConditions::mirror_image</a> (const Func &amp;source, const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same.  <a href="#a9d0cea1519a98d7983d754323250bd95"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a90210f3878ff4e84f37e1a1d201ce7c0">Halide::BoundaryConditions::mirror_image</a> (T func_like)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a90210f3878ff4e84f37e1a1d201ce7c0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a20f3907b2141da518dde88b5ce0360e7">Halide::BoundaryConditions::mirror_image</a> (T func_like, Expr min0, Expr extent0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a20f3907b2141da518dde88b5ce0360e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a9648de004485df3fef0d79d985d3c5e3">Halide::BoundaryConditions::mirror_image</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a9648de004485df3fef0d79d985d3c5e3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a121810c4055788c61755d3cd5c459e63">Halide::BoundaryConditions::mirror_image</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a121810c4055788c61755d3cd5c459e63"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#abcd833d8d10bc20e8c37966b28a4a264">Halide::BoundaryConditions::mirror_image</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#abcd833d8d10bc20e8c37966b28a4a264"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a717316832fe3f3f4ed651d40286dd8ef">Halide::BoundaryConditions::mirror_image</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#a717316832fe3f3f4ed651d40286dd8ef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ab9c62a0e12724ce941fc4dfccbe4eb36">Halide::BoundaryConditions::mirror_image</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4, Expr min5, Expr extent5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="#ab9c62a0e12724ce941fc4dfccbe4eb36"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a090e3e8b50a162f92777f19b84e5b453">Halide::BoundaryConditions::mirror_interior</a> (const Func &amp;source, const std::vector&lt; std::pair&lt; Expr, Expr &gt; &gt; &amp;bounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a090e3e8b50a162f92777f19b84e5b453"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a6f7e2ad1955724feb83bbaec99363b91">Halide::BoundaryConditions::mirror_interior</a> (T func_like)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a6f7e2ad1955724feb83bbaec99363b91"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a35d63ccb1eaca9eb2119d455994fc027">Halide::BoundaryConditions::mirror_interior</a> (T func_like, Expr min0, Expr extent0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a35d63ccb1eaca9eb2119d455994fc027"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a4c34c03095c23274ef88a9c6901e535e">Halide::BoundaryConditions::mirror_interior</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a4c34c03095c23274ef88a9c6901e535e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a06572fdbca0463371ff4989383e00c62">Halide::BoundaryConditions::mirror_interior</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a06572fdbca0463371ff4989383e00c62"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a28341dfe322cdab5da3a2b9466f865b0">Halide::BoundaryConditions::mirror_interior</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a28341dfe322cdab5da3a2b9466f865b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a7585f628b4a0cb88edbc9712c1ed119f">Halide::BoundaryConditions::mirror_interior</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#a7585f628b4a0cb88edbc9712c1ed119f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#ab5ce7bd7fe4169a9f709815f03f9870b">NO_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ae925984131df74f183b82a44ef1ca1e3">Halide::BoundaryConditions::mirror_interior</a> (T func_like, Expr min0, Expr extent0, Expr min1, Expr extent1, Expr min2, Expr extent2, Expr min3, Expr extent3, Expr min4, Expr extent4, Expr min5, Expr extent5)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="#ae925984131df74f183b82a44ef1ca1e3"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Support for imposing boundary conditions on Halide::Funcs. </p>

<p>Definition in file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>
</div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_boundary_conditions_8h.html">BoundaryConditions.h</a>      </li>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
