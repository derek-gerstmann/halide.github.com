<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: BoundaryConditions.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_boundary_conditions_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BoundaryConditions.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Support for imposing boundary conditions on Halide::Funcs.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="_lambda_8h_source.html">Lambda.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_func_8h_source.html">Func.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_i_r_8h_source.html">IR.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_util_8h_source.html">Util.h</a>&quot;</code><br />
</div>
<p><a href="_boundary_conditions_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr class="memdesc:namespace_halide"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines methods for manipulating and analyzing boolean expressions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_boundary_conditions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html">Halide::BoundaryConditions</a></td></tr>
<tr class="memdesc:namespace_halide_1_1_boundary_conditions"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace to hold functions for imposing boundary conditions on <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Funcs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_boundary_conditions_1_1_internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html">Halide::BoundaryConditions::Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a72afc90ec442417063c57e86a026ef6d"><td class="memItemLeft" align="right" valign="top">const Func &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html#a72afc90ec442417063c57e86a026ef6d">Halide::BoundaryConditions::Internal::func_like_to_func</a> (const Func &amp;func)</td></tr>
<tr class="separator:a72afc90ec442417063c57e86a026ef6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69438e0edca0f3277b51eb0507657de6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69438e0edca0f3277b51eb0507657de6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions_1_1_internal.html#a69438e0edca0f3277b51eb0507657de6">Halide::BoundaryConditions::Internal::func_like_to_func</a> (const T &amp;func_like)</td></tr>
<tr class="separator:a69438e0edca0f3277b51eb0507657de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad65753e2ba404adf3c8a1615fa67e7e5"><td class="memItemLeft" align="right" valign="top">Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad65753e2ba404adf3c8a1615fa67e7e5">Halide::BoundaryConditions::constant_exterior</a> (const Func &amp;source, Tuple value, const std::vector&lt; std::pair&lt; Expr, Expr &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:ad65753e2ba404adf3c8a1615fa67e7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="namespace_halide_1_1_boundary_conditions.html#ad65753e2ba404adf3c8a1615fa67e7e5">More...</a><br /></td></tr>
<tr class="separator:ad65753e2ba404adf3c8a1615fa67e7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067b81624cdf509eb1f14f9485c77014"><td class="memItemLeft" align="right" valign="top">Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a067b81624cdf509eb1f14f9485c77014">Halide::BoundaryConditions::constant_exterior</a> (const Func &amp;source, Expr value, const std::vector&lt; std::pair&lt; Expr, Expr &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:a067b81624cdf509eb1f14f9485c77014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="namespace_halide_1_1_boundary_conditions.html#a067b81624cdf509eb1f14f9485c77014">More...</a><br /></td></tr>
<tr class="separator:a067b81624cdf509eb1f14f9485c77014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403721f48e0e86d288acb9fb63bf880c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a403721f48e0e86d288acb9fb63bf880c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a403721f48e0e86d288acb9fb63bf880c">Halide::BoundaryConditions::constant_exterior</a> (const T &amp;func_like, Tuple value)</td></tr>
<tr class="memdesc:a403721f48e0e86d288acb9fb63bf880c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="namespace_halide_1_1_boundary_conditions.html#a403721f48e0e86d288acb9fb63bf880c">More...</a><br /></td></tr>
<tr class="separator:a403721f48e0e86d288acb9fb63bf880c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3c0a9315fa44215e05b12e1489ad99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d3c0a9315fa44215e05b12e1489ad99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a5d3c0a9315fa44215e05b12e1489ad99">Halide::BoundaryConditions::constant_exterior</a> (const T &amp;func_like, Expr value)</td></tr>
<tr class="memdesc:a5d3c0a9315fa44215e05b12e1489ad99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="namespace_halide_1_1_boundary_conditions.html#a5d3c0a9315fa44215e05b12e1489ad99">More...</a><br /></td></tr>
<tr class="separator:a5d3c0a9315fa44215e05b12e1489ad99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56c305fef05526a323c3c3496e79b5c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa56c305fef05526a323c3c3496e79b5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#aa56c305fef05526a323c3c3496e79b5c">Halide::BoundaryConditions::constant_exterior</a> (const T &amp;func_like, Tuple value, Bounds &amp;&amp;... bounds)</td></tr>
<tr class="memdesc:aa56c305fef05526a323c3c3496e79b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="namespace_halide_1_1_boundary_conditions.html#aa56c305fef05526a323c3c3496e79b5c">More...</a><br /></td></tr>
<tr class="separator:aa56c305fef05526a323c3c3496e79b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f9553b8d3e4a705ba55ac5a503d774"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae9f9553b8d3e4a705ba55ac5a503d774"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ae9f9553b8d3e4a705ba55ac5a503d774">Halide::BoundaryConditions::constant_exterior</a> (const T &amp;func_like, Expr value, Bounds &amp;&amp;... bounds)</td></tr>
<tr class="memdesc:ae9f9553b8d3e4a705ba55ac5a503d774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that a given expression is returned everywhere outside the boundary.  <a href="namespace_halide_1_1_boundary_conditions.html#ae9f9553b8d3e4a705ba55ac5a503d774">More...</a><br /></td></tr>
<tr class="separator:ae9f9553b8d3e4a705ba55ac5a503d774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a773e2cba15577ec6ed683208b4556375"><td class="memItemLeft" align="right" valign="top">Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a773e2cba15577ec6ed683208b4556375">Halide::BoundaryConditions::repeat_edge</a> (const Func &amp;source, const std::vector&lt; std::pair&lt; Expr, Expr &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:a773e2cba15577ec6ed683208b4556375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="namespace_halide_1_1_boundary_conditions.html#a773e2cba15577ec6ed683208b4556375">More...</a><br /></td></tr>
<tr class="separator:a773e2cba15577ec6ed683208b4556375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af552f8e2d722e1248cf4d0a8027a81df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af552f8e2d722e1248cf4d0a8027a81df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#af552f8e2d722e1248cf4d0a8027a81df">Halide::BoundaryConditions::repeat_edge</a> (const T &amp;func_like)</td></tr>
<tr class="memdesc:af552f8e2d722e1248cf4d0a8027a81df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="namespace_halide_1_1_boundary_conditions.html#af552f8e2d722e1248cf4d0a8027a81df">More...</a><br /></td></tr>
<tr class="separator:af552f8e2d722e1248cf4d0a8027a81df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad6282e286f854f7d71a34746bec3c9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:acad6282e286f854f7d71a34746bec3c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#acad6282e286f854f7d71a34746bec3c9">Halide::BoundaryConditions::repeat_edge</a> (const T &amp;func_like, Bounds &amp;&amp;... bounds)</td></tr>
<tr class="memdesc:acad6282e286f854f7d71a34746bec3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the nearest edge sample is returned everywhere outside the given region.  <a href="namespace_halide_1_1_boundary_conditions.html#acad6282e286f854f7d71a34746bec3c9">More...</a><br /></td></tr>
<tr class="separator:acad6282e286f854f7d71a34746bec3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6b1961595eb14c04860d6e67819104a6"><td class="memItemLeft" align="right" valign="top">Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a6b1961595eb14c04860d6e67819104a6">Halide::BoundaryConditions::repeat_image</a> (const Func &amp;source, const std::vector&lt; std::pair&lt; Expr, Expr &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:a6b1961595eb14c04860d6e67819104a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="namespace_halide_1_1_boundary_conditions.html#a6b1961595eb14c04860d6e67819104a6">More...</a><br /></td></tr>
<tr class="separator:a6b1961595eb14c04860d6e67819104a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c53aee37e3c73c1b57f69a3ee17a29e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c53aee37e3c73c1b57f69a3ee17a29e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a8c53aee37e3c73c1b57f69a3ee17a29e">Halide::BoundaryConditions::repeat_image</a> (const T &amp;func_like)</td></tr>
<tr class="memdesc:a8c53aee37e3c73c1b57f69a3ee17a29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="namespace_halide_1_1_boundary_conditions.html#a8c53aee37e3c73c1b57f69a3ee17a29e">More...</a><br /></td></tr>
<tr class="separator:a8c53aee37e3c73c1b57f69a3ee17a29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7695077ee4e64ac565a3bcb49b1c3c72"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7695077ee4e64ac565a3bcb49b1c3c72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a7695077ee4e64ac565a3bcb49b1c3c72">Halide::BoundaryConditions::repeat_image</a> (const T &amp;func_like, Bounds &amp;&amp;... bounds)</td></tr>
<tr class="memdesc:a7695077ee4e64ac565a3bcb49b1c3c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="namespace_halide_1_1_boundary_conditions.html#a7695077ee4e64ac565a3bcb49b1c3c72">More...</a><br /></td></tr>
<tr class="separator:a7695077ee4e64ac565a3bcb49b1c3c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c0fc9d62f74de85e5e9e5690d97018"><td class="memItemLeft" align="right" valign="top">Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a02c0fc9d62f74de85e5e9e5690d97018">Halide::BoundaryConditions::mirror_image</a> (const Func &amp;source, const std::vector&lt; std::pair&lt; Expr, Expr &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:a02c0fc9d62f74de85e5e9e5690d97018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same.  <a href="namespace_halide_1_1_boundary_conditions.html#a02c0fc9d62f74de85e5e9e5690d97018">More...</a><br /></td></tr>
<tr class="separator:a02c0fc9d62f74de85e5e9e5690d97018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add16db9977891439ac354596aa8208dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add16db9977891439ac354596aa8208dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#add16db9977891439ac354596aa8208dc">Halide::BoundaryConditions::mirror_image</a> (const T &amp;func_like)</td></tr>
<tr class="memdesc:add16db9977891439ac354596aa8208dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="namespace_halide_1_1_boundary_conditions.html#add16db9977891439ac354596aa8208dc">More...</a><br /></td></tr>
<tr class="separator:add16db9977891439ac354596aa8208dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfad9a52f73c4990e164768e0fd40be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7bfad9a52f73c4990e164768e0fd40be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a7bfad9a52f73c4990e164768e0fd40be">Halide::BoundaryConditions::mirror_image</a> (const T &amp;func_like, Bounds &amp;&amp;... bounds)</td></tr>
<tr class="memdesc:a7bfad9a52f73c4990e164768e0fd40be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other.  <a href="namespace_halide_1_1_boundary_conditions.html#a7bfad9a52f73c4990e164768e0fd40be">More...</a><br /></td></tr>
<tr class="separator:a7bfad9a52f73c4990e164768e0fd40be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad5eac859bc8e6c92efc8312c615482a2"><td class="memItemLeft" align="right" valign="top">Func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ad5eac859bc8e6c92efc8312c615482a2">Halide::BoundaryConditions::mirror_interior</a> (const Func &amp;source, const std::vector&lt; std::pair&lt; Expr, Expr &gt;&gt; &amp;bounds)</td></tr>
<tr class="memdesc:ad5eac859bc8e6c92efc8312c615482a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="namespace_halide_1_1_boundary_conditions.html#ad5eac859bc8e6c92efc8312c615482a2">More...</a><br /></td></tr>
<tr class="separator:ad5eac859bc8e6c92efc8312c615482a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0141a01322201a6c9ef2bd93c39aa6bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0141a01322201a6c9ef2bd93c39aa6bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#a0141a01322201a6c9ef2bd93c39aa6bd">Halide::BoundaryConditions::mirror_interior</a> (const T &amp;func_like)</td></tr>
<tr class="memdesc:a0141a01322201a6c9ef2bd93c39aa6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="namespace_halide_1_1_boundary_conditions.html#a0141a01322201a6c9ef2bd93c39aa6bd">More...</a><br /></td></tr>
<tr class="separator:a0141a01322201a6c9ef2bd93c39aa6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab572a64d9edf13a6b4e30e81755ecbfd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Bounds, typename std::enable_if&lt; Halide::Internal::all_are_convertible&lt; Expr, Bounds... &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ab572a64d9edf13a6b4e30e81755ecbfd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> Func&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_boundary_conditions.html#ab572a64d9edf13a6b4e30e81755ecbfd">Halide::BoundaryConditions::mirror_interior</a> (const T &amp;func_like, Bounds &amp;&amp;... bounds)</td></tr>
<tr class="memdesc:ab572a64d9edf13a6b4e30e81755ecbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a boundary condition such that the entire coordinate space is tiled with copies of the image abutted against each other, but mirror them such that adjacent edges are the same and then overlap the edges.  <a href="namespace_halide_1_1_boundary_conditions.html#ab572a64d9edf13a6b4e30e81755ecbfd">More...</a><br /></td></tr>
<tr class="separator:ab572a64d9edf13a6b4e30e81755ecbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Support for imposing boundary conditions on Halide::Funcs. </p>

<p class="definition">Definition in file <a class="el" href="_boundary_conditions_8h_source.html">BoundaryConditions.h</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_boundary_conditions_8h.html">BoundaryConditions.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
