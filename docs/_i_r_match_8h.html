<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Halide: /home/halidenightly/build_bot/worker/x86-64-linux-1000-cmake/halide/src/IRMatch.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">10.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_i_r_match_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">IRMatch.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines a method to match a fragment of IR against a pattern containing wildcards.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;map&gt;</code><br />
<code>#include &lt;random&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="_i_r_8h_source.html">IR.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_i_r_equality_8h_source.html">IREquality.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_i_r_operator_8h_source.html">IROperator.h</a>&quot;</code><br />
</div>
<p><a href="_i_r_match_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_matcher_state.html">Halide::Internal::IRMatcher::MatcherState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">To save stack space, the matcher objects are largely stateless and immutable.  <a href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_matcher_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1enable__if__pattern.html">Halide::Internal::IRMatcher::enable_if_pattern&lt; T, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1enable__if__pattern_1_1type.html">Halide::Internal::IRMatcher::enable_if_pattern&lt; T, typename &gt;::type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1bindings.html">Halide::Internal::IRMatcher::bindings&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr.html">Halide::Internal::IRMatcher::SpecificExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_specific_expr_1_1pattern__tag.html">Halide::Internal::IRMatcher::SpecificExpr::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_int.html">Halide::Internal::IRMatcher::WildConstInt&lt; i &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_int_1_1pattern__tag.html">Halide::Internal::IRMatcher::WildConstInt&lt; i &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_u_int.html">Halide::Internal::IRMatcher::WildConstUInt&lt; i &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_u_int_1_1pattern__tag.html">Halide::Internal::IRMatcher::WildConstUInt&lt; i &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_float.html">Halide::Internal::IRMatcher::WildConstFloat&lt; i &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_float_1_1pattern__tag.html">Halide::Internal::IRMatcher::WildConstFloat&lt; i &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const.html">Halide::Internal::IRMatcher::WildConst&lt; i &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_const_1_1pattern__tag.html">Halide::Internal::IRMatcher::WildConst&lt; i &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild.html">Halide::Internal::IRMatcher::Wild&lt; i &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_wild_1_1pattern__tag.html">Halide::Internal::IRMatcher::Wild&lt; i &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_const.html">Halide::Internal::IRMatcher::Const</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_const_1_1pattern__tag.html">Halide::Internal::IRMatcher::Const::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op.html">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_bin_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::BinOp&lt; Op, A, B &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op.html">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cmp_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::CmpOp&lt; Op, A, B &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin.html">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_intrin_1_1pattern__tag.html">Halide::Internal::IRMatcher::Intrin&lt; Args &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_not_op.html">Halide::Internal::IRMatcher::NotOp&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_not_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::NotOp&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_select_op.html">Halide::Internal::IRMatcher::SelectOp&lt; C, T, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_select_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::SelectOp&lt; C, T, F &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_broadcast_op.html">Halide::Internal::IRMatcher::BroadcastOp&lt; A, known_lanes &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_broadcast_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::BroadcastOp&lt; A, known_lanes &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_ramp_op.html">Halide::Internal::IRMatcher::RampOp&lt; A, B, known_lanes &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_ramp_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::RampOp&lt; A, B, known_lanes &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op.html">Halide::Internal::IRMatcher::VectorReduceOp&lt; A, known_lanes, reduce_op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_vector_reduce_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::VectorReduceOp&lt; A, known_lanes, reduce_op &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_negate_op.html">Halide::Internal::IRMatcher::NegateOp&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_negate_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::NegateOp&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cast_op.html">Halide::Internal::IRMatcher::CastOp&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_cast_op_1_1pattern__tag.html">Halide::Internal::IRMatcher::CastOp&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_fold.html">Halide::Internal::IRMatcher::Fold&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_fold_1_1pattern__tag.html">Halide::Internal::IRMatcher::Fold&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflows.html">Halide::Internal::IRMatcher::Overflows&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflows_1_1pattern__tag.html">Halide::Internal::IRMatcher::Overflows&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflow.html">Halide::Internal::IRMatcher::Overflow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_overflow_1_1pattern__tag.html">Halide::Internal::IRMatcher::Overflow::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_const.html">Halide::Internal::IRMatcher::IsConst&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_const_1_1pattern__tag.html">Halide::Internal::IRMatcher::IsConst&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_can_prove.html">Halide::Internal::IRMatcher::CanProve&lt; A, Prover &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_can_prove_1_1pattern__tag.html">Halide::Internal::IRMatcher::CanProve&lt; A, Prover &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_float.html">Halide::Internal::IRMatcher::IsFloat&lt; A &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_is_float_1_1pattern__tag.html">Halide::Internal::IRMatcher::IsFloat&lt; A &gt;::pattern_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1_internal_1_1_i_r_matcher_1_1_rewriter.html">Halide::Internal::IRMatcher::Rewriter&lt; Instance &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_halide"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide.html">Halide</a></td></tr>
<tr class="memdesc:namespace_halide"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file defines the class FunctionDAG, which is our representation of a <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> pipeline, and contains methods to using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a>'s bounds tools to query properties of it. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html">Halide::Internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_halide_1_1_internal_1_1_i_r_matcher"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html">Halide::Internal::IRMatcher</a></td></tr>
<tr class="memdesc:namespace_halide_1_1_internal_1_1_i_r_matcher"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative template-metaprogramming approach to expression matching. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac3cabe703f762c1fb43f00c9a77d6ae4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_r_match_8h.html#ac3cabe703f762c1fb43f00c9a77d6ae4">HALIDE_DEBUG_MATCHED_RULES</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ac3cabe703f762c1fb43f00c9a77d6ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38de29759124484d5b8934bf77b54fc4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_r_match_8h.html#a38de29759124484d5b8934bf77b54fc4">HALIDE_DEBUG_UNMATCHED_RULES</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a38de29759124484d5b8934bf77b54fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71623e6847732d0ea4b811d8f93d0bd6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_i_r_match_8h.html#a71623e6847732d0ea4b811d8f93d0bd6">HALIDE_FUZZ_TEST_RULES</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a71623e6847732d0ea4b811d8f93d0bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad10452d8940fd9d44b657a915b7cea42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad10452d8940fd9d44b657a915b7cea42">Halide::Internal::expr_match</a> (const Expr &amp;pattern, const Expr &amp;expr, std::vector&lt; Expr &gt; &amp;result)</td></tr>
<tr class="memdesc:ad10452d8940fd9d44b657a915b7cea42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables in the first expression with the name * are interpreted as wildcards, and their matching equivalent in the second expression is placed in the vector give as the third argument.  <a href="namespace_halide_1_1_internal.html#ad10452d8940fd9d44b657a915b7cea42">More...</a><br /></td></tr>
<tr class="separator:ad10452d8940fd9d44b657a915b7cea42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d77cbd158befc1b58416319609f313"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#ad8d77cbd158befc1b58416319609f313">Halide::Internal::expr_match</a> (const Expr &amp;pattern, const Expr &amp;expr, std::map&lt; std::string, Expr &gt; &amp;result)</td></tr>
<tr class="memdesc:ad8d77cbd158befc1b58416319609f313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the first expression have the same structure as the second? Variables are matched consistently.  <a href="namespace_halide_1_1_internal.html#ad8d77cbd158befc1b58416319609f313">More...</a><br /></td></tr>
<tr class="separator:ad8d77cbd158befc1b58416319609f313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eed932bc0eb3a15edcb20795bfb8c2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal.html#a1eed932bc0eb3a15edcb20795bfb8c2f">Halide::Internal::expr_match_test</a> ()</td></tr>
<tr class="separator:a1eed932bc0eb3a15edcb20795bfb8c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29c5f8f734b23806ea65f9480e68426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae29c5f8f734b23806ea65f9480e68426">Halide::Internal::IRMatcher::make_const_special_expr</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> ty)</td></tr>
<tr class="separator:ae29c5f8f734b23806ea65f9480e68426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbef33d9a64963f7e5a6b8bd1ddc6565"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> Expr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#adbef33d9a64963f7e5a6b8bd1ddc6565">Halide::Internal::IRMatcher::make_const_expr</a> (<a class="el" href="structhalide__scalar__value__t.html">halide_scalar_value_t</a> val, <a class="el" href="structhalide__type__t.html">halide_type_t</a> ty)</td></tr>
<tr class="separator:adbef33d9a64963f7e5a6b8bd1ddc6565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f95ba2ddda30f44c2c99900c0822f9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7f95ba2ddda30f44c2c99900c0822f9a">Halide::Internal::IRMatcher::equal_helper</a> (const BaseExprNode &amp;a, const BaseExprNode &amp;b) noexcept</td></tr>
<tr class="separator:a7f95ba2ddda30f44c2c99900c0822f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ab6dff7268fca017db4bb871e9b0d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a72ab6dff7268fca017db4bb871e9b0d5">Halide::Internal::IRMatcher::equal</a> (const BaseExprNode &amp;a, const BaseExprNode &amp;b) noexcept</td></tr>
<tr class="separator:a72ab6dff7268fca017db4bb871e9b0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d0eff39076f8e54e8e556b8e8d19ba"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a00d0eff39076f8e54e8e556b8e8d19ba">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const SpecificExpr &amp;e)</td></tr>
<tr class="separator:a00d0eff39076f8e54e8e556b8e8d19ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96344dee0a97d8a8fbb5be28b1e886c"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:af96344dee0a97d8a8fbb5be28b1e886c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af96344dee0a97d8a8fbb5be28b1e886c">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const WildConstInt&lt; i &gt; &amp;c)</td></tr>
<tr class="separator:af96344dee0a97d8a8fbb5be28b1e886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1bdbd1185ecb89a237a7530eeefe1c"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:a4d1bdbd1185ecb89a237a7530eeefe1c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a4d1bdbd1185ecb89a237a7530eeefe1c">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const WildConstUInt&lt; i &gt; &amp;c)</td></tr>
<tr class="separator:a4d1bdbd1185ecb89a237a7530eeefe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873658452a3a78825f8d4cc6f97d7a02"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:a873658452a3a78825f8d4cc6f97d7a02"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a873658452a3a78825f8d4cc6f97d7a02">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const WildConstFloat&lt; i &gt; &amp;c)</td></tr>
<tr class="separator:a873658452a3a78825f8d4cc6f97d7a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90c67a51701c0919c6c2b4e490240cd"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:ab90c67a51701c0919c6c2b4e490240cd"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab90c67a51701c0919c6c2b4e490240cd">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const WildConst&lt; i &gt; &amp;c)</td></tr>
<tr class="separator:ab90c67a51701c0919c6c2b4e490240cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9221dbcdf25ffb974940eb4b797b8c78"><td class="memTemplParams" colspan="2">template&lt;int i&gt; </td></tr>
<tr class="memitem:a9221dbcdf25ffb974940eb4b797b8c78"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9221dbcdf25ffb974940eb4b797b8c78">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const Wild&lt; i &gt; &amp;op)</td></tr>
<tr class="separator:a9221dbcdf25ffb974940eb4b797b8c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04098851fbbe2fcc79ea1cf70344d4f3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::decay&lt;T&gt;::type::pattern_tag&gt; </td></tr>
<tr class="memitem:a04098851fbbe2fcc79ea1cf70344d4f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a04098851fbbe2fcc79ea1cf70344d4f3">Halide::Internal::IRMatcher::pattern_arg</a> (T t)</td></tr>
<tr class="separator:a04098851fbbe2fcc79ea1cf70344d4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546ffd6b69b49db4ca4d1cee2bab2894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> Const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a546ffd6b69b49db4ca4d1cee2bab2894">Halide::Internal::IRMatcher::pattern_arg</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> x)</td></tr>
<tr class="separator:a546ffd6b69b49db4ca4d1cee2bab2894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020bea0ec58e519d7a8ca02ab611e799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const SpecificExpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a020bea0ec58e519d7a8ca02ab611e799">Halide::Internal::IRMatcher::pattern_arg</a> (const Expr &amp;e)</td></tr>
<tr class="separator:a020bea0ec58e519d7a8ca02ab611e799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e53940f96fc63b025f2c4b5476b1d41"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::decay&lt;T&gt;::type::pattern_tag, typename  = typename std::enable_if&lt;!std::is_same&lt;typename std::decay&lt;T&gt;::type, SpecificExpr&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3e53940f96fc63b025f2c4b5476b1d41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3e53940f96fc63b025f2c4b5476b1d41">Halide::Internal::IRMatcher::unwrap</a> (T t)</td></tr>
<tr class="separator:a3e53940f96fc63b025f2c4b5476b1d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557f86d86e9d90046df54af6d5700657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const BaseExprNode &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a557f86d86e9d90046df54af6d5700657">Halide::Internal::IRMatcher::unwrap</a> (const SpecificExpr &amp;e)</td></tr>
<tr class="separator:a557f86d86e9d90046df54af6d5700657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4ff90507030539788eefe46c4e8502"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2b4ff90507030539788eefe46c4e8502">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const Const &amp;op)</td></tr>
<tr class="separator:a2b4ff90507030539788eefe46c4e8502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02c255ad5cbd923bb80d831dcb29a9f"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:ae02c255ad5cbd923bb80d831dcb29a9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae02c255ad5cbd923bb80d831dcb29a9f">Halide::Internal::IRMatcher::constant_fold_bin_op</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>) noexcept</td></tr>
<tr class="separator:ae02c255ad5cbd923bb80d831dcb29a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d935203140ecdaa7c89c2f61a66371d"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a9d935203140ecdaa7c89c2f61a66371d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9d935203140ecdaa7c89c2f61a66371d">Halide::Internal::IRMatcher::constant_fold_bin_op</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>) noexcept</td></tr>
<tr class="separator:a9d935203140ecdaa7c89c2f61a66371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5823d477b61633b1b0607075dea6a5f"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:af5823d477b61633b1b0607075dea6a5f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af5823d477b61633b1b0607075dea6a5f">Halide::Internal::IRMatcher::constant_fold_bin_op</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;, double, double) noexcept</td></tr>
<tr class="separator:af5823d477b61633b1b0607075dea6a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c85b1b1664ed0848b20ddbb235747ad"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8c85b1b1664ed0848b20ddbb235747ad">Halide::Internal::IRMatcher::commutative</a> (IRNodeType t)</td></tr>
<tr class="separator:a8c85b1b1664ed0848b20ddbb235747ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e96dcc65e8cb2a61d81b286441a6dc5"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a1e96dcc65e8cb2a61d81b286441a6dc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e96dcc65e8cb2a61d81b286441a6dc5">Halide::Internal::IRMatcher::constant_fold_cmp_op</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>) noexcept</td></tr>
<tr class="separator:a1e96dcc65e8cb2a61d81b286441a6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61cdd5630b9f58581f7be27e747bf76"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:af61cdd5630b9f58581f7be27e747bf76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af61cdd5630b9f58581f7be27e747bf76">Halide::Internal::IRMatcher::constant_fold_cmp_op</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>) noexcept</td></tr>
<tr class="separator:af61cdd5630b9f58581f7be27e747bf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5671074743a4d51f6d5470676fdd6f32"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a5671074743a4d51f6d5470676fdd6f32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5671074743a4d51f6d5470676fdd6f32">Halide::Internal::IRMatcher::constant_fold_cmp_op</a> (double, double) noexcept</td></tr>
<tr class="separator:a5671074743a4d51f6d5470676fdd6f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b827754f38c7395eef6ed55e86744f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a01b827754f38c7395eef6ed55e86744f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a01b827754f38c7395eef6ed55e86744f">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const BinOp&lt; Add, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a01b827754f38c7395eef6ed55e86744f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04fb6f843a9dec7cb8cce8d3b9e4179"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ae04fb6f843a9dec7cb8cce8d3b9e4179"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae04fb6f843a9dec7cb8cce8d3b9e4179">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const BinOp&lt; Sub, A, B &gt; &amp;op)</td></tr>
<tr class="separator:ae04fb6f843a9dec7cb8cce8d3b9e4179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad634aa13ee1e4f8bf3cc7ffb76cc6527"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ad634aa13ee1e4f8bf3cc7ffb76cc6527"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad634aa13ee1e4f8bf3cc7ffb76cc6527">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const BinOp&lt; Mul, A, B &gt; &amp;op)</td></tr>
<tr class="separator:ad634aa13ee1e4f8bf3cc7ffb76cc6527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673efcbbd601474b50c94b948bdbabfb"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a673efcbbd601474b50c94b948bdbabfb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a673efcbbd601474b50c94b948bdbabfb">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const BinOp&lt; Div, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a673efcbbd601474b50c94b948bdbabfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a8f9c7203794cc695bcd47bb0bc157"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aa2a8f9c7203794cc695bcd47bb0bc157"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa2a8f9c7203794cc695bcd47bb0bc157">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const BinOp&lt; And, A, B &gt; &amp;op)</td></tr>
<tr class="separator:aa2a8f9c7203794cc695bcd47bb0bc157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab152d1e44d088c50c74079c4661fd84"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aab152d1e44d088c50c74079c4661fd84"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aab152d1e44d088c50c74079c4661fd84">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const BinOp&lt; Or, A, B &gt; &amp;op)</td></tr>
<tr class="separator:aab152d1e44d088c50c74079c4661fd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39eeba4c9bd01e2128d06c5f174adba"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:af39eeba4c9bd01e2128d06c5f174adba"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af39eeba4c9bd01e2128d06c5f174adba">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const BinOp&lt; Min, A, B &gt; &amp;op)</td></tr>
<tr class="separator:af39eeba4c9bd01e2128d06c5f174adba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436f691c61c99d48cda1bbb7a16353ee"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a436f691c61c99d48cda1bbb7a16353ee"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a436f691c61c99d48cda1bbb7a16353ee">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const BinOp&lt; Max, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a436f691c61c99d48cda1bbb7a16353ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa01c252c46b4f9ed044b3b54ea6a86"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a5aa01c252c46b4f9ed044b3b54ea6a86"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5aa01c252c46b4f9ed044b3b54ea6a86">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const CmpOp&lt; LE, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a5aa01c252c46b4f9ed044b3b54ea6a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3eae0c97045cfb0af9107a71ae912f9"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ab3eae0c97045cfb0af9107a71ae912f9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab3eae0c97045cfb0af9107a71ae912f9">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const CmpOp&lt; LT, A, B &gt; &amp;op)</td></tr>
<tr class="separator:ab3eae0c97045cfb0af9107a71ae912f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bae2a19d3624dda0eb9fa89f5bee0c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a35bae2a19d3624dda0eb9fa89f5bee0c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a35bae2a19d3624dda0eb9fa89f5bee0c">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const CmpOp&lt; GE, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a35bae2a19d3624dda0eb9fa89f5bee0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57429fca1464dcda68e9eef990212b94"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a57429fca1464dcda68e9eef990212b94"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a57429fca1464dcda68e9eef990212b94">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const CmpOp&lt; GT, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a57429fca1464dcda68e9eef990212b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972d8bb67d41187b0c20cf9cd84bbc2a"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a972d8bb67d41187b0c20cf9cd84bbc2a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a972d8bb67d41187b0c20cf9cd84bbc2a">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const CmpOp&lt; EQ, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a972d8bb67d41187b0c20cf9cd84bbc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1807e136ef4a774cdf620167d92c8125"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a1807e136ef4a774cdf620167d92c8125"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1807e136ef4a774cdf620167d92c8125">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const CmpOp&lt; NE, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a1807e136ef4a774cdf620167d92c8125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e75343df60924b4086f6c3f5b9d440"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a15e75343df60924b4086f6c3f5b9d440"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a15e75343df60924b4086f6c3f5b9d440">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const BinOp&lt; Mod, A, B &gt; &amp;op)</td></tr>
<tr class="separator:a15e75343df60924b4086f6c3f5b9d440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5196ad50e5baebd4504f6ee0fa558cd"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ad5196ad50e5baebd4504f6ee0fa558cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad5196ad50e5baebd4504f6ee0fa558cd">Halide::Internal::IRMatcher::operator+</a> (A a, B b) noexcept-&gt; BinOp&lt; Add, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:ad5196ad50e5baebd4504f6ee0fa558cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6668d9047293282afeaf11e40b26ba1c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a6668d9047293282afeaf11e40b26ba1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6668d9047293282afeaf11e40b26ba1c">Halide::Internal::IRMatcher::add</a> (A a, B b) -&gt; decltype(IRMatcher::operator+(a, b))</td></tr>
<tr class="separator:a6668d9047293282afeaf11e40b26ba1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdd7fb7b36b2cf3b64bda5111d28b4e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:afbdd7fb7b36b2cf3b64bda5111d28b4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#afbdd7fb7b36b2cf3b64bda5111d28b4e">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Add &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:afbdd7fb7b36b2cf3b64bda5111d28b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a4cb65f0a03b2bd504543b36bd9817"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad0a4cb65f0a03b2bd504543b36bd9817"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad0a4cb65f0a03b2bd504543b36bd9817">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Add &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:ad0a4cb65f0a03b2bd504543b36bd9817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fd876acceaa7d5ecf7c52ce3fb847b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a21fd876acceaa7d5ecf7c52ce3fb847b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a21fd876acceaa7d5ecf7c52ce3fb847b">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Add &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a21fd876acceaa7d5ecf7c52ce3fb847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0025d4824368490a26cec10dfd17e31"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ad0025d4824368490a26cec10dfd17e31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad0025d4824368490a26cec10dfd17e31">Halide::Internal::IRMatcher::operator-</a> (A a, B b) noexcept-&gt; BinOp&lt; Sub, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:ad0025d4824368490a26cec10dfd17e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6517db2a239c33b31518d48c2fd440"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a6f6517db2a239c33b31518d48c2fd440"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6f6517db2a239c33b31518d48c2fd440">Halide::Internal::IRMatcher::sub</a> (A a, B b) -&gt; decltype(IRMatcher::operator-(a, b))</td></tr>
<tr class="separator:a6f6517db2a239c33b31518d48c2fd440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9451c858ad2679ef5b735719ddd065"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a5e9451c858ad2679ef5b735719ddd065"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a5e9451c858ad2679ef5b735719ddd065">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Sub &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a5e9451c858ad2679ef5b735719ddd065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31218a5a5b22ea9d423a526bf48b3197"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a31218a5a5b22ea9d423a526bf48b3197"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a31218a5a5b22ea9d423a526bf48b3197">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Sub &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a31218a5a5b22ea9d423a526bf48b3197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160bccbd5b3260ff67658ea4d533952d"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a160bccbd5b3260ff67658ea4d533952d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a160bccbd5b3260ff67658ea4d533952d">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Sub &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a160bccbd5b3260ff67658ea4d533952d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb062f018e16bcb76e5af4e0fcb8951"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aebb062f018e16bcb76e5af4e0fcb8951"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aebb062f018e16bcb76e5af4e0fcb8951">Halide::Internal::IRMatcher::operator*</a> (A a, B b) noexcept-&gt; BinOp&lt; Mul, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:aebb062f018e16bcb76e5af4e0fcb8951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329dcbe58748a7ed1924c2b7e5f158ac"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a329dcbe58748a7ed1924c2b7e5f158ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a329dcbe58748a7ed1924c2b7e5f158ac">Halide::Internal::IRMatcher::mul</a> (A a, B b) -&gt; decltype(IRMatcher::operator*(a, b))</td></tr>
<tr class="separator:a329dcbe58748a7ed1924c2b7e5f158ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47740df91721e730d765b5472669f11"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa47740df91721e730d765b5472669f11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa47740df91721e730d765b5472669f11">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mul &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:aa47740df91721e730d765b5472669f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a6c8f1d6156f6cd65f9a5521909ac6"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a41a6c8f1d6156f6cd65f9a5521909ac6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a41a6c8f1d6156f6cd65f9a5521909ac6">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mul &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a41a6c8f1d6156f6cd65f9a5521909ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e49735a398b8127b96e4d5713e571f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a78e49735a398b8127b96e4d5713e571f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a78e49735a398b8127b96e4d5713e571f">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mul &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a78e49735a398b8127b96e4d5713e571f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0759fc1b3ff6ca139145f3be8d02948e"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a0759fc1b3ff6ca139145f3be8d02948e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0759fc1b3ff6ca139145f3be8d02948e">Halide::Internal::IRMatcher::operator/</a> (A a, B b) noexcept-&gt; BinOp&lt; Div, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:a0759fc1b3ff6ca139145f3be8d02948e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad138f76ee3f6479299dbe70896b28b8c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ad138f76ee3f6479299dbe70896b28b8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad138f76ee3f6479299dbe70896b28b8c">Halide::Internal::IRMatcher::div</a> (A a, B b) -&gt; decltype(IRMatcher::operator/(a, b))</td></tr>
<tr class="separator:ad138f76ee3f6479299dbe70896b28b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183445e4d4dca061c05996652f2dac5b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a183445e4d4dca061c05996652f2dac5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a183445e4d4dca061c05996652f2dac5b">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Div &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a183445e4d4dca061c05996652f2dac5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a117db2cf577ff20571558dbe97bf7f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7a117db2cf577ff20571558dbe97bf7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7a117db2cf577ff20571558dbe97bf7f">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Div &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a7a117db2cf577ff20571558dbe97bf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d8b67bef430b9df555bf291792614f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae4d8b67bef430b9df555bf291792614f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae4d8b67bef430b9df555bf291792614f">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Div &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:ae4d8b67bef430b9df555bf291792614f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3722b3814a19435439839712e02d6476"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a3722b3814a19435439839712e02d6476"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3722b3814a19435439839712e02d6476">Halide::Internal::IRMatcher::operator%</a> (A a, B b) noexcept-&gt; BinOp&lt; Mod, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:a3722b3814a19435439839712e02d6476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a16bf1b700457f62c6e06b19853414"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a54a16bf1b700457f62c6e06b19853414"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a54a16bf1b700457f62c6e06b19853414">Halide::Internal::IRMatcher::mod</a> (A a, B b) -&gt; decltype(IRMatcher::operator%(a, b))</td></tr>
<tr class="separator:a54a16bf1b700457f62c6e06b19853414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bb7e262c2c8f83476f33fa96ab4411"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a49bb7e262c2c8f83476f33fa96ab4411"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a49bb7e262c2c8f83476f33fa96ab4411">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mod &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a49bb7e262c2c8f83476f33fa96ab4411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac259ecbd0cbade6ea8b16a03992de682"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac259ecbd0cbade6ea8b16a03992de682"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac259ecbd0cbade6ea8b16a03992de682">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mod &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:ac259ecbd0cbade6ea8b16a03992de682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5ce93cc0835cb6d4c79f2aa366ae5d"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:acb5ce93cc0835cb6d4c79f2aa366ae5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#acb5ce93cc0835cb6d4c79f2aa366ae5d">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Mod &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:acb5ce93cc0835cb6d4c79f2aa366ae5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfb995fbe38a5ad4cf34844767d543d"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a2dfb995fbe38a5ad4cf34844767d543d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2dfb995fbe38a5ad4cf34844767d543d">Halide::Internal::IRMatcher::min</a> (A a, B b) noexcept-&gt; BinOp&lt; Min, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:a2dfb995fbe38a5ad4cf34844767d543d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f49f4ff4022205c07838918fd036ec2"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a9f49f4ff4022205c07838918fd036ec2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9f49f4ff4022205c07838918fd036ec2">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Min &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a9f49f4ff4022205c07838918fd036ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee047ac24b43b0ea19cdc26ae9177a0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a0ee047ac24b43b0ea19cdc26ae9177a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0ee047ac24b43b0ea19cdc26ae9177a0">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Min &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a0ee047ac24b43b0ea19cdc26ae9177a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e1f600078ba83441a1da2e360cc255"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a78e1f600078ba83441a1da2e360cc255"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a78e1f600078ba83441a1da2e360cc255">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Min &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a78e1f600078ba83441a1da2e360cc255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d8206ae7d63d32005ca5995d7e2291"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a74d8206ae7d63d32005ca5995d7e2291"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a74d8206ae7d63d32005ca5995d7e2291">Halide::Internal::IRMatcher::max</a> (A a, B b) noexcept-&gt; BinOp&lt; Max, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:a74d8206ae7d63d32005ca5995d7e2291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62dd8f17b989502f974f83eb229b318c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a62dd8f17b989502f974f83eb229b318c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a62dd8f17b989502f974f83eb229b318c">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Max &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a62dd8f17b989502f974f83eb229b318c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8986bb12c496cdc93b809e91f10613ad"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8986bb12c496cdc93b809e91f10613ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8986bb12c496cdc93b809e91f10613ad">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Max &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a8986bb12c496cdc93b809e91f10613ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab312d3c67fa31a253ca57f6420879d5f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab312d3c67fa31a253ca57f6420879d5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab312d3c67fa31a253ca57f6420879d5f">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Max &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:ab312d3c67fa31a253ca57f6420879d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202bbe7e1043e45988e63ea5594d4ad4"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a202bbe7e1043e45988e63ea5594d4ad4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a202bbe7e1043e45988e63ea5594d4ad4">Halide::Internal::IRMatcher::operator&lt;</a> (A a, B b) noexcept-&gt; CmpOp&lt; LT, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:a202bbe7e1043e45988e63ea5594d4ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d763f9bd946860f21f2b3ce347a496"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a07d763f9bd946860f21f2b3ce347a496"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a07d763f9bd946860f21f2b3ce347a496">Halide::Internal::IRMatcher::lt</a> (A a, B b) -&gt; decltype(IRMatcher::operator&lt;(a, b))</td></tr>
<tr class="separator:a07d763f9bd946860f21f2b3ce347a496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59404f6a9be2edd1e7b087067186085"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad59404f6a9be2edd1e7b087067186085"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad59404f6a9be2edd1e7b087067186085">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; LT &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:ad59404f6a9be2edd1e7b087067186085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2f045c1fac015142c7849a2d0a6c0e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6f2f045c1fac015142c7849a2d0a6c0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6f2f045c1fac015142c7849a2d0a6c0e">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; LT &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a6f2f045c1fac015142c7849a2d0a6c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fd57e139aae6bc2a749b7dd7a2fa5b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a90fd57e139aae6bc2a749b7dd7a2fa5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a90fd57e139aae6bc2a749b7dd7a2fa5b">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; LT &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:a90fd57e139aae6bc2a749b7dd7a2fa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9683421c706b87c44af160caadc6fc7"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ac9683421c706b87c44af160caadc6fc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac9683421c706b87c44af160caadc6fc7">Halide::Internal::IRMatcher::operator&gt;</a> (A a, B b) noexcept-&gt; CmpOp&lt; GT, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:ac9683421c706b87c44af160caadc6fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7582c17cc0611594f3136386c070af99"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a7582c17cc0611594f3136386c070af99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7582c17cc0611594f3136386c070af99">Halide::Internal::IRMatcher::gt</a> (A a, B b) -&gt; decltype(IRMatcher::operator&gt;(a, b))</td></tr>
<tr class="separator:a7582c17cc0611594f3136386c070af99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21a7fd9d8ad2e8c69060a0ba114658c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa21a7fd9d8ad2e8c69060a0ba114658c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa21a7fd9d8ad2e8c69060a0ba114658c">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; GT &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:aa21a7fd9d8ad2e8c69060a0ba114658c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b98496c33623a602cfc21154a2c5a4c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6b98496c33623a602cfc21154a2c5a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6b98496c33623a602cfc21154a2c5a4c">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; GT &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a6b98496c33623a602cfc21154a2c5a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88710908fc5963e4b0f13cf21bc8d406"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a88710908fc5963e4b0f13cf21bc8d406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a88710908fc5963e4b0f13cf21bc8d406">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; GT &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:a88710908fc5963e4b0f13cf21bc8d406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac095625ffde136b2d032274ef9e7273d"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ac095625ffde136b2d032274ef9e7273d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac095625ffde136b2d032274ef9e7273d">Halide::Internal::IRMatcher::operator&lt;=</a> (A a, B b) noexcept-&gt; CmpOp&lt; LE, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:ac095625ffde136b2d032274ef9e7273d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f808deb37f9db2bf55ffd592c29c47"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a81f808deb37f9db2bf55ffd592c29c47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a81f808deb37f9db2bf55ffd592c29c47">Halide::Internal::IRMatcher::le</a> (A a, B b) -&gt; decltype(IRMatcher::operator&lt;=(a, b))</td></tr>
<tr class="separator:a81f808deb37f9db2bf55ffd592c29c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c526b5044511ee7ca7e9bcdcb1a69b6"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2c526b5044511ee7ca7e9bcdcb1a69b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2c526b5044511ee7ca7e9bcdcb1a69b6">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; LE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a2c526b5044511ee7ca7e9bcdcb1a69b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d4471ac09a360f80dd78b853300053"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac8d4471ac09a360f80dd78b853300053"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac8d4471ac09a360f80dd78b853300053">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; LE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:ac8d4471ac09a360f80dd78b853300053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d1b4920a766465287987573f8f6a13"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a98d1b4920a766465287987573f8f6a13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a98d1b4920a766465287987573f8f6a13">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; LE &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:a98d1b4920a766465287987573f8f6a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a279e66fa280f7ea34554fdc9947e5"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a39a279e66fa280f7ea34554fdc9947e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a39a279e66fa280f7ea34554fdc9947e5">Halide::Internal::IRMatcher::operator&gt;=</a> (A a, B b) noexcept-&gt; CmpOp&lt; GE, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:a39a279e66fa280f7ea34554fdc9947e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b8ce1149703d5aa9fa2c9df1281ddf"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a52b8ce1149703d5aa9fa2c9df1281ddf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a52b8ce1149703d5aa9fa2c9df1281ddf">Halide::Internal::IRMatcher::ge</a> (A a, B b) -&gt; decltype(IRMatcher::operator&gt;=(a, b))</td></tr>
<tr class="separator:a52b8ce1149703d5aa9fa2c9df1281ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a6bc166b2fb647aa37ee405b103547"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab0a6bc166b2fb647aa37ee405b103547"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab0a6bc166b2fb647aa37ee405b103547">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; GE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:ab0a6bc166b2fb647aa37ee405b103547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de7f8aad5e2da6f956f9793c17b05a2"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a0de7f8aad5e2da6f956f9793c17b05a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0de7f8aad5e2da6f956f9793c17b05a2">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; GE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a0de7f8aad5e2da6f956f9793c17b05a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0615b3c844f1bbbdc91d406c38a702f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae0615b3c844f1bbbdc91d406c38a702f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae0615b3c844f1bbbdc91d406c38a702f">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; GE &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:ae0615b3c844f1bbbdc91d406c38a702f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e847886a5371dbce3faf7cc874d4227"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a7e847886a5371dbce3faf7cc874d4227"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7e847886a5371dbce3faf7cc874d4227">Halide::Internal::IRMatcher::operator==</a> (A a, B b) noexcept-&gt; CmpOp&lt; EQ, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:a7e847886a5371dbce3faf7cc874d4227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2c3c722b1dcbd178ab3ad17367c39f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a0f2c3c722b1dcbd178ab3ad17367c39f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a0f2c3c722b1dcbd178ab3ad17367c39f">Halide::Internal::IRMatcher::eq</a> (A a, B b) -&gt; decltype(IRMatcher::operator==(a, b))</td></tr>
<tr class="separator:a0f2c3c722b1dcbd178ab3ad17367c39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae039e07269a504c112cccbbddad2abd5"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae039e07269a504c112cccbbddad2abd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae039e07269a504c112cccbbddad2abd5">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; EQ &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:ae039e07269a504c112cccbbddad2abd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369eaca268feef6557e2a11f3d3d44f6"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a369eaca268feef6557e2a11f3d3d44f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a369eaca268feef6557e2a11f3d3d44f6">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; EQ &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a369eaca268feef6557e2a11f3d3d44f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a3fec822b82e4550f36edcd0f94395"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a77a3fec822b82e4550f36edcd0f94395"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a77a3fec822b82e4550f36edcd0f94395">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; EQ &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:a77a3fec822b82e4550f36edcd0f94395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ec11cb6c23f1dd06fe7a525e873557"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a03ec11cb6c23f1dd06fe7a525e873557"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a03ec11cb6c23f1dd06fe7a525e873557">Halide::Internal::IRMatcher::operator!=</a> (A a, B b) noexcept-&gt; CmpOp&lt; NE, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:a03ec11cb6c23f1dd06fe7a525e873557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a906780b90265517a8bd1c986fec6da"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a4a906780b90265517a8bd1c986fec6da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a4a906780b90265517a8bd1c986fec6da">Halide::Internal::IRMatcher::ne</a> (A a, B b) -&gt; decltype(IRMatcher::operator!=(a, b))</td></tr>
<tr class="separator:a4a906780b90265517a8bd1c986fec6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d31793eaf2c9bb7b2091ed268032cd"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af1d31793eaf2c9bb7b2091ed268032cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af1d31793eaf2c9bb7b2091ed268032cd">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; NE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:af1d31793eaf2c9bb7b2091ed268032cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88969b742de298fa4e89c1b7e0cd9507"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a88969b742de298fa4e89c1b7e0cd9507"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a88969b742de298fa4e89c1b7e0cd9507">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; NE &gt;</a> (<a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a88969b742de298fa4e89c1b7e0cd9507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac761e19f9cf67ff92b92350cb2f6b113"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac761e19f9cf67ff92b92350cb2f6b113"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac761e19f9cf67ff92b92350cb2f6b113">Halide::Internal::IRMatcher::constant_fold_cmp_op&lt; NE &gt;</a> (double a, double b) noexcept</td></tr>
<tr class="separator:ac761e19f9cf67ff92b92350cb2f6b113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94d85808b783275e1a9d40c98057043"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ae94d85808b783275e1a9d40c98057043"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae94d85808b783275e1a9d40c98057043">Halide::Internal::IRMatcher::operator||</a> (A a, B b) noexcept-&gt; BinOp&lt; Or, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:ae94d85808b783275e1a9d40c98057043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bf9f9c7fde8541246b48cfb42d59a7"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ab0bf9f9c7fde8541246b48cfb42d59a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab0bf9f9c7fde8541246b48cfb42d59a7">Halide::Internal::IRMatcher::or_op</a> (A a, B b) -&gt; decltype(IRMatcher::operator||(a, b))</td></tr>
<tr class="separator:ab0bf9f9c7fde8541246b48cfb42d59a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e3a69d10dc265ce7af23472b244e7a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad6e3a69d10dc265ce7af23472b244e7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad6e3a69d10dc265ce7af23472b244e7a">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Or &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:ad6e3a69d10dc265ce7af23472b244e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9551d885c2e22f2a7452adad11b9088"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac9551d885c2e22f2a7452adad11b9088"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac9551d885c2e22f2a7452adad11b9088">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Or &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:ac9551d885c2e22f2a7452adad11b9088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af673f00fb1b63e823eba6f706412faf3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af673f00fb1b63e823eba6f706412faf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af673f00fb1b63e823eba6f706412faf3">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; Or &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:af673f00fb1b63e823eba6f706412faf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f8065441ef524e838228d4fbcaff71"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ac8f8065441ef524e838228d4fbcaff71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac8f8065441ef524e838228d4fbcaff71">Halide::Internal::IRMatcher::operator&amp;&amp;</a> (A a, B b) noexcept-&gt; BinOp&lt; And, decltype(pattern_arg(a)), decltype(pattern_arg(b))&gt;</td></tr>
<tr class="separator:ac8f8065441ef524e838228d4fbcaff71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6a6ea12f22e51277195015c162c2bd"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a2a6a6ea12f22e51277195015c162c2bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2a6a6ea12f22e51277195015c162c2bd">Halide::Internal::IRMatcher::and_op</a> (A a, B b) -&gt; decltype(IRMatcher::operator&amp;&amp;(a, b))</td></tr>
<tr class="separator:a2a6a6ea12f22e51277195015c162c2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5bef8af3af1585ae4d230d4096ea7e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a4b5bef8af3af1585ae4d230d4096ea7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a4b5bef8af3af1585ae4d230d4096ea7e">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; And &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> a, <a class="el" href="runtime__internal_8h.html#a11cbdb02b138f338b174a78c683f85fc">int64_t</a> b) noexcept</td></tr>
<tr class="separator:a4b5bef8af3af1585ae4d230d4096ea7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7c3ee7ce56b6e53ed07ee537ad0ae0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6d7c3ee7ce56b6e53ed07ee537ad0ae0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6d7c3ee7ce56b6e53ed07ee537ad0ae0">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; And &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> a, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> b) noexcept</td></tr>
<tr class="separator:a6d7c3ee7ce56b6e53ed07ee537ad0ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d065a5b95304e191321a47658e1da7"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a90d065a5b95304e191321a47658e1da7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a90d065a5b95304e191321a47658e1da7">Halide::Internal::IRMatcher::constant_fold_bin_op&lt; And &gt;</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> &amp;t, double a, double b) noexcept</td></tr>
<tr class="separator:a90d065a5b95304e191321a47658e1da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade15fc322252444c511ae6458ee2e898"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ade15fc322252444c511ae6458ee2e898">Halide::Internal::IRMatcher::bitwise_or_reduce</a> ()</td></tr>
<tr class="separator:ade15fc322252444c511ae6458ee2e898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0da60a736630e11d9ace4a610ec302"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aeb0da60a736630e11d9ace4a610ec302"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aeb0da60a736630e11d9ace4a610ec302">Halide::Internal::IRMatcher::bitwise_or_reduce</a> (<a class="el" href="runtime__internal_8h.html#ab422cc94a75a12c4e5646c5065674172">uint32_t</a> first, Args...rest)</td></tr>
<tr class="separator:aeb0da60a736630e11d9ace4a610ec302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fba2b048ff9dfde5b4fd084ae4a6de"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a67fba2b048ff9dfde5b4fd084ae4a6de">Halide::Internal::IRMatcher::and_reduce</a> ()</td></tr>
<tr class="separator:a67fba2b048ff9dfde5b4fd084ae4a6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8ba044778fbe09ed501b99bf3c85c1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acd8ba044778fbe09ed501b99bf3c85c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#acd8ba044778fbe09ed501b99bf3c85c1">Halide::Internal::IRMatcher::and_reduce</a> (bool first, Args...rest)</td></tr>
<tr class="separator:acd8ba044778fbe09ed501b99bf3c85c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25115ad072f9d082bcc9bfc4c83399c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac25115ad072f9d082bcc9bfc4c83399c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac25115ad072f9d082bcc9bfc4c83399c">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const Intrin&lt; Args... &gt; &amp;op)</td></tr>
<tr class="separator:ac25115ad072f9d082bcc9bfc4c83399c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cab04d11f6db097fa57dae62884d063"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6cab04d11f6db097fa57dae62884d063"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6cab04d11f6db097fa57dae62884d063">Halide::Internal::IRMatcher::intrin</a> (Call::IntrinsicOp intrinsic_op, Args...args) noexcept-&gt; Intrin&lt; decltype(pattern_arg(args))... &gt;</td></tr>
<tr class="separator:a6cab04d11f6db097fa57dae62884d063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7715f8e39df61398ec861a93af254312"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a7715f8e39df61398ec861a93af254312"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7715f8e39df61398ec861a93af254312">Halide::Internal::IRMatcher::operator!</a> (A a) noexcept-&gt; NotOp&lt; decltype(pattern_arg(a))&gt;</td></tr>
<tr class="separator:a7715f8e39df61398ec861a93af254312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c8d5239f78cadce0cd58f32583e5d3"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a87c8d5239f78cadce0cd58f32583e5d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a87c8d5239f78cadce0cd58f32583e5d3">Halide::Internal::IRMatcher::not_op</a> (A a) -&gt; decltype(IRMatcher::operator!(a))</td></tr>
<tr class="separator:a87c8d5239f78cadce0cd58f32583e5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad9a3678ae50d42223cc2609be3edc0"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a9ad9a3678ae50d42223cc2609be3edc0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9ad9a3678ae50d42223cc2609be3edc0">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const NotOp&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a9ad9a3678ae50d42223cc2609be3edc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3423872962efc0a52a5acdb3b7def67"><td class="memTemplParams" colspan="2">template&lt;typename C , typename T , typename F &gt; </td></tr>
<tr class="memitem:aa3423872962efc0a52a5acdb3b7def67"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa3423872962efc0a52a5acdb3b7def67">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const SelectOp&lt; C, T, F &gt; &amp;op)</td></tr>
<tr class="separator:aa3423872962efc0a52a5acdb3b7def67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37693b11993311b2cf7cb0c82e60f85b"><td class="memTemplParams" colspan="2">template&lt;typename C , typename T , typename F &gt; </td></tr>
<tr class="memitem:a37693b11993311b2cf7cb0c82e60f85b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a37693b11993311b2cf7cb0c82e60f85b">Halide::Internal::IRMatcher::select</a> (C c, T t, F f) noexcept-&gt; SelectOp&lt; decltype(pattern_arg(c)), decltype(pattern_arg(t)), decltype(pattern_arg(f))&gt;</td></tr>
<tr class="separator:a37693b11993311b2cf7cb0c82e60f85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dcbb3c3058e759b3c7ba04252c80fa"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a63dcbb3c3058e759b3c7ba04252c80fa"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a63dcbb3c3058e759b3c7ba04252c80fa">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const BroadcastOp&lt; A, true &gt; &amp;op)</td></tr>
<tr class="separator:a63dcbb3c3058e759b3c7ba04252c80fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b7faa2bbcb9240ab02a32b745b4377"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a21b7faa2bbcb9240ab02a32b745b4377"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a21b7faa2bbcb9240ab02a32b745b4377">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const BroadcastOp&lt; A, false &gt; &amp;op)</td></tr>
<tr class="separator:a21b7faa2bbcb9240ab02a32b745b4377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667ddb45c9e5245797730f66f924d1a3"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a667ddb45c9e5245797730f66f924d1a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a667ddb45c9e5245797730f66f924d1a3">Halide::Internal::IRMatcher::broadcast</a> (A a, int lanes) noexcept-&gt; BroadcastOp&lt; decltype(pattern_arg(a)), true &gt;</td></tr>
<tr class="separator:a667ddb45c9e5245797730f66f924d1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086a9ed9444c047acc4f542425355890"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a086a9ed9444c047acc4f542425355890"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a086a9ed9444c047acc4f542425355890">Halide::Internal::IRMatcher::broadcast</a> (A a) noexcept-&gt; BroadcastOp&lt; decltype(pattern_arg(a)), false &gt;</td></tr>
<tr class="separator:a086a9ed9444c047acc4f542425355890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2029e699a739fb7b43fbb660c673fd15"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a2029e699a739fb7b43fbb660c673fd15"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a2029e699a739fb7b43fbb660c673fd15">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const RampOp&lt; A, B, true &gt; &amp;op)</td></tr>
<tr class="separator:a2029e699a739fb7b43fbb660c673fd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d5aba42fb475b7c9baf382ec775af7"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a94d5aba42fb475b7c9baf382ec775af7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a94d5aba42fb475b7c9baf382ec775af7">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const RampOp&lt; A, B, false &gt; &amp;op)</td></tr>
<tr class="separator:a94d5aba42fb475b7c9baf382ec775af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad330b2cf5a3fb075142ef3ab578ef63e"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ad330b2cf5a3fb075142ef3ab578ef63e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad330b2cf5a3fb075142ef3ab578ef63e">Halide::Internal::IRMatcher::ramp</a> (A a, B b, int lanes) noexcept-&gt; RampOp&lt; decltype(pattern_arg(a)), decltype(pattern_arg(b)), true &gt;</td></tr>
<tr class="separator:ad330b2cf5a3fb075142ef3ab578ef63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958083cc58a4dab9f0389986fcdef9e6"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a958083cc58a4dab9f0389986fcdef9e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a958083cc58a4dab9f0389986fcdef9e6">Halide::Internal::IRMatcher::ramp</a> (A a, B b) noexcept-&gt; RampOp&lt; decltype(pattern_arg(a)), decltype(pattern_arg(b)), false &gt;</td></tr>
<tr class="separator:a958083cc58a4dab9f0389986fcdef9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360befd39bcbdb48f493e4fd80f8d3eb"><td class="memTemplParams" colspan="2">template&lt;typename A , VectorReduce::Operator reduce_op&gt; </td></tr>
<tr class="memitem:a360befd39bcbdb48f493e4fd80f8d3eb"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a360befd39bcbdb48f493e4fd80f8d3eb">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const VectorReduceOp&lt; A, true, reduce_op &gt; &amp;op)</td></tr>
<tr class="separator:a360befd39bcbdb48f493e4fd80f8d3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8cd14ec3a193675a03fc2e39d4522e"><td class="memTemplParams" colspan="2">template&lt;typename A , VectorReduce::Operator reduce_op&gt; </td></tr>
<tr class="memitem:a1e8cd14ec3a193675a03fc2e39d4522e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a1e8cd14ec3a193675a03fc2e39d4522e">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const VectorReduceOp&lt; A, false, reduce_op &gt; &amp;op)</td></tr>
<tr class="separator:a1e8cd14ec3a193675a03fc2e39d4522e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d33f85eed79a52003c120ec709deed"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:ab0d33f85eed79a52003c120ec709deed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab0d33f85eed79a52003c120ec709deed">Halide::Internal::IRMatcher::h_add</a> (A a, int lanes) noexcept-&gt; VectorReduceOp&lt; decltype(pattern_arg(a)), true, VectorReduce::Add &gt;</td></tr>
<tr class="separator:ab0d33f85eed79a52003c120ec709deed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9128b4a6a2d3985f65c8627ad683bb"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a7f9128b4a6a2d3985f65c8627ad683bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a7f9128b4a6a2d3985f65c8627ad683bb">Halide::Internal::IRMatcher::h_add</a> (A a) noexcept-&gt; VectorReduceOp&lt; decltype(pattern_arg(a)), false, VectorReduce::Add &gt;</td></tr>
<tr class="separator:a7f9128b4a6a2d3985f65c8627ad683bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6975843decba7662e4e43d0abba26e6f"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a6975843decba7662e4e43d0abba26e6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6975843decba7662e4e43d0abba26e6f">Halide::Internal::IRMatcher::h_min</a> (A a, int lanes) noexcept-&gt; VectorReduceOp&lt; decltype(pattern_arg(a)), true, VectorReduce::Min &gt;</td></tr>
<tr class="separator:a6975843decba7662e4e43d0abba26e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce3be35299314ab19c80cf8b058b905"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a9ce3be35299314ab19c80cf8b058b905"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9ce3be35299314ab19c80cf8b058b905">Halide::Internal::IRMatcher::h_min</a> (A a) noexcept-&gt; VectorReduceOp&lt; decltype(pattern_arg(a)), false, VectorReduce::Min &gt;</td></tr>
<tr class="separator:a9ce3be35299314ab19c80cf8b058b905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb85bd695d5dc4855e0a2a0436e07f1"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:aebb85bd695d5dc4855e0a2a0436e07f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aebb85bd695d5dc4855e0a2a0436e07f1">Halide::Internal::IRMatcher::h_max</a> (A a, int lanes) noexcept-&gt; VectorReduceOp&lt; decltype(pattern_arg(a)), true, VectorReduce::Max &gt;</td></tr>
<tr class="separator:aebb85bd695d5dc4855e0a2a0436e07f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae468ace73503b445f617740949e6b63b"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:ae468ace73503b445f617740949e6b63b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ae468ace73503b445f617740949e6b63b">Halide::Internal::IRMatcher::h_max</a> (A a) noexcept-&gt; VectorReduceOp&lt; decltype(pattern_arg(a)), false, VectorReduce::Max &gt;</td></tr>
<tr class="separator:ae468ace73503b445f617740949e6b63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7596ffc8394c508bdfc5da4f9de60e9"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:ac7596ffc8394c508bdfc5da4f9de60e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ac7596ffc8394c508bdfc5da4f9de60e9">Halide::Internal::IRMatcher::h_and</a> (A a, int lanes) noexcept-&gt; VectorReduceOp&lt; decltype(pattern_arg(a)), true, VectorReduce::And &gt;</td></tr>
<tr class="separator:ac7596ffc8394c508bdfc5da4f9de60e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5447dca123658f63835d5b6615e75f"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a3a5447dca123658f63835d5b6615e75f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3a5447dca123658f63835d5b6615e75f">Halide::Internal::IRMatcher::h_and</a> (A a) noexcept-&gt; VectorReduceOp&lt; decltype(pattern_arg(a)), false, VectorReduce::And &gt;</td></tr>
<tr class="separator:a3a5447dca123658f63835d5b6615e75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf340149942c33b3d2840c8d03f751c2"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:adf340149942c33b3d2840c8d03f751c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#adf340149942c33b3d2840c8d03f751c2">Halide::Internal::IRMatcher::h_or</a> (A a, int lanes) noexcept-&gt; VectorReduceOp&lt; decltype(pattern_arg(a)), true, VectorReduce::Or &gt;</td></tr>
<tr class="separator:adf340149942c33b3d2840c8d03f751c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9237747079fa4f81cc4dc81d28761c50"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a9237747079fa4f81cc4dc81d28761c50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a9237747079fa4f81cc4dc81d28761c50">Halide::Internal::IRMatcher::h_or</a> (A a) noexcept-&gt; VectorReduceOp&lt; decltype(pattern_arg(a)), false, VectorReduce::Or &gt;</td></tr>
<tr class="separator:a9237747079fa4f81cc4dc81d28761c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6144c2094a04fc0650b13e88c8cb0e7"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:af6144c2094a04fc0650b13e88c8cb0e7"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#af6144c2094a04fc0650b13e88c8cb0e7">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const NegateOp&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:af6144c2094a04fc0650b13e88c8cb0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef29daac62ddf7c97a80b84aaaec24f6"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:aef29daac62ddf7c97a80b84aaaec24f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aef29daac62ddf7c97a80b84aaaec24f6">Halide::Internal::IRMatcher::operator-</a> (A a) noexcept-&gt; NegateOp&lt; decltype(pattern_arg(a))&gt;</td></tr>
<tr class="separator:aef29daac62ddf7c97a80b84aaaec24f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e404380e6cd44651835ba853b292c4d"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a6e404380e6cd44651835ba853b292c4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6e404380e6cd44651835ba853b292c4d">Halide::Internal::IRMatcher::negate</a> (A a) -&gt; decltype(IRMatcher::operator-(a))</td></tr>
<tr class="separator:a6e404380e6cd44651835ba853b292c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcf314c678215e84e8af4eef15a6a21"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:adbcf314c678215e84e8af4eef15a6a21"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#adbcf314c678215e84e8af4eef15a6a21">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const CastOp&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:adbcf314c678215e84e8af4eef15a6a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac5ddee1a92d00e56166f2c67130d63"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:aaac5ddee1a92d00e56166f2c67130d63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aaac5ddee1a92d00e56166f2c67130d63">Halide::Internal::IRMatcher::cast</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, A a) noexcept-&gt; CastOp&lt; decltype(pattern_arg(a))&gt;</td></tr>
<tr class="separator:aaac5ddee1a92d00e56166f2c67130d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a94a5473d92d16fe2bcdbc34691bf6"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a49a94a5473d92d16fe2bcdbc34691bf6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a49a94a5473d92d16fe2bcdbc34691bf6">Halide::Internal::IRMatcher::fold</a> (A a) noexcept-&gt; Fold&lt; decltype(pattern_arg(a))&gt;</td></tr>
<tr class="separator:a49a94a5473d92d16fe2bcdbc34691bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443d1c29beb1d2d9560984699366f67d"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a443d1c29beb1d2d9560984699366f67d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a443d1c29beb1d2d9560984699366f67d">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const Fold&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a443d1c29beb1d2d9560984699366f67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a381973833d53c5e0cce54ac58ddf07"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a8a381973833d53c5e0cce54ac58ddf07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8a381973833d53c5e0cce54ac58ddf07">Halide::Internal::IRMatcher::overflows</a> (A a) noexcept-&gt; Overflows&lt; decltype(pattern_arg(a))&gt;</td></tr>
<tr class="separator:a8a381973833d53c5e0cce54ac58ddf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af40420f92ca04ccdc2bd5ed78687fc"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a8af40420f92ca04ccdc2bd5ed78687fc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a8af40420f92ca04ccdc2bd5ed78687fc">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const Overflows&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a8af40420f92ca04ccdc2bd5ed78687fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0be969cbc9fde866414c2a7bd07648"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6b0be969cbc9fde866414c2a7bd07648">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const Overflow &amp;op)</td></tr>
<tr class="separator:a6b0be969cbc9fde866414c2a7bd07648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa3e27a9719454501dcfe500de8bc88"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a3aa3e27a9719454501dcfe500de8bc88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3aa3e27a9719454501dcfe500de8bc88">Halide::Internal::IRMatcher::is_const</a> (A a) noexcept-&gt; IsConst&lt; decltype(pattern_arg(a))&gt;</td></tr>
<tr class="separator:a3aa3e27a9719454501dcfe500de8bc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2ecf97f86f365e0346423805eaf05a"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:abb2ecf97f86f365e0346423805eaf05a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#abb2ecf97f86f365e0346423805eaf05a">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const IsConst&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:abb2ecf97f86f365e0346423805eaf05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d723ae7fedfec8379bfc3b878dc7b9"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Prover &gt; </td></tr>
<tr class="memitem:a95d723ae7fedfec8379bfc3b878dc7b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a95d723ae7fedfec8379bfc3b878dc7b9">Halide::Internal::IRMatcher::can_prove</a> (A a, Prover *p) noexcept-&gt; CanProve&lt; decltype(pattern_arg(a)), Prover &gt;</td></tr>
<tr class="separator:a95d723ae7fedfec8379bfc3b878dc7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d02ed6452c98a876e00e56486f131c3"><td class="memTemplParams" colspan="2">template&lt;typename A , typename Prover &gt; </td></tr>
<tr class="memitem:a3d02ed6452c98a876e00e56486f131c3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3d02ed6452c98a876e00e56486f131c3">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const CanProve&lt; A, Prover &gt; &amp;op)</td></tr>
<tr class="separator:a3d02ed6452c98a876e00e56486f131c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81e2ef3aa6ae73f2fabc1df3cbe1d21"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:ab81e2ef3aa6ae73f2fabc1df3cbe1d21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ab81e2ef3aa6ae73f2fabc1df3cbe1d21">Halide::Internal::IRMatcher::is_float</a> (A a) noexcept-&gt; IsFloat&lt; decltype(pattern_arg(a))&gt;</td></tr>
<tr class="separator:ab81e2ef3aa6ae73f2fabc1df3cbe1d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f605385d281d571e62de8fd0a5f008"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a40f605385d281d571e62de8fd0a5f008"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a40f605385d281d571e62de8fd0a5f008">Halide::Internal::IRMatcher::operator&lt;&lt;</a> (std::ostream &amp;s, const IsFloat&lt; A &gt; &amp;op)</td></tr>
<tr class="separator:a40f605385d281d571e62de8fd0a5f008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f60c82d8daf8da2c27b3497c6c083f"><td class="memTemplParams" colspan="2">template&lt;typename Before , typename After , typename Predicate , typename  = typename std::enable_if&lt;std::decay&lt;Before&gt;::type::foldable &amp;&amp;                                            std::decay&lt;After&gt;::type::foldable&gt;::type&gt; </td></tr>
<tr class="memitem:aa0f60c82d8daf8da2c27b3497c6c083f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#aaf5c75e0994add0b42829f89d0bf3345">HALIDE_NEVER_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aa0f60c82d8daf8da2c27b3497c6c083f">Halide::Internal::IRMatcher::fuzz_test_rule</a> (Before &amp;&amp;before, After &amp;&amp;after, Predicate &amp;&amp;pred, <a class="el" href="structhalide__type__t.html">halide_type_t</a> wildcard_type, <a class="el" href="structhalide__type__t.html">halide_type_t</a> output_type) noexcept</td></tr>
<tr class="separator:aa0f60c82d8daf8da2c27b3497c6c083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440cc0cc987c622f2361638a3d310170"><td class="memTemplParams" colspan="2">template&lt;typename Before , typename After , typename Predicate , typename  = typename std::enable_if&lt;!(std::decay&lt;Before&gt;::type::foldable &amp;&amp;                                              std::decay&lt;After&gt;::type::foldable)&gt;::type&gt; </td></tr>
<tr class="memitem:a440cc0cc987c622f2361638a3d310170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a440cc0cc987c622f2361638a3d310170">Halide::Internal::IRMatcher::fuzz_test_rule</a> (Before &amp;&amp;before, After &amp;&amp;after, Predicate &amp;&amp;pred, <a class="el" href="structhalide__type__t.html">halide_type_t</a>, <a class="el" href="structhalide__type__t.html">halide_type_t</a>, int dummy=0) noexcept</td></tr>
<tr class="separator:a440cc0cc987c622f2361638a3d310170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c3af3849b20aa80caa9ceeb4d67b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a17c3af3849b20aa80caa9ceeb4d67b66">Halide::Internal::IRMatcher::evaluate_predicate</a> (bool x, MatcherState &amp;) noexcept</td></tr>
<tr class="separator:a17c3af3849b20aa80caa9ceeb4d67b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef18091a070c6c3f362c6ca55e75c2db"><td class="memTemplParams" colspan="2">template&lt;typename Pattern , typename  = typename enable_if_pattern&lt;Pattern&gt;::type&gt; </td></tr>
<tr class="memitem:aef18091a070c6c3f362c6ca55e75c2db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#aef18091a070c6c3f362c6ca55e75c2db">Halide::Internal::IRMatcher::evaluate_predicate</a> (Pattern p, MatcherState &amp;state)</td></tr>
<tr class="separator:aef18091a070c6c3f362c6ca55e75c2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3e32fc14f327a3a1d47ee8840a39538f"><td class="memTemplParams" colspan="2">template&lt;typename Instance , typename  = typename enable_if_pattern&lt;Instance&gt;::type&gt; </td></tr>
<tr class="memitem:a3e32fc14f327a3a1d47ee8840a39538f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3e32fc14f327a3a1d47ee8840a39538f">Halide::Internal::IRMatcher::rewriter</a> (Instance instance, <a class="el" href="structhalide__type__t.html">halide_type_t</a> output_type, <a class="el" href="structhalide__type__t.html">halide_type_t</a> wildcard_type) noexcept-&gt; Rewriter&lt; decltype(pattern_arg(instance))&gt;</td></tr>
<tr class="memdesc:a3e32fc14f327a3a1d47ee8840a39538f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a rewriter for the given instance, which may be a pattern with concrete expressions as leaves, or just an expression.  <a href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a3e32fc14f327a3a1d47ee8840a39538f">More...</a><br /></td></tr>
<tr class="separator:a3e32fc14f327a3a1d47ee8840a39538f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811998349ee3579c6326b7c2f85defd4"><td class="memTemplParams" colspan="2">template&lt;typename Instance , typename  = typename enable_if_pattern&lt;Instance&gt;::type&gt; </td></tr>
<tr class="memitem:a811998349ee3579c6326b7c2f85defd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a811998349ee3579c6326b7c2f85defd4">Halide::Internal::IRMatcher::rewriter</a> (Instance instance, <a class="el" href="structhalide__type__t.html">halide_type_t</a> output_type) noexcept-&gt; Rewriter&lt; decltype(pattern_arg(instance))&gt;</td></tr>
<tr class="memdesc:a811998349ee3579c6326b7c2f85defd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a rewriter for the given instance, which may be a pattern with concrete expressions as leaves, or just an expression.  <a href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a811998349ee3579c6326b7c2f85defd4">More...</a><br /></td></tr>
<tr class="separator:a811998349ee3579c6326b7c2f85defd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1759b266b0a037ceb90a2fce7a83e13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad1759b266b0a037ceb90a2fce7a83e13">Halide::Internal::IRMatcher::rewriter</a> (const Expr &amp;e, <a class="el" href="structhalide__type__t.html">halide_type_t</a> wildcard_type) noexcept-&gt; Rewriter&lt; decltype(pattern_arg(e))&gt;</td></tr>
<tr class="memdesc:ad1759b266b0a037ceb90a2fce7a83e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a rewriter for the given instance, which may be a pattern with concrete expressions as leaves, or just an expression.  <a href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#ad1759b266b0a037ceb90a2fce7a83e13">More...</a><br /></td></tr>
<tr class="separator:ad1759b266b0a037ceb90a2fce7a83e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58eee18d93bb9bbf5be06c3799b0c070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a58eee18d93bb9bbf5be06c3799b0c070">Halide::Internal::IRMatcher::rewriter</a> (const Expr &amp;e) noexcept-&gt; Rewriter&lt; decltype(pattern_arg(e))&gt;</td></tr>
<tr class="memdesc:a58eee18d93bb9bbf5be06c3799b0c070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a rewriter for the given instance, which may be a pattern with concrete expressions as leaves, or just an expression.  <a href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a58eee18d93bb9bbf5be06c3799b0c070">More...</a><br /></td></tr>
<tr class="separator:a58eee18d93bb9bbf5be06c3799b0c070"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6feb6895f4d41d350eda704b7e3cc4bc"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_halide_1_1_internal_1_1_i_r_matcher.html#a6feb6895f4d41d350eda704b7e3cc4bc">Halide::Internal::IRMatcher::max_wild</a> = 6</td></tr>
<tr class="separator:a6feb6895f4d41d350eda704b7e3cc4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines a method to match a fragment of IR against a pattern containing wildcards. </p>

<p>Definition in file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ac3cabe703f762c1fb43f00c9a77d6ae4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_DEBUG_MATCHED_RULES&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_match_8h_source.html#l02265">2265</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a class="anchor" id="a38de29759124484d5b8934bf77b54fc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_DEBUG_UNMATCHED_RULES&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_match_8h_source.html#l02266">2266</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
<a class="anchor" id="a71623e6847732d0ea4b811d8f93d0bd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HALIDE_FUZZ_TEST_RULES&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_i_r_match_8h_source.html#l02272">2272</a> of file <a class="el" href="_i_r_match_8h_source.html">IRMatch.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="_i_r_match_8h.html">IRMatch.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
