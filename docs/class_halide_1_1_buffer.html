<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: Halide::Buffer&lt; T, D &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_halide_1_1_buffer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_halide_1_1_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Buffer&lt; T, D &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A templated <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> class that wraps <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> and adds functionality.  
 <a href="class_halide_1_1_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer_1_1_dimension.html">Dimension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to the shape.  <a href="class_halide_1_1_buffer_1_1_dimension.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeb8e480b19032840b1c4fb6b8d32843a"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#aeb8e480b19032840b1c4fb6b8d32843a">ElemType</a></td></tr>
<tr class="separator:aeb8e480b19032840b1c4fb6b8d32843a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86c5eb230d814e020f3e822576aeb35b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_buffer_1_1_dimension.html">Dimension</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a86c5eb230d814e020f3e822576aeb35b">dim</a> (int i) const </td></tr>
<tr class="memdesc:a86c5eb230d814e020f3e822576aeb35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the shape of the buffer.  <a href="#a86c5eb230d814e020f3e822576aeb35b">More...</a><br/></td></tr>
<tr class="separator:a86c5eb230d814e020f3e822576aeb35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6874e089fea815dc01abe47c768fe254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a6874e089fea815dc01abe47c768fe254">number_of_elements</a> () const </td></tr>
<tr class="memdesc:a6874e089fea815dc01abe47c768fe254"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of elements this buffer represents.  <a href="#a6874e089fea815dc01abe47c768fe254">More...</a><br/></td></tr>
<tr class="separator:a6874e089fea815dc01abe47c768fe254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62457f00ec956c482c10d29e5fd9a9ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a62457f00ec956c482c10d29e5fd9a9ad">dimensions</a> () const </td></tr>
<tr class="memdesc:a62457f00ec956c482c10d29e5fd9a9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimensionality of the buffer.  <a href="#a62457f00ec956c482c10d29e5fd9a9ad">More...</a><br/></td></tr>
<tr class="separator:a62457f00ec956c482c10d29e5fd9a9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef076b0bef9d9aca1c448c4d1fd3c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a3ef076b0bef9d9aca1c448c4d1fd3c78">type</a> () const </td></tr>
<tr class="memdesc:a3ef076b0bef9d9aca1c448c4d1fd3c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the elements.  <a href="#a3ef076b0bef9d9aca1c448c4d1fd3c78">More...</a><br/></td></tr>
<tr class="separator:a3ef076b0bef9d9aca1c448c4d1fd3c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5b86295655ec3a9b69ef8fa8196b38"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a2d5b86295655ec3a9b69ef8fa8196b38">begin</a> () const </td></tr>
<tr class="memdesc:a2d5b86295655ec3a9b69ef8fa8196b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the element with the lowest address.  <a href="#a2d5b86295655ec3a9b69ef8fa8196b38">More...</a><br/></td></tr>
<tr class="separator:a2d5b86295655ec3a9b69ef8fa8196b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1a20a86aa83f88f5c5cc6c5211c0fb"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a1a1a20a86aa83f88f5c5cc6c5211c0fb">end</a> () const </td></tr>
<tr class="memdesc:a1a1a20a86aa83f88f5c5cc6c5211c0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to one beyond the element with the highest address.  <a href="#a1a1a20a86aa83f88f5c5cc6c5211c0fb">More...</a><br/></td></tr>
<tr class="separator:a1a1a20a86aa83f88f5c5cc6c5211c0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286c7e243fa5b5a56f56acef67e54c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a286c7e243fa5b5a56f56acef67e54c78">size_in_bytes</a> () const </td></tr>
<tr class="memdesc:a286c7e243fa5b5a56f56acef67e54c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of bytes spanned by the data in memory.  <a href="#a286c7e243fa5b5a56f56acef67e54c78">More...</a><br/></td></tr>
<tr class="separator:a286c7e243fa5b5a56f56acef67e54c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73685e116c75b8f3b8c7d66df2498b2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a73685e116c75b8f3b8c7d66df2498b2c">Buffer</a> ()</td></tr>
<tr class="separator:a73685e116c75b8f3b8c7d66df2498b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a889fc4922206d827b7800cd25af001"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a5a889fc4922206d827b7800cd25af001">Buffer</a> (const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;buf)</td></tr>
<tr class="memdesc:a5a889fc4922206d827b7800cd25af001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a buffer from a <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a>.  <a href="#a5a889fc4922206d827b7800cd25af001">More...</a><br/></td></tr>
<tr class="separator:a5a889fc4922206d827b7800cd25af001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9bff509a2b2e4c628ae84a7ffa6c67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a5e9bff509a2b2e4c628ae84a7ffa6c67">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;buf)</td></tr>
<tr class="separator:a5e9bff509a2b2e4c628ae84a7ffa6c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ea0c9ed7161b9a78315e507bdb5d84"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a90ea0c9ed7161b9a78315e507bdb5d84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a90ea0c9ed7161b9a78315e507bdb5d84">assert_can_convert_from</a> (const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a90ea0c9ed7161b9a78315e507bdb5d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fail an assertion at runtime or compile-time if an Buffer&lt;T, D&gt; cannot be constructed from some other <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> type.  <a href="#a90ea0c9ed7161b9a78315e507bdb5d84">More...</a><br/></td></tr>
<tr class="separator:a90ea0c9ed7161b9a78315e507bdb5d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83abb0752ce95b70d0048e0e4546e1e2"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a83abb0752ce95b70d0048e0e4546e1e2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a83abb0752ce95b70d0048e0e4546e1e2">Buffer</a> (const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a83abb0752ce95b70d0048e0e4546e1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Buffer&lt;T&gt; from another Buffer&lt;T&gt; of possibly-different dimensionality and type.  <a href="#a83abb0752ce95b70d0048e0e4546e1e2">More...</a><br/></td></tr>
<tr class="separator:a83abb0752ce95b70d0048e0e4546e1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6114a9201a16ca43abb0408f0c4ebb4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a6114a9201a16ca43abb0408f0c4ebb4e">Buffer</a> (const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;other)</td></tr>
<tr class="separator:a6114a9201a16ca43abb0408f0c4ebb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e447129139b649afb12569b90ad9f4a"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a9e447129139b649afb12569b90ad9f4a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a9e447129139b649afb12569b90ad9f4a">Buffer</a> (<a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a9e447129139b649afb12569b90ad9f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct an <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> from another <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality.  <a href="#a9e447129139b649afb12569b90ad9f4a">More...</a><br/></td></tr>
<tr class="separator:a9e447129139b649afb12569b90ad9f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e10e860d9fd5021554bcfaa355e2ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#ab9e10e860d9fd5021554bcfaa355e2ef">Buffer</a> (<a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&amp;other)</td></tr>
<tr class="separator:ab9e10e860d9fd5021554bcfaa355e2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499bd4c574b62d6c922b88d83f35adaa"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a499bd4c574b62d6c922b88d83f35adaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a499bd4c574b62d6c922b88d83f35adaa">operator=</a> (const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a499bd4c574b62d6c922b88d83f35adaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from another <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality and type.  <a href="#a499bd4c574b62d6c922b88d83f35adaa">More...</a><br/></td></tr>
<tr class="separator:a499bd4c574b62d6c922b88d83f35adaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65d8e9cdab536031e900279eda660dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#aa65d8e9cdab536031e900279eda660dd">operator=</a> (const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;other)</td></tr>
<tr class="separator:aa65d8e9cdab536031e900279eda660dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4025d98d4b0fcd5eb0205cc3d5918d"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:abf4025d98d4b0fcd5eb0205cc3d5918d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#abf4025d98d4b0fcd5eb0205cc3d5918d">operator=</a> (<a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:abf4025d98d4b0fcd5eb0205cc3d5918d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move from another <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality and type.  <a href="#abf4025d98d4b0fcd5eb0205cc3d5918d">More...</a><br/></td></tr>
<tr class="separator:abf4025d98d4b0fcd5eb0205cc3d5918d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929e77055f39ba4ffb70ee33b5ee8e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a929e77055f39ba4ffb70ee33b5ee8e44">operator=</a> (<a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&amp;other)</td></tr>
<tr class="separator:a929e77055f39ba4ffb70ee33b5ee8e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca70239ecd36891a76e6648d6ecf16f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#afca70239ecd36891a76e6648d6ecf16f">check_overflow</a> ()</td></tr>
<tr class="memdesc:afca70239ecd36891a76e6648d6ecf16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the product of the extents fits in memory.  <a href="#afca70239ecd36891a76e6648d6ecf16f">More...</a><br/></td></tr>
<tr class="separator:afca70239ecd36891a76e6648d6ecf16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcd9d2b701260e0a281f7240c9b2aef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#acbcd9d2b701260e0a281f7240c9b2aef">allocate</a> (void *(*allocate_fn)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)=nullptr, void(*deallocate_fn)(void *)=nullptr)</td></tr>
<tr class="memdesc:acbcd9d2b701260e0a281f7240c9b2aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for this <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a>.  <a href="#acbcd9d2b701260e0a281f7240c9b2aef">More...</a><br/></td></tr>
<tr class="separator:acbcd9d2b701260e0a281f7240c9b2aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46d7228360d4b1e6fea7139e40de584"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae46d7228360d4b1e6fea7139e40de584"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#ae46d7228360d4b1e6fea7139e40de584">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, int first, Args...rest)</td></tr>
<tr class="memdesc:ae46d7228360d4b1e6fea7139e40de584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of the given size with a runtime type.  <a href="#ae46d7228360d4b1e6fea7139e40de584">More...</a><br/></td></tr>
<tr class="separator:ae46d7228360d4b1e6fea7139e40de584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0fd8357e1754ce006bdee7ff70940c"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a9f0fd8357e1754ce006bdee7ff70940c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a9f0fd8357e1754ce006bdee7ff70940c">Buffer</a> (int first, Args...rest)</td></tr>
<tr class="memdesc:a9f0fd8357e1754ce006bdee7ff70940c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of the given size.  <a href="#a9f0fd8357e1754ce006bdee7ff70940c">More...</a><br/></td></tr>
<tr class="separator:a9f0fd8357e1754ce006bdee7ff70940c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac45051cbae289d681df6e98017fbbf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#aac45051cbae289d681df6e98017fbbf3">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, const std::vector&lt; int &gt; &amp;sizes)</td></tr>
<tr class="memdesc:aac45051cbae289d681df6e98017fbbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of unknown type using a vector of ints as the size.  <a href="#aac45051cbae289d681df6e98017fbbf3">More...</a><br/></td></tr>
<tr class="separator:aac45051cbae289d681df6e98017fbbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c55da8974fb848a078076113387ce6"><td class="memTemplParams" colspan="2">template&lt;typename Array , size_t N&gt; </td></tr>
<tr class="memitem:ae6c55da8974fb848a078076113387ce6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#ae6c55da8974fb848a078076113387ce6">Buffer</a> (Array(&amp;vals)[N])</td></tr>
<tr class="memdesc:ae6c55da8974fb848a078076113387ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> that refers to a statically sized array.  <a href="#ae6c55da8974fb848a078076113387ce6">More...</a><br/></td></tr>
<tr class="separator:ae6c55da8974fb848a078076113387ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57379875ff756278dce79ffee65277e7"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a57379875ff756278dce79ffee65277e7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a57379875ff756278dce79ffee65277e7">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, void *<a class="el" href="class_halide_1_1_buffer.html#a2a4ae3c17b9c920b665b22b0de66550e">data</a>, int first, Args &amp;&amp;...rest)</td></tr>
<tr class="memdesc:a57379875ff756278dce79ffee65277e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> of runtime type from a pointer and some sizes.  <a href="#a57379875ff756278dce79ffee65277e7">More...</a><br/></td></tr>
<tr class="separator:a57379875ff756278dce79ffee65277e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bb593c9c0efa68955cce6edfb5e82c"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a76bb593c9c0efa68955cce6edfb5e82c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a76bb593c9c0efa68955cce6edfb5e82c">Buffer</a> (T *<a class="el" href="class_halide_1_1_buffer.html#a2a4ae3c17b9c920b665b22b0de66550e">data</a>, int first, Args &amp;&amp;...rest)</td></tr>
<tr class="memdesc:a76bb593c9c0efa68955cce6edfb5e82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> from a pointer and some sizes.  <a href="#a76bb593c9c0efa68955cce6edfb5e82c">More...</a><br/></td></tr>
<tr class="separator:a76bb593c9c0efa68955cce6edfb5e82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af660a85d430d2b0e01d2fb3c21d91bb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#af660a85d430d2b0e01d2fb3c21d91bb0">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, void *<a class="el" href="class_halide_1_1_buffer.html#a2a4ae3c17b9c920b665b22b0de66550e">data</a>, int d, const <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> *shape)</td></tr>
<tr class="memdesc:af660a85d430d2b0e01d2fb3c21d91bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and an array describing the shape.  <a href="#af660a85d430d2b0e01d2fb3c21d91bb0">More...</a><br/></td></tr>
<tr class="separator:af660a85d430d2b0e01d2fb3c21d91bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad08b2093877cfa27376ac8dc9035b90"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#aad08b2093877cfa27376ac8dc9035b90">Buffer</a> (T *<a class="el" href="class_halide_1_1_buffer.html#a2a4ae3c17b9c920b665b22b0de66550e">data</a>, int d, const <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> *shape)</td></tr>
<tr class="memdesc:aad08b2093877cfa27376ac8dc9035b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and an array describing the shape.  <a href="#aad08b2093877cfa27376ac8dc9035b90">More...</a><br/></td></tr>
<tr class="separator:aad08b2093877cfa27376ac8dc9035b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05fc82b82832089da167b7ca90c7b0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#aa05fc82b82832089da167b7ca90c7b0d">~Buffer</a> ()</td></tr>
<tr class="memdesc:aa05fc82b82832089da167b7ca90c7b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aa05fc82b82832089da167b7ca90c7b0d">More...</a><br/></td></tr>
<tr class="separator:aa05fc82b82832089da167b7ca90c7b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0755ebe467bb994ea6d08a8fe59303fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a0755ebe467bb994ea6d08a8fe59303fb">operator buffer_t *</a> ()</td></tr>
<tr class="memdesc:a0755ebe467bb994ea6d08a8fe59303fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a cast operator to <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> *, so that instances can be passed directly to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> filters.  <a href="#a0755ebe467bb994ea6d08a8fe59303fb">More...</a><br/></td></tr>
<tr class="separator:a0755ebe467bb994ea6d08a8fe59303fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9311b632b671dac2f216a8b3bc1dbeca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a9311b632b671dac2f216a8b3bc1dbeca">copy</a> (void *(*allocate_fn)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)=nullptr, void(*deallocate_fn)(void *)=nullptr) const </td></tr>
<tr class="memdesc:a9311b632b671dac2f216a8b3bc1dbeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new image which is a deep copy of this image.  <a href="#a9311b632b671dac2f216a8b3bc1dbeca">More...</a><br/></td></tr>
<tr class="separator:a9311b632b671dac2f216a8b3bc1dbeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e55fb68de35a85185e2ec224e4b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a2b3e55fb68de35a85185e2ec224e4b16">cropped</a> (int d, int <a class="el" href="class_halide_1_1_buffer.html#aa0c6af1ead7054fadad49f3902c3a5ba">min</a>, int <a class="el" href="class_halide_1_1_buffer.html#a2f40720f1d579c25aebb45ee29d47371">extent</a>) const </td></tr>
<tr class="memdesc:a2b3e55fb68de35a85185e2ec224e4b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image that refers to a sub-range of this image along the given dimension.  <a href="#a2b3e55fb68de35a85185e2ec224e4b16">More...</a><br/></td></tr>
<tr class="separator:a2b3e55fb68de35a85185e2ec224e4b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb03c20872c08359208eae83369cb910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#aeb03c20872c08359208eae83369cb910">crop</a> (int d, int <a class="el" href="class_halide_1_1_buffer.html#aa0c6af1ead7054fadad49f3902c3a5ba">min</a>, int <a class="el" href="class_halide_1_1_buffer.html#a2f40720f1d579c25aebb45ee29d47371">extent</a>)</td></tr>
<tr class="memdesc:aeb03c20872c08359208eae83369cb910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crop an image in-place along the given dimension.  <a href="#aeb03c20872c08359208eae83369cb910">More...</a><br/></td></tr>
<tr class="separator:aeb03c20872c08359208eae83369cb910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bced70efdb1428cd12cd2cf86a0d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a98bced70efdb1428cd12cd2cf86a0d54">cropped</a> (const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;rect) const </td></tr>
<tr class="memdesc:a98bced70efdb1428cd12cd2cf86a0d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image that refers to a sub-rectangle of this image along the first N dimensions.  <a href="#a98bced70efdb1428cd12cd2cf86a0d54">More...</a><br/></td></tr>
<tr class="separator:a98bced70efdb1428cd12cd2cf86a0d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b2303a1cb27d74f9f7cfaf199bde49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a22b2303a1cb27d74f9f7cfaf199bde49">crop</a> (const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;rect)</td></tr>
<tr class="memdesc:a22b2303a1cb27d74f9f7cfaf199bde49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crop an image in-place along the first N dimensions.  <a href="#a22b2303a1cb27d74f9f7cfaf199bde49">More...</a><br/></td></tr>
<tr class="separator:a22b2303a1cb27d74f9f7cfaf199bde49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fe83fb4d0545d303cba50d0ff68e14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a46fe83fb4d0545d303cba50d0ff68e14">translated</a> (int d, int dx) const </td></tr>
<tr class="memdesc:a46fe83fb4d0545d303cba50d0ff68e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image which refers to the same data with using translated coordinates in the given dimension.  <a href="#a46fe83fb4d0545d303cba50d0ff68e14">More...</a><br/></td></tr>
<tr class="separator:a46fe83fb4d0545d303cba50d0ff68e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4916b7277d2dbb2e994f859184e925ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a4916b7277d2dbb2e994f859184e925ab">translate</a> (int d, int delta)</td></tr>
<tr class="memdesc:a4916b7277d2dbb2e994f859184e925ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate an image in-place along one dimension.  <a href="#a4916b7277d2dbb2e994f859184e925ab">More...</a><br/></td></tr>
<tr class="separator:a4916b7277d2dbb2e994f859184e925ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcd4d8e943eefa038e8e03e926ae5a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a9dcd4d8e943eefa038e8e03e926ae5a0">translated</a> (const std::vector&lt; int &gt; &amp;delta)</td></tr>
<tr class="memdesc:a9dcd4d8e943eefa038e8e03e926ae5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image which refers to the same data translated along the first N dimensions.  <a href="#a9dcd4d8e943eefa038e8e03e926ae5a0">More...</a><br/></td></tr>
<tr class="separator:a9dcd4d8e943eefa038e8e03e926ae5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d2ab7d832fa03b195a0bf0b7e8f03a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a16d2ab7d832fa03b195a0bf0b7e8f03a">translate</a> (const std::vector&lt; int &gt; &amp;delta)</td></tr>
<tr class="memdesc:a16d2ab7d832fa03b195a0bf0b7e8f03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate an image along the first N dimensions.  <a href="#a16d2ab7d832fa03b195a0bf0b7e8f03a">More...</a><br/></td></tr>
<tr class="separator:a16d2ab7d832fa03b195a0bf0b7e8f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b1ec3b9f174f27c9b8034d87c92b40"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a18b1ec3b9f174f27c9b8034d87c92b40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a18b1ec3b9f174f27c9b8034d87c92b40">set_min</a> (Args...args)</td></tr>
<tr class="memdesc:a18b1ec3b9f174f27c9b8034d87c92b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the min coordinate of an image in the first N dimensions.  <a href="#a18b1ec3b9f174f27c9b8034d87c92b40">More...</a><br/></td></tr>
<tr class="separator:a18b1ec3b9f174f27c9b8034d87c92b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb7333d35797bb0eb87c3cc85a9b1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#abbb7333d35797bb0eb87c3cc85a9b1cd">transposed</a> (int d1, int d2) const </td></tr>
<tr class="memdesc:abbb7333d35797bb0eb87c3cc85a9b1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image which refers to the same data using a different ordering of the dimensions.  <a href="#abbb7333d35797bb0eb87c3cc85a9b1cd">More...</a><br/></td></tr>
<tr class="separator:abbb7333d35797bb0eb87c3cc85a9b1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade0b39013c79390a2f450e693eeaa23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#aade0b39013c79390a2f450e693eeaa23">transpose</a> (int d1, int d2)</td></tr>
<tr class="memdesc:aade0b39013c79390a2f450e693eeaa23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose an image in-place.  <a href="#aade0b39013c79390a2f450e693eeaa23">More...</a><br/></td></tr>
<tr class="separator:aade0b39013c79390a2f450e693eeaa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e07da22f5dfcf35b8a3dc55a26e9ca4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D-1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a3e07da22f5dfcf35b8a3dc55a26e9ca4">sliced</a> (int d, int pos) const </td></tr>
<tr class="memdesc:a3e07da22f5dfcf35b8a3dc55a26e9ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a lower-dimensional image that refers to one slice of this image.  <a href="#a3e07da22f5dfcf35b8a3dc55a26e9ca4">More...</a><br/></td></tr>
<tr class="separator:a3e07da22f5dfcf35b8a3dc55a26e9ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a9ed6f06da6ed41542a7568b12fbb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a36a9ed6f06da6ed41542a7568b12fbb5">slice</a> (int d, int pos)</td></tr>
<tr class="memdesc:a36a9ed6f06da6ed41542a7568b12fbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice an image in-place.  <a href="#a36a9ed6f06da6ed41542a7568b12fbb5">More...</a><br/></td></tr>
<tr class="separator:a36a9ed6f06da6ed41542a7568b12fbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd3075002bc58f419cd63c516dde635"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a0dd3075002bc58f419cd63c516dde635">embedded</a> (int d, int pos) const </td></tr>
<tr class="memdesc:a0dd3075002bc58f419cd63c516dde635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new image that views this image as a single slice in a higher-dimensional space.  <a href="#a0dd3075002bc58f419cd63c516dde635">More...</a><br/></td></tr>
<tr class="separator:a0dd3075002bc58f419cd63c516dde635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e0cd6659b1abeaa41c8b7250a9197c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#ae3e0cd6659b1abeaa41c8b7250a9197c">embed</a> (int d, int pos)</td></tr>
<tr class="memdesc:ae3e0cd6659b1abeaa41c8b7250a9197c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Embed an image in-place, increasing the dimensionality.  <a href="#ae3e0cd6659b1abeaa41c8b7250a9197c">More...</a><br/></td></tr>
<tr class="separator:ae3e0cd6659b1abeaa41c8b7250a9197c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11c825f189aae4fa2bee9fb2e2ec31d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#af11c825f189aae4fa2bee9fb2e2ec31d">add_dimension</a> ()</td></tr>
<tr class="memdesc:af11c825f189aae4fa2bee9fb2e2ec31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new dimension with a min of zero and an extent of one.  <a href="#af11c825f189aae4fa2bee9fb2e2ec31d">More...</a><br/></td></tr>
<tr class="separator:af11c825f189aae4fa2bee9fb2e2ec31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e41ca198e36bc0967386d3dc9699937"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a8e41ca198e36bc0967386d3dc9699937"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a8e41ca198e36bc0967386d3dc9699937">for_each_element</a> (Fn f) const </td></tr>
<tr class="memdesc:a8e41ca198e36bc0967386d3dc9699937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a callable at each location within the image.  <a href="#a8e41ca198e36bc0967386d3dc9699937">More...</a><br/></td></tr>
<tr class="separator:a8e41ca198e36bc0967386d3dc9699937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa693fc8ac6e3f11ee9a78fb975200f9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#aa693fc8ac6e3f11ee9a78fb975200f9a">fill</a> (not_void_T val)</td></tr>
<tr class="memdesc:aa693fc8ac6e3f11ee9a78fb975200f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set every value in the buffer to the given value.  <a href="#aa693fc8ac6e3f11ee9a78fb975200f9a">More...</a><br/></td></tr>
<tr class="separator:aa693fc8ac6e3f11ee9a78fb975200f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa0c6af1ead7054fadad49f3902c3a5ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#aa0c6af1ead7054fadad49f3902c3a5ba">min</a> (int i) const </td></tr>
<tr class="memdesc:aa0c6af1ead7054fadad49f3902c3a5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the mins, strides, extents.  <a href="#aa0c6af1ead7054fadad49f3902c3a5ba">More...</a><br/></td></tr>
<tr class="separator:aa0c6af1ead7054fadad49f3902c3a5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f40720f1d579c25aebb45ee29d47371"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a2f40720f1d579c25aebb45ee29d47371">extent</a> (int i) const </td></tr>
<tr class="memdesc:a2f40720f1d579c25aebb45ee29d47371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the mins, strides, extents.  <a href="#a2f40720f1d579c25aebb45ee29d47371">More...</a><br/></td></tr>
<tr class="separator:a2f40720f1d579c25aebb45ee29d47371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c6b61a4230004c97f58689288ae352"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a73c6b61a4230004c97f58689288ae352">stride</a> (int i) const </td></tr>
<tr class="memdesc:a73c6b61a4230004c97f58689288ae352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the mins, strides, extents.  <a href="#a73c6b61a4230004c97f58689288ae352">More...</a><br/></td></tr>
<tr class="separator:a73c6b61a4230004c97f58689288ae352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:abf453a9c1fc044393bcae55b2f93c572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#abf453a9c1fc044393bcae55b2f93c572">raw_buffer</a> ()</td></tr>
<tr class="memdesc:abf453a9c1fc044393bcae55b2f93c572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> this wraps.  <a href="#abf453a9c1fc044393bcae55b2f93c572">More...</a><br/></td></tr>
<tr class="separator:abf453a9c1fc044393bcae55b2f93c572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81560ecb869bc8b5027dd89c1d888f02"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbuffer__t.html">buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a81560ecb869bc8b5027dd89c1d888f02">raw_buffer</a> () const </td></tr>
<tr class="memdesc:a81560ecb869bc8b5027dd89c1d888f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> this wraps.  <a href="#a81560ecb869bc8b5027dd89c1d888f02">More...</a><br/></td></tr>
<tr class="separator:a81560ecb869bc8b5027dd89c1d888f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac0032539a7342e1ec79210a373f48c12"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#ac0032539a7342e1ec79210a373f48c12">host_ptr</a> () const </td></tr>
<tr class="memdesc:ac0032539a7342e1ec79210a373f48c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the untyped host pointer.  <a href="#ac0032539a7342e1ec79210a373f48c12">More...</a><br/></td></tr>
<tr class="separator:ac0032539a7342e1ec79210a373f48c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fe7eb9342b9cef867e6896e8d1461d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a75fe7eb9342b9cef867e6896e8d1461d">host_ptr</a> ()</td></tr>
<tr class="memdesc:a75fe7eb9342b9cef867e6896e8d1461d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the untyped host pointer.  <a href="#a75fe7eb9342b9cef867e6896e8d1461d">More...</a><br/></td></tr>
<tr class="separator:a75fe7eb9342b9cef867e6896e8d1461d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa617822fc9ed907631306dab784d8ea1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#aa617822fc9ed907631306dab784d8ea1">width</a> () const </td></tr>
<tr class="memdesc:aa617822fc9ed907631306dab784d8ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the first three dimensions.  <a href="#aa617822fc9ed907631306dab784d8ea1">More...</a><br/></td></tr>
<tr class="separator:aa617822fc9ed907631306dab784d8ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3b230743401a274cdce661f4890614"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#abd3b230743401a274cdce661f4890614">height</a> () const </td></tr>
<tr class="memdesc:abd3b230743401a274cdce661f4890614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the first three dimensions.  <a href="#abd3b230743401a274cdce661f4890614">More...</a><br/></td></tr>
<tr class="separator:abd3b230743401a274cdce661f4890614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55371dab681299cac52cc76de00e6f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#ac55371dab681299cac52cc76de00e6f8">channels</a> () const </td></tr>
<tr class="memdesc:ac55371dab681299cac52cc76de00e6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the first three dimensions.  <a href="#ac55371dab681299cac52cc76de00e6f8">More...</a><br/></td></tr>
<tr class="separator:ac55371dab681299cac52cc76de00e6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae3f238bd19736ee200f717ca55f532e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#ae3f238bd19736ee200f717ca55f532e7">left</a> () const </td></tr>
<tr class="memdesc:ae3f238bd19736ee200f717ca55f532e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the min and max value of each dimension.  <a href="#ae3f238bd19736ee200f717ca55f532e7">More...</a><br/></td></tr>
<tr class="separator:ae3f238bd19736ee200f717ca55f532e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaabbfa8b0e18de8120d9480adbe998"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a9eaabbfa8b0e18de8120d9480adbe998">right</a> () const </td></tr>
<tr class="memdesc:a9eaabbfa8b0e18de8120d9480adbe998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the min and max value of each dimension.  <a href="#a9eaabbfa8b0e18de8120d9480adbe998">More...</a><br/></td></tr>
<tr class="separator:a9eaabbfa8b0e18de8120d9480adbe998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcdb6d93dab25b727ad842be7c2cf86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#abfcdb6d93dab25b727ad842be7c2cf86">top</a> () const </td></tr>
<tr class="memdesc:abfcdb6d93dab25b727ad842be7c2cf86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the min and max value of each dimension.  <a href="#abfcdb6d93dab25b727ad842be7c2cf86">More...</a><br/></td></tr>
<tr class="separator:abfcdb6d93dab25b727ad842be7c2cf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052be6a4179ad3668d5448956448b117"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a052be6a4179ad3668d5448956448b117">bottom</a> () const </td></tr>
<tr class="memdesc:a052be6a4179ad3668d5448956448b117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the min and max value of each dimension.  <a href="#a052be6a4179ad3668d5448956448b117">More...</a><br/></td></tr>
<tr class="separator:a052be6a4179ad3668d5448956448b117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a22b9d36de1b23c4300649ff7fc06f8c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a22b9d36de1b23c4300649ff7fc06f8c8">set_host_dirty</a> (bool v=true)</td></tr>
<tr class="memdesc:a22b9d36de1b23c4300649ff7fc06f8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a22b9d36de1b23c4300649ff7fc06f8c8">More...</a><br/></td></tr>
<tr class="separator:a22b9d36de1b23c4300649ff7fc06f8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996ffbeea2d591d2f96ace77428cbec9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a996ffbeea2d591d2f96ace77428cbec9">device_dirty</a> () const </td></tr>
<tr class="memdesc:a996ffbeea2d591d2f96ace77428cbec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a996ffbeea2d591d2f96ace77428cbec9">More...</a><br/></td></tr>
<tr class="separator:a996ffbeea2d591d2f96ace77428cbec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f03e25ee5f42743048276541aeebdd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a3f03e25ee5f42743048276541aeebdd9">host_dirty</a> () const </td></tr>
<tr class="memdesc:a3f03e25ee5f42743048276541aeebdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a3f03e25ee5f42743048276541aeebdd9">More...</a><br/></td></tr>
<tr class="separator:a3f03e25ee5f42743048276541aeebdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab613ff5669d2697f5729ed3a775dd616"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#ab613ff5669d2697f5729ed3a775dd616">set_device_dirty</a> (bool v=true)</td></tr>
<tr class="memdesc:ab613ff5669d2697f5729ed3a775dd616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#ab613ff5669d2697f5729ed3a775dd616">More...</a><br/></td></tr>
<tr class="separator:ab613ff5669d2697f5729ed3a775dd616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670397fc9de22741d727c41122b62750"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a670397fc9de22741d727c41122b62750">copy_to_host</a> (void *ctx=nullptr)</td></tr>
<tr class="memdesc:a670397fc9de22741d727c41122b62750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a670397fc9de22741d727c41122b62750">More...</a><br/></td></tr>
<tr class="separator:a670397fc9de22741d727c41122b62750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d73861a5cdeeb1f4276c07ddb653e85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a4d73861a5cdeeb1f4276c07ddb653e85">copy_to_device</a> (const struct <a class="el" href="structhalide__device__interface.html">halide_device_interface</a> *device_interface, void *ctx=nullptr)</td></tr>
<tr class="memdesc:a4d73861a5cdeeb1f4276c07ddb653e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a4d73861a5cdeeb1f4276c07ddb653e85">More...</a><br/></td></tr>
<tr class="separator:a4d73861a5cdeeb1f4276c07ddb653e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5edeae398486ae33ab2c158ec4a7e84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#af5edeae398486ae33ab2c158ec4a7e84">device_free</a> (void *ctx=nullptr)</td></tr>
<tr class="memdesc:af5edeae398486ae33ab2c158ec4a7e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#af5edeae398486ae33ab2c158ec4a7e84">More...</a><br/></td></tr>
<tr class="separator:af5edeae398486ae33ab2c158ec4a7e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bbe8e9425f43588000fe9dffc6b9e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a53bbe8e9425f43588000fe9dffc6b9e7">device_sync</a> (void *ctx=nullptr)</td></tr>
<tr class="memdesc:a53bbe8e9425f43588000fe9dffc6b9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a53bbe8e9425f43588000fe9dffc6b9e7">More...</a><br/></td></tr>
<tr class="separator:a53bbe8e9425f43588000fe9dffc6b9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2a4ae3c17b9c920b665b22b0de66550e"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a2a4ae3c17b9c920b665b22b0de66550e">data</a> ()</td></tr>
<tr class="memdesc:a2a4ae3c17b9c920b665b22b0de66550e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the address of the min coordinate.  <a href="#a2a4ae3c17b9c920b665b22b0de66550e">More...</a><br/></td></tr>
<tr class="separator:a2a4ae3c17b9c920b665b22b0de66550e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacee330da621820d34c21f5d79f3105"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#adacee330da621820d34c21f5d79f3105">data</a> () const </td></tr>
<tr class="memdesc:adacee330da621820d34c21f5d79f3105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the address of the min coordinate.  <a href="#adacee330da621820d34c21f5d79f3105">More...</a><br/></td></tr>
<tr class="separator:adacee330da621820d34c21f5d79f3105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad8d039e4896d72830bb0242082e05e80"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad8d039e4896d72830bb0242082e05e80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> const not_void_T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#ad8d039e4896d72830bb0242082e05e80">operator()</a> (int first, Args...rest) const </td></tr>
<tr class="memdesc:ad8d039e4896d72830bb0242082e05e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#ad8d039e4896d72830bb0242082e05e80">More...</a><br/></td></tr>
<tr class="separator:ad8d039e4896d72830bb0242082e05e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494f09fa40b4257b82877483026c9a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> const not_void_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a494f09fa40b4257b82877483026c9a1c">operator()</a> () const </td></tr>
<tr class="memdesc:a494f09fa40b4257b82877483026c9a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#a494f09fa40b4257b82877483026c9a1c">More...</a><br/></td></tr>
<tr class="separator:a494f09fa40b4257b82877483026c9a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62eb5fb79f3fcd584d04a7183b8e3c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> const not_void_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#ad62eb5fb79f3fcd584d04a7183b8e3c2">operator()</a> (const int *pos) const </td></tr>
<tr class="memdesc:ad62eb5fb79f3fcd584d04a7183b8e3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#ad62eb5fb79f3fcd584d04a7183b8e3c2">More...</a><br/></td></tr>
<tr class="separator:ad62eb5fb79f3fcd584d04a7183b8e3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4e24d75f9cd33ad9fb64d6f11d3e08"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aae4e24d75f9cd33ad9fb64d6f11d3e08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> not_void_T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#aae4e24d75f9cd33ad9fb64d6f11d3e08">operator()</a> (int first, Args...rest)</td></tr>
<tr class="memdesc:aae4e24d75f9cd33ad9fb64d6f11d3e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#aae4e24d75f9cd33ad9fb64d6f11d3e08">More...</a><br/></td></tr>
<tr class="separator:aae4e24d75f9cd33ad9fb64d6f11d3e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b092056e74f3693644e6c3e293645e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> not_void_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a96b092056e74f3693644e6c3e293645e">operator()</a> ()</td></tr>
<tr class="memdesc:a96b092056e74f3693644e6c3e293645e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#a96b092056e74f3693644e6c3e293645e">More...</a><br/></td></tr>
<tr class="separator:a96b092056e74f3693644e6c3e293645e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b95b5ee39fed033bbcdb21edafe456b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> not_void_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a4b95b5ee39fed033bbcdb21edafe456b">operator()</a> (const int *pos)</td></tr>
<tr class="memdesc:a4b95b5ee39fed033bbcdb21edafe456b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#a4b95b5ee39fed033bbcdb21edafe456b">More...</a><br/></td></tr>
<tr class="separator:a4b95b5ee39fed033bbcdb21edafe456b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a96df98ba3fce7b6238bddb09754f164e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a96df98ba3fce7b6238bddb09754f164e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a96df98ba3fce7b6238bddb09754f164e">operator()</a> (Args...args) const -&gt; decltype(<a class="el" href="namespace_halide.html#a471d67f16ba731c512c017aea89f20f5">image_accessor</a>(*this, args...))</td></tr>
<tr class="memdesc:a96df98ba3fce7b6238bddb09754f164e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Other calls to operator()(Args...) get redirected to a call to image_accessor(const Buffer&lt;T, D&gt; &amp;, Args...).  <a href="#a96df98ba3fce7b6238bddb09754f164e">More...</a><br/></td></tr>
<tr class="separator:a96df98ba3fce7b6238bddb09754f164e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7dcf3e7ae6bcd69af9d6834e08c392"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aae7dcf3e7ae6bcd69af9d6834e08c392"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#aae7dcf3e7ae6bcd69af9d6834e08c392">operator()</a> (Args...args) -&gt; decltype(<a class="el" href="namespace_halide.html#a471d67f16ba731c512c017aea89f20f5">image_accessor</a>(*this, args...))</td></tr>
<tr class="memdesc:aae7dcf3e7ae6bcd69af9d6834e08c392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Other calls to operator()(Args...) get redirected to a call to image_accessor(const Buffer&lt;T, D&gt; &amp;, Args...).  <a href="#aae7dcf3e7ae6bcd69af9d6834e08c392">More...</a><br/></td></tr>
<tr class="separator:aae7dcf3e7ae6bcd69af9d6834e08c392"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a816556bb6d48a73602927c11078478af"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; void, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a816556bb6d48a73602927c11078478af">make_interleaved</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, int <a class="el" href="class_halide_1_1_buffer.html#aa617822fc9ed907631306dab784d8ea1">width</a>, int <a class="el" href="class_halide_1_1_buffer.html#abd3b230743401a274cdce661f4890614">height</a>, int <a class="el" href="class_halide_1_1_buffer.html#ac55371dab681299cac52cc76de00e6f8">channels</a>)</td></tr>
<tr class="memdesc:a816556bb6d48a73602927c11078478af"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you use the (x, y, c) indexing convention, then <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Buffers are stored planar by default.  <a href="#a816556bb6d48a73602927c11078478af">More...</a><br/></td></tr>
<tr class="separator:a816556bb6d48a73602927c11078478af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0ff4d9e143d93f226b6ad291a7f1f3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#ace0ff4d9e143d93f226b6ad291a7f1f3">make_interleaved</a> (int <a class="el" href="class_halide_1_1_buffer.html#aa617822fc9ed907631306dab784d8ea1">width</a>, int <a class="el" href="class_halide_1_1_buffer.html#abd3b230743401a274cdce661f4890614">height</a>, int <a class="el" href="class_halide_1_1_buffer.html#ac55371dab681299cac52cc76de00e6f8">channels</a>)</td></tr>
<tr class="memdesc:ace0ff4d9e143d93f226b6ad291a7f1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you use the (x, y, c) indexing convention, then <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Buffers are stored planar by default.  <a href="#ace0ff4d9e143d93f226b6ad291a7f1f3">More...</a><br/></td></tr>
<tr class="separator:ace0ff4d9e143d93f226b6ad291a7f1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9ba2e2c395e3f74bdc0f6af7b1178d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; void, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a1c9ba2e2c395e3f74bdc0f6af7b1178d">make_interleaved</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, T *<a class="el" href="class_halide_1_1_buffer.html#a2a4ae3c17b9c920b665b22b0de66550e">data</a>, int <a class="el" href="class_halide_1_1_buffer.html#aa617822fc9ed907631306dab784d8ea1">width</a>, int <a class="el" href="class_halide_1_1_buffer.html#abd3b230743401a274cdce661f4890614">height</a>, int <a class="el" href="class_halide_1_1_buffer.html#ac55371dab681299cac52cc76de00e6f8">channels</a>)</td></tr>
<tr class="memdesc:a1c9ba2e2c395e3f74bdc0f6af7b1178d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an existing interleaved image.  <a href="#a1c9ba2e2c395e3f74bdc0f6af7b1178d">More...</a><br/></td></tr>
<tr class="separator:a1c9ba2e2c395e3f74bdc0f6af7b1178d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94eb162884b30d77651a2ed7750cc6ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a94eb162884b30d77651a2ed7750cc6ad">make_interleaved</a> (T *<a class="el" href="class_halide_1_1_buffer.html#a2a4ae3c17b9c920b665b22b0de66550e">data</a>, int <a class="el" href="class_halide_1_1_buffer.html#aa617822fc9ed907631306dab784d8ea1">width</a>, int <a class="el" href="class_halide_1_1_buffer.html#abd3b230743401a274cdce661f4890614">height</a>, int <a class="el" href="class_halide_1_1_buffer.html#ac55371dab681299cac52cc76de00e6f8">channels</a>)</td></tr>
<tr class="memdesc:a94eb162884b30d77651a2ed7750cc6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an existing interleaved image.  <a href="#a94eb162884b30d77651a2ed7750cc6ad">More...</a><br/></td></tr>
<tr class="separator:a94eb162884b30d77651a2ed7750cc6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ad8170e21de12c5d7c53df3e7b3bee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; void, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#ab1ad8170e21de12c5d7c53df3e7b3bee">make_scalar</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t)</td></tr>
<tr class="memdesc:ab1ad8170e21de12c5d7c53df3e7b3bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a zero-dimensional <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a>.  <a href="#ab1ad8170e21de12c5d7c53df3e7b3bee">More...</a><br/></td></tr>
<tr class="separator:ab1ad8170e21de12c5d7c53df3e7b3bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb74f655ad7ecb025fd53e07ec2ad65"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_buffer.html#a0eb74f655ad7ecb025fd53e07ec2ad65">make_scalar</a> ()</td></tr>
<tr class="memdesc:a0eb74f655ad7ecb025fd53e07ec2ad65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a zero-dimensional <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a>.  <a href="#a0eb74f655ad7ecb025fd53e07ec2ad65">More...</a><br/></td></tr>
<tr class="separator:a0eb74f655ad7ecb025fd53e07ec2ad65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, int D&gt;<br/>
class Halide::Buffer&lt; T, D &gt;</h3>

<p>A templated <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> class that wraps <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> and adds functionality. </p>
<p>When using <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> from C++, this is the preferred way to create input and output buffers. The overhead of using this class relative to a naked <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> is minimal - it uses another ~100 bytes on the stack, and does no dynamic allocations when using it to represent existing memory. This overhead will shrink further in the future once <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> is deprecated.</p>
<p>The template parameter T is the element type, and D is the maximum number of dimensions. It must be less than or equal to 4 for now. For buffers where the element type is not known at compile time, use void for T.</p>
<p>The class optionally allocates and owns memory for the image using a shared pointer allocated with the provided allocator. If they are null, malloc and free are used. Any device-side allocation is considered as owned if and only if the host-side allocation is owned.</p>
<p>For accessing the shape and type, this class provides both the buffer_t-style interface (extent(i), min(i), and stride(i)), and also the interface of the yet-to-come halide_buffer_t, which will replace <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a>. This is intended to allow a gradual transition to halide_buffer_t. New code should access the shape via dim(i).<a class="el" href="class_halide_1_1_buffer.html#a2f40720f1d579c25aebb45ee29d47371" title="Access to the mins, strides, extents. ">extent()</a>, dim(i).<a class="el" href="class_halide_1_1_buffer.html#aa0c6af1ead7054fadad49f3902c3a5ba" title="Access to the mins, strides, extents. ">min()</a>, and dim(i).<a class="el" href="class_halide_1_1_buffer.html#a73c6b61a4230004c97f58689288ae352" title="Access to the mins, strides, extents. ">stride()</a> </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_01_basics_8cpp-example.html#_a3">tutorial/lesson_01_basics.cpp</a>, <a class="el" href="tutorial_2lesson_02_input_image_8cpp-example.html#_a0">tutorial/lesson_02_input_image.cpp</a>, <a class="el" href="tutorial_2lesson_03_debugging_1_8cpp-example.html#_a2">tutorial/lesson_03_debugging_1.cpp</a>, <a class="el" href="tutorial_2lesson_04_debugging_2_8cpp-example.html#_a3">tutorial/lesson_04_debugging_2.cpp</a>, <a class="el" href="tutorial_2lesson_05_scheduling_1_8cpp-example.html#_a3">tutorial/lesson_05_scheduling_1.cpp</a>, <a class="el" href="tutorial_2lesson_06_realizing_over_shifted_domains_8cpp-example.html#_a3">tutorial/lesson_06_realizing_over_shifted_domains.cpp</a>, <a class="el" href="tutorial_2lesson_07_multi_stage_pipelines_8cpp-example.html#_a1">tutorial/lesson_07_multi_stage_pipelines.cpp</a>, <a class="el" href="tutorial_2lesson_08_scheduling_2_8cpp-example.html#_a14">tutorial/lesson_08_scheduling_2.cpp</a>, <a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#_a1">tutorial/lesson_09_update_definitions.cpp</a>, <a class="el" href="tutorial_2lesson_12_using_the_gpu_8cpp-example.html#_a2">tutorial/lesson_12_using_the_gpu.cpp</a>, and <a class="el" href="tutorial_2lesson_13_tuples_8cpp-example.html#_a9">tutorial/lesson_13_tuples.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00044">44</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aeb8e480b19032840b1c4fb6b8d32843a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html#aeb8e480b19032840b1c4fb6b8d32843a">ElemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00281">281</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a73685e116c75b8f3b8c7d66df2498b2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00392">392</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5a889fc4922206d827b7800cd25af001"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a buffer from a <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a>. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00395">395</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e9bff509a2b2e4c628ae84a7ffa6c67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00400">400</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a83abb0752ce95b70d0048e0e4546e1e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a Buffer&lt;T&gt; from another Buffer&lt;T&gt; of possibly-different dimensionality and type. </p>
<p>Asserts if D is less than the dimensionality of the argument, or if there's a type mismatch. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00430">430</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00410">Halide::Buffer&lt; T, D &gt;::assert_can_convert_from()</a>.</p>

</div>
</div>
<a class="anchor" id="a6114a9201a16ca43abb0408f0c4ebb4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00438">438</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9e447129139b649afb12569b90ad9f4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct an <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> from another <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality. </p>
<p>Asserts if D is less than the dimensionality of the argument, or if there's a type mismatch. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00450">450</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00410">Halide::Buffer&lt; T, D &gt;::assert_can_convert_from()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9e10e860d9fd5021554bcfaa355e2ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00458">458</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae46d7228360d4b1e6fea7139e40de584"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of the given size with a runtime type. </p>
<p>Only used when you do know what size you want but you don't know statically what type the elements are. Pass zeroes to make a buffer suitable for bounds query calls. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00577">577</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00547">Halide::Buffer&lt; T, D &gt;::allocate()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00532">Halide::Buffer&lt; T, D &gt;::check_overflow()</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>.</p>

</div>
</div>
<a class="anchor" id="a9f0fd8357e1754ce006bdee7ff70940c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of the given size. </p>
<p>Pass zeroes to make a buffer suitable for bounds query calls. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00598">598</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00547">Halide::Buffer&lt; T, D &gt;::allocate()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00532">Halide::Buffer&lt; T, D &gt;::check_overflow()</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>.</p>

</div>
</div>
<a class="anchor" id="aac45051cbae289d681df6e98017fbbf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of unknown type using a vector of ints as the size. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00614">614</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00547">Halide::Buffer&lt; T, D &gt;::allocate()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00532">Halide::Buffer&lt; T, D &gt;::check_overflow()</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>.</p>

</div>
</div>
<a class="anchor" id="ae6c55da8974fb848a078076113387ce6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename Array , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">Array(&amp;)&#160;</td>
          <td class="paramname"><em>vals</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> that refers to a statically sized array. </p>
<p>Does not take ownership of the data. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00631">631</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>.</p>

</div>
</div>
<a class="anchor" id="a57379875ff756278dce79ffee65277e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> of runtime type from a pointer and some sizes. </p>
<p>Assumes dense row-major packing and a min coordinate of zero. Does not take ownership of the data. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00645">645</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>, <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>, and <a class="el" href="runtime__internal_8h_source.html#l00184">Halide::Runtime::Internal::t</a>.</p>

</div>
</div>
<a class="anchor" id="a76bb593c9c0efa68955cce6edfb5e82c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> from a pointer and some sizes. </p>
<p>Assumes dense row-major packing and a min coordinate of zero. Does not take ownership of the data. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00665">665</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>.</p>

</div>
</div>
<a class="anchor" id="af660a85d430d2b0e01d2fb3c21d91bb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> *&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and an array describing the shape. </p>
<p>Does not take ownership of the data. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00680">680</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>, <a class="el" href="_halide_buffer_8h_source.html#l00035">halide_dimension_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l00789">buffer_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>, <a class="el" href="_halide_buffer_8h_source.html#l00035">halide_dimension_t::min</a>, <a class="el" href="_halide_runtime_8h_source.html#l00806">buffer_t::min</a>, <a class="el" href="_halide_buffer_8h_source.html#l00035">halide_dimension_t::stride</a>, <a class="el" href="_halide_runtime_8h_source.html#l00801">buffer_t::stride</a>, and <a class="el" href="runtime__internal_8h_source.html#l00184">Halide::Runtime::Internal::t</a>.</p>

</div>
</div>
<a class="anchor" id="aad08b2093877cfa27376ac8dc9035b90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> *&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and an array describing the shape. </p>
<p>Does not take ownership of the data. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00699">699</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>, <a class="el" href="_halide_buffer_8h_source.html#l00035">halide_dimension_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l00789">buffer_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>, <a class="el" href="_halide_buffer_8h_source.html#l00035">halide_dimension_t::min</a>, <a class="el" href="_halide_runtime_8h_source.html#l00806">buffer_t::min</a>, <a class="el" href="_halide_buffer_8h_source.html#l00035">halide_dimension_t::stride</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00801">buffer_t::stride</a>.</p>

</div>
</div>
<a class="anchor" id="aa05fc82b82832089da167b7ca90c7b0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::~<a class="el" href="class_halide_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Will release any underlying owned allocation if this is the last reference to it. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00714">714</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a86c5eb230d814e020f3e822576aeb35b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_buffer_1_1_dimension.html">Dimension</a> <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::dim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the shape of the buffer. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00332">332</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00365">Halide::Buffer&lt; T, D &gt;::begin()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00772">Halide::Buffer&lt; T, D &gt;::bottom()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00753">Halide::Buffer&lt; T, D &gt;::channels()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00532">Halide::Buffer&lt; T, D &gt;::check_overflow()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00781">Halide::Buffer&lt; T, D &gt;::copy()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00843">Halide::Buffer&lt; T, D &gt;::crop()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00376">Halide::Buffer&lt; T, D &gt;::end()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00339">Halide::Buffer&lt; T, D &gt;::extent()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00750">Halide::Buffer&lt; T, D &gt;::height()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00760">Halide::Buffer&lt; T, D &gt;::left()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00338">Halide::Buffer&lt; T, D &gt;::min()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00345">Halide::Buffer&lt; T, D &gt;::number_of_elements()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00764">Halide::Buffer&lt; T, D &gt;::right()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00942">Halide::Buffer&lt; T, D &gt;::slice()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00340">Halide::Buffer&lt; T, D &gt;::stride()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00768">Halide::Buffer&lt; T, D &gt;::top()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00747">Halide::Buffer&lt; T, D &gt;::width()</a>.</p>

</div>
</div>
<a class="anchor" id="aa0c6af1ead7054fadad49f3902c3a5ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::min </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the mins, strides, extents. </p>
<p>Will be deprecated. Do not use. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00338">338</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00289">Halide::Buffer&lt; T, D &gt;::Dimension::min()</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00843">Halide::Buffer&lt; T, D &gt;::crop()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f40720f1d579c25aebb45ee29d47371"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::extent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the mins, strides, extents. </p>
<p>Will be deprecated. Do not use. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00339">339</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00300">Halide::Buffer&lt; T, D &gt;::Dimension::extent()</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00843">Halide::Buffer&lt; T, D &gt;::crop()</a>.</p>

</div>
</div>
<a class="anchor" id="a73c6b61a4230004c97f58689288ae352"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::stride </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the mins, strides, extents. </p>
<p>Will be deprecated. Do not use. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00340">340</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00295">Halide::Buffer&lt; T, D &gt;::Dimension::stride()</a>.</p>

</div>
</div>
<a class="anchor" id="a6874e089fea815dc01abe47c768fe254"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::number_of_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of elements this buffer represents. </p>
<p>Equal to the product of the extents </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00345">345</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00300">Halide::Buffer&lt; T, D &gt;::Dimension::extent()</a>.</p>

</div>
</div>
<a class="anchor" id="a62457f00ec956c482c10d29e5fd9a9ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimensionality of the buffer. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00354">354</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00410">Halide::Buffer&lt; T, D &gt;::assert_can_convert_from()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00365">Halide::Buffer&lt; T, D &gt;::begin()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00753">Halide::Buffer&lt; T, D &gt;::channels()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00532">Halide::Buffer&lt; T, D &gt;::check_overflow()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00781">Halide::Buffer&lt; T, D &gt;::copy()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00982">Halide::Buffer&lt; T, D &gt;::embed()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00967">Halide::Buffer&lt; T, D &gt;::embedded()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00376">Halide::Buffer&lt; T, D &gt;::end()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00750">Halide::Buffer&lt; T, D &gt;::height()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00345">Halide::Buffer&lt; T, D &gt;::number_of_elements()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00908">Halide::Buffer&lt; T, D &gt;::set_min()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00942">Halide::Buffer&lt; T, D &gt;::slice()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00747">Halide::Buffer&lt; T, D &gt;::width()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ef076b0bef9d9aca1c448c4d1fd3c78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhalide__type__t.html">halide_type_t</a> <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of the elements. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00359">359</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2d5b86295655ec3a9b69ef8fa8196b38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the element with the lowest address. </p>
<p>If all strides are positive, equal to the host pointer. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00365">365</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>, <a class="el" href="_halide_buffer_8h_source.html#l00300">Halide::Buffer&lt; T, D &gt;::Dimension::extent()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00295">Halide::Buffer&lt; T, D &gt;::Dimension::stride()</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00388">Halide::Buffer&lt; T, D &gt;::size_in_bytes()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a1a20a86aa83f88f5c5cc6c5211c0fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to one beyond the element with the highest address. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00376">376</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>, <a class="el" href="_halide_buffer_8h_source.html#l00300">Halide::Buffer&lt; T, D &gt;::Dimension::extent()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00295">Halide::Buffer&lt; T, D &gt;::Dimension::stride()</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00388">Halide::Buffer&lt; T, D &gt;::size_in_bytes()</a>.</p>

</div>
</div>
<a class="anchor" id="a286c7e243fa5b5a56f56acef67e54c78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::size_in_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of bytes spanned by the data in memory. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00388">388</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00365">Halide::Buffer&lt; T, D &gt;::begin()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00376">Halide::Buffer&lt; T, D &gt;::end()</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00547">Halide::Buffer&lt; T, D &gt;::allocate()</a>.</p>

</div>
</div>
<a class="anchor" id="a90ea0c9ed7161b9a78315e507bdb5d84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::assert_can_convert_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fail an assertion at runtime or compile-time if an Buffer&lt;T, D&gt; cannot be constructed from some other <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> type. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00410">410</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00430">Halide::Buffer&lt; T, D &gt;::Buffer()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00469">Halide::Buffer&lt; T, D &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a499bd4c574b62d6c922b88d83f35adaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign from another <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality and type. </p>
<p>Asserts if D is less than the dimensionality of the argument, or if there's a type mismatch. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00469">469</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00410">Halide::Buffer&lt; T, D &gt;::assert_can_convert_from()</a>.</p>

</div>
</div>
<a class="anchor" id="aa65d8e9cdab536031e900279eda660dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00484">484</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="abf4025d98d4b0fcd5eb0205cc3d5918d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move from another <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality and type. </p>
<p>Asserts if D is less than the dimensionality of the argument, or if there's a type mismatch. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00502">502</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00410">Halide::Buffer&lt; T, D &gt;::assert_can_convert_from()</a>.</p>

</div>
</div>
<a class="anchor" id="a929e77055f39ba4ffb70ee33b5ee8e44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00517">517</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="afca70239ecd36891a76e6648d6ecf16f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::check_overflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the product of the extents fits in memory. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00532">532</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00300">Halide::Buffer&lt; T, D &gt;::Dimension::extent()</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00577">Halide::Buffer&lt; T, D &gt;::Buffer()</a>.</p>

</div>
</div>
<a class="anchor" id="acbcd9d2b701260e0a281f7240c9b2aef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">void *(*)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)&#160;</td>
          <td class="paramname"><em>allocate_fn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>deallocate_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for this <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a>. </p>
<p>Drops the reference to any owned memory. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00547">547</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00086">Halide::AllocationHeader::deallocate_fn</a>, <a class="el" href="runtime__internal_8h.html#af07d89f5ceaea0c7c8252cc41fd75f37">free()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>, <a class="el" href="runtime__internal_8h.html#a1c8580582aae58105f16108d4ec89e9a">malloc()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00087">Halide::AllocationHeader::ref_count</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00388">Halide::Buffer&lt; T, D &gt;::size_in_bytes()</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00577">Halide::Buffer&lt; T, D &gt;::Buffer()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00781">Halide::Buffer&lt; T, D &gt;::copy()</a>.</p>

</div>
</div>
<a class="anchor" id="abf453a9c1fc044393bcae55b2f93c572"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuffer__t.html">buffer_t</a>* <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::raw_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the raw <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> this wraps. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00720">720</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="printer_8h_source.html#l00030">buf</a>.</p>

</div>
</div>
<a class="anchor" id="a81560ecb869bc8b5027dd89c1d888f02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbuffer__t.html">buffer_t</a>* <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::raw_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the raw <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> this wraps. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00724">724</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="printer_8h_source.html#l00030">buf</a>.</p>

</div>
</div>
<a class="anchor" id="ac0032539a7342e1ec79210a373f48c12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::host_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the untyped host pointer. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00731">731</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>.</p>

</div>
</div>
<a class="anchor" id="a75fe7eb9342b9cef867e6896e8d1461d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::host_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the untyped host pointer. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00734">734</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>.</p>

</div>
</div>
<a class="anchor" id="a0755ebe467bb994ea6d08a8fe59303fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator <a class="el" href="structbuffer__t.html">buffer_t</a> * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a cast operator to <a class="el" href="structbuffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">buffer_t</a> *, so that instances can be passed directly to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> filters. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00741">741</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="printer_8h_source.html#l00030">buf</a>.</p>

</div>
</div>
<a class="anchor" id="aa617822fc9ed907631306dab784d8ea1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the first three dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00747">747</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00300">Halide::Buffer&lt; T, D &gt;::Dimension::extent()</a>.</p>

</div>
</div>
<a class="anchor" id="abd3b230743401a274cdce661f4890614"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the first three dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00750">750</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00300">Halide::Buffer&lt; T, D &gt;::Dimension::extent()</a>.</p>

</div>
</div>
<a class="anchor" id="ac55371dab681299cac52cc76de00e6f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::channels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the first three dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00753">753</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00300">Halide::Buffer&lt; T, D &gt;::Dimension::extent()</a>.</p>

</div>
</div>
<a class="anchor" id="ae3f238bd19736ee200f717ca55f532e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the min and max value of each dimension. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00760">760</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00289">Halide::Buffer&lt; T, D &gt;::Dimension::min()</a>.</p>

</div>
</div>
<a class="anchor" id="a9eaabbfa8b0e18de8120d9480adbe998"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the min and max value of each dimension. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00764">764</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00305">Halide::Buffer&lt; T, D &gt;::Dimension::max()</a>.</p>

</div>
</div>
<a class="anchor" id="abfcdb6d93dab25b727ad842be7c2cf86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the min and max value of each dimension. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00768">768</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00289">Halide::Buffer&lt; T, D &gt;::Dimension::min()</a>.</p>

</div>
</div>
<a class="anchor" id="a052be6a4179ad3668d5448956448b117"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::bottom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the min and max value of each dimension. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00772">772</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00305">Halide::Buffer&lt; T, D &gt;::Dimension::max()</a>.</p>

</div>
</div>
<a class="anchor" id="a9311b632b671dac2f216a8b3bc1dbeca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">void *(*)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)&#160;</td>
          <td class="paramname"><em>allocate_fn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>deallocate_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a new image which is a deep copy of this image. </p>
<p>Use crop or slice followed by copy to make a copy of only a portion of the image. The new image uses the same memory layout as the original, with holes compacted away. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00781">781</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00547">Halide::Buffer&lt; T, D &gt;::allocate()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>, <a class="el" href="printer_8h_source.html#l00030">dst</a>, <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>, <a class="el" href="_halide_buffer_8h_source.html#l01011">Halide::Buffer&lt; T, D &gt;::for_each_element()</a>, <a class="el" href="runtime__internal_8h.html#add55236e1a6168d059f1409762081d1a">memcpy()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00289">Halide::Buffer&lt; T, D &gt;::Dimension::min()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00934">Halide::Buffer&lt; T, D &gt;::sliced()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00295">Halide::Buffer&lt; T, D &gt;::Dimension::stride()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00926">Halide::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="a2b3e55fb68de35a85185e2ec224e4b16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::cropped </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image that refers to a sub-range of this image along the given dimension. </p>
<p>Does not assert the crop region is within the existing bounds. The cropped image drops any device handle. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00831">831</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00843">Halide::Buffer&lt; T, D &gt;::crop()</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00781">buffer_t::dev</a>.</p>

</div>
</div>
<a class="anchor" id="aeb03c20872c08359208eae83369cb910"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::crop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crop an image in-place along the given dimension. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00843">843</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00781">buffer_t::dev</a>, <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>, <a class="el" href="_halide_buffer_8h_source.html#l00339">Halide::Buffer&lt; T, D &gt;::extent()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00789">buffer_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>, <a class="el" href="_halide_buffer_8h_source.html#l00289">Halide::Buffer&lt; T, D &gt;::Dimension::min()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00338">Halide::Buffer&lt; T, D &gt;::min()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00806">buffer_t::min</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00295">Halide::Buffer&lt; T, D &gt;::Dimension::stride()</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00868">Halide::Buffer&lt; T, D &gt;::crop()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00831">Halide::Buffer&lt; T, D &gt;::cropped()</a>.</p>

</div>
</div>
<a class="anchor" id="a98bced70efdb1428cd12cd2cf86a0d54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::cropped </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image that refers to a sub-rectangle of this image along the first N dimensions. </p>
<p>Does not assert the crop region is within the existing bounds. The cropped image drops any device handle. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00856">856</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00843">Halide::Buffer&lt; T, D &gt;::crop()</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00781">buffer_t::dev</a>.</p>

</div>
</div>
<a class="anchor" id="a22b2303a1cb27d74f9f7cfaf199bde49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::crop </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crop an image in-place along the first N dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00868">868</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00843">Halide::Buffer&lt; T, D &gt;::crop()</a>.</p>

</div>
</div>
<a class="anchor" id="a46fe83fb4d0545d303cba50d0ff68e14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::translated </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image which refers to the same data with using translated coordinates in the given dimension. </p>
<p>Positive values move the image data to the right or down relative to the coordinate system. Drops any device handle. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00878">878</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00781">buffer_t::dev</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00886">Halide::Buffer&lt; T, D &gt;::translate()</a>.</p>

</div>
</div>
<a class="anchor" id="a4916b7277d2dbb2e994f859184e925ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::translate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate an image in-place along one dimension. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00886">886</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00806">buffer_t::min</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00982">Halide::Buffer&lt; T, D &gt;::embed()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00967">Halide::Buffer&lt; T, D &gt;::embedded()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00900">Halide::Buffer&lt; T, D &gt;::translate()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00878">Halide::Buffer&lt; T, D &gt;::translated()</a>.</p>

</div>
</div>
<a class="anchor" id="a9dcd4d8e943eefa038e8e03e926ae5a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::translated </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image which refers to the same data translated along the first N dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00892">892</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00781">buffer_t::dev</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00886">Halide::Buffer&lt; T, D &gt;::translate()</a>.</p>

</div>
</div>
<a class="anchor" id="a16d2ab7d832fa03b195a0bf0b7e8f03a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::translate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate an image along the first N dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00900">900</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00886">Halide::Buffer&lt; T, D &gt;::translate()</a>.</p>

</div>
</div>
<a class="anchor" id="a18b1ec3b9f174f27c9b8034d87c92b40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::set_min </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the min coordinate of an image in the first N dimensions. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_07_multi_stage_pipelines_8cpp-example.html#a5">tutorial/lesson_07_multi_stage_pipelines.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00908">908</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00806">buffer_t::min</a>.</p>

</div>
</div>
<a class="anchor" id="abbb7333d35797bb0eb87c3cc85a9b1cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::transposed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image which refers to the same data using a different ordering of the dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00919">919</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00926">Halide::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="aade0b39013c79390a2f450e693eeaa23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::transpose </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose an image in-place. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00926">926</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00789">buffer_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l00806">buffer_t::min</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00801">buffer_t::stride</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00781">Halide::Buffer&lt; T, D &gt;::copy()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00982">Halide::Buffer&lt; T, D &gt;::embed()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00967">Halide::Buffer&lt; T, D &gt;::embedded()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01060">Halide::Buffer&lt; T, D &gt;::make_interleaved()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00919">Halide::Buffer&lt; T, D &gt;::transposed()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e07da22f5dfcf35b8a3dc55a26e9ca4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D-1&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::sliced </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a lower-dimensional image that refers to one slice of this image. </p>
<p>Drops any device handle. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00934">934</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00781">buffer_t::dev</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00942">Halide::Buffer&lt; T, D &gt;::slice()</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00781">Halide::Buffer&lt; T, D &gt;::copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a36a9ed6f06da6ed41542a7568b12fbb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slice an image in-place. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00942">942</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00781">buffer_t::dev</a>, <a class="el" href="_halide_buffer_8h_source.html#l00332">Halide::Buffer&lt; T, D &gt;::dim()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00810">buffer_t::elem_size</a>, <a class="el" href="_halide_runtime_8h_source.html#l00789">buffer_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>, <a class="el" href="_halide_buffer_8h_source.html#l00289">Halide::Buffer&lt; T, D &gt;::Dimension::min()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00806">buffer_t::min</a>, <a class="el" href="_halide_buffer_8h_source.html#l00295">Halide::Buffer&lt; T, D &gt;::Dimension::stride()</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00801">buffer_t::stride</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01101">Halide::Buffer&lt; T, D &gt;::make_scalar()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00934">Halide::Buffer&lt; T, D &gt;::sliced()</a>.</p>

</div>
</div>
<a class="anchor" id="a0dd3075002bc58f419cd63c516dde635"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D+1&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::embedded </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a new image that views this image as a single slice in a higher-dimensional space. </p>
<p>The new dimension has extent one and the given min. Drops any device handle. This operation is the opposite of slice. As an example, the following condition is true:</p>
<div class="fragment"><div class="line">im2 = im.embedded(1, 17);</div>
<div class="line">&amp;im(x, y, c) == &amp;im2(x, 17, y, c);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00967">967</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00995">Halide::Buffer&lt; T, D &gt;::add_dimension()</a>, <a class="el" href="_halide_runtime_8h_source.html#l00781">buffer_t::dev</a>, <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00886">Halide::Buffer&lt; T, D &gt;::translate()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00926">Halide::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="ae3e0cd6659b1abeaa41c8b7250a9197c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::embed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Embed an image in-place, increasing the dimensionality. </p>
<p>Requires that the actual number of dimensions is less than template parameter D </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00982">982</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00995">Halide::Buffer&lt; T, D &gt;::add_dimension()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00354">Halide::Buffer&lt; T, D &gt;::dimensions()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00886">Halide::Buffer&lt; T, D &gt;::translate()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00926">Halide::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="af11c825f189aae4fa2bee9fb2e2ec31d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::add_dimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new dimension with a min of zero and an extent of one. </p>
<p>The new dimension is the last dimension. This is a special case of embed. It requires that the actual number of dimensions is less than template parameter D. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00995">995</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00789">buffer_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l00806">buffer_t::min</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00801">buffer_t::stride</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00982">Halide::Buffer&lt; T, D &gt;::embed()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00967">Halide::Buffer&lt; T, D &gt;::embedded()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e41ca198e36bc0967386d3dc9699937"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::for_each_element </td>
          <td>(</td>
          <td class="paramtype">Fn&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a callable at each location within the image. </p>
<p>See for_each_element below for more details. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01011">1011</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l01451">Halide::for_each_element()</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00781">Halide::Buffer&lt; T, D &gt;::copy()</a>.</p>

</div>
</div>
<a class="anchor" id="a22b9d36de1b23c4300649ff7fc06f8c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::set_host_dirty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01017">1017</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01183">Halide::Buffer&lt; T, D &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a996ffbeea2d591d2f96ace77428cbec9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::device_dirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01021">1021</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01033">Halide::Buffer&lt; T, D &gt;::copy_to_host()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f03e25ee5f42743048276541aeebdd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::host_dirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01025">1025</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01039">Halide::Buffer&lt; T, D &gt;::copy_to_device()</a>.</p>

</div>
</div>
<a class="anchor" id="ab613ff5669d2697f5729ed3a775dd616"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::set_device_dirty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01029">1029</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a670397fc9de22741d727c41122b62750"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::copy_to_host </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01033">1033</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l01021">Halide::Buffer&lt; T, D &gt;::device_dirty()</a>, and <a class="el" href="_halide_runtime_8h.html#a5980f17918155363078056e6a32de301">halide_copy_to_host()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d73861a5cdeeb1f4276c07ddb653e85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::copy_to_device </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface.html">halide_device_interface</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01039">1039</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h.html#ac9a7860edb474f46a761cd4e80a410b0">halide_copy_to_device()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01025">Halide::Buffer&lt; T, D &gt;::host_dirty()</a>.</p>

</div>
</div>
<a class="anchor" id="af5edeae398486ae33ab2c158ec4a7e84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::device_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01045">1045</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h.html#ab234e67973d0504a63002c64db55d6fa">halide_device_free()</a>.</p>

</div>
</div>
<a class="anchor" id="a53bbe8e9425f43588000fe9dffc6b9e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::device_sync </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01049">1049</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h.html#a68ef5b5e82021e9ffc31a734b9123903">halide_device_sync()</a>.</p>

</div>
</div>
<a class="anchor" id="a816556bb6d48a73602927c11078478af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;void, D&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::make_interleaved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If you use the (x, y, c) indexing convention, then <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Buffers are stored planar by default. </p>
<p>This function constructs an interleaved RGB or RGBA image that can still be indexed using (x, y, c). Passing it to a generator requires that the generator has been compiled with support for interleaved (also known as packed or chunky) memory layouts. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01060">1060</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00926">Halide::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="ace0ff4d9e143d93f226b6ad291a7f1f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::make_interleaved </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If you use the (x, y, c) indexing convention, then <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Buffers are stored planar by default. </p>
<p>This function constructs an interleaved RGB or RGBA image that can still be indexed using (x, y, c). Passing it to a generator requires that the generator has been compiled with support for interleaved (also known as packed or chunky) memory layouts. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01074">1074</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00926">Halide::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="a1c9ba2e2c395e3f74bdc0f6af7b1178d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;void, D&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::make_interleaved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an existing interleaved image. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01083">1083</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00926">Halide::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="a94eb162884b30d77651a2ed7750cc6ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::make_interleaved </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an existing interleaved image. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01092">1092</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l00926">Halide::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="ab1ad8170e21de12c5d7c53df3e7b3bee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;void, D&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::make_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a zero-dimensional <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a>. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01101">1101</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="printer_8h_source.html#l00030">buf</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00942">Halide::Buffer&lt; T, D &gt;::slice()</a>.</p>

</div>
</div>
<a class="anchor" id="a0eb74f655ad7ecb025fd53e07ec2ad65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::make_scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a zero-dimensional <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a>. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01108">1108</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="printer_8h_source.html#l00030">buf</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00942">Halide::Buffer&lt; T, D &gt;::slice()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a4ae3c17b9c920b665b22b0de66550e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the address of the min coordinate. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01140">1140</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01166">Halide::Buffer&lt; T, D &gt;::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="adacee330da621820d34c21f5d79f3105"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the address of the min coordinate. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01144">1144</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00786">buffer_t::host</a>.</p>

</div>
</div>
<a class="anchor" id="ad8d039e4896d72830bb0242082e05e80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> const not_void_T&amp; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01158">1158</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a494f09fa40b4257b82877483026c9a1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> const not_void_T&amp; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01166">1166</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l01140">Halide::Buffer&lt; T, D &gt;::data()</a>.</p>

</div>
</div>
<a class="anchor" id="ad62eb5fb79f3fcd584d04a7183b8e3c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> const not_void_T&amp; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01174">1174</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aae4e24d75f9cd33ad9fb64d6f11d3e08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> not_void_T&amp; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01183">1183</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l01017">Halide::Buffer&lt; T, D &gt;::set_host_dirty()</a>.</p>

</div>
</div>
<a class="anchor" id="a96b092056e74f3693644e6c3e293645e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> not_void_T&amp; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01192">1192</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l01140">Halide::Buffer&lt; T, D &gt;::data()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01017">Halide::Buffer&lt; T, D &gt;::set_host_dirty()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b95b5ee39fed033bbcdb21edafe456b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> not_void_T&amp; <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01201">1201</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_buffer_8h_source.html#l01017">Halide::Buffer&lt; T, D &gt;::set_host_dirty()</a>.</p>

</div>
</div>
<a class="anchor" id="a96df98ba3fce7b6238bddb09754f164e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const -&gt; decltype(<a class="el" href="namespace_halide.html#a471d67f16ba731c512c017aea89f20f5">image_accessor</a>(*this, args...)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Other calls to operator()(Args...) get redirected to a call to image_accessor(const Buffer&lt;T, D&gt; &amp;, Args...). </p>
<p>This makes it possible for later code to add new <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> access methods for types not convertible to int (e.g. Exprs). To add a custom accessor, define an overload of image_accessor that takes the expected arguments. See test/correctness/custom_image_accessor.cpp for an example. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01218">1218</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_buffer_ptr_8h_source.html#l00094">Halide::image_accessor()</a>.</p>

</div>
</div>
<a class="anchor" id="aae7dcf3e7ae6bcd69af9d6834e08c392"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespace_halide.html#a471d67f16ba731c512c017aea89f20f5">image_accessor</a>(*this, args...)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Other calls to operator()(Args...) get redirected to a call to image_accessor(const Buffer&lt;T, D&gt; &amp;, Args...). </p>
<p>This makes it possible for later code to add new <a class="el" href="class_halide_1_1_buffer.html" title="A templated Buffer class that wraps buffer_t and adds functionality. ">Buffer</a> access methods for types not convertible to int (e.g. Exprs). To add a custom accessor, define an overload of image_accessor that takes the expected arguments. See test/correctness/custom_image_accessor.cpp for an example. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01224">1224</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_buffer_ptr_8h_source.html#l00094">Halide::image_accessor()</a>.</p>

</div>
</div>
<a class="anchor" id="aa693fc8ac6e3f11ee9a78fb975200f9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_buffer.html">Halide::Buffer</a>&lt; T, D &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">not_void_T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set every value in the buffer to the given value. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01254">1254</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="class_halide_1_1_buffer.html">Buffer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
