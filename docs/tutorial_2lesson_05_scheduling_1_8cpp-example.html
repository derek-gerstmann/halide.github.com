<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Halide: tutorial/lesson_05_scheduling_1.cpp</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('tutorial_2lesson_05_scheduling_1_8cpp-example.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">tutorial/lesson_05_scheduling_1.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><span class="comment">// Halide tutorial lesson 5</span>

<span class="comment">// This lesson demonstrates how to manipulate the order in which you</span>
<span class="comment">// evaluate pixels in a Func, including vectorization,</span>
<span class="comment">// parallelization, unrolling, and tiling.</span>

<span class="comment">// On linux, you can compile and run it like so:</span>
<span class="comment">// g++ lesson_05*.cpp -g -I ../include -L ../bin -lHalide -lpthread -ldl -o lesson_05</span>
<span class="comment">// LD_LIBRARY_PATH=../bin ./lesson_05</span>

<span class="comment">// On os x:</span>
<span class="comment">// g++ lesson_05*.cpp -g -I ../include -L ../bin -lHalide -o lesson_05</span>
<span class="comment">// DYLD_LIBRARY_PATH=../bin ./lesson_05</span>

<span class="preprocessor">#include &lt;Halide.h&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="keyword">using namespace </span>Halide;

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {

    <span class="comment">// We&#39;re going to define and schedule our gradient function in</span>
    <span class="comment">// several different ways, and see what order pixels are computed</span>
    <span class="comment">// in.</span>

    <a name="_a0"></a><a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x(<span class="stringliteral">&quot;x&quot;</span>), y(<span class="stringliteral">&quot;y&quot;</span>);

    <span class="comment">// First we observe the default ordering.</span>
    {
        <a name="_a1"></a><a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> gradient(<span class="stringliteral">&quot;gradient&quot;</span>);
        gradient(x, y) = x + y;
        gradient.<a name="a2"></a><a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        <span class="comment">// By default we walk along the rows and then down the columns.</span>
        printf(<span class="stringliteral">&quot;Evaluating gradient row-major\n&quot;</span>);
        <a name="_a3"></a><a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> output = gradient.<a name="a4"></a><a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        <span class="comment">// The equivalent C is:</span>
        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {
                printf(<span class="stringliteral">&quot;Evaluating at %d, %d: %d\n&quot;</span>, x, y, x + y);
            }
        }
        printf(<span class="stringliteral">&quot;\n\n&quot;</span>);
    }

    <span class="comment">// Reorder variables.</span>
    {
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> gradient(<span class="stringliteral">&quot;gradient_col_major&quot;</span>);
        gradient(x, y) = x + y;
        gradient.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        <span class="comment">// If we reorder x and y, we can walk down the columns</span>
        <span class="comment">// instead. The reorder call takes the arguments of the func,</span>
        <span class="comment">// and sets a new nesting order for the for loops that are</span>
        <span class="comment">// generated. The arguments are specified from the innermost</span>
        <span class="comment">// loop out, so the following call puts y in the inner loop:</span>
        gradient.<a name="a5"></a><a class="code" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754" title="Reorder variables to have the given nesting order, from innermost out.">reorder</a>(y, x);

        printf(<span class="stringliteral">&quot;Evaluating gradient column-major\n&quot;</span>);
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> output = gradient.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {
                printf(<span class="stringliteral">&quot;Evaluating at %d, %d: %d\n&quot;</span>, x, y, x + y);
            }
        }
        printf(<span class="stringliteral">&quot;\n\n&quot;</span>);
    }

    <span class="comment">// Split a variable into two.</span>
    {
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> gradient(<span class="stringliteral">&quot;gradient_split&quot;</span>);
        gradient(x, y) = x + y;
        gradient.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        <span class="comment">// The most powerful primitive scheduling operation you can do</span>
        <span class="comment">// to a var is to split it into inner and outer sub-variables:</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x_outer, x_inner;
        gradient.<a name="a6"></a><a class="code" href="class_halide_1_1_func.html#a52a4cace19fc024959cda3a7e82dd9f6" title="Split a dimension into inner and outer subdimensions with the given names, where the inner dimension ...">split</a>(x, x_outer, x_inner, 2);

        <span class="comment">// This breaks the loop over x into two nested loops: an outer</span>
        <span class="comment">// one over x_outer, and an inner one over x_inner. The last</span>
        <span class="comment">// argument to split was the &quot;split factor&quot;. The inner loop</span>
        <span class="comment">// runs from zero to the split factor. The outer loop runs</span>
        <span class="comment">// from zero to the extent required of x (4 in this case)</span>
        <span class="comment">// divided by the split factor. Within the loops, the old</span>
        <span class="comment">// variable is defined to be outer * factor + inner. If the</span>
        <span class="comment">// old loop started at a value other than zero, then that is</span>
        <span class="comment">// also added within the loops.</span>

        printf(<span class="stringliteral">&quot;Evaluating gradient with x split into x_outer and x_inner \n&quot;</span>);
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> output = gradient.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 2; x_outer++) {
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner = 0; x_inner &lt; 2; x_inner++) {
                    <span class="keywordtype">int</span> x = x_outer * 2 + x_inner;
                    printf(<span class="stringliteral">&quot;Evaluating at %d, %d: %d\n&quot;</span>, x, y, x + y);
                }
            }
        }
        printf(<span class="stringliteral">&quot;\n\n&quot;</span>);

        <span class="comment">// Note that the order of evaluation of pixels didn&#39;t actually</span>
        <span class="comment">// change! Splitting by itself does nothing, but it does open</span>
        <span class="comment">// up all of the scheduling possibilities that we will explore</span>
        <span class="comment">// below.</span>
    }

    <span class="comment">// Fuse two variables into one.</span>
    {
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> gradient(<span class="stringliteral">&quot;gradient_fused&quot;</span>);
        gradient(x, y) = x + y;

        <span class="comment">// The opposite of splitting is &#39;fusing&#39;. Fusing two variables</span>
        <span class="comment">// merges the two loops into a single for loop over the</span>
        <span class="comment">// product of the extents. Fusing is less important that</span>
        <span class="comment">// splitting, but it also sees use (as we&#39;ll see later in this</span>
        <span class="comment">// lesson). Like splitting, fusing by itself doesn&#39;t change</span>
        <span class="comment">// the order of evaluation.</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> fused;
        gradient.<a name="a7"></a><a class="code" href="class_halide_1_1_func.html#a07ae6163527e6319a9352f7648afd875" title="Join two dimensions into a single fused dimenion.">fuse</a>(x, y, fused);

        printf(<span class="stringliteral">&quot;Evaluating gradient with x and y fused\n&quot;</span>);
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> output = gradient.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> fused = 0; fused &lt; 4*4; fused++) {
            <span class="keywordtype">int</span> y = fused / 4;
            <span class="keywordtype">int</span> x = fused % 4;
            printf(<span class="stringliteral">&quot;Evaluating at %d, %d: %d\n&quot;</span>, x, y, x + y);
        }
    }

    <span class="comment">// Evaluating in tiles.</span>
    {
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> gradient(<span class="stringliteral">&quot;gradient_tiled&quot;</span>);
        gradient(x, y) = x + y;
        gradient.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        <span class="comment">// Now that we can both split and reorder, we can do tiled</span>
        <span class="comment">// evaluation. Let&#39;s split both x and y by a factor of two,</span>
        <span class="comment">// and then reorder the vars to express a tiled traversal.</span>
        <span class="comment">//</span>
        <span class="comment">// A tiled traversal splits the domain into small rectangular</span>
        <span class="comment">// tiles, and outermost iterates over the tiles, and within</span>
        <span class="comment">// that iterates over the points within each tile. It can be</span>
        <span class="comment">// good for performance if neighboring pixels use overlapping</span>
        <span class="comment">// input data, for example in a blur. We can express a tiled</span>
        <span class="comment">// traversal like so:</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x_outer, x_inner, y_outer, y_inner;
        gradient.<a class="code" href="class_halide_1_1_func.html#a52a4cace19fc024959cda3a7e82dd9f6" title="Split a dimension into inner and outer subdimensions with the given names, where the inner dimension ...">split</a>(x, x_outer, x_inner, 2);
        gradient.<a class="code" href="class_halide_1_1_func.html#a52a4cace19fc024959cda3a7e82dd9f6" title="Split a dimension into inner and outer subdimensions with the given names, where the inner dimension ...">split</a>(y, y_outer, y_inner, 2);
        gradient.<a class="code" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754" title="Reorder variables to have the given nesting order, from innermost out.">reorder</a>(x_inner, y_inner, x_outer, y_outer);

        <span class="comment">// This pattern is common enough that there&#39;s a shorthand for it:</span>
        <span class="comment">// gradient.tile(x, y, x_outer, y_outer, x_inner, y_inner, 2, 2);</span>

        printf(<span class="stringliteral">&quot;Evaluating gradient in 2x2 tiles\n&quot;</span>);
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> output = gradient.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_outer = 0; y_outer &lt; 2; y_outer++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 2; x_outer++) {
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_inner = 0; y_inner &lt; 2; y_inner++) {
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner = 0; x_inner &lt; 2; x_inner++) {
                        <span class="keywordtype">int</span> x = x_outer * 2 + x_inner;
                        <span class="keywordtype">int</span> y = y_outer * 2 + y_inner;
                        printf(<span class="stringliteral">&quot;Evaluating at %d, %d: %d\n&quot;</span>, x, y, x + y);
                    }
                }
            }
        }
        printf(<span class="stringliteral">&quot;\n\n&quot;</span>);
    }

    <span class="comment">// Evaluating in vectors.</span>
    {
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> gradient(<span class="stringliteral">&quot;gradient_in_vectors&quot;</span>);
        gradient(x, y) = x + y;
        gradient.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        <span class="comment">// The nice thing about splitting is that it guarantees the</span>
        <span class="comment">// inner variable runs from zero to the split factor. Most of</span>
        <span class="comment">// the time the split-factor will be a compile-time constant,</span>
        <span class="comment">// so we can replace the loop over the inner variable with a</span>
        <span class="comment">// single vectorized computation. This time we&#39;ll split by a</span>
        <span class="comment">// factor of four, because on X86 we can use SSE to compute in</span>
        <span class="comment">// 4-wide vectors.</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x_outer, x_inner;
        gradient.<a class="code" href="class_halide_1_1_func.html#a52a4cace19fc024959cda3a7e82dd9f6" title="Split a dimension into inner and outer subdimensions with the given names, where the inner dimension ...">split</a>(x, x_outer, x_inner, 4);
        gradient.<a name="a8"></a><a class="code" href="class_halide_1_1_func.html#a7b1857a62deca8bc9a477c1b26720950" title="Mark a dimension to be computed all-at-once as a single vector.">vectorize</a>(x_inner);

        <span class="comment">// Splitting and then vectorizing the inner variable is common</span>
        <span class="comment">// enough that there&#39;s a short-hand for it. We could have also</span>
        <span class="comment">// said:</span>
        <span class="comment">//</span>
        <span class="comment">// gradient.vectorize(x, 4);</span>
        <span class="comment">//</span>
        <span class="comment">// which is equivalent to:</span>
        <span class="comment">//</span>
        <span class="comment">// gradient.split(x, x, x_inner, 4);</span>
        <span class="comment">// gradient.vectorize(x_inner);</span>
        <span class="comment">//</span>
        <span class="comment">// Note that in this case we reused the name &#39;x&#39; as the new</span>
        <span class="comment">// outer variable. Later scheduling calls that refer to x</span>
        <span class="comment">// will refer to this new outer variable named x.</span>
        <span class="comment">//</span>
        <span class="comment">// Our snoop function isn&#39;t set-up to print out vectors, this</span>
        <span class="comment">// is why we included one called snoopx4 above.</span>

        <span class="comment">// This time we&#39;ll evaluate over an 8x4 box, so that we have</span>
        <span class="comment">// more than one vector of work per scanline.</span>
        printf(<span class="stringliteral">&quot;Evaluating gradient with x_inner vectorized \n&quot;</span>);
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> output = gradient.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(8, 4);

        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 2; x_outer++) {
                <span class="comment">// The loop over x_inner has gone away, and has been</span>
                <span class="comment">// replaced by a vectorized version of the</span>
                <span class="comment">// expression. On x86 processors, Halide generates SSE</span>
                <span class="comment">// for all of this.</span>
                <span class="keywordtype">int</span> x_vec[] = {x_outer * 4 + 0,
                               x_outer * 4 + 1,
                               x_outer * 4 + 2,
                               x_outer * 4 + 3};
                <span class="keywordtype">int</span> val[] = {x_vec[0] + y,
                             x_vec[1] + y,
                             x_vec[2] + y,
                             x_vec[3] + y};
                printf(<span class="stringliteral">&quot;Evaluating at &lt;%d, %d, %d, %d&gt;, &lt;%d, %d, %d, %d&gt;: &lt;%d, %d, %d, %d&gt;\n&quot;</span>,
                       x_vec[0], x_vec[1], x_vec[2], x_vec[3],
                       y, y, y, y,
                       val[0], val[1], val[2], val[3]);
            }
        }
        printf(<span class="stringliteral">&quot;\n\n&quot;</span>);
    }

    <span class="comment">// Unrolling a loop.</span>
    {
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> gradient(<span class="stringliteral">&quot;gradient_in_vectors&quot;</span>);
        gradient(x, y) = x + y;
        gradient.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        <span class="comment">// If multiple pixels share overlapping data, it can make</span>
        <span class="comment">// sense to unroll a computation so that shared values are</span>
        <span class="comment">// only computed or loaded once. We do this similarly to how</span>
        <span class="comment">// we expressed vectorizing. We split a dimension and then</span>
        <span class="comment">// fully unroll the loop of the inner variable. Unrolling</span>
        <span class="comment">// doesn&#39;t change the order in which things are evaluated.</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x_outer, x_inner;
        gradient.<a class="code" href="class_halide_1_1_func.html#a52a4cace19fc024959cda3a7e82dd9f6" title="Split a dimension into inner and outer subdimensions with the given names, where the inner dimension ...">split</a>(x, x_outer, x_inner, 2);
        gradient.<a name="a9"></a><a class="code" href="class_halide_1_1_func.html#a75c97910f964410df65f04f7a85e3518" title="Mark a dimension to be completely unrolled.">unroll</a>(x_inner);

        <span class="comment">// The shorthand for this is:</span>
        <span class="comment">// gradient.unroll(x, 2);</span>

        printf(<span class="stringliteral">&quot;Evaluating gradient unrolled by a factor of two\n&quot;</span>);
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> result = gradient.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 2; x_outer++) {
                <span class="comment">// Instead of a for loop over x_inner, we get two</span>
                <span class="comment">// copies of the innermost statement.</span>
                {
                    <span class="keywordtype">int</span> x_inner = 0;
                    <span class="keywordtype">int</span> x = x_outer * 2 + x_inner;
                    printf(<span class="stringliteral">&quot;Evaluating at %d, %d: %d\n&quot;</span>, x, y, x + y);
                }
                {
                    <span class="keywordtype">int</span> x_inner = 1;
                    <span class="keywordtype">int</span> x = x_outer * 2 + x_inner;
                    printf(<span class="stringliteral">&quot;Evaluating at %d, %d: %d\n&quot;</span>, x, y, x + y);
                }
            }
        }


    }

    <span class="comment">// Splitting by factors that don&#39;t divide the extent.</span>
    {
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> gradient(<span class="stringliteral">&quot;gradient_split_5x4&quot;</span>);
        gradient(x, y) = x + y;
        gradient.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        <span class="comment">// Splitting guarantees that the inner loop runs from zero to</span>
        <span class="comment">// the split factor, which is important for the uses we saw</span>
        <span class="comment">// above. So what happens when the total extent we wish to</span>
        <span class="comment">// evaluate x over isn&#39;t a multiple of the split factor? We&#39;ll</span>
        <span class="comment">// split by a factor of two again, but now we&#39;ll evaluate</span>
        <span class="comment">// gradient over a 5x4 box instead of the 4x4 box we&#39;ve been</span>
        <span class="comment">// using.</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x_outer, x_inner;
        gradient.<a class="code" href="class_halide_1_1_func.html#a52a4cace19fc024959cda3a7e82dd9f6" title="Split a dimension into inner and outer subdimensions with the given names, where the inner dimension ...">split</a>(x, x_outer, x_inner, 2);

        printf(<span class="stringliteral">&quot;Evaluating gradient over a 5x4 box with x split by two \n&quot;</span>);
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> output = gradient.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(5, 4);

        printf(<span class="stringliteral">&quot;Equivalent C:\n&quot;</span>);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_outer = 0; x_outer &lt; 3; x_outer++) { <span class="comment">// Now runs from 0 to 3</span>
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner = 0; x_inner &lt; 2; x_inner++) {
                    <span class="keywordtype">int</span> x = x_outer * 2;
                    <span class="comment">// Before we add x_inner, make sure we don&#39;t</span>
                    <span class="comment">// evaluate points outside of the 5x4 box. We&#39;ll</span>
                    <span class="comment">// clamp x to be at most 3 (5 minus the split</span>
                    <span class="comment">// factor).</span>
                    <span class="keywordflow">if</span> (x &gt; 3) x = 3;
                    x += x_inner;
                    printf(<span class="stringliteral">&quot;Evaluating at %d, %d: %d\n&quot;</span>, x, y, x + y);
                }
            }
        }
        printf(<span class="stringliteral">&quot;\n\n&quot;</span>);

        <span class="comment">// If you read the output, you&#39;ll see that some coordinates</span>
        <span class="comment">// were evaluated more than once! That&#39;s generally OK, because</span>
        <span class="comment">// pure Halide functions have no side-effects, so it&#39;s safe to</span>
        <span class="comment">// evaluate the same point multiple times. If you&#39;re calling</span>
        <span class="comment">// out to C functions like we are, it&#39;s your responsibility to</span>
        <span class="comment">// make sure you can handle the same point being evaluated</span>
        <span class="comment">// multiple times.</span>

        <span class="comment">// The general rule is: If we require x from x_min to x_min + x_extent, and</span>
        <span class="comment">// we split by a factor &#39;factor&#39;, then:</span>
        <span class="comment">//</span>
        <span class="comment">// x_outer runs from 0 to (x_extent + factor - 1)/factor</span>
        <span class="comment">// x_inner runs from 0 to factor</span>
        <span class="comment">// x = min(x_outer * factor, x_extent - factor) + x_inner + x_min</span>
        <span class="comment">//</span>
        <span class="comment">// In our example, x_min was 0, x_extent was 5, and factor was 2.</span>
    }

    <span class="comment">// Fusing, tiling, and parallelizing.</span>
    {
        <span class="comment">// We saw in the previous lesson that we can parallelize</span>
        <span class="comment">// across a variable. Here we combine it with fusing and</span>
        <span class="comment">// tiling to express a useful pattern - processing tiles in</span>
        <span class="comment">// parallel.</span>

        <span class="comment">// This is where fusing shines. Fusing helps when you want to</span>
        <span class="comment">// parallelize across multiple dimensions without introducing</span>
        <span class="comment">// nested parallelism. Nested parallelism (parallel for loops</span>
        <span class="comment">// within parallel for loops) is supported by Halide, but</span>
        <span class="comment">// often gives poor performance compared to fusing the</span>
        <span class="comment">// parallel variables into a single parallel for loop.</span>

        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> gradient(<span class="stringliteral">&quot;gradient_fused_tiles&quot;</span>);
        gradient(x, y) = x + y;
        gradient.<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();

        <span class="comment">// First we&#39;ll tile, then we&#39;ll fuse the tile indices and</span>
        <span class="comment">// parallelize across the combination.</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x_outer, y_outer, x_inner, y_inner, tile_index;
        gradient.<a name="a10"></a><a class="code" href="class_halide_1_1_func.html#ab15001cd4af9e8c2808f45ff53b81582" title="Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi...">tile</a>(x, y, x_outer, y_outer, x_inner, y_inner, 2, 2);
        gradient.<a class="code" href="class_halide_1_1_func.html#a07ae6163527e6319a9352f7648afd875" title="Join two dimensions into a single fused dimenion.">fuse</a>(x_outer, y_outer, tile_index);
        gradient.<a name="a11"></a><a class="code" href="class_halide_1_1_func.html#aa0050c604179b43a8deb42b62dedd29d" title="Mark a dimension to be traversed in parallel.">parallel</a>(tile_index);

        <span class="comment">// The scheduling calls all return a reference to the Func, so</span>
        <span class="comment">// you can also chain them together into a single statement to</span>
        <span class="comment">// make things slightly clearer:</span>
        <span class="comment">//</span>
        <span class="comment">// gradient</span>
        <span class="comment">//     .tile(x, y, x_outer, y_outer, x_inner, y_inner, 2, 2)</span>
        <span class="comment">//     .fuse(x_outer, y_outer, tile_index)</span>
        <span class="comment">//     .parallel(tile_index);</span>


        printf(<span class="stringliteral">&quot;Evaluating gradient tiles in parallel\n&quot;</span>);
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> output = gradient.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(4, 4);

        <span class="comment">// The tiles should occur in arbitrary order, but within each</span>
        <span class="comment">// tile the pixels will be traversed in row-major order.</span>

        printf(<span class="stringliteral">&quot;Equivalent (serial) C:\n&quot;</span>);
        <span class="comment">// This outermost loop should be a parallel for loop, but that&#39;s hard in C.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tile_index = 0; tile_index &lt; 4; tile_index++) {
            <span class="keywordtype">int</span> y_outer = tile_index / 2;
            <span class="keywordtype">int</span> x_outer = tile_index % 2;
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_inner = 0; y_inner &lt; 2; y_inner++) {
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner = 0; x_inner &lt; 2; x_inner++) {
                    <span class="keywordtype">int</span> y = y_outer * 2 + y_inner;
                    <span class="keywordtype">int</span> x = x_outer * 2 + x_inner;
                    printf(<span class="stringliteral">&quot;Evaluating at %d, %d: %d\n&quot;</span>, x, y, x + y);
                }
            }
        }
        printf(<span class="stringliteral">&quot;\n\n&quot;</span>);
    }

    <span class="comment">// Putting it all together.</span>
    {
        <span class="comment">// Are you ready? We&#39;re going to use all of the features above now.</span>
        <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> gradient_fast(<span class="stringliteral">&quot;gradient_fast&quot;</span>);
        gradient_fast(x, y) = x + y;

        <span class="comment">// We&#39;ll process 256x256 tiles in parallel.</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x_outer, y_outer, x_inner, y_inner, tile_index;
        gradient_fast
            .<a class="code" href="class_halide_1_1_func.html#ab15001cd4af9e8c2808f45ff53b81582" title="Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi...">tile</a>(x, y, x_outer, y_outer, x_inner, y_inner, 256, 256)
            .<a class="code" href="class_halide_1_1_func.html#a07ae6163527e6319a9352f7648afd875" title="Join two dimensions into a single fused dimenion.">fuse</a>(x_outer, y_outer, tile_index)
            .<a class="code" href="class_halide_1_1_func.html#aa0050c604179b43a8deb42b62dedd29d" title="Mark a dimension to be traversed in parallel.">parallel</a>(tile_index);

        <span class="comment">// We&#39;ll compute two scanlines at once while we walk across</span>
        <span class="comment">// each tile. We&#39;ll also vectorize in x. The easiest way to</span>
        <span class="comment">// express this is to recursively tile again within each tile</span>
        <span class="comment">// into 4x2 subtiles, then vectorize the subtiles across x and</span>
        <span class="comment">// unroll them across y:</span>
        <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x_inner_outer, y_inner_outer, x_vectors, y_pairs;
        gradient_fast
            .<a class="code" href="class_halide_1_1_func.html#ab15001cd4af9e8c2808f45ff53b81582" title="Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi...">tile</a>(x_inner, y_inner, x_inner_outer, y_inner_outer, x_vectors, y_pairs, 4, 2)
            .<a class="code" href="class_halide_1_1_func.html#a7b1857a62deca8bc9a477c1b26720950" title="Mark a dimension to be computed all-at-once as a single vector.">vectorize</a>(x_vectors)
            .<a class="code" href="class_halide_1_1_func.html#a75c97910f964410df65f04f7a85e3518" title="Mark a dimension to be completely unrolled.">unroll</a>(y_pairs);

        <span class="comment">// Note that we didn&#39;t do any explicit splitting or</span>
        <span class="comment">// reordering. Those are the most important primitive</span>
        <span class="comment">// operations, but mostly they are buried underneath tiling,</span>
        <span class="comment">// vectorizing, or unrolling calls.</span>

        <span class="comment">// Now let&#39;s evaluate this over a range which is not a</span>
        <span class="comment">// multiple of the tile size.</span>

        <span class="comment">// If you like you can turn on tracing, but it&#39;s going to</span>
        <span class="comment">// produce a lot of printfs. Instead we&#39;ll compute the answer</span>
        <span class="comment">// both in C and Halide and see if the answers match.</span>
        <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;int&gt;</a> result = gradient_fast.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(800, 600);

        printf(<span class="stringliteral">&quot;Checking Halide result against equivalent C...\n&quot;</span>);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> tile_index = 0; tile_index &lt; 4 * 3; tile_index++) {
            <span class="keywordtype">int</span> y_outer = tile_index / 4;
            <span class="keywordtype">int</span> x_outer = tile_index % 4;
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y_inner_outer = 0; y_inner_outer &lt; 256/2; y_inner_outer++) {
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x_inner_outer = 0; x_inner_outer &lt; 256/4; x_inner_outer++) {
                    <span class="comment">// We&#39;re vectorized across x</span>
                    <span class="keywordtype">int</span> x = <a name="a12"></a><a class="code" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940" title="Returns an expression representing the lesser of the two arguments, after doing any necessary type co...">std::min</a>(x_outer * 256, 800-256) + x_inner_outer*4;
                    <span class="keywordtype">int</span> x_vec[4] = {x + 0,
                                    x + 1,
                                    x + 2,
                                    x + 3};

                    <span class="comment">// And we unrolled across y</span>
                    <span class="keywordtype">int</span> y_base = <a class="code" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940" title="Returns an expression representing the lesser of the two arguments, after doing any necessary type co...">std::min</a>(y_outer * 256, 600-256) + y_inner_outer*2;
                    {
                        <span class="comment">// y_pairs = 0</span>
                        <span class="keywordtype">int</span> y = y_base + 0;
                        <span class="keywordtype">int</span> y_vec[4] = {y, y, y, y};
                        <span class="keywordtype">int</span> val[4] = {x_vec[0] + y_vec[0],
                                      x_vec[1] + y_vec[1],
                                      x_vec[2] + y_vec[2],
                                      x_vec[3] + y_vec[3]};

                        <span class="comment">// Check the result.</span>
                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++) {
                            <span class="keywordflow">if</span> (result(x_vec[i], y_vec[i]) != val[i]) {
                                printf(<span class="stringliteral">&quot;There was an error at %d %d!\n&quot;</span>, x_vec[i], y_vec[i]);
                                <span class="keywordflow">return</span> -1;
                            }
                        }
                    }
                    {
                        <span class="comment">// y_pairs = 1</span>
                        <span class="keywordtype">int</span> y = y_base + 1;
                        <span class="keywordtype">int</span> y_vec[4] = {y, y, y, y};
                        <span class="keywordtype">int</span> val[4] = {x_vec[0] + y_vec[0],
                                      x_vec[1] + y_vec[1],
                                      x_vec[2] + y_vec[2],
                                      x_vec[3] + y_vec[3]};

                        <span class="comment">// Check the result.</span>
                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++) {
                            <span class="keywordflow">if</span> (result(x_vec[i], y_vec[i]) != val[i]) {
                                printf(<span class="stringliteral">&quot;There was an error at %d %d!\n&quot;</span>, x_vec[i], y_vec[i]);
                                <span class="keywordflow">return</span> -1;
                            }
                        }
                    }
                }
            }
        }
    }

    <span class="comment">// Note that in the Halide version, the algorithm is specified</span>
    <span class="comment">// once at the top, separately from the optimizations, and there</span>
    <span class="comment">// aren&#39;t that many lines of code total. Compare this to the C</span>
    <span class="comment">// version. There&#39;s more code (and it isn&#39;t even parallelized or</span>
    <span class="comment">// vectorized properly). More annoyingly, the statement of the</span>
    <span class="comment">// algorithm (the result is x plus y) is buried in multiple places</span>
    <span class="comment">// within the mess. This C code is hard to write, hard to read,</span>
    <span class="comment">// hard to debug, and hard to optimize further. This is why Halide</span>
    <span class="comment">// exists.</span>

    printf(<span class="stringliteral">&quot;Success!\n&quot;</span>);
    <span class="keywordflow">return</span> 0;
}
</pre></div> </div><!-- contents -->
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
