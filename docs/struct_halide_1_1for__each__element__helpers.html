<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Halide: Halide::for_each_element_helpers&lt; Fn &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('struct_halide_1_1for__each__element__helpers.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="struct_halide_1_1for__each__element__helpers-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::for_each_element_helpers&lt; Fn &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Some helpers for for_each_element.  
 <a href="struct_halide_1_1for__each__element__helpers.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa0c14dd04818f335177ebf39280fc3c8"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa0c14dd04818f335177ebf39280fc3c8"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1for__each__element__helpers.html#aa0c14dd04818f335177ebf39280fc3c8">for_each_element_variadic</a> (int, int d, Fn &amp;&amp;f, const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, Args...args) -&gt; decltype(f(args...))</td></tr>
<tr class="memdesc:aa0c14dd04818f335177ebf39280fc3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If f is callable with this many args, call it.  <a href="#aa0c14dd04818f335177ebf39280fc3c8">More...</a><br/></td></tr>
<tr class="separator:aa0c14dd04818f335177ebf39280fc3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8472275750a818f31944af348ed95a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a0b8472275750a818f31944af348ed95a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1for__each__element__helpers.html#a0b8472275750a818f31944af348ed95a">for_each_element_variadic</a> (double, int d, Fn &amp;&amp;f, const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, Args...args)</td></tr>
<tr class="memdesc:a0b8472275750a818f31944af348ed95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the above overload is impossible, we add an outer loop over an additional argument and try again.  <a href="#a0b8472275750a818f31944af348ed95a">More...</a><br/></td></tr>
<tr class="separator:a0b8472275750a818f31944af348ed95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58fc4dd457ea2ef6af7a1b3a0d1a42c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac58fc4dd457ea2ef6af7a1b3a0d1a42c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1for__each__element__helpers.html#ac58fc4dd457ea2ef6af7a1b3a0d1a42c">sink</a> (Args...)</td></tr>
<tr class="memdesc:ac58fc4dd457ea2ef6af7a1b3a0d1a42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sink function used to suppress compiler warnings in compilers that don't think decltype counts as a use.  <a href="#ac58fc4dd457ea2ef6af7a1b3a0d1a42c">More...</a><br/></td></tr>
<tr class="separator:ac58fc4dd457ea2ef6af7a1b3a0d1a42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac256c4b83335e756a28257fb7c43415f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac256c4b83335e756a28257fb7c43415f"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1for__each__element__helpers.html#ac256c4b83335e756a28257fb7c43415f">num_args</a> (int, int *result, Fn &amp;&amp;f, Args...args) -&gt; decltype(f(args...))</td></tr>
<tr class="memdesc:ac256c4b83335e756a28257fb7c43415f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the minimum number of arguments a callable can take using the same trick.  <a href="#ac256c4b83335e756a28257fb7c43415f">More...</a><br/></td></tr>
<tr class="separator:ac256c4b83335e756a28257fb7c43415f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c579768281c667153cb326310834a9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a60c579768281c667153cb326310834a9"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1for__each__element__helpers.html#a60c579768281c667153cb326310834a9">num_args</a> (double, int *result, Fn &amp;&amp;f, Args...args)</td></tr>
<tr class="memdesc:a60c579768281c667153cb326310834a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The recursive version is only enabled up to a recursion limit of 256.  <a href="#a60c579768281c667153cb326310834a9">More...</a><br/></td></tr>
<tr class="separator:a60c579768281c667153cb326310834a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacb476d730b8357a0865b44980d552c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1for__each__element__helpers.html#aeacb476d730b8357a0865b44980d552c">get_number_of_args</a> (Fn &amp;&amp;f)</td></tr>
<tr class="separator:aeacb476d730b8357a0865b44980d552c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89066b6727399f208198ae7067d7c2bb"><td class="memTemplParams" colspan="2">template&lt;int d&gt; </td></tr>
<tr class="memitem:a89066b6727399f208198ae7067d7c2bb"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1for__each__element__helpers.html#a89066b6727399f208198ae7067d7c2bb">for_each_element_array_helper</a> (int, Fn &amp;&amp;f, const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, int *pos)</td></tr>
<tr class="separator:a89066b6727399f208198ae7067d7c2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb249a6afceb8a7f769925aba68f9577"><td class="memTemplParams" colspan="2">template&lt;int d&gt; </td></tr>
<tr class="memitem:afb249a6afceb8a7f769925aba68f9577"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1for__each__element__helpers.html#afb249a6afceb8a7f769925aba68f9577">for_each_element_array_helper</a> (double, Fn &amp;&amp;f, const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, int *pos)</td></tr>
<tr class="memdesc:afb249a6afceb8a7f769925aba68f9577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case for recursion above.  <a href="#afb249a6afceb8a7f769925aba68f9577">More...</a><br/></td></tr>
<tr class="separator:afb249a6afceb8a7f769925aba68f9577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d187a1ab0f94357588103911475a31"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_halide_1_1for__each__element__helpers.html#aa7d187a1ab0f94357588103911475a31">for_each_element_array</a> (int d, Fn &amp;&amp;f, const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, int *pos)</td></tr>
<tr class="memdesc:aa7d187a1ab0f94357588103911475a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">A run-time-recursive version (instead of compile-time-recursive) that requires the callable to take a pointer to a position array instead.  <a href="#aa7d187a1ab0f94357588103911475a31">More...</a><br/></td></tr>
<tr class="separator:aa7d187a1ab0f94357588103911475a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc55516e3579675a13107e0a6c97792"><td class="memTemplParams" colspan="2">template&lt;typename Fn2 &gt; </td></tr>
<tr class="memitem:a0fc55516e3579675a13107e0a6c97792"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1for__each__element__helpers.html#a0fc55516e3579675a13107e0a6c97792">for_each_element</a> (int, const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, Fn2 &amp;&amp;f) -&gt; decltype(f((const int *) 0))</td></tr>
<tr class="memdesc:a0fc55516e3579675a13107e0a6c97792"><td class="mdescLeft">&#160;</td><td class="mdescRight">We now have two overloads for for_each_element.  <a href="#a0fc55516e3579675a13107e0a6c97792">More...</a><br/></td></tr>
<tr class="separator:a0fc55516e3579675a13107e0a6c97792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13d97c54b9ce0417f9bd53b1b902e29"><td class="memTemplParams" colspan="2">template&lt;typename Fn2 &gt; </td></tr>
<tr class="memitem:aa13d97c54b9ce0417f9bd53b1b902e29"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_halide_1_1for__each__element__helpers.html#aa13d97c54b9ce0417f9bd53b1b902e29">for_each_element</a> (double, const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;<a class="el" href="printer_8h.html#a1fe855c208bc17a51a4d34fefdb2d5b1">buf</a>, Fn2 &amp;&amp;f)</td></tr>
<tr class="memdesc:aa13d97c54b9ce0417f9bd53b1b902e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">This one triggers otherwise.  <a href="#aa13d97c54b9ce0417f9bd53b1b902e29">More...</a><br/></td></tr>
<tr class="separator:aa13d97c54b9ce0417f9bd53b1b902e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Fn&gt;<br/>
struct Halide::for_each_element_helpers&lt; Fn &gt;</h3>

<p>Some helpers for for_each_element. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01263">1263</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa0c14dd04818f335177ebf39280fc3c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> auto <a class="el" href="struct_halide_1_1for__each__element__helpers.html">Halide::for_each_element_helpers</a>&lt; Fn &gt;::for_each_element_variadic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(f(args...)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If f is callable with this many args, call it. </p>
<p>The first dummy argument is to make this version preferable for overload resolution. The decltype is to make this version impossible if the function is not callable with this many args. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01271">1271</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0b8472275750a818f31944af348ed95a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void <a class="el" href="struct_halide_1_1for__each__element__helpers.html">Halide::for_each_element_helpers</a>&lt; Fn &gt;::for_each_element_variadic </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the above overload is impossible, we add an outer loop over an additional argument and try again. </p>
<p>This trick is known as SFINAE. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01281">1281</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00789">buffer_t::extent</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00806">buffer_t::min</a>.</p>

</div>
</div>
<a class="anchor" id="ac58fc4dd457ea2ef6af7a1b3a0d1a42c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="struct_halide_1_1for__each__element__helpers.html">Halide::for_each_element_helpers</a>&lt; Fn &gt;::sink </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A sink function used to suppress compiler warnings in compilers that don't think decltype counts as a use. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01291">1291</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac256c4b83335e756a28257fb7c43415f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> auto <a class="el" href="struct_halide_1_1for__each__element__helpers.html">Halide::for_each_element_helpers</a>&lt; Fn &gt;::num_args </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(f(args...)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the minimum number of arguments a callable can take using the same trick. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01297">1297</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a60c579768281c667153cb326310834a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void <a class="el" href="struct_halide_1_1for__each__element__helpers.html">Halide::for_each_element_helpers</a>&lt; Fn &gt;::num_args </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The recursive version is only enabled up to a recursion limit of 256. </p>
<p>This catches callables that aren't callable with any number of ints. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01307">1307</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeacb476d730b8357a0865b44980d552c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> int <a class="el" href="struct_halide_1_1for__each__element__helpers.html">Halide::for_each_element_helpers</a>&lt; Fn &gt;::get_number_of_args </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01315">1315</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a89066b6727399f208198ae7067d7c2bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<div class="memtemplate">
template&lt;int d&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void ::type <a class="el" href="struct_halide_1_1for__each__element__helpers.html">Halide::for_each_element_helpers</a>&lt; Fn &gt;::for_each_element_array_helper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01329">1329</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00789">buffer_t::extent</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00806">buffer_t::min</a>.</p>

</div>
</div>
<a class="anchor" id="afb249a6afceb8a7f769925aba68f9577"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<div class="memtemplate">
template&lt;int d&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void <a class="el" href="struct_halide_1_1for__each__element__helpers.html">Halide::for_each_element_helpers</a>&lt; Fn &gt;::for_each_element_array_helper </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Base case for recursion above. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01338">1338</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa7d187a1ab0f94357588103911475a31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="struct_halide_1_1for__each__element__helpers.html">Halide::for_each_element_helpers</a>&lt; Fn &gt;::for_each_element_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A run-time-recursive version (instead of compile-time-recursive) that requires the callable to take a pointer to a position array instead. </p>
<p>Dispatches to the compile-time-recursive version once the dimensionality gets small. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01348">1348</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00789">buffer_t::extent</a>, and <a class="el" href="_halide_runtime_8h_source.html#l00806">buffer_t::min</a>.</p>

</div>
</div>
<a class="anchor" id="a0fc55516e3579675a13107e0a6c97792"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<div class="memtemplate">
template&lt;typename Fn2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="struct_halide_1_1for__each__element__helpers.html">Halide::for_each_element_helpers</a>&lt; Fn &gt;::for_each_element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(f((const int *)0)) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We now have two overloads for for_each_element. </p>
<p>This one triggers if the callable takes a const int *. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01373">1373</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>References <a class="el" href="_halide_runtime_8h_source.html#l00789">buffer_t::extent</a>.</p>

</div>
</div>
<a class="anchor" id="aa13d97c54b9ce0417f9bd53b1b902e29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<div class="memtemplate">
template&lt;typename Fn2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_halide_buffer_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void <a class="el" href="struct_halide_1_1for__each__element__helpers.html">Halide::for_each_element_helpers</a>&lt; Fn &gt;::for_each_element </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fn2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This one triggers otherwise. </p>
<p>It treats the callable as something that takes some number of ints. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01387">1387</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="struct_halide_1_1for__each__element__helpers.html">for_each_element_helpers</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
