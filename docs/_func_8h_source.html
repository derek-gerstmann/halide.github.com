<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Halide: Func.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Halide
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_func_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Func.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_func_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef HALIDE_FUNC_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define HALIDE_FUNC_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">/** \file</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * Defines Func - the front-end handle on a halide function, and related classes.</span>
<a name="l00007"></a>00007 <span class="comment"> */</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;<a class="code" href="_i_r_8h.html" title="Halide expressions (Halide::Expr) and statements (Halide::Internal::Stmt)">IR.h</a>&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;<a class="code" href="_var_8h.html" title="Defines the Var - the front-end variable.">Var.h</a>&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;<a class="code" href="_function_8h.html" title="Defines the internal representation of a halide function and related classes.">Function.h</a>&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;<a class="code" href="_param_8h.html" title="Classes for declaring scalar and image parameters to halide pipelines.">Param.h</a>&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;<a class="code" href="_argument_8h.html" title="Defines a type used for expressing the type signature of a generated halide pipeline.">Argument.h</a>&quot;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;<a class="code" href="_r_dom_8h.html" title="Defines the front-end syntax for reduction domains and reduction variables.">RDom.h</a>&quot;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &quot;<a class="code" href="_j_i_t_compiled_module_8h.html" title="Defines the struct representing a JIT compiled halide pipeline.">JITCompiledModule.h</a>&quot;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;<a class="code" href="_image_8h.html" title="Defines Halide&#39;s Image data type.">Image.h</a>&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;<a class="code" href="_target_8h.html" title="Defines the structure that describes a Halide target.">Target.h</a>&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;<a class="code" href="_tuple_8h.html" title="Defines Tuple - the front-end handle on small arrays of expressions.">Tuple.h</a>&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;<a class="code" href="_target_8h.html" title="Defines the structure that describes a Halide target.">Target.h</a>&quot;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="keyword">namespace </span>Halide {
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">/** A fragment of front-end syntax of the form f(x, y, z), where x,</span>
<a name="l00024"></a>00024 <span class="comment"> * y, z are Vars. It could be the left-hand side of a function</span>
<a name="l00025"></a>00025 <span class="comment"> * definition, or it could be a call to a function. We don&#39;t know</span>
<a name="l00026"></a>00026 <span class="comment"> * until we see how this object gets used.</span>
<a name="l00027"></a>00027 <span class="comment"> */</span>
<a name="l00028"></a>00028 <span class="keyword">class </span>FuncRefExpr;
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment">/** A class that can represent Vars or RVars. Used for reorder calls</span>
<a name="l00031"></a>00031 <span class="comment"> * which can accept a mix of either. */</span>
<a name="l00032"></a><a class="code" href="struct_halide_1_1_var_or_r_var.html">00032</a> <span class="keyword">struct </span><a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> {
<a name="l00033"></a><a class="code" href="struct_halide_1_1_var_or_r_var.html#a37ad2763785fd69ae52e4dc2ce8351e1">00033</a>     <a class="code" href="struct_halide_1_1_var_or_r_var.html#a37ad2763785fd69ae52e4dc2ce8351e1">VarOrRVar</a>(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> &amp;v) : <a class="code" href="struct_halide_1_1_var_or_r_var.html#ae46b214b33e1c145133a6319b56aa0a2">var</a>(v), <a class="code" href="struct_halide_1_1_var_or_r_var.html#a55f1535c001e2c84c8a29e1237803014">is_rvar</a>(false) {}
<a name="l00034"></a><a class="code" href="struct_halide_1_1_var_or_r_var.html#a76a291661fbf21cae8d755ada1bb1848">00034</a>     <a class="code" href="struct_halide_1_1_var_or_r_var.html#a76a291661fbf21cae8d755ada1bb1848">VarOrRVar</a>(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> &amp;r) : <a class="code" href="struct_halide_1_1_var_or_r_var.html#ad7d3d0199cd499f168f9cfa2ea298d1b">rvar</a>(r), <a class="code" href="struct_halide_1_1_var_or_r_var.html#a55f1535c001e2c84c8a29e1237803014">is_rvar</a>(true) {}
<a name="l00035"></a><a class="code" href="struct_halide_1_1_var_or_r_var.html#ae66d720e7d90dfcf2079e84f40948ad2">00035</a>     <a class="code" href="struct_halide_1_1_var_or_r_var.html#ae66d720e7d90dfcf2079e84f40948ad2">VarOrRVar</a>(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> &amp;r) : <a class="code" href="struct_halide_1_1_var_or_r_var.html#ad7d3d0199cd499f168f9cfa2ea298d1b">rvar</a>(<a class="code" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a>(r)), <a class="code" href="struct_halide_1_1_var_or_r_var.html#a55f1535c001e2c84c8a29e1237803014">is_rvar</a>(true) {}
<a name="l00036"></a>00036 
<a name="l00037"></a><a class="code" href="struct_halide_1_1_var_or_r_var.html#aac1d3baf423e038e2ffa68ea09baa0ed">00037</a>     <span class="keyword">const</span> std::string &amp;<a class="code" href="struct_halide_1_1_var_or_r_var.html#aac1d3baf423e038e2ffa68ea09baa0ed">name</a>()<span class="keyword"> const </span>{
<a name="l00038"></a>00038         <span class="keywordflow">if</span> (<a class="code" href="struct_halide_1_1_var_or_r_var.html#a55f1535c001e2c84c8a29e1237803014">is_rvar</a>) <span class="keywordflow">return</span> <a class="code" href="struct_halide_1_1_var_or_r_var.html#ad7d3d0199cd499f168f9cfa2ea298d1b">rvar</a>.<a class="code" href="class_halide_1_1_r_var.html#adcff378d68790dd295748152d61de49d" title="The name of this reduction variable.">name</a>();
<a name="l00039"></a>00039         <span class="keywordflow">else</span> <span class="keywordflow">return</span> <a class="code" href="struct_halide_1_1_var_or_r_var.html#ae46b214b33e1c145133a6319b56aa0a2">var</a>.<a class="code" href="class_halide_1_1_var.html#ae6e9f2ae00bf60198fae6629c7964ecf" title="Get the name of a Var.">name</a>();
<a name="l00040"></a>00040     }
<a name="l00041"></a>00041 
<a name="l00042"></a><a class="code" href="struct_halide_1_1_var_or_r_var.html#ae46b214b33e1c145133a6319b56aa0a2">00042</a>     <span class="keyword">const</span> <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> <a class="code" href="struct_halide_1_1_var_or_r_var.html#ae46b214b33e1c145133a6319b56aa0a2">var</a>;
<a name="l00043"></a><a class="code" href="struct_halide_1_1_var_or_r_var.html#ad7d3d0199cd499f168f9cfa2ea298d1b">00043</a>     <span class="keyword">const</span> <a class="code" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> <a class="code" href="struct_halide_1_1_var_or_r_var.html#ad7d3d0199cd499f168f9cfa2ea298d1b">rvar</a>;
<a name="l00044"></a><a class="code" href="struct_halide_1_1_var_or_r_var.html#a55f1535c001e2c84c8a29e1237803014">00044</a>     <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="struct_halide_1_1_var_or_r_var.html#a55f1535c001e2c84c8a29e1237803014">is_rvar</a>;
<a name="l00045"></a>00045 };
<a name="l00046"></a>00046 
<a name="l00047"></a><a class="code" href="class_halide_1_1_func_ref_var.html">00047</a> <span class="keyword">class </span><a class="code" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> {
<a name="l00048"></a>00048     <a class="code" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Internal::Function</a> func;
<a name="l00049"></a>00049     <span class="keywordtype">int</span> implicit_placeholder_pos;
<a name="l00050"></a>00050     std::vector&lt;std::string&gt; args;
<a name="l00051"></a>00051     std::vector&lt;std::string&gt; args_with_implicit_vars(<span class="keyword">const</span> std::vector&lt;Expr&gt; &amp;e) <span class="keyword">const</span>;
<a name="l00052"></a>00052 <span class="keyword">public</span>:
<a name="l00053"></a>00053     <a class="code" href="class_halide_1_1_func_ref_var.html#a52612379696e4510a18084efbffbb7db">FuncRefVar</a>(<a class="code" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Internal::Function</a>, <span class="keyword">const</span> std::vector&lt;Var&gt; &amp;, <span class="keywordtype">int</span> placeholder_pos = -1);
<a name="l00054"></a>00054 <span class="comment"></span>
<a name="l00055"></a>00055 <span class="comment">    /**  Use this as the left-hand-side of a definition. */</span>
<a name="l00056"></a>00056     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_var.html#a8589f39b01708e3c3de7a57051cbc037" title="Use this as the left-hand-side of a definition.">operator=</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>);
<a name="l00057"></a>00057 <span class="comment"></span>
<a name="l00058"></a>00058 <span class="comment">    /** Use this as the left-hand-side of a definition for a Func with</span>
<a name="l00059"></a>00059 <span class="comment">     * multiple outputs. */</span>
<a name="l00060"></a>00060     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_var.html#a8589f39b01708e3c3de7a57051cbc037" title="Use this as the left-hand-side of a definition.">operator=</a>(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> &amp;);
<a name="l00061"></a>00061 <span class="comment"></span>
<a name="l00062"></a>00062 <span class="comment">    /** Define this function as a sum reduction over the negative of</span>
<a name="l00063"></a>00063 <span class="comment">     * the given expression. The expression should refer to some RDom</span>
<a name="l00064"></a>00064 <span class="comment">     * to sum over. If the function does not already have a pure</span>
<a name="l00065"></a>00065 <span class="comment">     * definition, this sets it to zero.</span>
<a name="l00066"></a>00066 <span class="comment">     */</span>
<a name="l00067"></a>00067     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_var.html#afa8d9d494c8466c6d8b488f6460b9157" title="Define this function as a sum reduction over the negative of the given expression.">operator+=</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>);
<a name="l00068"></a>00068 <span class="comment"></span>
<a name="l00069"></a>00069 <span class="comment">    /** Define this function as a sum reduction over the given</span>
<a name="l00070"></a>00070 <span class="comment">     * expression. The expression should refer to some RDom to sum</span>
<a name="l00071"></a>00071 <span class="comment">     * over. If the function does not already have a pure definition,</span>
<a name="l00072"></a>00072 <span class="comment">     * this sets it to zero.</span>
<a name="l00073"></a>00073 <span class="comment">     */</span>
<a name="l00074"></a>00074     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_var.html#a12613c2131e9f0b133c16d05462895d4" title="Define this function as a sum reduction over the given expression.">operator-=</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>);
<a name="l00075"></a>00075 <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">    /** Define this function as a product reduction. The expression</span>
<a name="l00077"></a>00077 <span class="comment">     * should refer to some RDom to take the product over. If the</span>
<a name="l00078"></a>00078 <span class="comment">     * function does not already have a pure definition, this sets it</span>
<a name="l00079"></a>00079 <span class="comment">     * to 1.</span>
<a name="l00080"></a>00080 <span class="comment">     */</span>
<a name="l00081"></a>00081     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_var.html#a27f31b6e04ffb0d5bca35268584ff6a9" title="Define this function as a product reduction.">operator*=</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>);
<a name="l00082"></a>00082 <span class="comment"></span>
<a name="l00083"></a>00083 <span class="comment">    /** Define this function as the product reduction over the inverse</span>
<a name="l00084"></a>00084 <span class="comment">     * of the expression. The expression should refer to some RDom to</span>
<a name="l00085"></a>00085 <span class="comment">     * take the product over. If the function does not already have a</span>
<a name="l00086"></a>00086 <span class="comment">     * pure definition, this sets it to 1.</span>
<a name="l00087"></a>00087 <span class="comment">     */</span>
<a name="l00088"></a>00088     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_var.html#a05fa14c6c5aae990a2748704d5212302" title="Define this function as the product reduction over the inverse of the expression.">operator/=</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>);
<a name="l00089"></a>00089 <span class="comment"></span>
<a name="l00090"></a>00090 <span class="comment">    /** Override the usual assignment operator, so that</span>
<a name="l00091"></a>00091 <span class="comment">     * f(x, y) = g(x, y) defines f.</span>
<a name="l00092"></a>00092 <span class="comment">     */</span>
<a name="l00093"></a>00093     <span class="comment">// @{</span>
<a name="l00094"></a>00094     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_var.html#a8589f39b01708e3c3de7a57051cbc037" title="Use this as the left-hand-side of a definition.">operator=</a>(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> &amp;e);
<a name="l00095"></a>00095     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_var.html#a8589f39b01708e3c3de7a57051cbc037" title="Use this as the left-hand-side of a definition.">operator=</a>(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_func_ref_expr.html" title="A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Exprs.">FuncRefExpr</a> &amp;e);
<a name="l00096"></a>00096     <span class="comment">// @}</span>
<a name="l00097"></a>00097 <span class="comment"></span>
<a name="l00098"></a>00098 <span class="comment">    /** Use this FuncRefVar as a call to the function, and not as the</span>
<a name="l00099"></a>00099 <span class="comment">     * left-hand-side of a definition. Only works for single-output</span>
<a name="l00100"></a>00100 <span class="comment">     * funcs.</span>
<a name="l00101"></a>00101 <span class="comment">     */</span>
<a name="l00102"></a>00102     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_var.html#a79b9cd725bef87d1fa7cc86a4570d441" title="Use this FuncRefVar as a call to the function, and not as the left-hand-side of a definition...">operator Expr</a>() <span class="keyword">const</span>;
<a name="l00103"></a>00103 <span class="comment"></span>
<a name="l00104"></a>00104 <span class="comment">    /** When a FuncRefVar refers to a function that provides multiple</span>
<a name="l00105"></a>00105 <span class="comment">     * outputs, you can access each output as an Expr using</span>
<a name="l00106"></a>00106 <span class="comment">     * operator[] */</span>
<a name="l00107"></a>00107     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> <a class="code" href="class_halide_1_1_func_ref_var.html#a3ef603dc005a416cd50edab04ce2d32e" title="When a FuncRefVar refers to a function that provides multiple outputs, you can access each output as ...">operator[]</a>(<span class="keywordtype">int</span>) <span class="keyword">const</span>;
<a name="l00108"></a>00108 <span class="comment"></span>
<a name="l00109"></a>00109 <span class="comment">    /** How many outputs does the function this refers to produce. */</span>
<a name="l00110"></a>00110     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">size_t</span> <a class="code" href="class_halide_1_1_func_ref_var.html#adeb67d84dc692b4a1e9565f4d26376d5" title="How many outputs does the function this refers to produce.">size</a>() <span class="keyword">const</span>;
<a name="l00111"></a>00111 };
<a name="l00112"></a>00112 <span class="comment"></span>
<a name="l00113"></a>00113 <span class="comment">/** A fragment of front-end syntax of the form f(x, y, z), where x, y,</span>
<a name="l00114"></a>00114 <span class="comment"> * z are Exprs. If could be the left hand side of a reduction</span>
<a name="l00115"></a>00115 <span class="comment"> * definition, or it could be a call to a function. We don&#39;t know</span>
<a name="l00116"></a>00116 <span class="comment"> * until we see how this object gets used.</span>
<a name="l00117"></a>00117 <span class="comment"> */</span>
<a name="l00118"></a><a class="code" href="class_halide_1_1_func_ref_expr.html">00118</a> <span class="keyword">class </span><a class="code" href="class_halide_1_1_func_ref_expr.html" title="A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Exprs.">FuncRefExpr</a> {
<a name="l00119"></a>00119     <a class="code" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Internal::Function</a> func;
<a name="l00120"></a>00120     <span class="keywordtype">int</span> implicit_placeholder_pos;
<a name="l00121"></a>00121     std::vector&lt;Expr&gt; args;
<a name="l00122"></a>00122     std::vector&lt;Expr&gt; args_with_implicit_vars(<span class="keyword">const</span> std::vector&lt;Expr&gt; &amp;e) <span class="keyword">const</span>;
<a name="l00123"></a>00123 <span class="keyword">public</span>:
<a name="l00124"></a>00124     <a class="code" href="class_halide_1_1_func_ref_expr.html#a13068a51e81a8b27cb6e6a92df3d80ba">FuncRefExpr</a>(<a class="code" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Internal::Function</a>, <span class="keyword">const</span> std::vector&lt;Expr&gt; &amp;,
<a name="l00125"></a>00125                 <span class="keywordtype">int</span> placeholder_pos = -1);
<a name="l00126"></a>00126     <a class="code" href="class_halide_1_1_func_ref_expr.html#a13068a51e81a8b27cb6e6a92df3d80ba">FuncRefExpr</a>(<a class="code" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Internal::Function</a>, <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;,
<a name="l00127"></a>00127                 <span class="keywordtype">int</span> placeholder_pos = -1);
<a name="l00128"></a>00128 <span class="comment"></span>
<a name="l00129"></a>00129 <span class="comment">    /** Use this as the left-hand-side of a reduction definition (see</span>
<a name="l00130"></a>00130 <span class="comment">     * \ref RDom). The function must already have a pure definition.</span>
<a name="l00131"></a>00131 <span class="comment">     */</span>
<a name="l00132"></a>00132     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_expr.html#ad03f29cf7737eede9af9e588f5a824a3" title="Use this as the left-hand-side of a reduction definition (see RDom).">operator=</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>);
<a name="l00133"></a>00133 <span class="comment"></span>
<a name="l00134"></a>00134 <span class="comment">    /** Use this as the left-hand-side of a reduction definition for a</span>
<a name="l00135"></a>00135 <span class="comment">     * Func with multiple outputs. */</span>
<a name="l00136"></a>00136     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_expr.html#ad03f29cf7737eede9af9e588f5a824a3" title="Use this as the left-hand-side of a reduction definition (see RDom).">operator=</a>(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> &amp;);
<a name="l00137"></a>00137 <span class="comment"></span>
<a name="l00138"></a>00138 <span class="comment">    /** Define this function as a sum reduction over the negative of</span>
<a name="l00139"></a>00139 <span class="comment">     * the given expression. The expression should refer to some RDom</span>
<a name="l00140"></a>00140 <span class="comment">     * to sum over. If the function does not already have a pure</span>
<a name="l00141"></a>00141 <span class="comment">     * definition, this sets it to zero.</span>
<a name="l00142"></a>00142 <span class="comment">     */</span>
<a name="l00143"></a>00143     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_expr.html#a0cec34830d5a7e2079e2398bb00330f1" title="Define this function as a sum reduction over the negative of the given expression.">operator+=</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>);
<a name="l00144"></a>00144 <span class="comment"></span>
<a name="l00145"></a>00145 <span class="comment">    /** Define this function as a sum reduction over the given</span>
<a name="l00146"></a>00146 <span class="comment">     * expression. The expression should refer to some RDom to sum</span>
<a name="l00147"></a>00147 <span class="comment">     * over. If the function does not already have a pure definition,</span>
<a name="l00148"></a>00148 <span class="comment">     * this sets it to zero.</span>
<a name="l00149"></a>00149 <span class="comment">     */</span>
<a name="l00150"></a>00150     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_expr.html#aef5d918b8622b8d8c752eaf695e45000" title="Define this function as a sum reduction over the given expression.">operator-=</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>);
<a name="l00151"></a>00151 <span class="comment"></span>
<a name="l00152"></a>00152 <span class="comment">    /** Define this function as a product reduction. The expression</span>
<a name="l00153"></a>00153 <span class="comment">     * should refer to some RDom to take the product over. If the</span>
<a name="l00154"></a>00154 <span class="comment">     * function does not already have a pure definition, this sets it</span>
<a name="l00155"></a>00155 <span class="comment">     * to 1.</span>
<a name="l00156"></a>00156 <span class="comment">     */</span>
<a name="l00157"></a>00157     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_expr.html#a4ec8d865a720b51e1979991413714bc4" title="Define this function as a product reduction.">operator*=</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>);
<a name="l00158"></a>00158 <span class="comment"></span>
<a name="l00159"></a>00159 <span class="comment">    /** Define this function as the product reduction over the inverse</span>
<a name="l00160"></a>00160 <span class="comment">     * of the expression. The expression should refer to some RDom to</span>
<a name="l00161"></a>00161 <span class="comment">     * take the product over. If the function does not already have a</span>
<a name="l00162"></a>00162 <span class="comment">     * pure definition, this sets it to 1.</span>
<a name="l00163"></a>00163 <span class="comment">     */</span>
<a name="l00164"></a>00164     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_expr.html#a5f00d618f4b38eaff47c07754b6eab32" title="Define this function as the product reduction over the inverse of the expression.">operator/=</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a>);
<a name="l00165"></a>00165 
<a name="l00166"></a>00166     <span class="comment">/* Override the usual assignment operator, so that</span>
<a name="l00167"></a>00167 <span class="comment">     * f(x, y) = g(x, y) defines f.</span>
<a name="l00168"></a>00168 <span class="comment">     */</span>
<a name="l00169"></a>00169     <span class="comment">// @{</span>
<a name="l00170"></a>00170     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_expr.html#ad03f29cf7737eede9af9e588f5a824a3" title="Use this as the left-hand-side of a reduction definition (see RDom).">operator=</a>(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> &amp;);
<a name="l00171"></a>00171     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func_ref_expr.html#ad03f29cf7737eede9af9e588f5a824a3" title="Use this as the left-hand-side of a reduction definition (see RDom).">operator=</a>(<span class="keyword">const</span> <a class="code" href="class_halide_1_1_func_ref_expr.html" title="A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Exprs.">FuncRefExpr</a> &amp;);
<a name="l00172"></a>00172     <span class="comment">// @}</span>
<a name="l00173"></a>00173 <span class="comment"></span>
<a name="l00174"></a>00174 <span class="comment">    /** Use this as a call to the function, and not the left-hand-side</span>
<a name="l00175"></a>00175 <span class="comment">     * of a definition. Only works for single-output Funcs. */</span>
<a name="l00176"></a>00176     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_expr.html#a0f0f5285bd8da726b08b80f6e9d947cd" title="Use this as a call to the function, and not the left-hand-side of a definition.">operator Expr</a>() <span class="keyword">const</span>;
<a name="l00177"></a>00177 <span class="comment"></span>
<a name="l00178"></a>00178 <span class="comment">    /** When a FuncRefExpr refers to a function that provides multiple</span>
<a name="l00179"></a>00179 <span class="comment">     * outputs, you can access each output as an Expr using</span>
<a name="l00180"></a>00180 <span class="comment">     * operator[].</span>
<a name="l00181"></a>00181 <span class="comment">     */</span>
<a name="l00182"></a>00182     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> <a class="code" href="class_halide_1_1_func_ref_expr.html#ae656ce57aa9ebd756e99f4e2a0650492" title="When a FuncRefExpr refers to a function that provides multiple outputs, you can access each output as...">operator[]</a>(<span class="keywordtype">int</span>) <span class="keyword">const</span>;
<a name="l00183"></a>00183 <span class="comment"></span>
<a name="l00184"></a>00184 <span class="comment">    /** How many outputs does the function this refers to produce. */</span>
<a name="l00185"></a>00185     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">size_t</span> <a class="code" href="class_halide_1_1_func_ref_expr.html#a6f34a32167cd5d9bcef9d7e099548a88" title="How many outputs does the function this refers to produce.">size</a>() <span class="keyword">const</span>;
<a name="l00186"></a>00186 };
<a name="l00187"></a>00187 
<a name="l00188"></a><a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">00188</a> <span class="keyword">enum</span> <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> {
<a name="l00189"></a><a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">00189</a>     <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>,
<a name="l00190"></a><a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5cac79d1abbd09af907b0cd8cb118eef393">00190</a>     <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5cac79d1abbd09af907b0cd8cb118eef393">GPU_CUDA</a>,
<a name="l00191"></a><a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca22df10f6563ebf4acbf783321a683513">00191</a>     <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca22df10f6563ebf4acbf783321a683513">GPU_OpenCL</a>,
<a name="l00192"></a><a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca7e649b55dc1fc35650105debb81a6652">00192</a>     <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca7e649b55dc1fc35650105debb81a6652">GPU_GLSL</a>
<a name="l00193"></a>00193 };
<a name="l00194"></a>00194 <span class="comment"></span>
<a name="l00195"></a>00195 <span class="comment">/** A wrapper around a schedule used for common schedule manipulations */</span>
<a name="l00196"></a><a class="code" href="class_halide_1_1_schedule_handle.html">00196</a> <span class="keyword">class </span><a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> {
<a name="l00197"></a>00197     <a class="code" href="struct_halide_1_1_internal_1_1_schedule.html" title="A schedule for a halide function, which defines where, when, and how it should be evaluated...">Internal::Schedule</a> &amp;schedule;
<a name="l00198"></a>00198     <span class="keywordtype">void</span> set_dim_type(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var, <a class="code" href="struct_halide_1_1_internal_1_1_for.html#a58f191c4b166630d13829e4f1840d5c6">Internal::For::ForType</a> t);
<a name="l00199"></a>00199     <span class="keywordtype">void</span> dump_argument_list();
<a name="l00200"></a>00200 <span class="keyword">public</span>:
<a name="l00201"></a><a class="code" href="class_halide_1_1_schedule_handle.html#a5ad2d8b9dd4f722890654fa6c911e1aa">00201</a>     <a class="code" href="class_halide_1_1_schedule_handle.html#a5ad2d8b9dd4f722890654fa6c911e1aa">ScheduleHandle</a>(<a class="code" href="struct_halide_1_1_internal_1_1_schedule.html" title="A schedule for a halide function, which defines where, when, and how it should be evaluated...">Internal::Schedule</a> &amp;s) : schedule(s) {s.<a class="code" href="struct_halide_1_1_internal_1_1_schedule.html#a1f4d76d2f9e7ff8cdad019fe2ba5d705" title="This flag is set to true if the dims list has been manipulated by the user (or if a ScheduleHandle wa...">touched</a> = <span class="keyword">true</span>;}
<a name="l00202"></a>00202 <span class="comment"></span>
<a name="l00203"></a>00203 <span class="comment">    /** Scheduling calls that control how the domain of this update is</span>
<a name="l00204"></a>00204 <span class="comment">     * traversed. See the documentation for Func for the meanings. */</span>
<a name="l00205"></a>00205     <span class="comment">// @{</span>
<a name="l00206"></a>00206 
<a name="l00207"></a>00207     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a82dcba5e287a284bfdb2eba997659daa" title="Scheduling calls that control how the domain of this update is traversed.">split</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> old, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> outer, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> inner, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> factor);
<a name="l00208"></a>00208     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a07b98d9cec11b5e3a17930b0b20d01be" title="Scheduling calls that control how the domain of this update is traversed.">fuse</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> inner, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> outer, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> fused);
<a name="l00209"></a>00209     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a341ae03504ed0261b1ffba9935844c2d" title="Scheduling calls that control how the domain of this update is traversed.">parallel</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var);
<a name="l00210"></a>00210     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a965ef3a905df60c3f59ca3743cbf668d" title="Scheduling calls that control how the domain of this update is traversed.">vectorize</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var);
<a name="l00211"></a>00211     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a0cf1e85d5dcb74d761d15546b5c6de90" title="Scheduling calls that control how the domain of this update is traversed.">unroll</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var);
<a name="l00212"></a>00212     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a341ae03504ed0261b1ffba9935844c2d" title="Scheduling calls that control how the domain of this update is traversed.">parallel</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> task_size);
<a name="l00213"></a>00213     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a965ef3a905df60c3f59ca3743cbf668d" title="Scheduling calls that control how the domain of this update is traversed.">vectorize</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var, <span class="keywordtype">int</span> factor);
<a name="l00214"></a>00214     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a0cf1e85d5dcb74d761d15546b5c6de90" title="Scheduling calls that control how the domain of this update is traversed.">unroll</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var, <span class="keywordtype">int</span> factor);
<a name="l00215"></a>00215     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a5034fe9fbd89a2e6262bbdf3ac02a9fd" title="Scheduling calls that control how the domain of this update is traversed.">tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> xo, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> yo, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> xi, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> yi, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> xfactor, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> yfactor);
<a name="l00216"></a>00216     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a5034fe9fbd89a2e6262bbdf3ac02a9fd" title="Scheduling calls that control how the domain of this update is traversed.">tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> xi, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> yi, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> xfactor, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> yfactor);
<a name="l00217"></a>00217     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a773a847970afdca60927044e827a412b" title="Scheduling calls that control how the domain of this update is traversed.">reorder</a>(<span class="keyword">const</span> std::vector&lt;VarOrRVar&gt; &amp;vars);
<a name="l00218"></a>00218     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a773a847970afdca60927044e827a412b" title="Scheduling calls that control how the domain of this update is traversed.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y);
<a name="l00219"></a>00219     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a773a847970afdca60927044e827a412b" title="Scheduling calls that control how the domain of this update is traversed.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z);
<a name="l00220"></a>00220     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a773a847970afdca60927044e827a412b" title="Scheduling calls that control how the domain of this update is traversed.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00221"></a>00221                                    <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w);
<a name="l00222"></a>00222     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a773a847970afdca60927044e827a412b" title="Scheduling calls that control how the domain of this update is traversed.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00223"></a>00223                                    <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t);
<a name="l00224"></a>00224     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a773a847970afdca60927044e827a412b" title="Scheduling calls that control how the domain of this update is traversed.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00225"></a>00225                                    <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t1, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t2);
<a name="l00226"></a>00226     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a773a847970afdca60927044e827a412b" title="Scheduling calls that control how the domain of this update is traversed.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00227"></a>00227                                    <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t1, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t2,
<a name="l00228"></a>00228                                    <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t3);
<a name="l00229"></a>00229     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a773a847970afdca60927044e827a412b" title="Scheduling calls that control how the domain of this update is traversed.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00230"></a>00230                                    <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t1, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t2,
<a name="l00231"></a>00231                                    <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t3, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t4);
<a name="l00232"></a>00232     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a773a847970afdca60927044e827a412b" title="Scheduling calls that control how the domain of this update is traversed.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00233"></a>00233                                    <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t1, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t2,
<a name="l00234"></a>00234                                    <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t3, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t4, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t5);
<a name="l00235"></a>00235     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a773a847970afdca60927044e827a412b" title="Scheduling calls that control how the domain of this update is traversed.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00236"></a>00236                                    <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t1, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t2,
<a name="l00237"></a>00237                                    <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t3, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t4, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t5,
<a name="l00238"></a>00238                                    <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t6);
<a name="l00239"></a>00239     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#ae3cc45869ffbe51fa95f3fe7bc0f8463" title="Scheduling calls that control how the domain of this update is traversed.">rename</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> old_name, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> new_name);
<a name="l00240"></a>00240 
<a name="l00241"></a>00241     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#ad055cd17fd6c2e7f29b2959c787d9605" title="Scheduling calls that control how the domain of this update is traversed.">gpu_threads</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00242"></a>00242     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#ad055cd17fd6c2e7f29b2959c787d9605" title="Scheduling calls that control how the domain of this update is traversed.">gpu_threads</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00243"></a>00243     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#ad055cd17fd6c2e7f29b2959c787d9605" title="Scheduling calls that control how the domain of this update is traversed.">gpu_threads</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_z, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a0040a5306746609dd8aec0bec03a003c" title="Scheduling calls that control how the domain of this update is traversed.">gpu_blocks</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00246"></a>00246     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a0040a5306746609dd8aec0bec03a003c" title="Scheduling calls that control how the domain of this update is traversed.">gpu_blocks</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00247"></a>00247     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a0040a5306746609dd8aec0bec03a003c" title="Scheduling calls that control how the domain of this update is traversed.">gpu_blocks</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_z, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00248"></a>00248 
<a name="l00249"></a>00249     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a480016a59e0dcddb03f94258dd6febed" title="Scheduling calls that control how the domain of this update is traversed.">gpu</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00250"></a>00250     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a480016a59e0dcddb03f94258dd6febed" title="Scheduling calls that control how the domain of this update is traversed.">gpu</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y,
<a name="l00251"></a>00251                                <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y,
<a name="l00252"></a>00252                    <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00253"></a>00253     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a480016a59e0dcddb03f94258dd6febed" title="Scheduling calls that control how the domain of this update is traversed.">gpu</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_z,
<a name="l00254"></a>00254                                <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_z,
<a name="l00255"></a>00255                    <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00256"></a>00256     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#ae0207078c6c248fa15a9d1669fbf7d9c" title="Scheduling calls that control how the domain of this update is traversed.">gpu_tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> x_size, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00257"></a>00257     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#ae0207078c6c248fa15a9d1669fbf7d9c" title="Scheduling calls that control how the domain of this update is traversed.">gpu_tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> x_size, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> y_size,
<a name="l00258"></a>00258                     <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00259"></a>00259     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#ae0207078c6c248fa15a9d1669fbf7d9c" title="Scheduling calls that control how the domain of this update is traversed.">gpu_tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> z,
<a name="l00260"></a>00260                                     <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> x_size, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> y_size, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> z_size, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpu_api = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00261"></a>00261     <span class="comment">// @}</span>
<a name="l00262"></a>00262 
<a name="l00263"></a>00263     <span class="comment">// These calls are for legacy compatibility only.</span>
<a name="l00264"></a><a class="code" href="class_halide_1_1_schedule_handle.html#aac3fd49ab9a92485f2a24ed997b2c46e">00264</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#aac3fd49ab9a92485f2a24ed997b2c46e">cuda_threads</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x) {
<a name="l00265"></a>00265         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_schedule_handle.html#ad055cd17fd6c2e7f29b2959c787d9605" title="Scheduling calls that control how the domain of this update is traversed.">gpu_threads</a>(thread_x);
<a name="l00266"></a>00266     }
<a name="l00267"></a><a class="code" href="class_halide_1_1_schedule_handle.html#aa964092fe660a59129d3ac20feb1867b">00267</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#aa964092fe660a59129d3ac20feb1867b">cuda_threads</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y) {
<a name="l00268"></a>00268         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_schedule_handle.html#ad055cd17fd6c2e7f29b2959c787d9605" title="Scheduling calls that control how the domain of this update is traversed.">gpu_threads</a>(thread_x, thread_y);
<a name="l00269"></a>00269     }
<a name="l00270"></a><a class="code" href="class_halide_1_1_schedule_handle.html#a43f6c5ca23e42a04a654a0e6daaf81f7">00270</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a43f6c5ca23e42a04a654a0e6daaf81f7">cuda_threads</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_z) {
<a name="l00271"></a>00271         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_schedule_handle.html#ad055cd17fd6c2e7f29b2959c787d9605" title="Scheduling calls that control how the domain of this update is traversed.">gpu_threads</a>(thread_x, thread_y, thread_z);
<a name="l00272"></a>00272     }
<a name="l00273"></a>00273 
<a name="l00274"></a><a class="code" href="class_halide_1_1_schedule_handle.html#a138e0ce958cda731f080088fb7f89a3b">00274</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a138e0ce958cda731f080088fb7f89a3b">cuda_blocks</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x) {
<a name="l00275"></a>00275         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_schedule_handle.html#a0040a5306746609dd8aec0bec03a003c" title="Scheduling calls that control how the domain of this update is traversed.">gpu_blocks</a>(block_x);
<a name="l00276"></a>00276     }
<a name="l00277"></a><a class="code" href="class_halide_1_1_schedule_handle.html#a2c1a089eab2c71f57e6e1f2f225b683f">00277</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a2c1a089eab2c71f57e6e1f2f225b683f">cuda_blocks</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y) {
<a name="l00278"></a>00278         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_schedule_handle.html#a0040a5306746609dd8aec0bec03a003c" title="Scheduling calls that control how the domain of this update is traversed.">gpu_blocks</a>(block_x, block_y);
<a name="l00279"></a>00279     }
<a name="l00280"></a><a class="code" href="class_halide_1_1_schedule_handle.html#abc11aebb55ad93ae7a2d9e80ebf260f4">00280</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#abc11aebb55ad93ae7a2d9e80ebf260f4">cuda_blocks</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_z) {
<a name="l00281"></a>00281         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_schedule_handle.html#a0040a5306746609dd8aec0bec03a003c" title="Scheduling calls that control how the domain of this update is traversed.">gpu_blocks</a>(block_x, block_y, block_z);
<a name="l00282"></a>00282     }
<a name="l00283"></a>00283 
<a name="l00284"></a><a class="code" href="class_halide_1_1_schedule_handle.html#acf7d873d44842d0f3116e6fbebd86507">00284</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#acf7d873d44842d0f3116e6fbebd86507">cuda</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x) {
<a name="l00285"></a>00285         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_schedule_handle.html#a480016a59e0dcddb03f94258dd6febed" title="Scheduling calls that control how the domain of this update is traversed.">gpu</a>(block_x, thread_x);
<a name="l00286"></a>00286     }
<a name="l00287"></a><a class="code" href="class_halide_1_1_schedule_handle.html#a6bf73d51bde948e08ac781639b4008d2">00287</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#acf7d873d44842d0f3116e6fbebd86507">cuda</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y,
<a name="l00288"></a>00288                                 <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y) {
<a name="l00289"></a>00289         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_schedule_handle.html#a480016a59e0dcddb03f94258dd6febed" title="Scheduling calls that control how the domain of this update is traversed.">gpu</a>(block_x, thread_x, block_y, thread_y);
<a name="l00290"></a>00290     }
<a name="l00291"></a><a class="code" href="class_halide_1_1_schedule_handle.html#a033f1275529d5387491db06718fe434c">00291</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#acf7d873d44842d0f3116e6fbebd86507">cuda</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_z,
<a name="l00292"></a>00292                                 <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_z) {
<a name="l00293"></a>00293         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_schedule_handle.html#a480016a59e0dcddb03f94258dd6febed" title="Scheduling calls that control how the domain of this update is traversed.">gpu</a>(block_x, thread_x, block_y, thread_y, block_z, thread_z);
<a name="l00294"></a>00294     }
<a name="l00295"></a><a class="code" href="class_halide_1_1_schedule_handle.html#aca3bf0f68bb50a1e2a7920cffc024737">00295</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#aca3bf0f68bb50a1e2a7920cffc024737">cuda_tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <span class="keywordtype">int</span> x_size) {
<a name="l00296"></a>00296         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_schedule_handle.html#ae0207078c6c248fa15a9d1669fbf7d9c" title="Scheduling calls that control how the domain of this update is traversed.">gpu_tile</a>(x, x_size);
<a name="l00297"></a>00297     }
<a name="l00298"></a><a class="code" href="class_halide_1_1_schedule_handle.html#a16ed2ef297d71d526311638e3c59ff8a">00298</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#a16ed2ef297d71d526311638e3c59ff8a">cuda_tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <span class="keywordtype">int</span> x_size, <span class="keywordtype">int</span> y_size) {
<a name="l00299"></a>00299         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_schedule_handle.html#ae0207078c6c248fa15a9d1669fbf7d9c" title="Scheduling calls that control how the domain of this update is traversed.">gpu_tile</a>(x, y, x_size, y_size);
<a name="l00300"></a>00300     }
<a name="l00301"></a><a class="code" href="class_halide_1_1_schedule_handle.html#ab9893c5369e40d5df86673e34894bf68">00301</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> &amp;<a class="code" href="class_halide_1_1_schedule_handle.html#aca3bf0f68bb50a1e2a7920cffc024737">cuda_tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> z,
<a name="l00302"></a>00302                                      <span class="keywordtype">int</span> x_size, <span class="keywordtype">int</span> y_size, <span class="keywordtype">int</span> z_size) {
<a name="l00303"></a>00303         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_schedule_handle.html#ae0207078c6c248fa15a9d1669fbf7d9c" title="Scheduling calls that control how the domain of this update is traversed.">gpu_tile</a>(x, y, z, x_size, y_size, z_size);
<a name="l00304"></a>00304     }
<a name="l00305"></a>00305 };
<a name="l00306"></a>00306 <span class="comment"></span>
<a name="l00307"></a>00307 <span class="comment">/** A halide function. This class represents one stage in a Halide</span>
<a name="l00308"></a>00308 <span class="comment"> * pipeline, and is the unit by which we schedule things. By default</span>
<a name="l00309"></a>00309 <span class="comment"> * they are aggressively inlined, so you are encouraged to make lots</span>
<a name="l00310"></a>00310 <span class="comment"> * of little functions, rather than storing things in Exprs. */</span>
<a name="l00311"></a><a class="code" href="class_halide_1_1_func.html">00311</a> <span class="keyword">class </span><a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> {
<a name="l00312"></a>00312 <span class="comment"></span>
<a name="l00313"></a>00313 <span class="comment">    /** A handle on the internal halide function that this</span>
<a name="l00314"></a>00314 <span class="comment">     * represents */</span>
<a name="l00315"></a>00315     <a class="code" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Internal::Function</a> func;
<a name="l00316"></a>00316 <span class="comment"></span>
<a name="l00317"></a>00317 <span class="comment">    /** When you make a reference to this function to with fewer</span>
<a name="l00318"></a>00318 <span class="comment">     * arguments that it has dimensions, the argument list is bulked</span>
<a name="l00319"></a>00319 <span class="comment">     * up with &#39;implicit&#39; vars with canonical names. This lets you</span>
<a name="l00320"></a>00320 <span class="comment">     * pass around partially-applied halide functions. */</span>
<a name="l00321"></a>00321     <span class="comment">// @{</span>
<a name="l00322"></a>00322     <span class="keywordtype">int</span> add_implicit_vars(std::vector&lt;Var&gt; &amp;) <span class="keyword">const</span>;
<a name="l00323"></a>00323     <span class="keywordtype">int</span> add_implicit_vars(std::vector&lt;Expr&gt; &amp;) <span class="keyword">const</span>;
<a name="l00324"></a>00324     <span class="comment">// @}</span>
<a name="l00325"></a>00325 <span class="comment"></span>
<a name="l00326"></a>00326 <span class="comment">    /** The lowered imperative form of this function. Cached here so</span>
<a name="l00327"></a>00327 <span class="comment">     * that recompilation for different targets doesn&#39;t require</span>
<a name="l00328"></a>00328 <span class="comment">     * re-lowering */</span>
<a name="l00329"></a>00329     <a class="code" href="struct_halide_1_1_internal_1_1_stmt.html" title="A reference-counted handle to a statement node.">Internal::Stmt</a> lowered;
<a name="l00330"></a>00330 <span class="comment"></span>
<a name="l00331"></a>00331 <span class="comment">    /** A JIT-compiled version of this function that we save so that</span>
<a name="l00332"></a>00332 <span class="comment">     * we don&#39;t have to rejit every time we want to evaluated it. */</span>
<a name="l00333"></a>00333     <a class="code" href="struct_halide_1_1_internal_1_1_j_i_t_compiled_module.html" title="Function pointers into a compiled halide module.">Internal::JITCompiledModule</a> compiled_module;
<a name="l00334"></a>00334 <span class="comment"></span>
<a name="l00335"></a>00335 <span class="comment">    /** The current error handler used for realizing this</span>
<a name="l00336"></a>00336 <span class="comment">     * function. May be NULL. Only relevant when jitting. */</span>
<a name="l00337"></a>00337     void (*error_handler)(<span class="keywordtype">void</span> *user_context, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l00338"></a>00338 <span class="comment"></span>
<a name="l00339"></a>00339 <span class="comment">    /** The current custom allocator used for realizing this</span>
<a name="l00340"></a>00340 <span class="comment">     * function. May be NULL. Only relevant when jitting. */</span>
<a name="l00341"></a>00341     <span class="comment">// @{</span>
<a name="l00342"></a>00342     <span class="keywordtype">void</span> *(*custom_malloc)(<span class="keywordtype">void</span> *user_context, size_t);
<a name="l00343"></a>00343     void (*custom_free)(<span class="keywordtype">void</span> *user_context, <span class="keywordtype">void</span> *ptr);
<a name="l00344"></a>00344     <span class="comment">// @}</span>
<a name="l00345"></a>00345 <span class="comment"></span>
<a name="l00346"></a>00346 <span class="comment">    /** The current custom parallel task launcher and handler for</span>
<a name="l00347"></a>00347 <span class="comment">     * realizing this function. May be NULL. */</span>
<a name="l00348"></a>00348     <span class="comment">// @{</span>
<a name="l00349"></a>00349     int (*custom_do_par_for)(<span class="keywordtype">void</span> *user_context,
<a name="l00350"></a>00350                              int (*)(<span class="keywordtype">void</span> *, int, <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *),
<a name="l00351"></a>00351                              <span class="keywordtype">int</span>, <span class="keywordtype">int</span>, <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *);
<a name="l00352"></a>00352     int (*custom_do_task)(<span class="keywordtype">void</span> *user_context, int (*)(<span class="keywordtype">void</span> *, int, <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *),
<a name="l00353"></a>00353                           <span class="keywordtype">int</span>, <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *);
<a name="l00354"></a>00354     <span class="comment">// @}</span>
<a name="l00355"></a>00355 <span class="comment"></span>
<a name="l00356"></a>00356 <span class="comment">    /** The current custom tracing function. May be NULL. */</span>
<a name="l00357"></a>00357     <span class="comment">// @{</span>
<a name="l00358"></a>00358     <a class="code" href="mini__stdint_8h.html#a32f2e37ee053cf2ce8ca28d1f74630e5">int32_t</a> (*custom_trace)(<span class="keywordtype">void</span> *, <span class="keyword">const</span> <a class="code" href="structhalide__trace__event.html">halide_trace_event</a> *);
<a name="l00359"></a>00359 
<a name="l00360"></a>00360     <span class="comment">// @}</span>
<a name="l00361"></a>00361 <span class="comment"></span>
<a name="l00362"></a>00362 <span class="comment">    /** The random seed to use for realizations of this function. */</span>
<a name="l00363"></a>00363     <a class="code" href="mini__stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> random_seed;
<a name="l00364"></a>00364 <span class="comment"></span>
<a name="l00365"></a>00365 <span class="comment">    /** Pointers to current values of the automatically inferred</span>
<a name="l00366"></a>00366 <span class="comment">     * arguments (buffers and scalars) used to realize this</span>
<a name="l00367"></a>00367 <span class="comment">     * function. Only relevant when jitting. We can hold these things</span>
<a name="l00368"></a>00368 <span class="comment">     * with raw pointers instead of reference-counted handles, because</span>
<a name="l00369"></a>00369 <span class="comment">     * func indirectly holds onto them with reference-counted handles</span>
<a name="l00370"></a>00370 <span class="comment">     * via its value Expr. */</span>
<a name="l00371"></a>00371     std::vector&lt;const void *&gt; arg_values;
<a name="l00372"></a>00372 <span class="comment"></span>
<a name="l00373"></a>00373 <span class="comment">    /** Some of the arg_values need to be rebound on every call if the</span>
<a name="l00374"></a>00374 <span class="comment">     * image params change. The pointers for the scalar params will</span>
<a name="l00375"></a>00375 <span class="comment">     * still be valid though. */</span>
<a name="l00376"></a>00376     std::vector&lt;std::pair&lt;int, Internal::Parameter&gt; &gt; image_param_args;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="keyword">public</span>:
<a name="l00379"></a>00379     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#adaf012731a0385693a9b5829f7146f4e">test</a>();
<a name="l00380"></a>00380 <span class="comment"></span>
<a name="l00381"></a>00381 <span class="comment">    /** Declare a new undefined function with the given name */</span>
<a name="l00382"></a>00382     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keyword">explicit</span> <a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a>(<span class="keyword">const</span> std::string &amp;<a class="code" href="class_halide_1_1_func.html#a1c36026717d2f74a842983d65e6b3bf8" title="The name of this function, either given during construction, or automatically generated.">name</a>);
<a name="l00383"></a>00383 <span class="comment"></span>
<a name="l00384"></a>00384 <span class="comment">    /** Declare a new undefined function with an</span>
<a name="l00385"></a>00385 <span class="comment">     * automatically-generated unique name */</span>
<a name="l00386"></a>00386     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a>();
<a name="l00387"></a>00387 <span class="comment"></span>
<a name="l00388"></a>00388 <span class="comment">    /** Declare a new function with an automatically-generated unique</span>
<a name="l00389"></a>00389 <span class="comment">     * name, and define it to return the given expression (which may</span>
<a name="l00390"></a>00390 <span class="comment">     * not contain free variables). */</span>
<a name="l00391"></a>00391     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keyword">explicit</span> <a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> e);
<a name="l00392"></a>00392 <span class="comment"></span>
<a name="l00393"></a>00393 <span class="comment">    /** Construct a new Func to wrap an existing, already-define</span>
<a name="l00394"></a>00394 <span class="comment">     * Function object. */</span>
<a name="l00395"></a>00395     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keyword">explicit</span> <a class="code" href="class_halide_1_1_func.html#aed876d44c3e1dd0a72c4111afc63018b" title="Declare a new undefined function with an automatically-generated unique name.">Func</a>(<a class="code" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Internal::Function</a> f);
<a name="l00396"></a>00396 <span class="comment"></span>
<a name="l00397"></a>00397 <span class="comment">    /** Evaluate this function over some rectangular domain and return</span>
<a name="l00398"></a>00398 <span class="comment">     * the resulting buffer or buffers. Performs compilation if the</span>
<a name="l00399"></a>00399 <span class="comment">     * Func has not previously been realized and jit_compile has not</span>
<a name="l00400"></a>00400 <span class="comment">     * been called. The returned Buffer should probably be instantly</span>
<a name="l00401"></a>00401 <span class="comment">     * wrapped in an Image class of the appropriate type. That is, do</span>
<a name="l00402"></a>00402 <span class="comment">     * this:</span>
<a name="l00403"></a>00403 <span class="comment">     *</span>
<a name="l00404"></a>00404 <span class="comment">     \code</span>
<a name="l00405"></a>00405 <span class="comment">     f(x) = sin(x);</span>
<a name="l00406"></a>00406 <span class="comment">     Image&lt;float&gt; im = f.realize(...);</span>
<a name="l00407"></a>00407 <span class="comment">     \endcode</span>
<a name="l00408"></a>00408 <span class="comment">     *</span>
<a name="l00409"></a>00409 <span class="comment">     * not this:</span>
<a name="l00410"></a>00410 <span class="comment">     *</span>
<a name="l00411"></a>00411 <span class="comment">     \code</span>
<a name="l00412"></a>00412 <span class="comment">     f(x) = sin(x)</span>
<a name="l00413"></a>00413 <span class="comment">     Buffer im = f.realize(...)</span>
<a name="l00414"></a>00414 <span class="comment">     \endcode</span>
<a name="l00415"></a>00415 <span class="comment">     *</span>
<a name="l00416"></a>00416 <span class="comment">     * If your Func has multiple values, because you defined it using</span>
<a name="l00417"></a>00417 <span class="comment">     * a Tuple, then casting the result of a realize call to a buffer</span>
<a name="l00418"></a>00418 <span class="comment">     * or image will produce a run-time error. Instead you should do the</span>
<a name="l00419"></a>00419 <span class="comment">     * following:</span>
<a name="l00420"></a>00420 <span class="comment">     *</span>
<a name="l00421"></a>00421 <span class="comment">     \code</span>
<a name="l00422"></a>00422 <span class="comment">     f(x) = Tuple(x, sin(x));</span>
<a name="l00423"></a>00423 <span class="comment">     Realization r = f.realize(...);</span>
<a name="l00424"></a>00424 <span class="comment">     Image&lt;int&gt; im0 = r[0];</span>
<a name="l00425"></a>00425 <span class="comment">     Image&lt;float&gt; im1 = r[1];</span>
<a name="l00426"></a>00426 <span class="comment">     \endcode</span>
<a name="l00427"></a>00427 <span class="comment">     *</span>
<a name="l00428"></a>00428 <span class="comment">     */</span>
<a name="l00429"></a>00429     <span class="comment">// @{</span>
<a name="l00430"></a>00430     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> <a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(std::vector&lt;int32_t&gt; sizes, <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">get_jit_target_from_environment</a>());
<a name="l00431"></a>00431     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> <a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(<span class="keywordtype">int</span> x_size, <span class="keywordtype">int</span> y_size, <span class="keywordtype">int</span> z_size, <span class="keywordtype">int</span> w_size,
<a name="l00432"></a>00432                                <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">get_jit_target_from_environment</a>());
<a name="l00433"></a>00433     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> <a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(<span class="keywordtype">int</span> x_size, <span class="keywordtype">int</span> y_size, <span class="keywordtype">int</span> z_size,
<a name="l00434"></a>00434                                <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">get_jit_target_from_environment</a>());
<a name="l00435"></a>00435     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> <a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(<span class="keywordtype">int</span> x_size, <span class="keywordtype">int</span> y_size,
<a name="l00436"></a>00436                                <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">get_jit_target_from_environment</a>());
<a name="l00437"></a>00437     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> <a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(<span class="keywordtype">int</span> x_size = 0,
<a name="l00438"></a>00438                                <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">get_jit_target_from_environment</a>());
<a name="l00439"></a>00439     <span class="comment">// @}</span>
<a name="l00440"></a>00440 <span class="comment"></span>
<a name="l00441"></a>00441 <span class="comment">    /** Evaluate this function into an existing allocated buffer or</span>
<a name="l00442"></a>00442 <span class="comment">     * buffers. If the buffer is also one of the arguments to the</span>
<a name="l00443"></a>00443 <span class="comment">     * function, strange things may happen, as the pipeline isn&#39;t</span>
<a name="l00444"></a>00444 <span class="comment">     * necessarily safe to run in-place. If you pass multiple buffers,</span>
<a name="l00445"></a>00445 <span class="comment">     * they must have matching sizes. */</span>
<a name="l00446"></a>00446     <span class="comment">// @{</span>
<a name="l00447"></a>00447     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(<a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> dst, <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">get_jit_target_from_environment</a>());
<a name="l00448"></a>00448     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(<a class="code" href="class_halide_1_1_buffer.html" title="The internal representation of an image, or other dense array data.">Buffer</a> dst, <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">get_jit_target_from_environment</a>());
<a name="l00449"></a>00449     <span class="comment">// @}</span>
<a name="l00450"></a>00450 <span class="comment"></span>
<a name="l00451"></a>00451 <span class="comment">    /** For a given size of output, or a given output buffer,</span>
<a name="l00452"></a>00452 <span class="comment">     * determine the bounds required of all unbound ImageParams</span>
<a name="l00453"></a>00453 <span class="comment">     * referenced. Communicates the result by allocating new buffers</span>
<a name="l00454"></a>00454 <span class="comment">     * of the appropriate size and binding them to the unbound</span>
<a name="l00455"></a>00455 <span class="comment">     * ImageParams. */</span>
<a name="l00456"></a>00456     <span class="comment">// @{</span>
<a name="l00457"></a>00457     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a7e4e93d5c38bf8094b6357e8900e5bd6" title="For a given size of output, or a given output buffer, determine the bounds required of all unbound Im...">infer_input_bounds</a>(<span class="keywordtype">int</span> x_size = 0, <span class="keywordtype">int</span> y_size = 0, <span class="keywordtype">int</span> z_size = 0, <span class="keywordtype">int</span> w_size = 0);
<a name="l00458"></a>00458     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a7e4e93d5c38bf8094b6357e8900e5bd6" title="For a given size of output, or a given output buffer, determine the bounds required of all unbound Im...">infer_input_bounds</a>(<a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> dst);
<a name="l00459"></a>00459     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a7e4e93d5c38bf8094b6357e8900e5bd6" title="For a given size of output, or a given output buffer, determine the bounds required of all unbound Im...">infer_input_bounds</a>(<a class="code" href="class_halide_1_1_buffer.html" title="The internal representation of an image, or other dense array data.">Buffer</a> dst);
<a name="l00460"></a>00460     <span class="comment">// @}</span>
<a name="l00461"></a>00461 <span class="comment"></span>
<a name="l00462"></a>00462 <span class="comment">    /** Statically compile this function to llvm bitcode, with the</span>
<a name="l00463"></a>00463 <span class="comment">     * given filename (which should probably end in .bc), type</span>
<a name="l00464"></a>00464 <span class="comment">     * signature, and C function name (which defaults to the same name</span>
<a name="l00465"></a>00465 <span class="comment">     * as this halide function */</span><span class="comment"></span>
<a name="l00466"></a>00466 <span class="comment">    //@{</span>
<a name="l00467"></a>00467 <span class="comment"></span>    <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#af62325fc687b6bdbc809baf892144519" title="Statically compile this function to llvm bitcode, with the given filename (which should probably end ...">compile_to_bitcode</a>(<span class="keyword">const</span> std::string &amp;filename, std::vector&lt;Argument&gt;, <span class="keyword">const</span> std::string &amp;fn_name,
<a name="l00468"></a>00468                                    <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00469"></a>00469     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#af62325fc687b6bdbc809baf892144519" title="Statically compile this function to llvm bitcode, with the given filename (which should probably end ...">compile_to_bitcode</a>(<span class="keyword">const</span> std::string &amp;filename, std::vector&lt;Argument&gt;,
<a name="l00470"></a>00470                                    <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00471"></a>00471     <span class="comment">// @}</span>
<a name="l00472"></a>00472 <span class="comment"></span>
<a name="l00473"></a>00473 <span class="comment">    /** Statically compile this function to an object file, with the</span>
<a name="l00474"></a>00474 <span class="comment">     * given filename (which should probably end in .o or .obj), type</span>
<a name="l00475"></a>00475 <span class="comment">     * signature, and C function name (which defaults to the same name</span>
<a name="l00476"></a>00476 <span class="comment">     * as this halide function. You probably don&#39;t want to use this</span>
<a name="l00477"></a>00477 <span class="comment">     * directly; call compile_to_file instead. */</span><span class="comment"></span>
<a name="l00478"></a>00478 <span class="comment">    //@{</span>
<a name="l00479"></a>00479 <span class="comment"></span>    <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a4536dcff3d4d9b8331745c230704961f" title="Statically compile this function to an object file, with the given filename (which should probably en...">compile_to_object</a>(<span class="keyword">const</span> std::string &amp;filename, std::vector&lt;Argument&gt;, <span class="keyword">const</span> std::string &amp;fn_name,
<a name="l00480"></a>00480                                   <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00481"></a>00481     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a4536dcff3d4d9b8331745c230704961f" title="Statically compile this function to an object file, with the given filename (which should probably en...">compile_to_object</a>(<span class="keyword">const</span> std::string &amp;filename, std::vector&lt;Argument&gt;,
<a name="l00482"></a>00482                                   <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00483"></a>00483     <span class="comment">// @}</span>
<a name="l00484"></a>00484 <span class="comment"></span>
<a name="l00485"></a>00485 <span class="comment">    /** Emit a header file with the given filename for this</span>
<a name="l00486"></a>00486 <span class="comment">     * function. The header will define a function with the type</span>
<a name="l00487"></a>00487 <span class="comment">     * signature given by the second argument, and a name given by the</span>
<a name="l00488"></a>00488 <span class="comment">     * third. The name defaults to the same name as this halide</span>
<a name="l00489"></a>00489 <span class="comment">     * function. You don&#39;t actually have to have defined this function</span>
<a name="l00490"></a>00490 <span class="comment">     * yet to call this. You probably don&#39;t want to use this directly;</span>
<a name="l00491"></a>00491 <span class="comment">     * call compile_to_file instead. */</span>
<a name="l00492"></a>00492     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#aae9623ffff43b170735b65c490b68ffb" title="Emit a header file with the given filename for this function.">compile_to_header</a>(<span class="keyword">const</span> std::string &amp;filename, std::vector&lt;Argument&gt;, <span class="keyword">const</span> std::string &amp;fn_name = <span class="stringliteral">&quot;&quot;</span>);
<a name="l00493"></a>00493 <span class="comment"></span>
<a name="l00494"></a>00494 <span class="comment">    /** Statically compile this function to text assembly equivalent</span>
<a name="l00495"></a>00495 <span class="comment">     * to the object file generated by compile_to_object. This is</span>
<a name="l00496"></a>00496 <span class="comment">     * useful for checking what Halide is producing without having to</span>
<a name="l00497"></a>00497 <span class="comment">     * disassemble anything, or if you need to feed the assembly into</span>
<a name="l00498"></a>00498 <span class="comment">     * some custom toolchain to produce an object file (e.g. iOS) */</span><span class="comment"></span>
<a name="l00499"></a>00499 <span class="comment">    //@{</span>
<a name="l00500"></a>00500 <span class="comment"></span>    <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a5db5d045e2246ebf3bdac5557768760a" title="Statically compile this function to text assembly equivalent to the object file generated by compile_...">compile_to_assembly</a>(<span class="keyword">const</span> std::string &amp;filename, std::vector&lt;Argument&gt;, <span class="keyword">const</span> std::string &amp;fn_name,
<a name="l00501"></a>00501                                     <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00502"></a>00502     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a5db5d045e2246ebf3bdac5557768760a" title="Statically compile this function to text assembly equivalent to the object file generated by compile_...">compile_to_assembly</a>(<span class="keyword">const</span> std::string &amp;filename, std::vector&lt;Argument&gt;,
<a name="l00503"></a>00503                                     <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00504"></a>00504     <span class="comment">// @}</span><span class="comment"></span>
<a name="l00505"></a>00505 <span class="comment">    /** Statically compile this function to C source code. This is</span>
<a name="l00506"></a>00506 <span class="comment">     * useful for providing fallback code paths that will compile on</span>
<a name="l00507"></a>00507 <span class="comment">     * many platforms. Vectorization will fail, and parallelization</span>
<a name="l00508"></a>00508 <span class="comment">     * will produce serial code. */</span>
<a name="l00509"></a>00509     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a04a6c208a0d447cb9e28c088d138e0a5" title="Statically compile this function to C source code.">compile_to_c</a>(<span class="keyword">const</span> std::string &amp;filename, std::vector&lt;Argument&gt;, <span class="keyword">const</span> std::string &amp;fn_name = <span class="stringliteral">&quot;&quot;</span>);
<a name="l00510"></a>00510 <span class="comment"></span>
<a name="l00511"></a>00511 <span class="comment">    /** Write out an internal representation of lowered code. Useful</span>
<a name="l00512"></a>00512 <span class="comment">     * for analyzing and debugging scheduling. Canonical extension is</span>
<a name="l00513"></a>00513 <span class="comment">     * .stmt, which must be supplied in filename. */</span>
<a name="l00514"></a>00514     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a419beef1aa58ba75c4605d099931f056" title="Write out an internal representation of lowered code.">compile_to_lowered_stmt</a>(<span class="keyword">const</span> std::string &amp;filename);
<a name="l00515"></a>00515 <span class="comment"></span>
<a name="l00516"></a>00516 <span class="comment">    /** Compile to object file and header pair, with the given</span>
<a name="l00517"></a>00517 <span class="comment">     * arguments. Also names the C function to match the first</span>
<a name="l00518"></a>00518 <span class="comment">     * argument.</span>
<a name="l00519"></a>00519 <span class="comment">     */</span><span class="comment"></span>
<a name="l00520"></a>00520 <span class="comment">    //@{</span>
<a name="l00521"></a>00521 <span class="comment"></span>    <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e" title="Compile to object file and header pair, with the given arguments.">compile_to_file</a>(<span class="keyword">const</span> std::string &amp;filename_prefix, std::vector&lt;Argument&gt; <a class="code" href="class_halide_1_1_func.html#a830f40950d6695281dc4c5057767ca4f" title="Get the pure arguments.">args</a>,
<a name="l00522"></a>00522                                 <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00523"></a>00523     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e" title="Compile to object file and header pair, with the given arguments.">compile_to_file</a>(<span class="keyword">const</span> std::string &amp;filename_prefix,
<a name="l00524"></a>00524                                 <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00525"></a>00525     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e" title="Compile to object file and header pair, with the given arguments.">compile_to_file</a>(<span class="keyword">const</span> std::string &amp;filename_prefix, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> a,
<a name="l00526"></a>00526                                 <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00527"></a>00527     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e" title="Compile to object file and header pair, with the given arguments.">compile_to_file</a>(<span class="keyword">const</span> std::string &amp;filename_prefix, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> a, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> b,
<a name="l00528"></a>00528                                 <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00529"></a>00529     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e" title="Compile to object file and header pair, with the given arguments.">compile_to_file</a>(<span class="keyword">const</span> std::string &amp;filename_prefix, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> a, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> b, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> c,
<a name="l00530"></a>00530                                 <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00531"></a>00531     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e" title="Compile to object file and header pair, with the given arguments.">compile_to_file</a>(<span class="keyword">const</span> std::string &amp;filename_prefix, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> a, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> b, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> c, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> d,
<a name="l00532"></a>00532                                 <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00533"></a>00533     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a5eba1cca2827f4210244deba8a71a64e" title="Compile to object file and header pair, with the given arguments.">compile_to_file</a>(<span class="keyword">const</span> std::string &amp;filename_prefix, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> a, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> b, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> c, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> d, <a class="code" href="struct_halide_1_1_argument.html" title="A struct representing an argument to a halide-generated function.">Argument</a> e,
<a name="l00534"></a>00534                                 <span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#a2d655bb0051fc525e3e5d73997f93cdd" title="Return the target that Halide will use.">get_target_from_environment</a>());
<a name="l00535"></a>00535     <span class="comment">// @}</span>
<a name="l00536"></a>00536 <span class="comment"></span>
<a name="l00537"></a>00537 <span class="comment">    /** Eagerly jit compile the function to machine code. This</span>
<a name="l00538"></a>00538 <span class="comment">     * normally happens on the first call to realize. If you&#39;re</span>
<a name="l00539"></a>00539 <span class="comment">     * running your halide pipeline inside time-sensitive code and</span>
<a name="l00540"></a>00540 <span class="comment">     * wish to avoid including the time taken to compile a pipeline,</span>
<a name="l00541"></a>00541 <span class="comment">     * then you can call this ahead of time. Returns the raw function</span>
<a name="l00542"></a>00542 <span class="comment">     * pointer to the compiled pipeline. Default is to use the Target</span>
<a name="l00543"></a>00543 <span class="comment">     * returned from Halide::get_jit_target_from_environment()</span>
<a name="l00544"></a>00544 <span class="comment">     */</span>
<a name="l00545"></a>00545      <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> *<a class="code" href="class_halide_1_1_func.html#a4bb020bfc9d7e83325dc59b271513dfc" title="Eagerly jit compile the function to machine code.">compile_jit</a>(<span class="keyword">const</span> <a class="code" href="struct_halide_1_1_target.html" title="A struct representing a target machine and os to generate code for.">Target</a> &amp;target = <a class="code" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">get_jit_target_from_environment</a>());
<a name="l00546"></a>00546 <span class="comment"></span>
<a name="l00547"></a>00547 <span class="comment">    /** Set the error handler function that be called in the case of</span>
<a name="l00548"></a>00548 <span class="comment">     * runtime errors during halide pipelines. If you are compiling</span>
<a name="l00549"></a>00549 <span class="comment">     * statically, you can also just define your own function with</span>
<a name="l00550"></a>00550 <span class="comment">     * signature</span>
<a name="l00551"></a>00551 <span class="comment">     \code</span>
<a name="l00552"></a>00552 <span class="comment">     extern &quot;C&quot; void halide_error(void *user_context, const char *);</span>
<a name="l00553"></a>00553 <span class="comment">     \endcode</span>
<a name="l00554"></a>00554 <span class="comment">     * This will clobber Halide&#39;s version.</span>
<a name="l00555"></a>00555 <span class="comment">     */</span>
<a name="l00556"></a>00556     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a043d5e26caec7bc3afb32c770699e3de" title="Set the error handler function that be called in the case of runtime errors during halide pipelines...">set_error_handler</a>(<span class="keywordtype">void</span> (*handler)(<span class="keywordtype">void</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *));
<a name="l00557"></a>00557 <span class="comment"></span>
<a name="l00558"></a>00558 <span class="comment">    /** Set a custom malloc and free for halide to use. Malloc should</span>
<a name="l00559"></a>00559 <span class="comment">     * return 32-byte aligned chunks of memory, and it should be safe</span>
<a name="l00560"></a>00560 <span class="comment">     * for Halide to read slightly out of bounds (up to 8 bytes before</span>
<a name="l00561"></a>00561 <span class="comment">     * the start or beyond the end). If compiling statically, routines</span>
<a name="l00562"></a>00562 <span class="comment">     * with appropriate signatures can be provided directly</span>
<a name="l00563"></a>00563 <span class="comment">    \code</span>
<a name="l00564"></a>00564 <span class="comment">     extern &quot;C&quot; void *halide_malloc(void *, size_t)</span>
<a name="l00565"></a>00565 <span class="comment">     extern &quot;C&quot; void halide_free(void *, void *)</span>
<a name="l00566"></a>00566 <span class="comment">     \endcode</span>
<a name="l00567"></a>00567 <span class="comment">     * These will clobber Halide&#39;s versions. See \file HalideRuntime.h</span>
<a name="l00568"></a>00568 <span class="comment">     * for declarations.</span>
<a name="l00569"></a>00569 <span class="comment">     */</span>
<a name="l00570"></a>00570     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#accac17bd1d0e40c50d50b515e082d922">set_custom_allocator</a>(<span class="keywordtype">void</span> *(*malloc)(<span class="keywordtype">void</span> *, <span class="keywordtype">size_t</span>),
<a name="l00571"></a>00571                                      <span class="keywordtype">void</span> (*free)(<span class="keywordtype">void</span> *, <span class="keywordtype">void</span> *));
<a name="l00572"></a>00572 <span class="comment"></span>
<a name="l00573"></a>00573 <span class="comment">    /** Set a custom task handler to be called by the parallel for</span>
<a name="l00574"></a>00574 <span class="comment">     * loop. It is useful to set this if you want to do some</span>
<a name="l00575"></a>00575 <span class="comment">     * additional bookkeeping at the granularity of parallel</span>
<a name="l00576"></a>00576 <span class="comment">     * tasks. The default implementation does this:</span>
<a name="l00577"></a>00577 <span class="comment">     \code</span>
<a name="l00578"></a>00578 <span class="comment">     extern &quot;C&quot; int halide_do_task(void *user_context,</span>
<a name="l00579"></a>00579 <span class="comment">                                   int (*f)(void *, int, uint8_t *),</span>
<a name="l00580"></a>00580 <span class="comment">                                   int idx, uint8_t *state) {</span>
<a name="l00581"></a>00581 <span class="comment">         return f(user_context, idx, state);</span>
<a name="l00582"></a>00582 <span class="comment">     }</span>
<a name="l00583"></a>00583 <span class="comment">     \endcode</span>
<a name="l00584"></a>00584 <span class="comment">     * If you are statically compiling, you can also just define your</span>
<a name="l00585"></a>00585 <span class="comment">     * own version of the above function, and it will clobber Halide&#39;s</span>
<a name="l00586"></a>00586 <span class="comment">     * version.</span>
<a name="l00587"></a>00587 <span class="comment">     *</span>
<a name="l00588"></a>00588 <span class="comment">     * If you&#39;re trying to use a custom parallel runtime, you probably</span>
<a name="l00589"></a>00589 <span class="comment">     * don&#39;t want to call this. See instead \ref Func::set_custom_do_par_for .</span>
<a name="l00590"></a>00590 <span class="comment">    */</span>
<a name="l00591"></a>00591     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#a18eb1fc8785fa98c27b44f0f3926c7fa" title="Set a custom task handler to be called by the parallel for loop.">set_custom_do_task</a>(
<a name="l00592"></a>00592         <span class="keywordtype">int</span> (*custom_do_task)(<span class="keywordtype">void</span> *, <span class="keywordtype">int</span> (*)(<span class="keywordtype">void</span> *, <span class="keywordtype">int</span>, <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *),
<a name="l00593"></a>00593                               <span class="keywordtype">int</span>, <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *));
<a name="l00594"></a>00594 <span class="comment"></span>
<a name="l00595"></a>00595 <span class="comment">    /** Set a custom parallel for loop launcher. Useful if your app</span>
<a name="l00596"></a>00596 <span class="comment">     * already manages a thread pool. The default implementation is</span>
<a name="l00597"></a>00597 <span class="comment">     * equivalent to this:</span>
<a name="l00598"></a>00598 <span class="comment">     \code</span>
<a name="l00599"></a>00599 <span class="comment">     extern &quot;C&quot; int halide_do_par_for(void *user_context,</span>
<a name="l00600"></a>00600 <span class="comment">                                      int (*f)(void *, int, uint8_t *),</span>
<a name="l00601"></a>00601 <span class="comment">                                      int min, int extent, uint8_t *state) {</span>
<a name="l00602"></a>00602 <span class="comment">         int exit_status = 0;</span>
<a name="l00603"></a>00603 <span class="comment">         parallel for (int idx = min; idx &lt; min+extent; idx++) {</span>
<a name="l00604"></a>00604 <span class="comment">             int job_status = halide_do_task(user_context, f, idx, state);</span>
<a name="l00605"></a>00605 <span class="comment">             if (job_status) exit_status = job_status;</span>
<a name="l00606"></a>00606 <span class="comment">         }</span>
<a name="l00607"></a>00607 <span class="comment">         return exit_status;</span>
<a name="l00608"></a>00608 <span class="comment">     }</span>
<a name="l00609"></a>00609 <span class="comment">     \endcode</span>
<a name="l00610"></a>00610 <span class="comment">     *</span>
<a name="l00611"></a>00611 <span class="comment">     * However, notwithstanding the above example code, if one task</span>
<a name="l00612"></a>00612 <span class="comment">     * fails, we may skip over other tasks, and if two tasks return</span>
<a name="l00613"></a>00613 <span class="comment">     * different error codes, we may select one arbitrarily to return.</span>
<a name="l00614"></a>00614 <span class="comment">     *</span>
<a name="l00615"></a>00615 <span class="comment">     * If you are statically compiling, you can also just define your</span>
<a name="l00616"></a>00616 <span class="comment">     * own version of the above function, and it will clobber Halide&#39;s</span>
<a name="l00617"></a>00617 <span class="comment">     * version.</span>
<a name="l00618"></a>00618 <span class="comment">     */</span>
<a name="l00619"></a>00619     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#afd38942fde8f87b6851d47bf99513ba1" title="Set a custom parallel for loop launcher.">set_custom_do_par_for</a>(
<a name="l00620"></a>00620         <span class="keywordtype">int</span> (*custom_do_par_for)(<span class="keywordtype">void</span> *, <span class="keywordtype">int</span> (*)(<span class="keywordtype">void</span> *, <span class="keywordtype">int</span>, <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *), <span class="keywordtype">int</span>,
<a name="l00621"></a>00621                                  <span class="keywordtype">int</span>, <a class="code" href="mini__stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> *));
<a name="l00622"></a>00622 <span class="comment"></span>
<a name="l00623"></a>00623 <span class="comment">    /** Set custom routines to call when tracing is enabled. Call this</span>
<a name="l00624"></a>00624 <span class="comment">     * on the output Func of your pipeline. This then sets custom</span>
<a name="l00625"></a>00625 <span class="comment">     * routines for the entire pipeline, not just calls to this</span>
<a name="l00626"></a>00626 <span class="comment">     * Func.</span>
<a name="l00627"></a>00627 <span class="comment">     *</span>
<a name="l00628"></a>00628 <span class="comment">     * If you are statically compiling, you can also just define your</span>
<a name="l00629"></a>00629 <span class="comment">     * own versions of the tracing functions (see HalideRuntime.h),</span>
<a name="l00630"></a>00630 <span class="comment">     * and they will clobber Halide&#39;s versions. */</span>
<a name="l00631"></a>00631     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#aad5f2b878005cd24c3b49c4856652971" title="Set custom routines to call when tracing is enabled.">set_custom_trace</a>(<a class="code" href="struct_halide_1_1_internal_1_1_j_i_t_compiled_module.html#ac96e1d288eaaa85933cda36bad19c5ef" title="Set a custom trace function.">Internal::JITCompiledModule::TraceFn</a>);
<a name="l00632"></a>00632 <span class="comment"></span>
<a name="l00633"></a>00633 <span class="comment">    /** When this function is compiled, include code that dumps its</span>
<a name="l00634"></a>00634 <span class="comment">     * values to a file after it is realized, for the purpose of</span>
<a name="l00635"></a>00635 <span class="comment">     * debugging.</span>
<a name="l00636"></a>00636 <span class="comment">     *</span>
<a name="l00637"></a>00637 <span class="comment">     * If filename ends in &quot;.tif&quot; or &quot;.tiff&quot; (case insensitive) the file</span>
<a name="l00638"></a>00638 <span class="comment">     * is in TIFF format and can be read by standard tools. Oherwise, the</span>
<a name="l00639"></a>00639 <span class="comment">     * file format is as follows:</span>
<a name="l00640"></a>00640 <span class="comment">     *</span>
<a name="l00641"></a>00641 <span class="comment">     * All data is in the byte-order of the target platform.  First, a</span>
<a name="l00642"></a>00642 <span class="comment">     * 20 byte-header containing four 32-bit ints, giving the extents</span>
<a name="l00643"></a>00643 <span class="comment">     * of the first four dimensions.  Dimensions beyond four are</span>
<a name="l00644"></a>00644 <span class="comment">     * folded into the fourth.  Then, a fifth 32-bit int giving the</span>
<a name="l00645"></a>00645 <span class="comment">     * data type of the function. The typecodes are given by: float =</span>
<a name="l00646"></a>00646 <span class="comment">     * 0, double = 1, uint8_t = 2, int8_t = 3, uint16_t = 4, int16_t =</span>
<a name="l00647"></a>00647 <span class="comment">     * 5, uint32_t = 6, int32_t = 7, uint64_t = 8, int64_t = 9. The</span>
<a name="l00648"></a>00648 <span class="comment">     * data follows the header, as a densely packed array of the given</span>
<a name="l00649"></a>00649 <span class="comment">     * size and the given type. If given the extension .tmp, this file</span>
<a name="l00650"></a>00650 <span class="comment">     * format can be natively read by the program ImageStack. */</span>
<a name="l00651"></a>00651     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#ad698122392e50574c38e3d19b0c9c41e" title="When this function is compiled, include code that dumps its values to a file after it is realized...">debug_to_file</a>(<span class="keyword">const</span> std::string &amp;filename);
<a name="l00652"></a>00652 <span class="comment"></span>
<a name="l00653"></a>00653 <span class="comment">    /** The name of this function, either given during construction,</span>
<a name="l00654"></a>00654 <span class="comment">     * or automatically generated. */</span>
<a name="l00655"></a>00655     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keyword">const</span> std::string &amp;<a class="code" href="class_halide_1_1_func.html#a1c36026717d2f74a842983d65e6b3bf8" title="The name of this function, either given during construction, or automatically generated.">name</a>() <span class="keyword">const</span>;
<a name="l00656"></a>00656 <span class="comment"></span>
<a name="l00657"></a>00657 <span class="comment">    /** Get the pure arguments. */</span>
<a name="l00658"></a>00658     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;Var&gt; <a class="code" href="class_halide_1_1_func.html#a830f40950d6695281dc4c5057767ca4f" title="Get the pure arguments.">args</a>() <span class="keyword">const</span>;
<a name="l00659"></a>00659 <span class="comment"></span>
<a name="l00660"></a>00660 <span class="comment">    /** The right-hand-side value of the pure definition of this</span>
<a name="l00661"></a>00661 <span class="comment">     * function. Causes an error if there&#39;s no pure definition, or if</span>
<a name="l00662"></a>00662 <span class="comment">     * the function is defined to return multiple values. */</span>
<a name="l00663"></a>00663     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> <a class="code" href="class_halide_1_1_func.html#a184f385b265e7ba488a2eed66a10b41a" title="The right-hand-side value of the pure definition of this function.">value</a>() <span class="keyword">const</span>;
<a name="l00664"></a>00664 <span class="comment"></span>
<a name="l00665"></a>00665 <span class="comment">    /** The values returned by this function. An error if the function</span>
<a name="l00666"></a>00666 <span class="comment">     * has not been been defined. Returns a Tuple with one element for</span>
<a name="l00667"></a>00667 <span class="comment">     * functions defined to return a single value. */</span>
<a name="l00668"></a>00668     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> <a class="code" href="class_halide_1_1_func.html#a2d2b62cf0249b0dcd24f41b246d82b3a" title="The values returned by this function.">values</a>() <span class="keyword">const</span>;
<a name="l00669"></a>00669 <span class="comment"></span>
<a name="l00670"></a>00670 <span class="comment">    /** Does this function have at least a pure definition. */</span>
<a name="l00671"></a>00671     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">bool</span> <a class="code" href="class_halide_1_1_func.html#a6744d1c69eeba054cc16c019a99e888d" title="Does this function have at least a pure definition.">defined</a>() <span class="keyword">const</span>;
<a name="l00672"></a>00672 <span class="comment"></span>
<a name="l00673"></a>00673 <span class="comment">    /** Get the left-hand-side of the reduction definition. An empty</span>
<a name="l00674"></a>00674 <span class="comment">     * vector if there&#39;s no reduction definition. If there are</span>
<a name="l00675"></a>00675 <span class="comment">     * multiple reduction definitions for this function, use the</span>
<a name="l00676"></a>00676 <span class="comment">     * argument to select which one you want. */</span>
<a name="l00677"></a>00677     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keyword">const</span> std::vector&lt;Expr&gt; &amp;<a class="code" href="class_halide_1_1_func.html#acc8d425e3fb3e53b47fb5a51f3e0f25d" title="Get the left-hand-side of the reduction definition.">reduction_args</a>(<span class="keywordtype">int</span> idx = 0) <span class="keyword">const</span>;
<a name="l00678"></a>00678 <span class="comment"></span>
<a name="l00679"></a>00679 <span class="comment">    /** Get the right-hand-side of a reduction definition. An error if</span>
<a name="l00680"></a>00680 <span class="comment">     * there&#39;s no reduction definition. If there are multiple</span>
<a name="l00681"></a>00681 <span class="comment">     * reduction definitions for this function, use the argument to</span>
<a name="l00682"></a>00682 <span class="comment">     * select which one you want. */</span>
<a name="l00683"></a>00683     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> <a class="code" href="class_halide_1_1_func.html#a485f5ee25ba872dcd7718d75a55a3b04" title="Get the right-hand-side of a reduction definition.">reduction_value</a>(<span class="keywordtype">int</span> idx = 0) <span class="keyword">const</span>;
<a name="l00684"></a>00684 <span class="comment"></span>
<a name="l00685"></a>00685 <span class="comment">    /** Get the right-hand-side of a reduction definition for</span>
<a name="l00686"></a>00686 <span class="comment">     * functions that returns multiple values. An error if there&#39;s no</span>
<a name="l00687"></a>00687 <span class="comment">     * reduction definition. Returns a Tuple with one element for</span>
<a name="l00688"></a>00688 <span class="comment">     * functions that return a single value. */</span>
<a name="l00689"></a>00689     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> <a class="code" href="class_halide_1_1_func.html#aaee216799a250d652047677e2e10994a" title="Get the right-hand-side of a reduction definition for functions that returns multiple values...">reduction_values</a>(<span class="keywordtype">int</span> idx = 0) <span class="keyword">const</span>;
<a name="l00690"></a>00690 <span class="comment"></span>
<a name="l00691"></a>00691 <span class="comment">    /** Get the reduction domain for a reduction definition. */</span>
<a name="l00692"></a>00692     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_r_dom.html" title="A multi-dimensional domain over which to iterate.">RDom</a> <a class="code" href="class_halide_1_1_func.html#aa7c366ab3a5c6a472e19f5860b309eda" title="Get the reduction domain for a reduction definition.">reduction_domain</a>(<span class="keywordtype">int</span> idx = 0) <span class="keyword">const</span>;
<a name="l00693"></a>00693 <span class="comment"></span>
<a name="l00694"></a>00694 <span class="comment">    /** Is this function a reduction (i.e. does it have at least one</span>
<a name="l00695"></a>00695 <span class="comment">     * reduction definition)? */</span>
<a name="l00696"></a>00696     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">bool</span> <a class="code" href="class_halide_1_1_func.html#a7037ff7ff29c32a2918f012a3bc897d8" title="Is this function a reduction (i.e.">is_reduction</a>() <span class="keyword">const</span>;
<a name="l00697"></a>00697 <span class="comment"></span>
<a name="l00698"></a>00698 <span class="comment">    /** How many reduction definitions does this function have? */</span>
<a name="l00699"></a>00699     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">int</span> <a class="code" href="class_halide_1_1_func.html#a45107807c692741d300bd98e8666473f" title="How many reduction definitions does this function have?">num_reduction_definitions</a>() <span class="keyword">const</span>;
<a name="l00700"></a>00700 <span class="comment"></span>
<a name="l00701"></a>00701 <span class="comment">    /** Is this function an external stage? That is, was it defined</span>
<a name="l00702"></a>00702 <span class="comment">     * using define_extern? */</span>
<a name="l00703"></a>00703     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">bool</span> <a class="code" href="class_halide_1_1_func.html#a10ea6486f854455c7c6275c5a34400f8" title="Is this function an external stage? That is, was it defined using define_extern?">is_extern</a>() <span class="keyword">const</span>;
<a name="l00704"></a>00704 <span class="comment"></span>
<a name="l00705"></a>00705 <span class="comment">    /** Add an extern definition for this Func. This lets you define a</span>
<a name="l00706"></a>00706 <span class="comment">     * Func that represents an external pipeline stage. You can, for</span>
<a name="l00707"></a>00707 <span class="comment">     * example, use it to wrap a call to an extern library such as</span>
<a name="l00708"></a>00708 <span class="comment">     * fftw. */</span>
<a name="l00709"></a>00709     <span class="comment">// @{</span>
<a name="l00710"></a><a class="code" href="class_halide_1_1_func.html#ab0c6a7f94cc7fdb8c42f2bcbc9013bfc">00710</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#ab0c6a7f94cc7fdb8c42f2bcbc9013bfc" title="Add an extern definition for this Func.">define_extern</a>(<span class="keyword">const</span> std::string &amp;function_name,
<a name="l00711"></a>00711                               <span class="keyword">const</span> std::vector&lt;ExternFuncArgument&gt; &amp;params,
<a name="l00712"></a>00712                               <a class="code" href="struct_halide_1_1_type.html" title="Types in the halide type system.">Type</a> t,
<a name="l00713"></a>00713                               <span class="keywordtype">int</span> dimensionality) {
<a name="l00714"></a>00714         <a class="code" href="class_halide_1_1_func.html#ab0c6a7f94cc7fdb8c42f2bcbc9013bfc" title="Add an extern definition for this Func.">define_extern</a>(function_name, params, Internal::vec&lt;Type&gt;(t), dimensionality);
<a name="l00715"></a>00715     }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">void</span> <a class="code" href="class_halide_1_1_func.html#ab0c6a7f94cc7fdb8c42f2bcbc9013bfc" title="Add an extern definition for this Func.">define_extern</a>(<span class="keyword">const</span> std::string &amp;function_name,
<a name="l00718"></a>00718                               <span class="keyword">const</span> std::vector&lt;ExternFuncArgument&gt; &amp;params,
<a name="l00719"></a>00719                               <span class="keyword">const</span> std::vector&lt;Type&gt; &amp;types,
<a name="l00720"></a>00720                               <span class="keywordtype">int</span> dimensionality);
<a name="l00721"></a>00721     <span class="comment">// @}</span>
<a name="l00722"></a>00722 <span class="comment"></span>
<a name="l00723"></a>00723 <span class="comment">    /** Get the types of the outputs of this Func. */</span>
<a name="l00724"></a>00724     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keyword">const</span> std::vector&lt;Type&gt; &amp;<a class="code" href="class_halide_1_1_func.html#a0622c8a11c948787eafbee82a0853030" title="Get the types of the outputs of this Func.">output_types</a>() <span class="keyword">const</span>;
<a name="l00725"></a>00725 <span class="comment"></span>
<a name="l00726"></a>00726 <span class="comment">    /** Get the number of outputs of this Func. Corresponds to the</span>
<a name="l00727"></a>00727 <span class="comment">     * size of the Tuple this Func was defined to return. */</span>
<a name="l00728"></a>00728     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">int</span> <a class="code" href="class_halide_1_1_func.html#a2ddfd0eef6173d668c0f76d6c52cefb7" title="Get the number of outputs of this Func.">outputs</a>() <span class="keyword">const</span>;
<a name="l00729"></a>00729 <span class="comment"></span>
<a name="l00730"></a>00730 <span class="comment">    /** Get the name of the extern function called for an extern</span>
<a name="l00731"></a>00731 <span class="comment">     * definition. */</span>
<a name="l00732"></a>00732     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keyword">const</span> std::string &amp;<a class="code" href="class_halide_1_1_func.html#aeb3bd4ac6913bc0137f91ea7b6412acd" title="Get the name of the extern function called for an extern definition.">extern_function_name</a>() <span class="keyword">const</span>;
<a name="l00733"></a>00733 <span class="comment"></span>
<a name="l00734"></a>00734 <span class="comment">    /** The dimensionality (number of arguments) of this</span>
<a name="l00735"></a>00735 <span class="comment">     * function. Zero if the function is not yet defined. */</span>
<a name="l00736"></a>00736     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <span class="keywordtype">int</span> <a class="code" href="class_halide_1_1_func.html#a8993a73f9eb2d0c7ccc58028447d42f3" title="The dimensionality (number of arguments) of this function.">dimensions</a>() <span class="keyword">const</span>;
<a name="l00737"></a>00737 <span class="comment"></span>
<a name="l00738"></a>00738 <span class="comment">    /** Construct either the left-hand-side of a definition, or a call</span>
<a name="l00739"></a>00739 <span class="comment">     * to a functions that happens to only contain vars as</span>
<a name="l00740"></a>00740 <span class="comment">     * arguments. If the function has already been defined, and fewer</span>
<a name="l00741"></a>00741 <span class="comment">     * arguments are given than the function has dimensions, then</span>
<a name="l00742"></a>00742 <span class="comment">     * enough implicit vars are added to the end of the argument list</span>
<a name="l00743"></a>00743 <span class="comment">     * to make up the difference (see \ref Var::implicit) */</span>
<a name="l00744"></a>00744     <span class="comment">// @{</span>
<a name="l00745"></a>00745     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>() <span class="keyword">const</span>;
<a name="l00746"></a>00746     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x) <span class="keyword">const</span>;
<a name="l00747"></a>00747     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y) <span class="keyword">const</span>;
<a name="l00748"></a>00748     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> z) <span class="keyword">const</span>;
<a name="l00749"></a>00749     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> z, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> w) <span class="keyword">const</span>;
<a name="l00750"></a>00750     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> z, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> w, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> u) <span class="keyword">const</span>;
<a name="l00751"></a>00751     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> z, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> w, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> u, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> v) <span class="keyword">const</span>;
<a name="l00752"></a>00752     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_var.html">FuncRefVar</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(std::vector&lt;Var&gt;) <span class="keyword">const</span>;
<a name="l00753"></a>00753     <span class="comment">// @}</span>
<a name="l00754"></a>00754 <span class="comment"></span>
<a name="l00755"></a>00755 <span class="comment">    /** Either calls to the function, or the left-hand-side of a</span>
<a name="l00756"></a>00756 <span class="comment">     * reduction definition (see \ref RDom). If the function has</span>
<a name="l00757"></a>00757 <span class="comment">     * already been defined, and fewer arguments are given than the</span>
<a name="l00758"></a>00758 <span class="comment">     * function has dimensions, then enough implicit vars are added to</span>
<a name="l00759"></a>00759 <span class="comment">     * the end of the argument list to make up the difference. (see</span>
<a name="l00760"></a>00760 <span class="comment">     * \ref Var::implicit)*/</span>
<a name="l00761"></a>00761     <span class="comment">// @{</span>
<a name="l00762"></a>00762     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_expr.html" title="A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Exprs.">FuncRefExpr</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> x) <span class="keyword">const</span>;
<a name="l00763"></a>00763     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_expr.html" title="A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Exprs.">FuncRefExpr</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> x, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> y) <span class="keyword">const</span>;
<a name="l00764"></a>00764     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_expr.html" title="A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Exprs.">FuncRefExpr</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> x, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> y, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> z) <span class="keyword">const</span>;
<a name="l00765"></a>00765     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_expr.html" title="A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Exprs.">FuncRefExpr</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> x, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> y, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> z, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> w) <span class="keyword">const</span>;
<a name="l00766"></a>00766     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_expr.html" title="A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Exprs.">FuncRefExpr</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> x, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> y, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> z, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> w, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> u) <span class="keyword">const</span>;
<a name="l00767"></a>00767     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_expr.html" title="A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Exprs.">FuncRefExpr</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> x, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> y, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> z, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> w, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> u, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> v) <span class="keyword">const</span>;
<a name="l00768"></a>00768     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_func_ref_expr.html" title="A fragment of front-end syntax of the form f(x, y, z), where x, y, z are Exprs.">FuncRefExpr</a> <a class="code" href="class_halide_1_1_func.html#afb028626864f2a3f39641d00af78910f" title="Construct either the left-hand-side of a definition, or a call to a functions that happens to only co...">operator()</a>(std::vector&lt;Expr&gt;) <span class="keyword">const</span>;
<a name="l00769"></a>00769     <span class="comment">// @}</span>
<a name="l00770"></a>00770 <span class="comment"></span>
<a name="l00771"></a>00771 <span class="comment">    /** Split a dimension into inner and outer subdimensions with the</span>
<a name="l00772"></a>00772 <span class="comment">     * given names, where the inner dimension iterates from 0 to</span>
<a name="l00773"></a>00773 <span class="comment">     * factor-1. The inner and outer subdimensions can then be dealt</span>
<a name="l00774"></a>00774 <span class="comment">     * with using the other scheduling calls. It&#39;s ok to reuse the old</span>
<a name="l00775"></a>00775 <span class="comment">     * variable name as either the inner or outer variable. */</span>
<a name="l00776"></a>00776     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#abefe6262e23d34d161c7cc0b85e07187" title="Split a dimension into inner and outer subdimensions with the given names, where the inner dimension ...">split</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> old, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> outer, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> inner, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> factor);
<a name="l00777"></a>00777 <span class="comment"></span>
<a name="l00778"></a>00778 <span class="comment">    /** Join two dimensions into a single fused dimenion. The fused</span>
<a name="l00779"></a>00779 <span class="comment">     * dimension covers the product of the extents of the inner and</span>
<a name="l00780"></a>00780 <span class="comment">     * outer dimensions given. */</span>
<a name="l00781"></a>00781     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a5ceb7639659b4e305b4ead3784ed1e6b" title="Join two dimensions into a single fused dimenion.">fuse</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> inner, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> outer, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> fused);
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 <span class="comment"></span>
<a name="l00784"></a>00784 <span class="comment">    /** Mark a dimension to be traversed in parallel */</span>
<a name="l00785"></a>00785     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a93ee31a00e40c4531af6f58187ee19b9" title="Mark a dimension to be traversed in parallel.">parallel</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var);
<a name="l00786"></a>00786 <span class="comment"></span>
<a name="l00787"></a>00787 <span class="comment">    /** Split a dimension by the given task_size, and the parallelize the</span>
<a name="l00788"></a>00788 <span class="comment">     * outer dimension. This creates parallel tasks that have size</span>
<a name="l00789"></a>00789 <span class="comment">     * task_size. After this call, var refers to the outer dimension of</span>
<a name="l00790"></a>00790 <span class="comment">     * the split. The inner dimension has a new anonymous name. If you</span>
<a name="l00791"></a>00791 <span class="comment">     * wish to mutate it, or schedule with respect to it, do the split</span>
<a name="l00792"></a>00792 <span class="comment">     * manually. */</span>
<a name="l00793"></a>00793     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a93ee31a00e40c4531af6f58187ee19b9" title="Mark a dimension to be traversed in parallel.">parallel</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> task_size);
<a name="l00794"></a>00794 <span class="comment"></span>
<a name="l00795"></a>00795 <span class="comment">    /** Mark a dimension to be computed all-at-once as a single</span>
<a name="l00796"></a>00796 <span class="comment">     * vector. The dimension should have constant extent -</span>
<a name="l00797"></a>00797 <span class="comment">     * e.g. because it is the inner dimension following a split by a</span>
<a name="l00798"></a>00798 <span class="comment">     * constant factor. For most uses of vectorize you want the two</span>
<a name="l00799"></a>00799 <span class="comment">     * argument form. The variable to be vectorized should be the</span>
<a name="l00800"></a>00800 <span class="comment">     * innermost one. */</span>
<a name="l00801"></a>00801     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a1cbde565654302d9c0ab9383a0e42708" title="Mark a dimension to be computed all-at-once as a single vector.">vectorize</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var);
<a name="l00802"></a>00802 <span class="comment"></span>
<a name="l00803"></a>00803 <span class="comment">    /** Mark a dimension to be completely unrolled. The dimension</span>
<a name="l00804"></a>00804 <span class="comment">     * should have constant extent - e.g. because it is the inner</span>
<a name="l00805"></a>00805 <span class="comment">     * dimension following a split by a constant factor. For most uses</span>
<a name="l00806"></a>00806 <span class="comment">     * of unroll you want the two-argument form. */</span>
<a name="l00807"></a>00807     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#ab0055492c3b10965e1656f26431a01d8" title="Mark a dimension to be completely unrolled.">unroll</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var);
<a name="l00808"></a>00808 <span class="comment"></span>
<a name="l00809"></a>00809 <span class="comment">    /** Split a dimension by the given factor, then vectorize the</span>
<a name="l00810"></a>00810 <span class="comment">     * inner dimension. This is how you vectorize a loop of unknown</span>
<a name="l00811"></a>00811 <span class="comment">     * size. The variable to be vectorized should be the innermost</span>
<a name="l00812"></a>00812 <span class="comment">     * one. After this call, var refers to the outer dimension of the</span>
<a name="l00813"></a>00813 <span class="comment">     * split. */</span>
<a name="l00814"></a>00814     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a1cbde565654302d9c0ab9383a0e42708" title="Mark a dimension to be computed all-at-once as a single vector.">vectorize</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var, <span class="keywordtype">int</span> factor);
<a name="l00815"></a>00815 <span class="comment"></span>
<a name="l00816"></a>00816 <span class="comment">    /** Split a dimension by the given factor, then unroll the inner</span>
<a name="l00817"></a>00817 <span class="comment">     * dimension. This is how you unroll a loop of unknown size by</span>
<a name="l00818"></a>00818 <span class="comment">     * some constant factor. After this call, var refers to the outer</span>
<a name="l00819"></a>00819 <span class="comment">     * dimension of the split. */</span>
<a name="l00820"></a>00820     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#ab0055492c3b10965e1656f26431a01d8" title="Mark a dimension to be completely unrolled.">unroll</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var, <span class="keywordtype">int</span> factor);
<a name="l00821"></a>00821 <span class="comment"></span>
<a name="l00822"></a>00822 <span class="comment">    /** Statically declare that the range over which a function should</span>
<a name="l00823"></a>00823 <span class="comment">     * be evaluated is given by the second and third arguments. This</span>
<a name="l00824"></a>00824 <span class="comment">     * can let Halide perform some optimizations. E.g. if you know</span>
<a name="l00825"></a>00825 <span class="comment">     * there are going to be 4 color channels, you can completely</span>
<a name="l00826"></a>00826 <span class="comment">     * vectorize the color channel dimension without the overhead of</span>
<a name="l00827"></a>00827 <span class="comment">     * splitting it up. If bounds inference decides that it requires</span>
<a name="l00828"></a>00828 <span class="comment">     * more of this function than the bounds you have stated, a</span>
<a name="l00829"></a>00829 <span class="comment">     * runtime error will occur when you try to run your pipeline. */</span>
<a name="l00830"></a>00830     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#afadd04bc51ed5999496eaa876a4ee790" title="Statically declare that the range over which a function should be evaluated is given by the second an...">bound</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> <a class="code" href="namespace_halide.html#a38b5db24ca379dda8241433c0014c940" title="Returns an expression representing the lesser of the two arguments, after doing any necessary type co...">min</a>, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> extent);
<a name="l00831"></a>00831 <span class="comment"></span>
<a name="l00832"></a>00832 <span class="comment">    /** Split two dimensions at once by the given factors, and then</span>
<a name="l00833"></a>00833 <span class="comment">     * reorder the resulting dimensions to be xi, yi, xo, yo from</span>
<a name="l00834"></a>00834 <span class="comment">     * innermost outwards. This gives a tiled traversal. */</span>
<a name="l00835"></a>00835     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a070bb51c52383bd6402d6002458a3788" title="Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi...">tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> xo, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> yo, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> xi, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> yi, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> xfactor, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> yfactor);
<a name="l00836"></a>00836 <span class="comment"></span>
<a name="l00837"></a>00837 <span class="comment">    /** A shorter form of tile, which reuses the old variable names as</span>
<a name="l00838"></a>00838 <span class="comment">     * the new outer dimensions */</span>
<a name="l00839"></a>00839     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a070bb51c52383bd6402d6002458a3788" title="Split two dimensions at once by the given factors, and then reorder the resulting dimensions to be xi...">tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> xi, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> yi, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> xfactor, <a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> yfactor);
<a name="l00840"></a>00840 <span class="comment"></span>
<a name="l00841"></a>00841 <span class="comment">    /** Reorder variables to have the given nesting order, from</span>
<a name="l00842"></a>00842 <span class="comment">     * innermost out */</span>
<a name="l00843"></a>00843     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754" title="Reorder variables to have the given nesting order, from innermost out.">reorder</a>(<span class="keyword">const</span> std::vector&lt;VarOrRVar&gt; &amp;vars);
<a name="l00844"></a>00844 <span class="comment"></span>
<a name="l00845"></a>00845 <span class="comment">    /** Reorder two dimensions so that x is traversed inside y. Does</span>
<a name="l00846"></a>00846 <span class="comment">     * not affect the nesting order of other dimensions. E.g, if you</span>
<a name="l00847"></a>00847 <span class="comment">     * say foo(x, y, z, w) = bar; foo.reorder(w, x); then foo will be</span>
<a name="l00848"></a>00848 <span class="comment">     * traversed in the order (w, y, z, x), from innermost</span>
<a name="l00849"></a>00849 <span class="comment">     * outwards. */</span>
<a name="l00850"></a>00850     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754" title="Reorder variables to have the given nesting order, from innermost out.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y);
<a name="l00851"></a>00851 <span class="comment"></span>
<a name="l00852"></a>00852 <span class="comment">    /** Reorder three dimensions to have the given nesting order, from</span>
<a name="l00853"></a>00853 <span class="comment">     * innermost out */</span>
<a name="l00854"></a>00854     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754" title="Reorder variables to have the given nesting order, from innermost out.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z);
<a name="l00855"></a>00855 <span class="comment"></span>
<a name="l00856"></a>00856 <span class="comment">    /** Reorder four dimensions to have the given nesting order, from</span>
<a name="l00857"></a>00857 <span class="comment">     * innermost out */</span>
<a name="l00858"></a>00858     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754" title="Reorder variables to have the given nesting order, from innermost out.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00859"></a>00859                          <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w);
<a name="l00860"></a>00860 <span class="comment"></span>
<a name="l00861"></a>00861 <span class="comment">    /** Reorder five dimensions to have the given nesting order, from</span>
<a name="l00862"></a>00862 <span class="comment">     * innermost out */</span>
<a name="l00863"></a>00863     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754" title="Reorder variables to have the given nesting order, from innermost out.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00864"></a>00864                          <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t);
<a name="l00865"></a>00865 <span class="comment"></span>
<a name="l00866"></a>00866 <span class="comment">    /** Reorder six dimensions to have the given nesting order, from</span>
<a name="l00867"></a>00867 <span class="comment">     * innermost out */</span>
<a name="l00868"></a>00868     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754" title="Reorder variables to have the given nesting order, from innermost out.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00869"></a>00869                          <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t1, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t2);
<a name="l00870"></a>00870 <span class="comment"></span>
<a name="l00871"></a>00871 <span class="comment">    /** Reorder seven dimensions to have the given nesting order, from</span>
<a name="l00872"></a>00872 <span class="comment">     * innermost out */</span>
<a name="l00873"></a>00873     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754" title="Reorder variables to have the given nesting order, from innermost out.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00874"></a>00874                          <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t1, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t2,
<a name="l00875"></a>00875                          <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t3);
<a name="l00876"></a>00876 <span class="comment"></span>
<a name="l00877"></a>00877 <span class="comment">    /** Reorder eight dimensions to have the given nesting order, from</span>
<a name="l00878"></a>00878 <span class="comment">     * innermost out */</span>
<a name="l00879"></a>00879     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754" title="Reorder variables to have the given nesting order, from innermost out.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00880"></a>00880                          <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t1, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t2,
<a name="l00881"></a>00881                          <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t3, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t4);
<a name="l00882"></a>00882 <span class="comment"></span>
<a name="l00883"></a>00883 <span class="comment">    /** Reorder nine dimensions to have the given nesting order, from</span>
<a name="l00884"></a>00884 <span class="comment">     * innermost out */</span>
<a name="l00885"></a>00885     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754" title="Reorder variables to have the given nesting order, from innermost out.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00886"></a>00886                          <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t1, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t2,
<a name="l00887"></a>00887                          <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t3, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t4, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t5);
<a name="l00888"></a>00888 <span class="comment"></span>
<a name="l00889"></a>00889 <span class="comment">    /** Reorder ten dimensions to have the given nesting order, from</span>
<a name="l00890"></a>00890 <span class="comment">     * innermost out */</span>
<a name="l00891"></a>00891     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a2ad991bc3ebd940906187a0552ef7754" title="Reorder variables to have the given nesting order, from innermost out.">reorder</a>(<a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> x, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> y, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> z,
<a name="l00892"></a>00892                          <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> w, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t1, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t2,
<a name="l00893"></a>00893                          <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t3, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t4, <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t5,
<a name="l00894"></a>00894                          <a class="code" href="struct_halide_1_1_var_or_r_var.html" title="A class that can represent Vars or RVars.">VarOrRVar</a> t6);
<a name="l00895"></a>00895 <span class="comment"></span>
<a name="l00896"></a>00896 <span class="comment">    /** Rename a dimension. Equivalent to split with a inner size of one. */</span>
<a name="l00897"></a>00897     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#ad7fc932b2a8be41af352c39f3128c74c" title="Rename a dimension.">rename</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> old_name, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> new_name);
<a name="l00898"></a>00898 <span class="comment"></span>
<a name="l00899"></a>00899 <span class="comment">    /** Tell Halide that the following dimensions correspond to GPU</span>
<a name="l00900"></a>00900 <span class="comment">     * thread indices. This is useful if you compute a producer</span>
<a name="l00901"></a>00901 <span class="comment">     * function within the block indices of a consumer function, and</span>
<a name="l00902"></a>00902 <span class="comment">     * want to control how that function&#39;s dimensions map to GPU</span>
<a name="l00903"></a>00903 <span class="comment">     * threads. If the selected target is not an appropriate GPU, this</span>
<a name="l00904"></a>00904 <span class="comment">     * just marks those dimensions as parallel. */</span>
<a name="l00905"></a>00905     <span class="comment">// @{</span>
<a name="l00906"></a>00906     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a18fe09b7992a12fc564e3ce98d65c672" title="Tell Halide that the following dimensions correspond to GPU thread indices.">gpu_threads</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpuapi = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00907"></a>00907     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a18fe09b7992a12fc564e3ce98d65c672" title="Tell Halide that the following dimensions correspond to GPU thread indices.">gpu_threads</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpuapi = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00908"></a>00908     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a18fe09b7992a12fc564e3ce98d65c672" title="Tell Halide that the following dimensions correspond to GPU thread indices.">gpu_threads</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_z, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpuapi = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00909"></a>00909     <span class="comment">// @}</span>
<a name="l00910"></a>00910 <span class="comment"></span>
<a name="l00911"></a>00911 <span class="comment">    /** \deprecated Old name for #gpu_threads. */</span>
<a name="l00912"></a>00912     <span class="comment">// @{</span>
<a name="l00913"></a><a class="code" href="class_halide_1_1_func.html#a025fbc02ba21775bc17665d2a29c017c">00913</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a025fbc02ba21775bc17665d2a29c017c">cuda_threads</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x) {
<a name="l00914"></a>00914         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_func.html#a18fe09b7992a12fc564e3ce98d65c672" title="Tell Halide that the following dimensions correspond to GPU thread indices.">gpu_threads</a>(thread_x);
<a name="l00915"></a>00915     }
<a name="l00916"></a><a class="code" href="class_halide_1_1_func.html#a8e1f253d87e6052e39a6e672d8ddb7e0">00916</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a8e1f253d87e6052e39a6e672d8ddb7e0">cuda_threads</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y) {
<a name="l00917"></a>00917         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_func.html#a18fe09b7992a12fc564e3ce98d65c672" title="Tell Halide that the following dimensions correspond to GPU thread indices.">gpu_threads</a>(thread_x, thread_y);
<a name="l00918"></a>00918     }
<a name="l00919"></a><a class="code" href="class_halide_1_1_func.html#aa48f5e79415eda6f01539dc0fc9ba05a">00919</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#aa48f5e79415eda6f01539dc0fc9ba05a">cuda_threads</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_z) {
<a name="l00920"></a>00920         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_func.html#a18fe09b7992a12fc564e3ce98d65c672" title="Tell Halide that the following dimensions correspond to GPU thread indices.">gpu_threads</a>(thread_x, thread_y, thread_z);
<a name="l00921"></a>00921     }
<a name="l00922"></a>00922     <span class="comment">// @}</span>
<a name="l00923"></a>00923 <span class="comment"></span>
<a name="l00924"></a>00924 <span class="comment">    /** Tell Halide that the following dimensions correspond to GPU</span>
<a name="l00925"></a>00925 <span class="comment">     * block indices. This is useful for scheduling stages that will</span>
<a name="l00926"></a>00926 <span class="comment">     * run serially within each GPU block. If the selected target is</span>
<a name="l00927"></a>00927 <span class="comment">     * not ptx, this just marks those dimensions as parallel. */</span>
<a name="l00928"></a>00928     <span class="comment">// @{</span>
<a name="l00929"></a>00929     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#ab222719c047a0971b1b146bcafeac3df" title="Tell Halide that the following dimensions correspond to GPU block indices.">gpu_blocks</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpuapi = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00930"></a>00930     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#ab222719c047a0971b1b146bcafeac3df" title="Tell Halide that the following dimensions correspond to GPU block indices.">gpu_blocks</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpuapi = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00931"></a>00931     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#ab222719c047a0971b1b146bcafeac3df" title="Tell Halide that the following dimensions correspond to GPU block indices.">gpu_blocks</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_z, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpuapi = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00932"></a>00932     <span class="comment">// @}</span>
<a name="l00933"></a>00933 <span class="comment"></span>
<a name="l00934"></a>00934 <span class="comment">    /** \deprecated Old name for #gpu_blocks. */</span>
<a name="l00935"></a>00935     <span class="comment">// @{</span>
<a name="l00936"></a><a class="code" href="class_halide_1_1_func.html#a94deb0bfb7286bf794cc0dcf00040a5d">00936</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a94deb0bfb7286bf794cc0dcf00040a5d">cuda_blocks</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x) {
<a name="l00937"></a>00937         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_func.html#ab222719c047a0971b1b146bcafeac3df" title="Tell Halide that the following dimensions correspond to GPU block indices.">gpu_blocks</a>(block_x);
<a name="l00938"></a>00938     }
<a name="l00939"></a><a class="code" href="class_halide_1_1_func.html#a1e05993bf55b53825d1c036804aa05db">00939</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a1e05993bf55b53825d1c036804aa05db">cuda_blocks</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y) {
<a name="l00940"></a>00940         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_func.html#ab222719c047a0971b1b146bcafeac3df" title="Tell Halide that the following dimensions correspond to GPU block indices.">gpu_blocks</a>(block_x, block_y);
<a name="l00941"></a>00941     }
<a name="l00942"></a><a class="code" href="class_halide_1_1_func.html#a50627066af66b070ce7f0515c733c4a5">00942</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a50627066af66b070ce7f0515c733c4a5">cuda_blocks</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_z) {
<a name="l00943"></a>00943         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_func.html#ab222719c047a0971b1b146bcafeac3df" title="Tell Halide that the following dimensions correspond to GPU block indices.">gpu_blocks</a>(block_x, block_y, block_z);
<a name="l00944"></a>00944     }
<a name="l00945"></a>00945     <span class="comment">// @}</span>
<a name="l00946"></a>00946 <span class="comment"></span>
<a name="l00947"></a>00947 <span class="comment">    /** Tell Halide that the following dimensions correspond to GPU</span>
<a name="l00948"></a>00948 <span class="comment">     * block indices and thread indices. If the selected target is not</span>
<a name="l00949"></a>00949 <span class="comment">     * ptx, these just mark the given dimensions as parallel. The</span>
<a name="l00950"></a>00950 <span class="comment">     * dimensions are consumed by this call, so do all other</span>
<a name="l00951"></a>00951 <span class="comment">     * unrolling, reordering, etc first. */</span>
<a name="l00952"></a>00952     <span class="comment">// @{</span>
<a name="l00953"></a>00953     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a394971b80e7e8e5b9bcdcf23ffd00f3b" title="Tell Halide that the following dimensions correspond to GPU block indices and thread indices...">gpu</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpuapi = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00954"></a>00954     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a394971b80e7e8e5b9bcdcf23ffd00f3b" title="Tell Halide that the following dimensions correspond to GPU block indices and thread indices...">gpu</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y,
<a name="l00955"></a>00955              <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpuapi = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00956"></a>00956     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a394971b80e7e8e5b9bcdcf23ffd00f3b" title="Tell Halide that the following dimensions correspond to GPU block indices and thread indices...">gpu</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_z,
<a name="l00957"></a>00957                      <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_z, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpuapi = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00958"></a>00958     <span class="comment">// @}</span>
<a name="l00959"></a>00959 <span class="comment"></span>
<a name="l00960"></a>00960 <span class="comment">    /** \deprecated Old name for #gpu. */</span>
<a name="l00961"></a>00961     <span class="comment">// @{</span>
<a name="l00962"></a><a class="code" href="class_halide_1_1_func.html#a9970910f3fa8dd312cadf0b848eec1fc">00962</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a9970910f3fa8dd312cadf0b848eec1fc">cuda</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x) {
<a name="l00963"></a>00963         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_func.html#a394971b80e7e8e5b9bcdcf23ffd00f3b" title="Tell Halide that the following dimensions correspond to GPU block indices and thread indices...">gpu</a>(block_x, thread_x);
<a name="l00964"></a>00964     }
<a name="l00965"></a><a class="code" href="class_halide_1_1_func.html#a251b2c0835d9ac9384729fe83d0b3ea4">00965</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a9970910f3fa8dd312cadf0b848eec1fc">cuda</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y,
<a name="l00966"></a>00966                       <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y) {
<a name="l00967"></a>00967         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_func.html#a394971b80e7e8e5b9bcdcf23ffd00f3b" title="Tell Halide that the following dimensions correspond to GPU block indices and thread indices...">gpu</a>(block_x, thread_x, block_y, thread_y);
<a name="l00968"></a>00968     }
<a name="l00969"></a><a class="code" href="class_halide_1_1_func.html#a62623f10f29023c1bd6b871ad9ede757">00969</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a9970910f3fa8dd312cadf0b848eec1fc">cuda</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> block_z,
<a name="l00970"></a>00970                       <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> thread_z) {
<a name="l00971"></a>00971         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_func.html#a394971b80e7e8e5b9bcdcf23ffd00f3b" title="Tell Halide that the following dimensions correspond to GPU block indices and thread indices...">gpu</a>(block_x, thread_x, block_y, thread_y, block_z, thread_z);
<a name="l00972"></a>00972     }
<a name="l00973"></a>00973     <span class="comment">// @}</span>
<a name="l00974"></a>00974 <span class="comment"></span>
<a name="l00975"></a>00975 <span class="comment">    /** Short-hand for tiling a domain and mapping the tile indices</span>
<a name="l00976"></a>00976 <span class="comment">     * to GPU block indices and the coordinates within each tile to</span>
<a name="l00977"></a>00977 <span class="comment">     * GPU thread indices. Consumes the variables given, so do all</span>
<a name="l00978"></a>00978 <span class="comment">     * other scheduling first. */</span>
<a name="l00979"></a>00979     <span class="comment">// @{</span>
<a name="l00980"></a>00980     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a9553df2b88fb02b13897960e356030c7" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <span class="keywordtype">int</span> x_size, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpuapi = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00981"></a>00981     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a9553df2b88fb02b13897960e356030c7" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <span class="keywordtype">int</span> x_size, <span class="keywordtype">int</span> y_size, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpuapi = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00982"></a>00982     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a9553df2b88fb02b13897960e356030c7" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> z,
<a name="l00983"></a>00983                           <span class="keywordtype">int</span> x_size, <span class="keywordtype">int</span> y_size, <span class="keywordtype">int</span> z_size, <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5c">GPUAPI</a> gpuapi = <a class="code" href="namespace_halide.html#aa5e16c1fed60e0a8f60277fa7587ef5ca607ce75df2e5133ac12da39b2bfd04cb">GPU_Default</a>);
<a name="l00984"></a>00984     <span class="comment">// @}</span>
<a name="l00985"></a>00985 <span class="comment"></span>
<a name="l00986"></a>00986 <span class="comment">    /** \deprecated Old name for #gpu_tile. */</span>
<a name="l00987"></a>00987     <span class="comment">// @{</span>
<a name="l00988"></a><a class="code" href="class_halide_1_1_func.html#af1e21fd647773e3fcbeedd137b520580">00988</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#af1e21fd647773e3fcbeedd137b520580">cuda_tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <span class="keywordtype">int</span> x_size) {
<a name="l00989"></a>00989         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_func.html#a9553df2b88fb02b13897960e356030c7" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>(x, x_size);
<a name="l00990"></a>00990     }
<a name="l00991"></a><a class="code" href="class_halide_1_1_func.html#a1a2e8367de42127278ce1d8c22bcbcaa">00991</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a1a2e8367de42127278ce1d8c22bcbcaa">cuda_tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <span class="keywordtype">int</span> x_size, <span class="keywordtype">int</span> y_size) {
<a name="l00992"></a>00992         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_func.html#a9553df2b88fb02b13897960e356030c7" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>(x, y, x_size, y_size);
<a name="l00993"></a>00993     }
<a name="l00994"></a><a class="code" href="class_halide_1_1_func.html#adbfaafe22b18f740f1f2248f3dc10b4a">00994</a>     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#af1e21fd647773e3fcbeedd137b520580">cuda_tile</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> z,
<a name="l00995"></a>00995                            <span class="keywordtype">int</span> x_size, <span class="keywordtype">int</span> y_size, <span class="keywordtype">int</span> z_size) {
<a name="l00996"></a>00996         <span class="keywordflow">return</span> <a class="code" href="class_halide_1_1_func.html#a9553df2b88fb02b13897960e356030c7" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>(x, y, z, x_size, y_size, z_size);
<a name="l00997"></a>00997     }
<a name="l00998"></a>00998     <span class="comment">// @}</span>
<a name="l00999"></a>00999 <span class="comment"></span>
<a name="l01000"></a>01000 <span class="comment">    /** Specify how the storage for the function is laid out. These</span>
<a name="l01001"></a>01001 <span class="comment">     * calls let you specify the nesting order of the dimensions. For</span>
<a name="l01002"></a>01002 <span class="comment">     * example, foo.reorder_storage(y, x) tells Halide to use</span>
<a name="l01003"></a>01003 <span class="comment">     * column-major storage for any realizations of foo, without</span>
<a name="l01004"></a>01004 <span class="comment">     * changing how you refer to foo in the code. You may want to do</span>
<a name="l01005"></a>01005 <span class="comment">     * this if you intend to vectorize across y. When representing</span>
<a name="l01006"></a>01006 <span class="comment">     * color images, foo.reorder_storage(c, x, y) specifies packed</span>
<a name="l01007"></a>01007 <span class="comment">     * storage (red, green, and blue values adjacent in memory), and</span>
<a name="l01008"></a>01008 <span class="comment">     * foo.reorder_storage(x, y, c) specifies planar storage (entire</span>
<a name="l01009"></a>01009 <span class="comment">     * red, green, and blue images one after the other in memory).</span>
<a name="l01010"></a>01010 <span class="comment">     *</span>
<a name="l01011"></a>01011 <span class="comment">     * If you leave out some dimensions, those remain in the same</span>
<a name="l01012"></a>01012 <span class="comment">     * positions in the nesting order while the specified variables</span>
<a name="l01013"></a>01013 <span class="comment">     * are reordered around them. */</span>
<a name="l01014"></a>01014     <span class="comment">// @{</span>
<a name="l01015"></a>01015     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a08d7274c38d341388f0c2c9c9b32f287" title="Specify how the storage for the function is laid out.">reorder_storage</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y);
<a name="l01016"></a>01016     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a08d7274c38d341388f0c2c9c9b32f287" title="Specify how the storage for the function is laid out.">reorder_storage</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> z);
<a name="l01017"></a>01017     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a08d7274c38d341388f0c2c9c9b32f287" title="Specify how the storage for the function is laid out.">reorder_storage</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> z, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> w);
<a name="l01018"></a>01018     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a08d7274c38d341388f0c2c9c9b32f287" title="Specify how the storage for the function is laid out.">reorder_storage</a>(<a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> y, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> z, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> w, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> t);
<a name="l01019"></a>01019     <span class="comment">// @}</span>
<a name="l01020"></a>01020 <span class="comment"></span>
<a name="l01021"></a>01021 <span class="comment">    /** Compute this function as needed for each unique value of the</span>
<a name="l01022"></a>01022 <span class="comment">     * given var for the given calling function f.</span>
<a name="l01023"></a>01023 <span class="comment">     *</span>
<a name="l01024"></a>01024 <span class="comment">     * For example, consider the simple pipeline:</span>
<a name="l01025"></a>01025 <span class="comment">     \code</span>
<a name="l01026"></a>01026 <span class="comment">     Func f, g;</span>
<a name="l01027"></a>01027 <span class="comment">     Var x, y;</span>
<a name="l01028"></a>01028 <span class="comment">     g(x, y) = x*y;</span>
<a name="l01029"></a>01029 <span class="comment">     f(x, y) = g(x, y) + g(x, y+1) + g(x+1, y) + g(x+1, y+1);</span>
<a name="l01030"></a>01030 <span class="comment">     \endcode</span>
<a name="l01031"></a>01031 <span class="comment">     *</span>
<a name="l01032"></a>01032 <span class="comment">     * If we schedule f like so:</span>
<a name="l01033"></a>01033 <span class="comment">     *</span>
<a name="l01034"></a>01034 <span class="comment">     \code</span>
<a name="l01035"></a>01035 <span class="comment">     g.compute_at(f, x);</span>
<a name="l01036"></a>01036 <span class="comment">     \endcode</span>
<a name="l01037"></a>01037 <span class="comment">     *</span>
<a name="l01038"></a>01038 <span class="comment">     * Then the C code equivalent to this pipeline will look like this</span>
<a name="l01039"></a>01039 <span class="comment">     *</span>
<a name="l01040"></a>01040 <span class="comment">     \code</span>
<a name="l01041"></a>01041 <span class="comment"></span>
<a name="l01042"></a>01042 <span class="comment">     int f[height][width];</span>
<a name="l01043"></a>01043 <span class="comment">     for (int y = 0; y &lt; height; y++) {</span>
<a name="l01044"></a>01044 <span class="comment">         for (int x = 0; x &lt; width; x++) {</span>
<a name="l01045"></a>01045 <span class="comment">             int g[2][2];</span>
<a name="l01046"></a>01046 <span class="comment">             g[0][0] = x*y;</span>
<a name="l01047"></a>01047 <span class="comment">             g[0][1] = (x+1)*y;</span>
<a name="l01048"></a>01048 <span class="comment">             g[1][0] = x*(y+1);</span>
<a name="l01049"></a>01049 <span class="comment">             g[1][1] = (x+1)*(y+1);</span>
<a name="l01050"></a>01050 <span class="comment">             f[y][x] = g[0][0] + g[1][0] + g[0][1] + g[1][1];</span>
<a name="l01051"></a>01051 <span class="comment">         }</span>
<a name="l01052"></a>01052 <span class="comment">     }</span>
<a name="l01053"></a>01053 <span class="comment"></span>
<a name="l01054"></a>01054 <span class="comment">     \endcode</span>
<a name="l01055"></a>01055 <span class="comment">     *</span>
<a name="l01056"></a>01056 <span class="comment">     * The allocation and computation of g is within f&#39;s loop over x,</span>
<a name="l01057"></a>01057 <span class="comment">     * and enough of g is computed to satisfy all that f will need for</span>
<a name="l01058"></a>01058 <span class="comment">     * that iteration. This has excellent locality - values of g are</span>
<a name="l01059"></a>01059 <span class="comment">     * used as soon as they are computed, but it does redundant</span>
<a name="l01060"></a>01060 <span class="comment">     * work. Each value of g ends up getting computed four times. If</span>
<a name="l01061"></a>01061 <span class="comment">     * we instead schedule f like so:</span>
<a name="l01062"></a>01062 <span class="comment">     *</span>
<a name="l01063"></a>01063 <span class="comment">     \code</span>
<a name="l01064"></a>01064 <span class="comment">     g.compute_at(f, y);</span>
<a name="l01065"></a>01065 <span class="comment">     \endcode</span>
<a name="l01066"></a>01066 <span class="comment">     *</span>
<a name="l01067"></a>01067 <span class="comment">     * The equivalent C code is:</span>
<a name="l01068"></a>01068 <span class="comment">     *</span>
<a name="l01069"></a>01069 <span class="comment">     \code</span>
<a name="l01070"></a>01070 <span class="comment">     int f[height][width];</span>
<a name="l01071"></a>01071 <span class="comment">     for (int y = 0; y &lt; height; y++) {</span>
<a name="l01072"></a>01072 <span class="comment">         int g[2][width+1];</span>
<a name="l01073"></a>01073 <span class="comment">         for (int x = 0; x &lt; width; x++) {</span>
<a name="l01074"></a>01074 <span class="comment">             g[0][x] = x*y;</span>
<a name="l01075"></a>01075 <span class="comment">             g[1][x] = x*(y+1);</span>
<a name="l01076"></a>01076 <span class="comment">         }</span>
<a name="l01077"></a>01077 <span class="comment">         for (int x = 0; x &lt; width; x++) {</span>
<a name="l01078"></a>01078 <span class="comment">             f[y][x] = g[0][x] + g[1][x] + g[0][x+1] + g[1][x+1];</span>
<a name="l01079"></a>01079 <span class="comment">         }</span>
<a name="l01080"></a>01080 <span class="comment">     }</span>
<a name="l01081"></a>01081 <span class="comment">     \endcode</span>
<a name="l01082"></a>01082 <span class="comment">     *</span>
<a name="l01083"></a>01083 <span class="comment">     * The allocation and computation of g is within f&#39;s loop over y,</span>
<a name="l01084"></a>01084 <span class="comment">     * and enough of g is computed to satisfy all that f will need for</span>
<a name="l01085"></a>01085 <span class="comment">     * that iteration. This does less redundant work (each point in g</span>
<a name="l01086"></a>01086 <span class="comment">     * ends up being evaluated twice), but the locality is not quite</span>
<a name="l01087"></a>01087 <span class="comment">     * as good, and we have to allocate more temporary memory to store</span>
<a name="l01088"></a>01088 <span class="comment">     * g.</span>
<a name="l01089"></a>01089 <span class="comment">     */</span>
<a name="l01090"></a>01090     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(Func f, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var);
<a name="l01091"></a>01091 <span class="comment"></span>
<a name="l01092"></a>01092 <span class="comment">    /** Schedule a function to be computed within the iteration over</span>
<a name="l01093"></a>01093 <span class="comment">     * some dimension of a reduction domain. Produces equivalent code</span>
<a name="l01094"></a>01094 <span class="comment">     * to the version of compute_at that takes a Var. */</span>
<a name="l01095"></a>01095     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a11de589971243d53709563789ef09273" title="Compute this function as needed for each unique value of the given var for the given calling function...">compute_at</a>(Func f, <a class="code" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> var);
<a name="l01096"></a>01096 <span class="comment"></span>
<a name="l01097"></a>01097 <span class="comment">    /** Compute all of this function once ahead of time. Reusing</span>
<a name="l01098"></a>01098 <span class="comment">     * the example in \ref Func::compute_at :</span>
<a name="l01099"></a>01099 <span class="comment">     *</span>
<a name="l01100"></a>01100 <span class="comment">     \code</span>
<a name="l01101"></a>01101 <span class="comment">     Func f, g;</span>
<a name="l01102"></a>01102 <span class="comment">     Var x, y;</span>
<a name="l01103"></a>01103 <span class="comment">     g(x, y) = x*y;</span>
<a name="l01104"></a>01104 <span class="comment">     f(x, y) = g(x, y) + g(x, y+1) + g(x+1, y) + g(x+1, y+1);</span>
<a name="l01105"></a>01105 <span class="comment"></span>
<a name="l01106"></a>01106 <span class="comment">     g.compute_root();</span>
<a name="l01107"></a>01107 <span class="comment">     \endcode</span>
<a name="l01108"></a>01108 <span class="comment">     *</span>
<a name="l01109"></a>01109 <span class="comment">     * is equivalent to</span>
<a name="l01110"></a>01110 <span class="comment">     *</span>
<a name="l01111"></a>01111 <span class="comment">     \code</span>
<a name="l01112"></a>01112 <span class="comment">     int f[height][width];</span>
<a name="l01113"></a>01113 <span class="comment">     int g[height+1][width+1];</span>
<a name="l01114"></a>01114 <span class="comment">     for (int y = 0; y &lt; height+1; y++) {</span>
<a name="l01115"></a>01115 <span class="comment">         for (int x = 0; x &lt; width+1; x++) {</span>
<a name="l01116"></a>01116 <span class="comment">             g[y][x] = x*y;</span>
<a name="l01117"></a>01117 <span class="comment">         }</span>
<a name="l01118"></a>01118 <span class="comment">     }</span>
<a name="l01119"></a>01119 <span class="comment">     for (int y = 0; y &lt; height; y++) {</span>
<a name="l01120"></a>01120 <span class="comment">         for (int x = 0; x &lt; width; x++) {</span>
<a name="l01121"></a>01121 <span class="comment">             f[y][x] = g[y][x] + g[y+1][x] + g[y][x+1] + g[y+1][x+1];</span>
<a name="l01122"></a>01122 <span class="comment">         }</span>
<a name="l01123"></a>01123 <span class="comment">     }</span>
<a name="l01124"></a>01124 <span class="comment">     \endcode</span>
<a name="l01125"></a>01125 <span class="comment">     *</span>
<a name="l01126"></a>01126 <span class="comment">     * g is computed once ahead of time, and enough is computed to</span>
<a name="l01127"></a>01127 <span class="comment">     * satisfy all uses of it. This does no redundant work (each point</span>
<a name="l01128"></a>01128 <span class="comment">     * in g is evaluated once), but has poor locality (values of g are</span>
<a name="l01129"></a>01129 <span class="comment">     * probably not still in cache when they are used by f), and</span>
<a name="l01130"></a>01130 <span class="comment">     * allocates lots of temporary memory to store g.</span>
<a name="l01131"></a>01131 <span class="comment">     */</span>
<a name="l01132"></a>01132     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a7f4db7e4884fe76399bf2a673567eab5" title="Compute all of this function once ahead of time.">compute_root</a>();
<a name="l01133"></a>01133 <span class="comment"></span>
<a name="l01134"></a>01134 <span class="comment">    /** Allocate storage for this function within f&#39;s loop over</span>
<a name="l01135"></a>01135 <span class="comment">     * var. Scheduling storage is optional, and can be used to</span>
<a name="l01136"></a>01136 <span class="comment">     * separate the loop level at which storage occurs from the loop</span>
<a name="l01137"></a>01137 <span class="comment">     * level at which computation occurs to trade off between locality</span>
<a name="l01138"></a>01138 <span class="comment">     * and redundant work. This can open the door for two types of</span>
<a name="l01139"></a>01139 <span class="comment">     * optimization.</span>
<a name="l01140"></a>01140 <span class="comment">     *</span>
<a name="l01141"></a>01141 <span class="comment">     * Consider again the pipeline from \ref Func::compute_at :</span>
<a name="l01142"></a>01142 <span class="comment">     \code</span>
<a name="l01143"></a>01143 <span class="comment">     Func f, g;</span>
<a name="l01144"></a>01144 <span class="comment">     Var x, y;</span>
<a name="l01145"></a>01145 <span class="comment">     g(x, y) = x*y;</span>
<a name="l01146"></a>01146 <span class="comment">     f(x, y) = g(x, y) + g(x+1, y) + g(x, y+1) + g(x+1, y+1);</span>
<a name="l01147"></a>01147 <span class="comment">     \endcode</span>
<a name="l01148"></a>01148 <span class="comment">     *</span>
<a name="l01149"></a>01149 <span class="comment">     * If we schedule it like so:</span>
<a name="l01150"></a>01150 <span class="comment">     *</span>
<a name="l01151"></a>01151 <span class="comment">     \code</span>
<a name="l01152"></a>01152 <span class="comment">     g.compute_at(f, x).store_at(f, y);</span>
<a name="l01153"></a>01153 <span class="comment">     \endcode</span>
<a name="l01154"></a>01154 <span class="comment">     *</span>
<a name="l01155"></a>01155 <span class="comment">     * Then the computation of g takes place within the loop over x,</span>
<a name="l01156"></a>01156 <span class="comment">     * but the storage takes place within the loop over y:</span>
<a name="l01157"></a>01157 <span class="comment">     *</span>
<a name="l01158"></a>01158 <span class="comment">     \code</span>
<a name="l01159"></a>01159 <span class="comment">     int f[height][width];</span>
<a name="l01160"></a>01160 <span class="comment">     for (int y = 0; y &lt; height; y++) {</span>
<a name="l01161"></a>01161 <span class="comment">         int g[2][width+1];</span>
<a name="l01162"></a>01162 <span class="comment">         for (int x = 0; x &lt; width; x++) {</span>
<a name="l01163"></a>01163 <span class="comment">             g[0][x] = x*y;</span>
<a name="l01164"></a>01164 <span class="comment">             g[0][x+1] = (x+1)*y;</span>
<a name="l01165"></a>01165 <span class="comment">             g[1][x] = x*(y+1);</span>
<a name="l01166"></a>01166 <span class="comment">             g[1][x+1] = (x+1)*(y+1);</span>
<a name="l01167"></a>01167 <span class="comment">             f[y][x] = g[0][x] + g[1][x] + g[0][x+1] + g[1][x+1];</span>
<a name="l01168"></a>01168 <span class="comment">         }</span>
<a name="l01169"></a>01169 <span class="comment">     }</span>
<a name="l01170"></a>01170 <span class="comment">     \endcode</span>
<a name="l01171"></a>01171 <span class="comment">     *</span>
<a name="l01172"></a>01172 <span class="comment">     * Provided the for loop over x is serial, halide then</span>
<a name="l01173"></a>01173 <span class="comment">     * automatically performs the following sliding window</span>
<a name="l01174"></a>01174 <span class="comment">     * optimization:</span>
<a name="l01175"></a>01175 <span class="comment">     *</span>
<a name="l01176"></a>01176 <span class="comment">     \code</span>
<a name="l01177"></a>01177 <span class="comment">     int f[height][width];</span>
<a name="l01178"></a>01178 <span class="comment">     for (int y = 0; y &lt; height; y++) {</span>
<a name="l01179"></a>01179 <span class="comment">         int g[2][width+1];</span>
<a name="l01180"></a>01180 <span class="comment">         for (int x = 0; x &lt; width; x++) {</span>
<a name="l01181"></a>01181 <span class="comment">             if (x == 0) {</span>
<a name="l01182"></a>01182 <span class="comment">                 g[0][x] = x*y;</span>
<a name="l01183"></a>01183 <span class="comment">                 g[1][x] = x*(y+1);</span>
<a name="l01184"></a>01184 <span class="comment">             }</span>
<a name="l01185"></a>01185 <span class="comment">             g[0][x+1] = (x+1)*y;</span>
<a name="l01186"></a>01186 <span class="comment">             g[1][x+1] = (x+1)*(y+1);</span>
<a name="l01187"></a>01187 <span class="comment">             f[y][x] = g[0][x] + g[1][x] + g[0][x+1] + g[1][x+1];</span>
<a name="l01188"></a>01188 <span class="comment">         }</span>
<a name="l01189"></a>01189 <span class="comment">     }</span>
<a name="l01190"></a>01190 <span class="comment">     \endcode</span>
<a name="l01191"></a>01191 <span class="comment">     *</span>
<a name="l01192"></a>01192 <span class="comment">     * Two of the assignments to g only need to be done when x is</span>
<a name="l01193"></a>01193 <span class="comment">     * zero. The rest of the time, those sites have already been</span>
<a name="l01194"></a>01194 <span class="comment">     * filled in by a previous iteration. This version has the</span>
<a name="l01195"></a>01195 <span class="comment">     * locality of compute_at(f, x), but allocates more memory and</span>
<a name="l01196"></a>01196 <span class="comment">     * does much less redundant work.</span>
<a name="l01197"></a>01197 <span class="comment">     *</span>
<a name="l01198"></a>01198 <span class="comment">     * Halide then further optimizes this pipeline like so:</span>
<a name="l01199"></a>01199 <span class="comment">     *</span>
<a name="l01200"></a>01200 <span class="comment">     \code</span>
<a name="l01201"></a>01201 <span class="comment">     int f[height][width];</span>
<a name="l01202"></a>01202 <span class="comment">     for (int y = 0; y &lt; height; y++) {</span>
<a name="l01203"></a>01203 <span class="comment">         int g[2][2];</span>
<a name="l01204"></a>01204 <span class="comment">         for (int x = 0; x &lt; width; x++) {</span>
<a name="l01205"></a>01205 <span class="comment">             if (x == 0) {</span>
<a name="l01206"></a>01206 <span class="comment">                 g[0][0] = x*y;</span>
<a name="l01207"></a>01207 <span class="comment">                 g[1][0] = x*(y+1);</span>
<a name="l01208"></a>01208 <span class="comment">             }</span>
<a name="l01209"></a>01209 <span class="comment">             g[0][(x+1)%2] = (x+1)*y;</span>
<a name="l01210"></a>01210 <span class="comment">             g[1][(x+1)%2] = (x+1)*(y+1);</span>
<a name="l01211"></a>01211 <span class="comment">             f[y][x] = g[0][x%2] + g[1][x%2] + g[0][(x+1)%2] + g[1][(x+1)%2];</span>
<a name="l01212"></a>01212 <span class="comment">         }</span>
<a name="l01213"></a>01213 <span class="comment">     }</span>
<a name="l01214"></a>01214 <span class="comment">     \endcode</span>
<a name="l01215"></a>01215 <span class="comment">     *</span>
<a name="l01216"></a>01216 <span class="comment">     * Halide has detected that it&#39;s possible to use a circular buffer</span>
<a name="l01217"></a>01217 <span class="comment">     * to represent g, and has reduced all accesses to g modulo 2 in</span>
<a name="l01218"></a>01218 <span class="comment">     * the x dimension. This optimization only triggers if the for</span>
<a name="l01219"></a>01219 <span class="comment">     * loop over x is serial, and if halide can statically determine</span>
<a name="l01220"></a>01220 <span class="comment">     * some power of two large enough to cover the range needed. For</span>
<a name="l01221"></a>01221 <span class="comment">     * powers of two, the modulo operator compiles to more efficient</span>
<a name="l01222"></a>01222 <span class="comment">     * bit-masking. This optimization reduces memory usage, and also</span>
<a name="l01223"></a>01223 <span class="comment">     * improves locality by reusing recently-accessed memory instead</span>
<a name="l01224"></a>01224 <span class="comment">     * of pulling new memory into cache.</span>
<a name="l01225"></a>01225 <span class="comment">     *</span>
<a name="l01226"></a>01226 <span class="comment">     */</span>
<a name="l01227"></a>01227     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7" title="Allocate storage for this function within f&#39;s loop over var.">store_at</a>(Func f, <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> var);
<a name="l01228"></a>01228 <span class="comment"></span>
<a name="l01229"></a>01229 <span class="comment">    /** Equivalent to the version of store_at that takes a Var, but</span>
<a name="l01230"></a>01230 <span class="comment">     * schedules storage within the loop over a dimension of a</span>
<a name="l01231"></a>01231 <span class="comment">     * reduction domain */</span>
<a name="l01232"></a>01232     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a33cb0d00bc9585bf3027011ecb1412b7" title="Allocate storage for this function within f&#39;s loop over var.">store_at</a>(Func f, <a class="code" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a> var);
<a name="l01233"></a>01233 <span class="comment"></span>
<a name="l01234"></a>01234 <span class="comment">    /** Equivalent to \ref Func::store_at, but schedules storage</span>
<a name="l01235"></a>01235 <span class="comment">     * outside the outermost loop. */</span>
<a name="l01236"></a>01236     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a7048eaf680bc0c78961c0bef48d37f85" title="Equivalent to Func::store_at, but schedules storage outside the outermost loop.">store_root</a>();
<a name="l01237"></a>01237 <span class="comment"></span>
<a name="l01238"></a>01238 <span class="comment">    /** Aggressively inline all uses of this function. This is the</span>
<a name="l01239"></a>01239 <span class="comment">     * default schedule, so you&#39;re unlikely to need to call this. For</span>
<a name="l01240"></a>01240 <span class="comment">     * a reduction, that means it gets computed as close to the</span>
<a name="l01241"></a>01241 <span class="comment">     * innermost loop as possible.</span>
<a name="l01242"></a>01242 <span class="comment">     *</span>
<a name="l01243"></a>01243 <span class="comment">     * Consider once more the pipeline from \ref Func::compute_at :</span>
<a name="l01244"></a>01244 <span class="comment">     *</span>
<a name="l01245"></a>01245 <span class="comment">     \code</span>
<a name="l01246"></a>01246 <span class="comment">     Func f, g;</span>
<a name="l01247"></a>01247 <span class="comment">     Var x, y;</span>
<a name="l01248"></a>01248 <span class="comment">     g(x, y) = x*y;</span>
<a name="l01249"></a>01249 <span class="comment">     f(x, y) = g(x, y) + g(x+1, y) + g(x, y+1) + g(x+1, y+1);</span>
<a name="l01250"></a>01250 <span class="comment">     \endcode</span>
<a name="l01251"></a>01251 <span class="comment">     *</span>
<a name="l01252"></a>01252 <span class="comment">     * Leaving g as inline, this compiles to code equivalent to the following C:</span>
<a name="l01253"></a>01253 <span class="comment">     *</span>
<a name="l01254"></a>01254 <span class="comment">     \code</span>
<a name="l01255"></a>01255 <span class="comment">     int f[height][width];</span>
<a name="l01256"></a>01256 <span class="comment">     for (int y = 0; y &lt; height; y++) {</span>
<a name="l01257"></a>01257 <span class="comment">         for (int x = 0; x &lt; width; x++) {</span>
<a name="l01258"></a>01258 <span class="comment">             f[y][x] = x*y + x*(y+1) + (x+1)*y + (x+1)*(y+1);</span>
<a name="l01259"></a>01259 <span class="comment">         }</span>
<a name="l01260"></a>01260 <span class="comment">     }</span>
<a name="l01261"></a>01261 <span class="comment">     \endcode</span>
<a name="l01262"></a>01262 <span class="comment">     */</span>
<a name="l01263"></a>01263     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a6b824c681a83aba8e318652bade047dc" title="Aggressively inline all uses of this function.">compute_inline</a>();
<a name="l01264"></a>01264 <span class="comment"></span>
<a name="l01265"></a>01265 <span class="comment">    /** Get a handle on an update step of a reduction for the</span>
<a name="l01266"></a>01266 <span class="comment">     * purposes of scheduling it. Only the pure dimensions of the</span>
<a name="l01267"></a>01267 <span class="comment">     * update step can be meaningfully manipulated (see \ref RDom) */</span>
<a name="l01268"></a>01268     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_schedule_handle.html" title="A wrapper around a schedule used for common schedule manipulations.">ScheduleHandle</a> <a class="code" href="class_halide_1_1_func.html#a5fd179a3631bfc16fc2e0cb3bb29ae0b" title="Get a handle on an update step of a reduction for the purposes of scheduling it.">update</a>(<span class="keywordtype">int</span> idx = 0);
<a name="l01269"></a>01269 <span class="comment"></span>
<a name="l01270"></a>01270 <span class="comment">    /** Trace all loads from this Func by emitting calls to</span>
<a name="l01271"></a>01271 <span class="comment">     * halide_trace. If the Func is inlined, this has no</span>
<a name="l01272"></a>01272 <span class="comment">     * effect. */</span>
<a name="l01273"></a>01273     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#a375c44be83cecdc181115a0018a7f31b" title="Trace all loads from this Func by emitting calls to halide_trace.">trace_loads</a>();
<a name="l01274"></a>01274 <span class="comment"></span>
<a name="l01275"></a>01275 <span class="comment">    /** Trace all stores to the buffer backing this Func by emitting</span>
<a name="l01276"></a>01276 <span class="comment">     * calls to halide_trace. If the Func is inlined, this call</span>
<a name="l01277"></a>01277 <span class="comment">     * has no effect. */</span>
<a name="l01278"></a>01278     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#ad88d11ad4164bce72320f2c064fc87d2" title="Trace all stores to the buffer backing this Func by emitting calls to halide_trace.">trace_stores</a>();
<a name="l01279"></a>01279 <span class="comment"></span>
<a name="l01280"></a>01280 <span class="comment">    /** Trace all realizations of this Func by emitting calls to</span>
<a name="l01281"></a>01281 <span class="comment">     * halide_trace. */</span>
<a name="l01282"></a>01282     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> Func &amp;<a class="code" href="class_halide_1_1_func.html#aa3981c97ffef96ab12c229371d766fef" title="Trace all realizations of this Func by emitting calls to halide_trace.">trace_realizations</a>();
<a name="l01283"></a>01283 <span class="comment"></span>
<a name="l01284"></a>01284 <span class="comment">    /** Get a handle on the internal halide function that this Func</span>
<a name="l01285"></a>01285 <span class="comment">     * represents. Useful if you want to do introspection on Halide</span>
<a name="l01286"></a>01286 <span class="comment">     * functions */</span>
<a name="l01287"></a><a class="code" href="class_halide_1_1_func.html#af53d44302c15c4335e55a2887e2f780e">01287</a>     <a class="code" href="class_halide_1_1_internal_1_1_function.html" title="A reference-counted handle to Halide&#39;s internal representation of a function.">Internal::Function</a> <span class="keyword">function</span>() <span class="keyword">const</span> {
<a name="l01288"></a>01288         <span class="keywordflow">return</span> func;
<a name="l01289"></a>01289     }
<a name="l01290"></a>01290 <span class="comment"></span>
<a name="l01291"></a>01291 <span class="comment">    /** Get a handle on the output buffer for this Func. Only relevant</span>
<a name="l01292"></a>01292 <span class="comment">     * if this is the output Func in a pipeline. Useful for making</span>
<a name="l01293"></a>01293 <span class="comment">     * static promises about strides, mins, and extents. */</span>
<a name="l01294"></a>01294     <span class="comment">// @{</span>
<a name="l01295"></a>01295     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> <a class="code" href="class_halide_1_1_output_image_param.html" title="A handle on the output buffer of a pipeline.">OutputImageParam</a> <a class="code" href="class_halide_1_1_func.html#a7ed1d8e36969e549cb42e2deb062ef37" title="Get a handle on the output buffer for this Func.">output_buffer</a>() <span class="keyword">const</span>;
<a name="l01296"></a>01296     <a class="code" href="_util_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> std::vector&lt;OutputImageParam&gt; <a class="code" href="class_halide_1_1_func.html#a196fa4dd98145740fe20e0a834b7d296" title="Get a handle on the output buffer for this Func.">output_buffers</a>() <span class="keyword">const</span>;
<a name="l01297"></a>01297     <span class="comment">// @}</span>
<a name="l01298"></a>01298 <span class="comment"></span>
<a name="l01299"></a>01299 <span class="comment">    /** Casting a function to an expression is equivalent to calling</span>
<a name="l01300"></a>01300 <span class="comment">     * the function with zero arguments. Implicit variables will be</span>
<a name="l01301"></a>01301 <span class="comment">     * injected according to the function&#39;s dimensionality</span>
<a name="l01302"></a>01302 <span class="comment">     * (see \ref Var::implicit).</span>
<a name="l01303"></a>01303 <span class="comment">     *</span>
<a name="l01304"></a>01304 <span class="comment">     * This lets you write things like:</span>
<a name="l01305"></a>01305 <span class="comment">     *</span>
<a name="l01306"></a>01306 <span class="comment">     \code</span>
<a name="l01307"></a>01307 <span class="comment">     Func f, g;</span>
<a name="l01308"></a>01308 <span class="comment">     Var x;</span>
<a name="l01309"></a>01309 <span class="comment">     g(x) = ...</span>
<a name="l01310"></a>01310 <span class="comment">     f(_) = g * 2;</span>
<a name="l01311"></a>01311 <span class="comment">     \endcode</span>
<a name="l01312"></a>01312 <span class="comment">    */</span>
<a name="l01313"></a><a class="code" href="class_halide_1_1_func.html#af30b03fbc4252d7e3c4baa63feedf8bd">01313</a>     <a class="code" href="class_halide_1_1_func.html#af30b03fbc4252d7e3c4baa63feedf8bd" title="Casting a function to an expression is equivalent to calling the function with zero arguments...">operator Expr</a>()<span class="keyword"> const </span>{
<a name="l01314"></a>01314         <span class="keywordflow">return</span> (*<span class="keyword">this</span>)(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>);
<a name="l01315"></a>01315     }
<a name="l01316"></a>01316 <span class="comment"></span>
<a name="l01317"></a>01317 <span class="comment">    /** Use a Func as an argument to an external stage. */</span>
<a name="l01318"></a><a class="code" href="class_halide_1_1_func.html#ab1d5c8ddfd40f829429c143ff05f9c9d">01318</a>     <a class="code" href="class_halide_1_1_func.html#ab1d5c8ddfd40f829429c143ff05f9c9d" title="Use a Func as an argument to an external stage.">operator ExternFuncArgument</a>()<span class="keyword"> const </span>{
<a name="l01319"></a>01319         <span class="keywordflow">return</span> <a class="code" href="struct_halide_1_1_extern_func_argument.html" title="An argument to an extern-defined Func.">ExternFuncArgument</a>(func);
<a name="l01320"></a>01320     }
<a name="l01321"></a>01321 
<a name="l01322"></a>01322 };
<a name="l01323"></a>01323 <span class="comment"></span>
<a name="l01324"></a>01324 <span class="comment"> /** JIT-Compile and run enough code to evaluate a Halide</span>
<a name="l01325"></a>01325 <span class="comment">  * expression. This can be thought of as a scalar version of</span>
<a name="l01326"></a>01326 <span class="comment">  * \ref Func::realize */</span>
<a name="l01327"></a>01327 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l01328"></a><a class="code" href="namespace_halide.html#a7542ab1823256bb847a2f18f22cf13b5">01328</a>   T <a class="code" href="namespace_halide.html#a7542ab1823256bb847a2f18f22cf13b5" title="JIT-Compile and run enough code to evaluate a Halide expression.">evaluate</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> e) {
<a name="l01329"></a>01329   assert(e.<a class="code" href="struct_halide_1_1_expr.html#a095f7fe04aa7c2a2acbc2dc4597a505c" title="Get the type of this expression node.">type</a>() == type_of&lt;T&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01330"></a>01330   <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f;
<a name="l01331"></a>01331   f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = e;
<a name="l01332"></a>01332   <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;T&gt;</a> im = f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>();
<a name="l01333"></a>01333   <span class="keywordflow">return</span> im(0);
<a name="l01334"></a>01334  }
<a name="l01335"></a>01335 <span class="comment"></span>
<a name="l01336"></a>01336 <span class="comment">/** JIT-compile and run enough code to evaluate a Halide Tuple. */</span>
<a name="l01337"></a>01337 <span class="comment">// @{</span>
<a name="l01338"></a>01338  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;
<a name="l01339"></a><a class="code" href="namespace_halide.html#a09eb5b4576b664ad8d3215df2c4194af">01339</a>    <span class="keywordtype">void</span> <a class="code" href="namespace_halide.html#a7542ab1823256bb847a2f18f22cf13b5" title="JIT-Compile and run enough code to evaluate a Halide expression.">evaluate</a>(<a class="code" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> t, A *a, B *b) {
<a name="l01340"></a>01340    assert(t[0].type() == type_of&lt;A&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01341"></a>01341    assert(t[1].type() == type_of&lt;B&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01342"></a>01342    <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f;
<a name="l01343"></a>01343    f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = t;
<a name="l01344"></a>01344    <a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> r = f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>();
<a name="l01345"></a>01345    *a = <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;A&gt;</a>(r[0])(0);
<a name="l01346"></a>01346    *b = <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;B&gt;</a>(r[1])(0);
<a name="l01347"></a>01347  }
<a name="l01348"></a>01348 
<a name="l01349"></a>01349  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C&gt;
<a name="l01350"></a><a class="code" href="namespace_halide.html#a86ad877a98b3fa7c2a87b52f9a83584c">01350</a>    <span class="keywordtype">void</span> <a class="code" href="namespace_halide.html#a7542ab1823256bb847a2f18f22cf13b5" title="JIT-Compile and run enough code to evaluate a Halide expression.">evaluate</a>(<a class="code" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> t, A *a, B *b, C *c) {
<a name="l01351"></a>01351    assert(t[0].type() == type_of&lt;A&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01352"></a>01352    assert(t[1].type() == type_of&lt;B&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01353"></a>01353    assert(t[2].type() == type_of&lt;C&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01354"></a>01354    <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f;
<a name="l01355"></a>01355    f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = t;
<a name="l01356"></a>01356    <a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> r = f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>();
<a name="l01357"></a>01357    *a = <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;A&gt;</a>(r[0])(0);
<a name="l01358"></a>01358    *b = <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;B&gt;</a>(r[1])(0);
<a name="l01359"></a>01359    *c = <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;C&gt;</a>(r[2])(0);
<a name="l01360"></a>01360  }
<a name="l01361"></a>01361 
<a name="l01362"></a>01362  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C, <span class="keyword">typename</span> D&gt;
<a name="l01363"></a><a class="code" href="namespace_halide.html#a9a2a699232b54d7bb8c478a54ffb7464">01363</a>    <span class="keywordtype">void</span> <a class="code" href="namespace_halide.html#a7542ab1823256bb847a2f18f22cf13b5" title="JIT-Compile and run enough code to evaluate a Halide expression.">evaluate</a>(<a class="code" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> t, A *a, B *b, C *c, D *d) {
<a name="l01364"></a>01364    assert(t[0].type() == type_of&lt;A&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01365"></a>01365    assert(t[1].type() == type_of&lt;B&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01366"></a>01366    assert(t[2].type() == type_of&lt;C&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01367"></a>01367    assert(t[3].type() == type_of&lt;D&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01368"></a>01368    <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f;
<a name="l01369"></a>01369    f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = t;
<a name="l01370"></a>01370    <a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> r = f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>();
<a name="l01371"></a>01371    *a = <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;A&gt;</a>(r[0])(0);
<a name="l01372"></a>01372    *b = <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;B&gt;</a>(r[1])(0);
<a name="l01373"></a>01373    *c = <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;C&gt;</a>(r[2])(0);
<a name="l01374"></a>01374    *d = <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;D&gt;</a>(r[3])(0);
<a name="l01375"></a>01375  }
<a name="l01376"></a>01376  <span class="comment">// @}</span>
<a name="l01377"></a>01377 
<a name="l01378"></a>01378 <span class="comment"></span>
<a name="l01379"></a>01379 <span class="comment">/** JIT-Compile and run enough code to evaluate a Halide</span>
<a name="l01380"></a>01380 <span class="comment"> * expression. This can be thought of as a scalar version of</span>
<a name="l01381"></a>01381 <span class="comment"> * \ref Func::realize. Can use GPU if jit target from environment</span>
<a name="l01382"></a>01382 <span class="comment"> * specifies one.</span>
<a name="l01383"></a>01383 <span class="comment"> */</span>
<a name="l01384"></a>01384 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l01385"></a><a class="code" href="namespace_halide.html#a381e168f467a972b4ac550f7f2ca0f81">01385</a> T <a class="code" href="namespace_halide.html#a381e168f467a972b4ac550f7f2ca0f81" title="JIT-Compile and run enough code to evaluate a Halide expression.">evaluate_may_gpu</a>(<a class="code" href="struct_halide_1_1_expr.html" title="A fragment of Halide syntax.">Expr</a> e) {
<a name="l01386"></a>01386     assert(e.<a class="code" href="struct_halide_1_1_expr.html#a095f7fe04aa7c2a2acbc2dc4597a505c" title="Get the type of this expression node.">type</a>() == type_of&lt;T&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01387"></a>01387     <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;T&gt;</a> im;
<a name="l01388"></a>01388     <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f;
<a name="l01389"></a>01389     f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = e;
<a name="l01390"></a>01390 
<a name="l01391"></a>01391     <span class="keywordflow">if</span> (<a class="code" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">get_jit_target_from_environment</a>().has_gpu_feature()) {
<a name="l01392"></a>01392         <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> g;
<a name="l01393"></a>01393     <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x;
<a name="l01394"></a>01394     g(x, <a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>);
<a name="l01395"></a>01395     g.<a class="code" href="class_halide_1_1_func.html#a9553df2b88fb02b13897960e356030c7" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>(x, 1);
<a name="l01396"></a>01396     im = g.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(1);
<a name="l01397"></a>01397     im.<a class="code" href="class_halide_1_1_image.html#af30a48c8b29e6d7c1bddad107fafccdc" title="Manually copy-back data to the host, if it&#39;s on a device.">copy_to_host</a>();
<a name="l01398"></a>01398     } <span class="keywordflow">else</span> {
<a name="l01399"></a>01399     im = f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>();
<a name="l01400"></a>01400     }
<a name="l01401"></a>01401     <span class="keywordflow">return</span> im(0);
<a name="l01402"></a>01402 }
<a name="l01403"></a>01403 <span class="comment"></span>
<a name="l01404"></a>01404 <span class="comment">/** JIT-compile and run enough code to evaluate a Halide Tuple. Can</span>
<a name="l01405"></a>01405 <span class="comment"> *  use GPU if jit target from environment specifies one. */</span>
<a name="l01406"></a>01406 <span class="comment">// @{</span>
<a name="l01407"></a>01407 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;
<a name="l01408"></a><a class="code" href="namespace_halide.html#a8294e0ca1c5820531d000742b5121f09">01408</a> <span class="keywordtype">void</span> <a class="code" href="namespace_halide.html#a381e168f467a972b4ac550f7f2ca0f81" title="JIT-Compile and run enough code to evaluate a Halide expression.">evaluate_may_gpu</a>(<a class="code" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> t, A *a, B *b) {
<a name="l01409"></a>01409     assert(t[0].type() == type_of&lt;A&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01410"></a>01410     assert(t[1].type() == type_of&lt;B&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01411"></a>01411 
<a name="l01412"></a>01412     <span class="keywordtype">bool</span> has_gpu_feature = <a class="code" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">get_jit_target_from_environment</a>().<a class="code" href="struct_halide_1_1_target.html#ae89c744ee593668ede7638246b59b5c8">has_gpu_feature</a>();
<a name="l01413"></a>01413     <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f;
<a name="l01414"></a>01414     f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = t;
<a name="l01415"></a>01415     <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;A&gt;</a> result_a(has_gpu_feature ? 1 : 0);
<a name="l01416"></a>01416     <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;B&gt;</a> result_b(has_gpu_feature ? 1 : 0);
<a name="l01417"></a>01417     <a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> r(result_a, result_b);
<a name="l01418"></a>01418     <span class="keywordflow">if</span> (has_gpu_feature) {
<a name="l01419"></a>01419         <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> g;
<a name="l01420"></a>01420     <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x;
<a name="l01421"></a>01421     g(x, <a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>);
<a name="l01422"></a>01422     g.<a class="code" href="class_halide_1_1_func.html#a9553df2b88fb02b13897960e356030c7" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>(x, 1);
<a name="l01423"></a>01423     g.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(r);
<a name="l01424"></a>01424     result_a.<a class="code" href="class_halide_1_1_image.html#af30a48c8b29e6d7c1bddad107fafccdc" title="Manually copy-back data to the host, if it&#39;s on a device.">copy_to_host</a>();
<a name="l01425"></a>01425     result_b.<a class="code" href="class_halide_1_1_image.html#af30a48c8b29e6d7c1bddad107fafccdc" title="Manually copy-back data to the host, if it&#39;s on a device.">copy_to_host</a>();
<a name="l01426"></a>01426     } <span class="keywordflow">else</span> {
<a name="l01427"></a>01427     f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(r);
<a name="l01428"></a>01428     }
<a name="l01429"></a>01429     *a = result_a(0);
<a name="l01430"></a>01430     *b = result_b(0);
<a name="l01431"></a>01431 }
<a name="l01432"></a>01432 
<a name="l01433"></a>01433 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C&gt;
<a name="l01434"></a><a class="code" href="namespace_halide.html#a1bb6877f8242a33539220fe44742495d">01434</a> <span class="keywordtype">void</span> <a class="code" href="namespace_halide.html#a381e168f467a972b4ac550f7f2ca0f81" title="JIT-Compile and run enough code to evaluate a Halide expression.">evaluate_may_gpu</a>(<a class="code" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> t, A *a, B *b, C *c) {
<a name="l01435"></a>01435     assert(t[0].type() == type_of&lt;A&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01436"></a>01436     assert(t[1].type() == type_of&lt;B&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01437"></a>01437     assert(t[2].type() == type_of&lt;C&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01438"></a>01438 
<a name="l01439"></a>01439     <span class="keywordtype">bool</span> has_gpu_feature = <a class="code" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">get_jit_target_from_environment</a>().<a class="code" href="struct_halide_1_1_target.html#ae89c744ee593668ede7638246b59b5c8">has_gpu_feature</a>();
<a name="l01440"></a>01440     <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f;
<a name="l01441"></a>01441     f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = t;
<a name="l01442"></a>01442     <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;A&gt;</a> result_a(has_gpu_feature ? 1 : 0);
<a name="l01443"></a>01443     <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;B&gt;</a> result_b(has_gpu_feature ? 1 : 0);
<a name="l01444"></a>01444     <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;C&gt;</a> result_c(has_gpu_feature ? 1 : 0);
<a name="l01445"></a>01445     <a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> r(result_a, result_b, result_c);
<a name="l01446"></a>01446     <span class="keywordflow">if</span> (has_gpu_feature) {
<a name="l01447"></a>01447         <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> g;
<a name="l01448"></a>01448     <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x;
<a name="l01449"></a>01449     g(x, <a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>);
<a name="l01450"></a>01450     g.<a class="code" href="class_halide_1_1_func.html#a9553df2b88fb02b13897960e356030c7" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>(x, 1);
<a name="l01451"></a>01451     g.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(r);
<a name="l01452"></a>01452     result_a.<a class="code" href="class_halide_1_1_image.html#af30a48c8b29e6d7c1bddad107fafccdc" title="Manually copy-back data to the host, if it&#39;s on a device.">copy_to_host</a>();
<a name="l01453"></a>01453     result_b.<a class="code" href="class_halide_1_1_image.html#af30a48c8b29e6d7c1bddad107fafccdc" title="Manually copy-back data to the host, if it&#39;s on a device.">copy_to_host</a>();
<a name="l01454"></a>01454     result_c.<a class="code" href="class_halide_1_1_image.html#af30a48c8b29e6d7c1bddad107fafccdc" title="Manually copy-back data to the host, if it&#39;s on a device.">copy_to_host</a>();
<a name="l01455"></a>01455     } <span class="keywordflow">else</span> {
<a name="l01456"></a>01456     f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(r);
<a name="l01457"></a>01457     }
<a name="l01458"></a>01458     *a = result_a(0);
<a name="l01459"></a>01459     *b = result_b(0);
<a name="l01460"></a>01460     *c = result_c(0);
<a name="l01461"></a>01461 }
<a name="l01462"></a>01462 
<a name="l01463"></a>01463 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B, <span class="keyword">typename</span> C, <span class="keyword">typename</span> D&gt;
<a name="l01464"></a><a class="code" href="namespace_halide.html#aecf04fc5073b1712dffd64489dc6efc3">01464</a> <span class="keywordtype">void</span> <a class="code" href="namespace_halide.html#a381e168f467a972b4ac550f7f2ca0f81" title="JIT-Compile and run enough code to evaluate a Halide expression.">evaluate_may_gpu</a>(<a class="code" href="class_halide_1_1_tuple.html" title="Create a small array of Exprs for defining and calling functions with multiple outputs.">Tuple</a> t, A *a, B *b, C *c, D *d) {
<a name="l01465"></a>01465     assert(t[0].type() == type_of&lt;A&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01466"></a>01466     assert(t[1].type() == type_of&lt;B&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01467"></a>01467     assert(t[2].type() == type_of&lt;C&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01468"></a>01468     assert(t[3].type() == type_of&lt;D&gt;() &amp;&amp; <span class="stringliteral">&quot;Type of argument to evaluate does not match templated type\n&quot;</span>);
<a name="l01469"></a>01469 
<a name="l01470"></a>01470     <span class="keywordtype">bool</span> has_gpu_feature = <a class="code" href="namespace_halide.html#afdb2fdc9b09935c4f2825d425359da37" title="Return the target that Halide will use for jit-compilation.">get_jit_target_from_environment</a>().<a class="code" href="struct_halide_1_1_target.html#ae89c744ee593668ede7638246b59b5c8">has_gpu_feature</a>();
<a name="l01471"></a>01471     <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> f;
<a name="l01472"></a>01472     f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = t;
<a name="l01473"></a>01473     <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;A&gt;</a> result_a(has_gpu_feature ? 1 : 0);
<a name="l01474"></a>01474     <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;B&gt;</a> result_b(has_gpu_feature ? 1 : 0);
<a name="l01475"></a>01475     <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;C&gt;</a> result_c(has_gpu_feature ? 1 : 0);
<a name="l01476"></a>01476     <a class="code" href="class_halide_1_1_image.html" title="A reference-counted handle on a dense multidimensional array containing scalar values of type T...">Image&lt;D&gt;</a> result_d(has_gpu_feature ? 1 : 0);
<a name="l01477"></a>01477     <a class="code" href="class_halide_1_1_realization.html" title="Funcs with Tuple values return multiple buffers when you realize them.">Realization</a> r(result_a, result_b, result_c, result_d);
<a name="l01478"></a>01478     <span class="keywordflow">if</span> (has_gpu_feature) {
<a name="l01479"></a>01479         <a class="code" href="class_halide_1_1_func.html" title="A halide function.">Func</a> g;
<a name="l01480"></a>01480     <a class="code" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a> x;
<a name="l01481"></a>01481     g(x, <a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>) = f(<a class="code" href="namespace_halide.html#a709cf1e833f387da9fbf94a075f38f02" title="A placeholder variable for infered arguments.">_</a>);
<a name="l01482"></a>01482     g.<a class="code" href="class_halide_1_1_func.html#a9553df2b88fb02b13897960e356030c7" title="Short-hand for tiling a domain and mapping the tile indices to GPU block indices and the coordinates ...">gpu_tile</a>(x, 1);
<a name="l01483"></a>01483     g.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(r);
<a name="l01484"></a>01484     result_a.<a class="code" href="class_halide_1_1_image.html#af30a48c8b29e6d7c1bddad107fafccdc" title="Manually copy-back data to the host, if it&#39;s on a device.">copy_to_host</a>();
<a name="l01485"></a>01485     result_b.<a class="code" href="class_halide_1_1_image.html#af30a48c8b29e6d7c1bddad107fafccdc" title="Manually copy-back data to the host, if it&#39;s on a device.">copy_to_host</a>();
<a name="l01486"></a>01486     result_c.<a class="code" href="class_halide_1_1_image.html#af30a48c8b29e6d7c1bddad107fafccdc" title="Manually copy-back data to the host, if it&#39;s on a device.">copy_to_host</a>();
<a name="l01487"></a>01487     result_d.<a class="code" href="class_halide_1_1_image.html#af30a48c8b29e6d7c1bddad107fafccdc" title="Manually copy-back data to the host, if it&#39;s on a device.">copy_to_host</a>();
<a name="l01488"></a>01488     } <span class="keywordflow">else</span> {
<a name="l01489"></a>01489     f.<a class="code" href="class_halide_1_1_func.html#a1fb0423663cc62b6e5ad0fef2195352b" title="Evaluate this function over some rectangular domain and return the resulting buffer or buffers...">realize</a>(r);
<a name="l01490"></a>01490     }
<a name="l01491"></a>01491     *a = result_a(0);
<a name="l01492"></a>01492     *b = result_b(0);
<a name="l01493"></a>01493     *c = result_c(0);
<a name="l01494"></a>01494     *d = result_d(0);
<a name="l01495"></a>01495 }
<a name="l01496"></a>01496 <span class="comment">// @}</span>
<a name="l01497"></a>01497 
<a name="l01498"></a>01498 }
<a name="l01499"></a>01499 
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_func_8h.html">Func.h</a>      </li>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
