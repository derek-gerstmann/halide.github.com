<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Halide: Halide::Runtime::Buffer&lt; T, D &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   &#160;<span id="projectnumber">10.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_halide_1_1_runtime_1_1_buffer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_halide_1_1_runtime_1_1_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Runtime::Buffer&lt; T, D &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A templated <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> class that wraps <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> and adds functionality.  
 <a href="class_halide_1_1_runtime_1_1_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer_1_1_dimension.html">Dimension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to the shape.  <a href="class_halide_1_1_runtime_1_1_buffer_1_1_dimension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a897dbebfae1a242dbac4e509861266dd"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a897dbebfae1a242dbac4e509861266dd">ElemType</a></td></tr>
<tr class="separator:a897dbebfae1a242dbac4e509861266dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68535e517e8356e1bf1e22a8d8da5d5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a68535e517e8356e1bf1e22a8d8da5d5f">owns_host_memory</a> () const </td></tr>
<tr class="memdesc:a68535e517e8356e1bf1e22a8d8da5d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> own the host memory it refers to?  <a href="#a68535e517e8356e1bf1e22a8d8da5d5f">More...</a><br /></td></tr>
<tr class="separator:a68535e517e8356e1bf1e22a8d8da5d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f3d58acaccbdcba70de2e854550fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer_1_1_dimension.html">Dimension</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a82f3d58acaccbdcba70de2e854550fc5">dim</a> (int i) const </td></tr>
<tr class="memdesc:a82f3d58acaccbdcba70de2e854550fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the shape of the buffer.  <a href="#a82f3d58acaccbdcba70de2e854550fc5">More...</a><br /></td></tr>
<tr class="separator:a82f3d58acaccbdcba70de2e854550fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16c3ceaa12ee1e1998cd2ab597d86e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad16c3ceaa12ee1e1998cd2ab597d86e1">number_of_elements</a> () const </td></tr>
<tr class="memdesc:ad16c3ceaa12ee1e1998cd2ab597d86e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of elements this buffer represents.  <a href="#ad16c3ceaa12ee1e1998cd2ab597d86e1">More...</a><br /></td></tr>
<tr class="separator:ad16c3ceaa12ee1e1998cd2ab597d86e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefeb8ca81329c0f91a08935418956ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aaefeb8ca81329c0f91a08935418956ed">dimensions</a> () const </td></tr>
<tr class="memdesc:aaefeb8ca81329c0f91a08935418956ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimensionality of the buffer.  <a href="#aaefeb8ca81329c0f91a08935418956ed">More...</a><br /></td></tr>
<tr class="separator:aaefeb8ca81329c0f91a08935418956ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad788c908d6b1dcd0c7c1acc5d0a37bc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad788c908d6b1dcd0c7c1acc5d0a37bc2">type</a> () const </td></tr>
<tr class="memdesc:ad788c908d6b1dcd0c7c1acc5d0a37bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the elements.  <a href="#ad788c908d6b1dcd0c7c1acc5d0a37bc2">More...</a><br /></td></tr>
<tr class="separator:ad788c908d6b1dcd0c7c1acc5d0a37bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506c21bfc249b172536a5dfb59b16da4"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a506c21bfc249b172536a5dfb59b16da4">begin</a> () const </td></tr>
<tr class="memdesc:a506c21bfc249b172536a5dfb59b16da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the element with the lowest address.  <a href="#a506c21bfc249b172536a5dfb59b16da4">More...</a><br /></td></tr>
<tr class="separator:a506c21bfc249b172536a5dfb59b16da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d4c313c43fead663bcff07e53f7d3d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af6d4c313c43fead663bcff07e53f7d3d">end</a> () const </td></tr>
<tr class="memdesc:af6d4c313c43fead663bcff07e53f7d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to one beyond the element with the highest address.  <a href="#af6d4c313c43fead663bcff07e53f7d3d">More...</a><br /></td></tr>
<tr class="separator:af6d4c313c43fead663bcff07e53f7d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b41f324dcf5b0cf2f46ab6e3d5f00e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ab8b41f324dcf5b0cf2f46ab6e3d5f00e">size_in_bytes</a> () const </td></tr>
<tr class="memdesc:ab8b41f324dcf5b0cf2f46ab6e3d5f00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of bytes spanned by the data in memory.  <a href="#ab8b41f324dcf5b0cf2f46ab6e3d5f00e">More...</a><br /></td></tr>
<tr class="separator:ab8b41f324dcf5b0cf2f46ab6e3d5f00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ef51e46c14c186f0c2b18f664b5e31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ab8ef51e46c14c186f0c2b18f664b5e31">reset</a> ()</td></tr>
<tr class="memdesc:ab8ef51e46c14c186f0c2b18f664b5e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> to be equivalent to a default-constructed <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of the same static type (if any); <a class="el" href="class_halide_1_1_buffer.html">Buffer&lt;void&gt;</a> will have its runtime type reset to uint8.  <a href="#ab8ef51e46c14c186f0c2b18f664b5e31">More...</a><br /></td></tr>
<tr class="separator:ab8ef51e46c14c186f0c2b18f664b5e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb70f579cf7cab5457f5ce88d771ac93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#acb70f579cf7cab5457f5ce88d771ac93">Buffer</a> ()</td></tr>
<tr class="separator:acb70f579cf7cab5457f5ce88d771ac93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9d31fcdc71f7c00dafe9d076e9dc27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a7a9d31fcdc71f7c00dafe9d076e9dc27">Buffer</a> (const <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> &amp;buf, <a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139">BufferDeviceOwnership</a> ownership=<a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139a6b982c948840b6e4b5fec2711f09627d">BufferDeviceOwnership::Unmanaged</a>)</td></tr>
<tr class="memdesc:a7a9d31fcdc71f7c00dafe9d076e9dc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a>.  <a href="#a7a9d31fcdc71f7c00dafe9d076e9dc27">More...</a><br /></td></tr>
<tr class="separator:a7a9d31fcdc71f7c00dafe9d076e9dc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47307ea974c0025db0b9d6bc646de65c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a47307ea974c0025db0b9d6bc646de65c">Buffer</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;other)</td></tr>
<tr class="memdesc:a47307ea974c0025db0b9d6bc646de65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a47307ea974c0025db0b9d6bc646de65c">More...</a><br /></td></tr>
<tr class="separator:a47307ea974c0025db0b9d6bc646de65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b96681d758ad414ff7751bca77ae863"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a1b96681d758ad414ff7751bca77ae863"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a1b96681d758ad414ff7751bca77ae863">Buffer</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a1b96681d758ad414ff7751bca77ae863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of different dimensionality and type.  <a href="#a1b96681d758ad414ff7751bca77ae863">More...</a><br /></td></tr>
<tr class="separator:a1b96681d758ad414ff7751bca77ae863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d1e07cb83829f379affad9123726c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a19d1e07cb83829f379affad9123726c7">Buffer</a> (<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a19d1e07cb83829f379affad9123726c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a19d1e07cb83829f379affad9123726c7">More...</a><br /></td></tr>
<tr class="separator:a19d1e07cb83829f379affad9123726c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2649e245b86b2975807b11a0d91f766e"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a2649e245b86b2975807b11a0d91f766e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2649e245b86b2975807b11a0d91f766e">Buffer</a> (<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a2649e245b86b2975807b11a0d91f766e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of different dimensionality and type.  <a href="#a2649e245b86b2975807b11a0d91f766e">More...</a><br /></td></tr>
<tr class="separator:a2649e245b86b2975807b11a0d91f766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b21234b1b51c23d70dde4c7bc0ce68"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a73b21234b1b51c23d70dde4c7bc0ce68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a73b21234b1b51c23d70dde4c7bc0ce68">operator=</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a73b21234b1b51c23d70dde4c7bc0ce68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality and type.  <a href="#a73b21234b1b51c23d70dde4c7bc0ce68">More...</a><br /></td></tr>
<tr class="separator:a73b21234b1b51c23d70dde4c7bc0ce68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b0a9cb0fed41c0445d6927240bb50c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a38b0a9cb0fed41c0445d6927240bb50c">operator=</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;other)</td></tr>
<tr class="memdesc:a38b0a9cb0fed41c0445d6927240bb50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard assignment operator.  <a href="#a38b0a9cb0fed41c0445d6927240bb50c">More...</a><br /></td></tr>
<tr class="separator:a38b0a9cb0fed41c0445d6927240bb50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2feda3bb0e3bde94f01791b2c3f45449"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a2feda3bb0e3bde94f01791b2c3f45449"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2feda3bb0e3bde94f01791b2c3f45449">operator=</a> (<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a2feda3bb0e3bde94f01791b2c3f45449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move from another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality and type.  <a href="#a2feda3bb0e3bde94f01791b2c3f45449">More...</a><br /></td></tr>
<tr class="separator:a2feda3bb0e3bde94f01791b2c3f45449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08d24f88faa83c622ab1a17c3c62310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af08d24f88faa83c622ab1a17c3c62310">operator=</a> (<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:af08d24f88faa83c622ab1a17c3c62310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard move-assignment operator.  <a href="#af08d24f88faa83c622ab1a17c3c62310">More...</a><br /></td></tr>
<tr class="separator:af08d24f88faa83c622ab1a17c3c62310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7961b0f7ee27508c36fb019d3d3a67e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ab7961b0f7ee27508c36fb019d3d3a67e">check_overflow</a> ()</td></tr>
<tr class="memdesc:ab7961b0f7ee27508c36fb019d3d3a67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the product of the extents fits in memory.  <a href="#ab7961b0f7ee27508c36fb019d3d3a67e">More...</a><br /></td></tr>
<tr class="separator:ab7961b0f7ee27508c36fb019d3d3a67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759f8c2487886eb85bc2607f11beabd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a759f8c2487886eb85bc2607f11beabd1">allocate</a> (void *(*allocate_fn)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)=nullptr, void(*deallocate_fn)(void *)=nullptr)</td></tr>
<tr class="memdesc:a759f8c2487886eb85bc2607f11beabd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#a759f8c2487886eb85bc2607f11beabd1">More...</a><br /></td></tr>
<tr class="separator:a759f8c2487886eb85bc2607f11beabd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b39bfac1c4ccca5eb45af9cfbeed7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a65b39bfac1c4ccca5eb45af9cfbeed7d">deallocate</a> ()</td></tr>
<tr class="memdesc:a65b39bfac1c4ccca5eb45af9cfbeed7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop reference to any owned host or device memory, possibly freeing it, if this buffer held the last reference to it.  <a href="#a65b39bfac1c4ccca5eb45af9cfbeed7d">More...</a><br /></td></tr>
<tr class="separator:a65b39bfac1c4ccca5eb45af9cfbeed7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82da5ef4c1264386e705ef9b7e475c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af82da5ef4c1264386e705ef9b7e475c7">device_deallocate</a> ()</td></tr>
<tr class="memdesc:af82da5ef4c1264386e705ef9b7e475c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop reference to any owned device memory, possibly freeing it if this buffer held the last reference to it.  <a href="#af82da5ef4c1264386e705ef9b7e475c7">More...</a><br /></td></tr>
<tr class="separator:af82da5ef4c1264386e705ef9b7e475c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2b58ef872e9fd22baac742271901d5"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:abb2b58ef872e9fd22baac742271901d5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#abb2b58ef872e9fd22baac742271901d5">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, int first, Args...rest)</td></tr>
<tr class="memdesc:abb2b58ef872e9fd22baac742271901d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of the given size with a runtime type.  <a href="#abb2b58ef872e9fd22baac742271901d5">More...</a><br /></td></tr>
<tr class="separator:abb2b58ef872e9fd22baac742271901d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0013744b24a2a075b4fd1ef123af495b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0013744b24a2a075b4fd1ef123af495b">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, const std::vector&lt; int &gt; &amp;sizes)</td></tr>
<tr class="memdesc:a0013744b24a2a075b4fd1ef123af495b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of unknown type using a vector of ints as the size.  <a href="#a0013744b24a2a075b4fd1ef123af495b">More...</a><br /></td></tr>
<tr class="separator:a0013744b24a2a075b4fd1ef123af495b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52db43880a5c487452f11936cb1166ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a52db43880a5c487452f11936cb1166ab">Buffer</a> (const std::vector&lt; int &gt; &amp;sizes)</td></tr>
<tr class="memdesc:a52db43880a5c487452f11936cb1166ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of known type using a vector of ints as the size.  <a href="#a52db43880a5c487452f11936cb1166ab">More...</a><br /></td></tr>
<tr class="separator:a52db43880a5c487452f11936cb1166ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a16d6c1d993b9c65e68aa204f893ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a13a16d6c1d993b9c65e68aa204f893ec">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, const std::vector&lt; int &gt; &amp;sizes, const std::vector&lt; int &gt; &amp;storage_order)</td></tr>
<tr class="memdesc:a13a16d6c1d993b9c65e68aa204f893ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of unknown type using a vector of ints as the size and a vector of indices indicating the storage order for each dimension.  <a href="#a13a16d6c1d993b9c65e68aa204f893ec">More...</a><br /></td></tr>
<tr class="separator:a13a16d6c1d993b9c65e68aa204f893ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72de05f0ec501ab2d7e130faaa5e25e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a72de05f0ec501ab2d7e130faaa5e25e4">Buffer</a> (const std::vector&lt; int &gt; &amp;sizes, const std::vector&lt; int &gt; &amp;storage_order)</td></tr>
<tr class="separator:a72de05f0ec501ab2d7e130faaa5e25e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aac7bbcf212bfd87b017ded998140a9"><td class="memTemplParams" colspan="2">template&lt;typename Array , size_t N&gt; </td></tr>
<tr class="memitem:a7aac7bbcf212bfd87b017ded998140a9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a7aac7bbcf212bfd87b017ded998140a9">Buffer</a> (Array(&amp;vals)[N])</td></tr>
<tr class="memdesc:a7aac7bbcf212bfd87b017ded998140a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> that refers to a statically sized array.  <a href="#a7aac7bbcf212bfd87b017ded998140a9">More...</a><br /></td></tr>
<tr class="separator:a7aac7bbcf212bfd87b017ded998140a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4998f8f4bae8c24ae47b19089de35b8b"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4998f8f4bae8c24ae47b19089de35b8b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4998f8f4bae8c24ae47b19089de35b8b">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, add_const_if_T_is_const&lt; void &gt; *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3814e3ef9f982a3aa036e90db2078006">data</a>, int first, Args &amp;&amp;...rest)</td></tr>
<tr class="memdesc:a4998f8f4bae8c24ae47b19089de35b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of runtime type from a pointer and some sizes.  <a href="#a4998f8f4bae8c24ae47b19089de35b8b">More...</a><br /></td></tr>
<tr class="separator:a4998f8f4bae8c24ae47b19089de35b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42234017b02db28ba6633b628c03868e"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a42234017b02db28ba6633b628c03868e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a42234017b02db28ba6633b628c03868e">Buffer</a> (T *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3814e3ef9f982a3aa036e90db2078006">data</a>, int first, Args &amp;&amp;...rest)</td></tr>
<tr class="memdesc:a42234017b02db28ba6633b628c03868e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer and some sizes.  <a href="#a42234017b02db28ba6633b628c03868e">More...</a><br /></td></tr>
<tr class="separator:a42234017b02db28ba6633b628c03868e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c020e81707b663ee4761d852222e94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a31c020e81707b663ee4761d852222e94">Buffer</a> (T *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3814e3ef9f982a3aa036e90db2078006">data</a>, const std::vector&lt; int &gt; &amp;sizes)</td></tr>
<tr class="memdesc:a31c020e81707b663ee4761d852222e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer and a vector of sizes.  <a href="#a31c020e81707b663ee4761d852222e94">More...</a><br /></td></tr>
<tr class="separator:a31c020e81707b663ee4761d852222e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9301d7908f8580de77b58384eb19582"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ae9301d7908f8580de77b58384eb19582">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, add_const_if_T_is_const&lt; void &gt; *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3814e3ef9f982a3aa036e90db2078006">data</a>, const std::vector&lt; int &gt; &amp;sizes)</td></tr>
<tr class="memdesc:ae9301d7908f8580de77b58384eb19582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of runtime type from a pointer and a vector of sizes.  <a href="#ae9301d7908f8580de77b58384eb19582">More...</a><br /></td></tr>
<tr class="separator:ae9301d7908f8580de77b58384eb19582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ce543ccc08cc06bf35050a0fca989e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a00ce543ccc08cc06bf35050a0fca989e">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, add_const_if_T_is_const&lt; void &gt; *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3814e3ef9f982a3aa036e90db2078006">data</a>, int d, const <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> *shape)</td></tr>
<tr class="memdesc:a00ce543ccc08cc06bf35050a0fca989e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and an array describing the shape.  <a href="#a00ce543ccc08cc06bf35050a0fca989e">More...</a><br /></td></tr>
<tr class="separator:a00ce543ccc08cc06bf35050a0fca989e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad536066ac6994e015090a7c7edf59e68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad536066ac6994e015090a7c7edf59e68">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, add_const_if_T_is_const&lt; void &gt; *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3814e3ef9f982a3aa036e90db2078006">data</a>, const std::vector&lt; <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> &gt; &amp;shape)</td></tr>
<tr class="memdesc:ad536066ac6994e015090a7c7edf59e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and a vector describing the shape.  <a href="#ad536066ac6994e015090a7c7edf59e68">More...</a><br /></td></tr>
<tr class="separator:ad536066ac6994e015090a7c7edf59e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a2b9d12d26d24480c0519490ee975e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a84a2b9d12d26d24480c0519490ee975e">Buffer</a> (T *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3814e3ef9f982a3aa036e90db2078006">data</a>, int d, const <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> *shape)</td></tr>
<tr class="memdesc:a84a2b9d12d26d24480c0519490ee975e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and an array describing the shape.  <a href="#a84a2b9d12d26d24480c0519490ee975e">More...</a><br /></td></tr>
<tr class="separator:a84a2b9d12d26d24480c0519490ee975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d14c533acc38b5737b9b832822ec8cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a1d14c533acc38b5737b9b832822ec8cf">Buffer</a> (T *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3814e3ef9f982a3aa036e90db2078006">data</a>, const std::vector&lt; <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> &gt; &amp;shape)</td></tr>
<tr class="memdesc:a1d14c533acc38b5737b9b832822ec8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and a vector describing the shape.  <a href="#a1d14c533acc38b5737b9b832822ec8cf">More...</a><br /></td></tr>
<tr class="separator:a1d14c533acc38b5737b9b832822ec8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f46c67f0f5210b97b570a3e7fac95e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ab3f46c67f0f5210b97b570a3e7fac95e">~Buffer</a> ()</td></tr>
<tr class="memdesc:ab3f46c67f0f5210b97b570a3e7fac95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab3f46c67f0f5210b97b570a3e7fac95e">More...</a><br /></td></tr>
<tr class="separator:ab3f46c67f0f5210b97b570a3e7fac95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6e8717724ac6b06571a1d0d82c064e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2a6e8717724ac6b06571a1d0d82c064e">operator halide_buffer_t *</a> ()</td></tr>
<tr class="memdesc:a2a6e8717724ac6b06571a1d0d82c064e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a cast operator to <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> *, so that instances can be passed directly to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> filters.  <a href="#a2a6e8717724ac6b06571a1d0d82c064e">More...</a><br /></td></tr>
<tr class="separator:a2a6e8717724ac6b06571a1d0d82c064e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8f8c9e94c65bf57359e157cf73a239"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2 = D&gt; </td></tr>
<tr class="memitem:a4d8f8c9e94c65bf57359e157cf73a239"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4d8f8c9e94c65bf57359e157cf73a239">as</a> ()&amp;</td></tr>
<tr class="memdesc:a4d8f8c9e94c65bf57359e157cf73a239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a typed reference to this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#a4d8f8c9e94c65bf57359e157cf73a239">More...</a><br /></td></tr>
<tr class="separator:a4d8f8c9e94c65bf57359e157cf73a239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e5981bd7a2303ee817237b18fef618"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2 = D&gt; </td></tr>
<tr class="memitem:aa3e5981bd7a2303ee817237b18fef618"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aa3e5981bd7a2303ee817237b18fef618">as</a> () const &amp;</td></tr>
<tr class="memdesc:aa3e5981bd7a2303ee817237b18fef618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const typed reference to this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#aa3e5981bd7a2303ee817237b18fef618">More...</a><br /></td></tr>
<tr class="separator:aa3e5981bd7a2303ee817237b18fef618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d898fb973e24ded5ead67fbf19bb20c"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2 = D&gt; </td></tr>
<tr class="memitem:a7d898fb973e24ded5ead67fbf19bb20c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a7d898fb973e24ded5ead67fbf19bb20c">as</a> ()&amp;&amp;</td></tr>
<tr class="memdesc:a7d898fb973e24ded5ead67fbf19bb20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this rval <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> with a different type attached.  <a href="#a7d898fb973e24ded5ead67fbf19bb20c">More...</a><br /></td></tr>
<tr class="separator:a7d898fb973e24ded5ead67fbf19bb20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3763a8dccaf387d0071f22f0f10135d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; not_const_T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3763a8dccaf387d0071f22f0f10135d4">copy</a> (void *(*allocate_fn)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)=nullptr, void(*deallocate_fn)(void *)=nullptr) const </td></tr>
<tr class="memdesc:a3763a8dccaf387d0071f22f0f10135d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new image which is a deep copy of this image.  <a href="#a3763a8dccaf387d0071f22f0f10135d4">More...</a><br /></td></tr>
<tr class="separator:a3763a8dccaf387d0071f22f0f10135d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac333783142c4d3911129c022a5930eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; not_const_T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ac333783142c4d3911129c022a5930eb1">copy_to_interleaved</a> (void *(*allocate_fn)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)=nullptr, void(*deallocate_fn)(void *)=nullptr) const </td></tr>
<tr class="memdesc:ac333783142c4d3911129c022a5930eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3763a8dccaf387d0071f22f0f10135d4" title="Make a new image which is a deep copy of this image. ">copy()</a>, but the copy is created in interleaved memory layout (vs.  <a href="#ac333783142c4d3911129c022a5930eb1">More...</a><br /></td></tr>
<tr class="separator:ac333783142c4d3911129c022a5930eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1f20fa69d87c8234e6452837f70d57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; not_const_T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#acf1f20fa69d87c8234e6452837f70d57">copy_to_planar</a> (void *(*allocate_fn)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)=nullptr, void(*deallocate_fn)(void *)=nullptr) const </td></tr>
<tr class="memdesc:acf1f20fa69d87c8234e6452837f70d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3763a8dccaf387d0071f22f0f10135d4" title="Make a new image which is a deep copy of this image. ">copy()</a>, but the copy is created in planar memory layout (vs.  <a href="#acf1f20fa69d87c8234e6452837f70d57">More...</a><br /></td></tr>
<tr class="separator:acf1f20fa69d87c8234e6452837f70d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa2bfab2ea348fb5c7392d50d3b290f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#adaa2bfab2ea348fb5c7392d50d3b290f">alias</a> () const </td></tr>
<tr class="memdesc:adaa2bfab2ea348fb5c7392d50d3b290f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a copy of the <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> which shares the underlying host and/or device allocations as the existing <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#adaa2bfab2ea348fb5c7392d50d3b290f">More...</a><br /></td></tr>
<tr class="separator:adaa2bfab2ea348fb5c7392d50d3b290f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9982b308f61426dd5a33aa31dfc156f"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:ac9982b308f61426dd5a33aa31dfc156f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ac9982b308f61426dd5a33aa31dfc156f">copy_from</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:ac9982b308f61426dd5a33aa31dfc156f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> with the values at the same coordinates in another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#ac9982b308f61426dd5a33aa31dfc156f">More...</a><br /></td></tr>
<tr class="separator:ac9982b308f61426dd5a33aa31dfc156f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbc2b5dec589194eef2c2856b8ef732"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aafbc2b5dec589194eef2c2856b8ef732">cropped</a> (int d, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8d66fbdc79107f8b6ff11c3cf1add174">min</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a13379161fe8d341bd0fbd4efee874a7e">extent</a>) const </td></tr>
<tr class="memdesc:aafbc2b5dec589194eef2c2856b8ef732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image that refers to a sub-range of this image along the given dimension.  <a href="#aafbc2b5dec589194eef2c2856b8ef732">More...</a><br /></td></tr>
<tr class="separator:aafbc2b5dec589194eef2c2856b8ef732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4e4a871377e1eb48980b5fc697c276"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4a4e4a871377e1eb48980b5fc697c276">crop</a> (int d, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8d66fbdc79107f8b6ff11c3cf1add174">min</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a13379161fe8d341bd0fbd4efee874a7e">extent</a>)</td></tr>
<tr class="memdesc:a4a4e4a871377e1eb48980b5fc697c276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crop an image in-place along the given dimension.  <a href="#a4a4e4a871377e1eb48980b5fc697c276">More...</a><br /></td></tr>
<tr class="separator:a4a4e4a871377e1eb48980b5fc697c276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4e9b37a5d038c889cf0e9f8e6518bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a6f4e9b37a5d038c889cf0e9f8e6518bd">cropped</a> (const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;rect) const </td></tr>
<tr class="memdesc:a6f4e9b37a5d038c889cf0e9f8e6518bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image that refers to a sub-rectangle of this image along the first N dimensions.  <a href="#a6f4e9b37a5d038c889cf0e9f8e6518bd">More...</a><br /></td></tr>
<tr class="separator:a6f4e9b37a5d038c889cf0e9f8e6518bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e4477fcde56c9f0f448281cd15efad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a73e4477fcde56c9f0f448281cd15efad">crop</a> (const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;rect)</td></tr>
<tr class="memdesc:a73e4477fcde56c9f0f448281cd15efad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crop an image in-place along the first N dimensions.  <a href="#a73e4477fcde56c9f0f448281cd15efad">More...</a><br /></td></tr>
<tr class="separator:a73e4477fcde56c9f0f448281cd15efad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ceba660b052e7c783d604225cc94c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a9ceba660b052e7c783d604225cc94c48">translated</a> (int d, int dx) const </td></tr>
<tr class="memdesc:a9ceba660b052e7c783d604225cc94c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image which refers to the same data with using translated coordinates in the given dimension.  <a href="#a9ceba660b052e7c783d604225cc94c48">More...</a><br /></td></tr>
<tr class="separator:a9ceba660b052e7c783d604225cc94c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08186761f27f13d4097e85b467d2b534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a08186761f27f13d4097e85b467d2b534">translate</a> (int d, int delta)</td></tr>
<tr class="memdesc:a08186761f27f13d4097e85b467d2b534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate an image in-place along one dimension by changing how it is indexed.  <a href="#a08186761f27f13d4097e85b467d2b534">More...</a><br /></td></tr>
<tr class="separator:a08186761f27f13d4097e85b467d2b534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7c882a0d5181db473ab23940ef8022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8e7c882a0d5181db473ab23940ef8022">translated</a> (const std::vector&lt; int &gt; &amp;delta) const </td></tr>
<tr class="memdesc:a8e7c882a0d5181db473ab23940ef8022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image which refers to the same data translated along the first N dimensions.  <a href="#a8e7c882a0d5181db473ab23940ef8022">More...</a><br /></td></tr>
<tr class="separator:a8e7c882a0d5181db473ab23940ef8022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401c86c132079debb43a85b5957ed9a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a401c86c132079debb43a85b5957ed9a5">translate</a> (const std::vector&lt; int &gt; &amp;delta)</td></tr>
<tr class="memdesc:a401c86c132079debb43a85b5957ed9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate an image along the first N dimensions by changing how it is indexed.  <a href="#a401c86c132079debb43a85b5957ed9a5">More...</a><br /></td></tr>
<tr class="separator:a401c86c132079debb43a85b5957ed9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d26b45fc275f98707b449ddffe4722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a12d26b45fc275f98707b449ddffe4722">transposed</a> (int d1, int d2) const </td></tr>
<tr class="memdesc:a12d26b45fc275f98707b449ddffe4722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a buffer which refers to the same data in the same layout using a swapped indexing order for the dimensions given.  <a href="#a12d26b45fc275f98707b449ddffe4722">More...</a><br /></td></tr>
<tr class="separator:a12d26b45fc275f98707b449ddffe4722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca18450bcc383920ca5f69a9b04b097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8ca18450bcc383920ca5f69a9b04b097">transpose</a> (int d1, int d2)</td></tr>
<tr class="memdesc:a8ca18450bcc383920ca5f69a9b04b097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose a buffer in-place by changing how it is indexed.  <a href="#a8ca18450bcc383920ca5f69a9b04b097">More...</a><br /></td></tr>
<tr class="separator:a8ca18450bcc383920ca5f69a9b04b097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbcff09c23d77a1c008409bdcaab258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2cbcff09c23d77a1c008409bdcaab258">transpose</a> (const std::vector&lt; int &gt; &amp;order)</td></tr>
<tr class="memdesc:a2cbcff09c23d77a1c008409bdcaab258"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generalized transpose: instead of swapping two dimensions, pass a vector that lists each dimension index exactly once, in the desired order.  <a href="#a2cbcff09c23d77a1c008409bdcaab258">More...</a><br /></td></tr>
<tr class="separator:a2cbcff09c23d77a1c008409bdcaab258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff164451de419f2076ebafefaedb8b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#adff164451de419f2076ebafefaedb8b8">transposed</a> (const std::vector&lt; int &gt; &amp;order) const </td></tr>
<tr class="memdesc:adff164451de419f2076ebafefaedb8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a buffer which refers to the same data in the same layout using a different ordering of the dimensions.  <a href="#adff164451de419f2076ebafefaedb8b8">More...</a><br /></td></tr>
<tr class="separator:adff164451de419f2076ebafefaedb8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab954688f8a932fd039a59bb1f309f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aaab954688f8a932fd039a59bb1f309f7">sliced</a> (int d, int pos) const </td></tr>
<tr class="memdesc:aaab954688f8a932fd039a59bb1f309f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a lower-dimensional buffer that refers to one slice of this buffer.  <a href="#aaab954688f8a932fd039a59bb1f309f7">More...</a><br /></td></tr>
<tr class="separator:aaab954688f8a932fd039a59bb1f309f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af913de6ba9a380076d4ccc4a9bc8918a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af913de6ba9a380076d4ccc4a9bc8918a">sliced</a> (int d) const </td></tr>
<tr class="memdesc:af913de6ba9a380076d4ccc4a9bc8918a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a lower-dimensional buffer that refers to one slice of this buffer at the dimension's minimum.  <a href="#af913de6ba9a380076d4ccc4a9bc8918a">More...</a><br /></td></tr>
<tr class="separator:af913de6ba9a380076d4ccc4a9bc8918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba2eeed0bf8a096915189de65a5922b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2ba2eeed0bf8a096915189de65a5922b">slice</a> (int d, int pos)</td></tr>
<tr class="memdesc:a2ba2eeed0bf8a096915189de65a5922b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the buffer to refer to a single lower-dimensional slice of itself along the given dimension at the given coordinate.  <a href="#a2ba2eeed0bf8a096915189de65a5922b">More...</a><br /></td></tr>
<tr class="separator:a2ba2eeed0bf8a096915189de65a5922b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78a00f58dc9628885afb731ffb6fb94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aa78a00f58dc9628885afb731ffb6fb94">slice</a> (int d)</td></tr>
<tr class="memdesc:aa78a00f58dc9628885afb731ffb6fb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice a buffer in-place at the dimension's minimum.  <a href="#aa78a00f58dc9628885afb731ffb6fb94">More...</a><br /></td></tr>
<tr class="separator:aa78a00f58dc9628885afb731ffb6fb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877b74e2b37ba6c0ca70bbee32681d1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a877b74e2b37ba6c0ca70bbee32681d1c">embedded</a> (int d, int pos=0) const </td></tr>
<tr class="memdesc:a877b74e2b37ba6c0ca70bbee32681d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new buffer that views this buffer as a single slice in a higher-dimensional space.  <a href="#a877b74e2b37ba6c0ca70bbee32681d1c">More...</a><br /></td></tr>
<tr class="separator:a877b74e2b37ba6c0ca70bbee32681d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06c4248b118d756c9678996ace05030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ae06c4248b118d756c9678996ace05030">embed</a> (int d, int pos=0)</td></tr>
<tr class="memdesc:ae06c4248b118d756c9678996ace05030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Embed a buffer in-place, increasing the dimensionality.  <a href="#ae06c4248b118d756c9678996ace05030">More...</a><br /></td></tr>
<tr class="separator:ae06c4248b118d756c9678996ace05030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bcf81706f57476668568dd8ea2c403"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aa2bcf81706f57476668568dd8ea2c403">add_dimension</a> ()</td></tr>
<tr class="memdesc:aa2bcf81706f57476668568dd8ea2c403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new dimension with a min of zero and an extent of one.  <a href="#aa2bcf81706f57476668568dd8ea2c403">More...</a><br /></td></tr>
<tr class="separator:aa2bcf81706f57476668568dd8ea2c403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7993fdda560897f4d745177470f03d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ae7993fdda560897f4d745177470f03d8">add_dimension_with_stride</a> (int s)</td></tr>
<tr class="memdesc:ae7993fdda560897f4d745177470f03d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new dimension with a min of zero, an extent of one, and the specified stride.  <a href="#ae7993fdda560897f4d745177470f03d8">More...</a><br /></td></tr>
<tr class="separator:ae7993fdda560897f4d745177470f03d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3814e3ef9f982a3aa036e90db2078006"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3814e3ef9f982a3aa036e90db2078006">data</a> () const </td></tr>
<tr class="memdesc:a3814e3ef9f982a3aa036e90db2078006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the address of the min coordinate.  <a href="#a3814e3ef9f982a3aa036e90db2078006">More...</a><br /></td></tr>
<tr class="separator:a3814e3ef9f982a3aa036e90db2078006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f75e4f03ef78e7dbabdce60f34b02a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a93f75e4f03ef78e7dbabdce60f34b02a">all_equal</a> (not_void_T val) const </td></tr>
<tr class="memdesc:a93f75e4f03ef78e7dbabdce60f34b02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests that all values in this buffer are equal to val.  <a href="#a93f75e4f03ef78e7dbabdce60f34b02a">More...</a><br /></td></tr>
<tr class="separator:a93f75e4f03ef78e7dbabdce60f34b02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6da53ff0035c65d762d91bb618f38f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad6da53ff0035c65d762d91bb618f38f4">fill</a> (not_void_T val)</td></tr>
<tr class="separator:ad6da53ff0035c65d762d91bb618f38f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dd431ae848e2b16ba659f3578f0776"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename  = typename std::enable_if&lt;!std::is_arithmetic&lt;typename std::decay&lt;Fn&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab6dd431ae848e2b16ba659f3578f0776"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ab6dd431ae848e2b16ba659f3578f0776">fill</a> (Fn &amp;&amp;f)</td></tr>
<tr class="memdesc:ab6dd431ae848e2b16ba659f3578f0776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a buffer by evaluating a callable at every site.  <a href="#ab6dd431ae848e2b16ba659f3578f0776">More...</a><br /></td></tr>
<tr class="separator:ab6dd431ae848e2b16ba659f3578f0776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4b9be7258804a1313a89f43a8d40e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a9b4b9be7258804a1313a89f43a8d40e4">is_bounds_query</a> () const </td></tr>
<tr class="memdesc:a9b4b9be7258804a1313a89f43a8d40e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an input buffer passed extern stage is a querying bounds.  <a href="#a9b4b9be7258804a1313a89f43a8d40e4">More...</a><br /></td></tr>
<tr class="separator:a9b4b9be7258804a1313a89f43a8d40e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f27e242b5bce071d42a2ef15550f012"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a9f27e242b5bce071d42a2ef15550f012">msan_check_mem_is_initialized</a> (bool entire=false) const </td></tr>
<tr class="memdesc:a9f27e242b5bce071d42a2ef15550f012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient check to verify that all of the interesting bytes in the <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> are initialized under MSAN.  <a href="#a9f27e242b5bce071d42a2ef15550f012">More...</a><br /></td></tr>
<tr class="separator:a9f27e242b5bce071d42a2ef15550f012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8d66fbdc79107f8b6ff11c3cf1add174"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8d66fbdc79107f8b6ff11c3cf1add174">min</a> (int i) const </td></tr>
<tr class="memdesc:a8d66fbdc79107f8b6ff11c3cf1add174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the mins, strides, extents.  <a href="#a8d66fbdc79107f8b6ff11c3cf1add174">More...</a><br /></td></tr>
<tr class="separator:a8d66fbdc79107f8b6ff11c3cf1add174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13379161fe8d341bd0fbd4efee874a7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a13379161fe8d341bd0fbd4efee874a7e">extent</a> (int i) const </td></tr>
<tr class="memdesc:a13379161fe8d341bd0fbd4efee874a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the mins, strides, extents.  <a href="#a13379161fe8d341bd0fbd4efee874a7e">More...</a><br /></td></tr>
<tr class="separator:a13379161fe8d341bd0fbd4efee874a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029ad7be5ae8188583b39e8d50bc35e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a029ad7be5ae8188583b39e8d50bc35e8">stride</a> (int i) const </td></tr>
<tr class="memdesc:a029ad7be5ae8188583b39e8d50bc35e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the mins, strides, extents.  <a href="#a029ad7be5ae8188583b39e8d50bc35e8">More...</a><br /></td></tr>
<tr class="separator:a029ad7be5ae8188583b39e8d50bc35e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1b9d3997c7c6d260a3419cda075178d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a1b9d3997c7c6d260a3419cda075178d1">Buffer</a> (int first)</td></tr>
<tr class="memdesc:a1b9d3997c7c6d260a3419cda075178d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of the given size.  <a href="#a1b9d3997c7c6d260a3419cda075178d1">More...</a><br /></td></tr>
<tr class="separator:a1b9d3997c7c6d260a3419cda075178d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32797f424892a4c602bac1054e8a99cf"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a32797f424892a4c602bac1054e8a99cf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a32797f424892a4c602bac1054e8a99cf">Buffer</a> (int first, int second, Args...rest)</td></tr>
<tr class="memdesc:a32797f424892a4c602bac1054e8a99cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of the given size.  <a href="#a32797f424892a4c602bac1054e8a99cf">More...</a><br /></td></tr>
<tr class="separator:a32797f424892a4c602bac1054e8a99cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2fcb27dc04a87015427ad6aa4bd55e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2fcb27dc04a87015427ad6aa4bd55e89">raw_buffer</a> ()</td></tr>
<tr class="memdesc:a2fcb27dc04a87015427ad6aa4bd55e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> this wraps.  <a href="#a2fcb27dc04a87015427ad6aa4bd55e89">More...</a><br /></td></tr>
<tr class="separator:a2fcb27dc04a87015427ad6aa4bd55e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb951224200a90c4cd127e7d091c5f4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#afbb951224200a90c4cd127e7d091c5f4">raw_buffer</a> () const </td></tr>
<tr class="memdesc:afbb951224200a90c4cd127e7d091c5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> this wraps.  <a href="#afbb951224200a90c4cd127e7d091c5f4">More...</a><br /></td></tr>
<tr class="separator:afbb951224200a90c4cd127e7d091c5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a702f639c8005677dbe66a50181df17e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; typename std::add_const&lt; T &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad788c908d6b1dcd0c7c1acc5d0a37bc2">type</a>, D &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a702f639c8005677dbe66a50181df17e2">as_const</a> ()&amp;</td></tr>
<tr class="memdesc:a702f639c8005677dbe66a50181df17e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a702f639c8005677dbe66a50181df17e2" title="as_const() is syntactic sugar for .as&lt;const T&gt;(), to avoid the need to recapitulate the type argument...">as_const()</a> is syntactic sugar for .<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4d8f8c9e94c65bf57359e157cf73a239" title="Return a typed reference to this Buffer. ">as&lt;const T&gt;()</a>, to avoid the need to recapitulate the type argument.  <a href="#a702f639c8005677dbe66a50181df17e2">More...</a><br /></td></tr>
<tr class="separator:a702f639c8005677dbe66a50181df17e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d75c45addc0b569abe9876cd7f90962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; typename std::add_const&lt; T &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad788c908d6b1dcd0c7c1acc5d0a37bc2">type</a>, D &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a9d75c45addc0b569abe9876cd7f90962">as_const</a> () const &amp;</td></tr>
<tr class="memdesc:a9d75c45addc0b569abe9876cd7f90962"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a702f639c8005677dbe66a50181df17e2" title="as_const() is syntactic sugar for .as&lt;const T&gt;(), to avoid the need to recapitulate the type argument...">as_const()</a> is syntactic sugar for .<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4d8f8c9e94c65bf57359e157cf73a239" title="Return a typed reference to this Buffer. ">as&lt;const T&gt;()</a>, to avoid the need to recapitulate the type argument.  <a href="#a9d75c45addc0b569abe9876cd7f90962">More...</a><br /></td></tr>
<tr class="separator:a9d75c45addc0b569abe9876cd7f90962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae97e4679611d7f944cc67ee487d66f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; typename std::add_const&lt; T &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad788c908d6b1dcd0c7c1acc5d0a37bc2">type</a>, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#adae97e4679611d7f944cc67ee487d66f">as_const</a> ()&amp;&amp;</td></tr>
<tr class="memdesc:adae97e4679611d7f944cc67ee487d66f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a702f639c8005677dbe66a50181df17e2" title="as_const() is syntactic sugar for .as&lt;const T&gt;(), to avoid the need to recapitulate the type argument...">as_const()</a> is syntactic sugar for .<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4d8f8c9e94c65bf57359e157cf73a239" title="Return a typed reference to this Buffer. ">as&lt;const T&gt;()</a>, to avoid the need to recapitulate the type argument.  <a href="#adae97e4679611d7f944cc67ee487d66f">More...</a><br /></td></tr>
<tr class="separator:adae97e4679611d7f944cc67ee487d66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acf79c935f9c932b199edc597ff101579"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#acf79c935f9c932b199edc597ff101579">width</a> () const </td></tr>
<tr class="memdesc:acf79c935f9c932b199edc597ff101579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the first three dimensions.  <a href="#acf79c935f9c932b199edc597ff101579">More...</a><br /></td></tr>
<tr class="separator:acf79c935f9c932b199edc597ff101579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcba83ef16a1817362b9b734d40d6ca9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#abcba83ef16a1817362b9b734d40d6ca9">height</a> () const </td></tr>
<tr class="memdesc:abcba83ef16a1817362b9b734d40d6ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the first three dimensions.  <a href="#abcba83ef16a1817362b9b734d40d6ca9">More...</a><br /></td></tr>
<tr class="separator:abcba83ef16a1817362b9b734d40d6ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecdfcb141d4433d580f962c2cd89e22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a7ecdfcb141d4433d580f962c2cd89e22">channels</a> () const </td></tr>
<tr class="memdesc:a7ecdfcb141d4433d580f962c2cd89e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the first three dimensions.  <a href="#a7ecdfcb141d4433d580f962c2cd89e22">More...</a><br /></td></tr>
<tr class="separator:a7ecdfcb141d4433d580f962c2cd89e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a78fa4b85ee3f1a486e1fd7e24d78e62e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a78fa4b85ee3f1a486e1fd7e24d78e62e">left</a> () const </td></tr>
<tr class="memdesc:a78fa4b85ee3f1a486e1fd7e24d78e62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the min and max value of each dimension.  <a href="#a78fa4b85ee3f1a486e1fd7e24d78e62e">More...</a><br /></td></tr>
<tr class="separator:a78fa4b85ee3f1a486e1fd7e24d78e62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c0b402a62f374130f0645bd633b507"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a30c0b402a62f374130f0645bd633b507">right</a> () const </td></tr>
<tr class="memdesc:a30c0b402a62f374130f0645bd633b507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the min and max value of each dimension.  <a href="#a30c0b402a62f374130f0645bd633b507">More...</a><br /></td></tr>
<tr class="separator:a30c0b402a62f374130f0645bd633b507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa517071f87ec9c484fb32d0034c03f3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aa517071f87ec9c484fb32d0034c03f3a">top</a> () const </td></tr>
<tr class="memdesc:aa517071f87ec9c484fb32d0034c03f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the min and max value of each dimension.  <a href="#aa517071f87ec9c484fb32d0034c03f3a">More...</a><br /></td></tr>
<tr class="separator:aa517071f87ec9c484fb32d0034c03f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1dc53423eb07931ef11918c35927d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a1c1dc53423eb07931ef11918c35927d0">bottom</a> () const </td></tr>
<tr class="memdesc:a1c1dc53423eb07931ef11918c35927d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the min and max value of each dimension.  <a href="#a1c1dc53423eb07931ef11918c35927d0">More...</a><br /></td></tr>
<tr class="separator:a1c1dc53423eb07931ef11918c35927d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aff3f53b0f24123f0d538c8ca24fb96ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aff3f53b0f24123f0d538c8ca24fb96ed">set_min</a> (const std::vector&lt; int &gt; &amp;mins)</td></tr>
<tr class="memdesc:aff3f53b0f24123f0d538c8ca24fb96ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the min coordinate of an image in the first N dimensions.  <a href="#aff3f53b0f24123f0d538c8ca24fb96ed">More...</a><br /></td></tr>
<tr class="separator:aff3f53b0f24123f0d538c8ca24fb96ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37b28d6ca3c8d406317362472d8740f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:af37b28d6ca3c8d406317362472d8740f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af37b28d6ca3c8d406317362472d8740f">set_min</a> (Args...args)</td></tr>
<tr class="memdesc:af37b28d6ca3c8d406317362472d8740f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the min coordinate of an image in the first N dimensions.  <a href="#af37b28d6ca3c8d406317362472d8740f">More...</a><br /></td></tr>
<tr class="separator:af37b28d6ca3c8d406317362472d8740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a32b659bc8241cb45b8a879fb6184a0de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a32b659bc8241cb45b8a879fb6184a0de">contains</a> (const std::vector&lt; int &gt; &amp;coords) const </td></tr>
<tr class="memdesc:a32b659bc8241cb45b8a879fb6184a0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a given coordinate is within the bounds of an image.  <a href="#a32b659bc8241cb45b8a879fb6184a0de">More...</a><br /></td></tr>
<tr class="separator:a32b659bc8241cb45b8a879fb6184a0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3789329c977c3b2be913d3ab75ddf145"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3789329c977c3b2be913d3ab75ddf145"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3789329c977c3b2be913d3ab75ddf145">contains</a> (Args...args) const </td></tr>
<tr class="memdesc:a3789329c977c3b2be913d3ab75ddf145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a given coordinate is within the bounds of an image.  <a href="#a3789329c977c3b2be913d3ab75ddf145">More...</a><br /></td></tr>
<tr class="separator:a3789329c977c3b2be913d3ab75ddf145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a69bb50f8b0e2f295ccea8fc5a6911849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a69bb50f8b0e2f295ccea8fc5a6911849">set_host_dirty</a> (bool v=true)</td></tr>
<tr class="memdesc:a69bb50f8b0e2f295ccea8fc5a6911849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a69bb50f8b0e2f295ccea8fc5a6911849">More...</a><br /></td></tr>
<tr class="separator:a69bb50f8b0e2f295ccea8fc5a6911849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4432ab0ef79b69a1490edce443ccba2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aa4432ab0ef79b69a1490edce443ccba2">device_dirty</a> () const </td></tr>
<tr class="memdesc:aa4432ab0ef79b69a1490edce443ccba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#aa4432ab0ef79b69a1490edce443ccba2">More...</a><br /></td></tr>
<tr class="separator:aa4432ab0ef79b69a1490edce443ccba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100ab21fe4346282af0544bea2a86da0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a100ab21fe4346282af0544bea2a86da0">host_dirty</a> () const </td></tr>
<tr class="memdesc:a100ab21fe4346282af0544bea2a86da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a100ab21fe4346282af0544bea2a86da0">More...</a><br /></td></tr>
<tr class="separator:a100ab21fe4346282af0544bea2a86da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3219cd20977b4e71add236e9145b7978"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3219cd20977b4e71add236e9145b7978">set_device_dirty</a> (bool v=true)</td></tr>
<tr class="memdesc:a3219cd20977b4e71add236e9145b7978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a3219cd20977b4e71add236e9145b7978">More...</a><br /></td></tr>
<tr class="separator:a3219cd20977b4e71add236e9145b7978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0af202d3ca2202627e8b80578a4b8e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af0af202d3ca2202627e8b80578a4b8e0">copy_to_host</a> (void *ctx=nullptr)</td></tr>
<tr class="memdesc:af0af202d3ca2202627e8b80578a4b8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#af0af202d3ca2202627e8b80578a4b8e0">More...</a><br /></td></tr>
<tr class="separator:af0af202d3ca2202627e8b80578a4b8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78605b601a2e0f548546d58cbee80eef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a78605b601a2e0f548546d58cbee80eef">copy_to_device</a> (const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface, void *ctx=nullptr)</td></tr>
<tr class="memdesc:a78605b601a2e0f548546d58cbee80eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a78605b601a2e0f548546d58cbee80eef">More...</a><br /></td></tr>
<tr class="separator:a78605b601a2e0f548546d58cbee80eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe">device_malloc</a> (const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface, void *ctx=nullptr)</td></tr>
<tr class="memdesc:ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe">More...</a><br /></td></tr>
<tr class="separator:ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f97463086f872f03d846bd13774401b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2f97463086f872f03d846bd13774401b">device_free</a> (void *ctx=nullptr)</td></tr>
<tr class="memdesc:a2f97463086f872f03d846bd13774401b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a2f97463086f872f03d846bd13774401b">More...</a><br /></td></tr>
<tr class="separator:a2f97463086f872f03d846bd13774401b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eab3a0f803010e2bbe998c5ba222fbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a5eab3a0f803010e2bbe998c5ba222fbe">device_wrap_native</a> (const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> handle, void *ctx=nullptr)</td></tr>
<tr class="memdesc:a5eab3a0f803010e2bbe998c5ba222fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a5eab3a0f803010e2bbe998c5ba222fbe">More...</a><br /></td></tr>
<tr class="separator:a5eab3a0f803010e2bbe998c5ba222fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f08f71aa63ed354760dc3d82156c913"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2f08f71aa63ed354760dc3d82156c913">device_detach_native</a> (void *ctx=nullptr)</td></tr>
<tr class="memdesc:a2f08f71aa63ed354760dc3d82156c913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a2f08f71aa63ed354760dc3d82156c913">More...</a><br /></td></tr>
<tr class="separator:a2f08f71aa63ed354760dc3d82156c913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785163ac59a479c35a1c40d6c7438196"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a785163ac59a479c35a1c40d6c7438196">device_and_host_malloc</a> (const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface, void *ctx=nullptr)</td></tr>
<tr class="memdesc:a785163ac59a479c35a1c40d6c7438196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a785163ac59a479c35a1c40d6c7438196">More...</a><br /></td></tr>
<tr class="separator:a785163ac59a479c35a1c40d6c7438196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e191e00e4e7be10f571f02d256adf2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8e191e00e4e7be10f571f02d256adf2d">device_and_host_free</a> (const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface, void *ctx=nullptr)</td></tr>
<tr class="memdesc:a8e191e00e4e7be10f571f02d256adf2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a8e191e00e4e7be10f571f02d256adf2d">More...</a><br /></td></tr>
<tr class="separator:a8e191e00e4e7be10f571f02d256adf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a7fb49d3ef831fcefde4e110d0dbba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad9a7fb49d3ef831fcefde4e110d0dbba">device_sync</a> (void *ctx=nullptr)</td></tr>
<tr class="memdesc:ad9a7fb49d3ef831fcefde4e110d0dbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#ad9a7fb49d3ef831fcefde4e110d0dbba">More...</a><br /></td></tr>
<tr class="separator:ad9a7fb49d3ef831fcefde4e110d0dbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7e8f92e86a4dd2707bc79b557bfb8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0f7e8f92e86a4dd2707bc79b557bfb8a">has_device_allocation</a> () const </td></tr>
<tr class="memdesc:a0f7e8f92e86a4dd2707bc79b557bfb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a0f7e8f92e86a4dd2707bc79b557bfb8a">More...</a><br /></td></tr>
<tr class="separator:a0f7e8f92e86a4dd2707bc79b557bfb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26820fb3dbdff826c26ff559510317c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139">BufferDeviceOwnership</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ab26820fb3dbdff826c26ff559510317c">device_ownership</a> () const </td></tr>
<tr class="memdesc:ab26820fb3dbdff826c26ff559510317c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the method by which the device field is managed.  <a href="#ab26820fb3dbdff826c26ff559510317c">More...</a><br /></td></tr>
<tr class="separator:ab26820fb3dbdff826c26ff559510317c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac7902663dbfb9dd5bfd912cac43ac22e"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ac7902663dbfb9dd5bfd912cac43ac22e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const not_void_T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ac7902663dbfb9dd5bfd912cac43ac22e">operator()</a> (int first, Args...rest) const </td></tr>
<tr class="memdesc:ac7902663dbfb9dd5bfd912cac43ac22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#ac7902663dbfb9dd5bfd912cac43ac22e">More...</a><br /></td></tr>
<tr class="separator:ac7902663dbfb9dd5bfd912cac43ac22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4d201d5dc57ab26ae257096f68c3b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const not_void_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ada4d201d5dc57ab26ae257096f68c3b2">operator()</a> () const </td></tr>
<tr class="memdesc:ada4d201d5dc57ab26ae257096f68c3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#ada4d201d5dc57ab26ae257096f68c3b2">More...</a><br /></td></tr>
<tr class="separator:ada4d201d5dc57ab26ae257096f68c3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21515ab5c7d44846928345e93230ef46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const not_void_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a21515ab5c7d44846928345e93230ef46">operator()</a> (const int *pos) const </td></tr>
<tr class="memdesc:a21515ab5c7d44846928345e93230ef46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#a21515ab5c7d44846928345e93230ef46">More...</a><br /></td></tr>
<tr class="separator:a21515ab5c7d44846928345e93230ef46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc7c0acfeeccc533292ff8aa78bf411"><td class="memTemplParams" colspan="2">template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a0dc7c0acfeeccc533292ff8aa78bf411"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> not_void_T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0dc7c0acfeeccc533292ff8aa78bf411">operator()</a> (int first, Args...rest)</td></tr>
<tr class="memdesc:a0dc7c0acfeeccc533292ff8aa78bf411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#a0dc7c0acfeeccc533292ff8aa78bf411">More...</a><br /></td></tr>
<tr class="separator:a0dc7c0acfeeccc533292ff8aa78bf411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e57ff7ae9db3df9e1ac0496315483d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> not_void_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a9e57ff7ae9db3df9e1ac0496315483d4">operator()</a> ()</td></tr>
<tr class="memdesc:a9e57ff7ae9db3df9e1ac0496315483d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#a9e57ff7ae9db3df9e1ac0496315483d4">More...</a><br /></td></tr>
<tr class="separator:a9e57ff7ae9db3df9e1ac0496315483d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f780f85d63212b6aaace8b3713d406a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> not_void_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8f780f85d63212b6aaace8b3713d406a">operator()</a> (const int *pos)</td></tr>
<tr class="memdesc:a8f780f85d63212b6aaace8b3713d406a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#a8f780f85d63212b6aaace8b3713d406a">More...</a><br /></td></tr>
<tr class="separator:a8f780f85d63212b6aaace8b3713d406a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4d0a0cc4790808e46084a6e26b399ed1"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename... Args, int N = sizeof...(Args) + 1&gt; </td></tr>
<tr class="memitem:a4d0a0cc4790808e46084a6e26b399ed1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4d0a0cc4790808e46084a6e26b399ed1">for_each_value</a> (Fn &amp;&amp;f, Args &amp;&amp;...other_buffers) const </td></tr>
<tr class="memdesc:a4d0a0cc4790808e46084a6e26b399ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function on every value in the buffer, and the corresponding values in some number of other buffers of the same size.  <a href="#a4d0a0cc4790808e46084a6e26b399ed1">More...</a><br /></td></tr>
<tr class="separator:a4d0a0cc4790808e46084a6e26b399ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a07082b0fe5d0e06c3f6fb3fa2b7797"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename... Args, int N = sizeof...(Args) + 1&gt; </td></tr>
<tr class="memitem:a0a07082b0fe5d0e06c3f6fb3fa2b7797"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0a07082b0fe5d0e06c3f6fb3fa2b7797">for_each_value</a> (Fn &amp;&amp;f, Args &amp;&amp;...other_buffers)</td></tr>
<tr class="memdesc:a0a07082b0fe5d0e06c3f6fb3fa2b7797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function on every value in the buffer, and the corresponding values in some number of other buffers of the same size.  <a href="#a0a07082b0fe5d0e06c3f6fb3fa2b7797">More...</a><br /></td></tr>
<tr class="separator:a0a07082b0fe5d0e06c3f6fb3fa2b7797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0cf726637c97b9a3aaaa0174151e244c"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a0cf726637c97b9a3aaaa0174151e244c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0cf726637c97b9a3aaaa0174151e244c">for_each_element</a> (Fn &amp;&amp;f) const </td></tr>
<tr class="memdesc:a0cf726637c97b9a3aaaa0174151e244c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function at each site in a buffer.  <a href="#a0cf726637c97b9a3aaaa0174151e244c">More...</a><br /></td></tr>
<tr class="separator:a0cf726637c97b9a3aaaa0174151e244c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad393aa0c8c02b91913cc093b0cb959d"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:aad393aa0c8c02b91913cc093b0cb959d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aad393aa0c8c02b91913cc093b0cb959d">for_each_element</a> (Fn &amp;&amp;f)</td></tr>
<tr class="memdesc:aad393aa0c8c02b91913cc093b0cb959d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function at each site in a buffer.  <a href="#aad393aa0c8c02b91913cc093b0cb959d">More...</a><br /></td></tr>
<tr class="separator:aad393aa0c8c02b91913cc093b0cb959d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a79d49b7ea3e9045ad11d1ca81c8ab408"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a79d49b7ea3e9045ad11d1ca81c8ab408">static_halide_type</a> ()</td></tr>
<tr class="memdesc:a79d49b7ea3e9045ad11d1ca81c8ab408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> type of T.  <a href="#a79d49b7ea3e9045ad11d1ca81c8ab408">More...</a><br /></td></tr>
<tr class="separator:a79d49b7ea3e9045ad11d1ca81c8ab408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d2f9350263f7cf70bb2c4ba7b9c99f"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a92d2f9350263f7cf70bb2c4ba7b9c99f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a92d2f9350263f7cf70bb2c4ba7b9c99f">can_convert_from</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a92d2f9350263f7cf70bb2c4ba7b9c99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if if an Buffer&lt;T, D&gt; can be constructed from some other <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> type.  <a href="#a92d2f9350263f7cf70bb2c4ba7b9c99f">More...</a><br /></td></tr>
<tr class="separator:a92d2f9350263f7cf70bb2c4ba7b9c99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffd23ee83f803d54a5af2bbf394650f"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a3ffd23ee83f803d54a5af2bbf394650f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3ffd23ee83f803d54a5af2bbf394650f">assert_can_convert_from</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a3ffd23ee83f803d54a5af2bbf394650f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fail an assertion at runtime or compile-time if an Buffer&lt;T, D&gt; cannot be constructed from some other <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> type.  <a href="#a3ffd23ee83f803d54a5af2bbf394650f">More...</a><br /></td></tr>
<tr class="separator:a3ffd23ee83f803d54a5af2bbf394650f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a91a4b8591494d648a720373c046f5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; void, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a68a91a4b8591494d648a720373c046f5">make_interleaved</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#acf79c935f9c932b199edc597ff101579">width</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#abcba83ef16a1817362b9b734d40d6ca9">height</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a7ecdfcb141d4433d580f962c2cd89e22">channels</a>)</td></tr>
<tr class="memdesc:a68a91a4b8591494d648a720373c046f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you use the (x, y, c) indexing convention, then <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> Buffers are stored planar by default.  <a href="#a68a91a4b8591494d648a720373c046f5">More...</a><br /></td></tr>
<tr class="separator:a68a91a4b8591494d648a720373c046f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cab9a483032a76377d6fc4af736cbf6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0cab9a483032a76377d6fc4af736cbf6">make_interleaved</a> (int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#acf79c935f9c932b199edc597ff101579">width</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#abcba83ef16a1817362b9b734d40d6ca9">height</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a7ecdfcb141d4433d580f962c2cd89e22">channels</a>)</td></tr>
<tr class="memdesc:a0cab9a483032a76377d6fc4af736cbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you use the (x, y, c) indexing convention, then <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> Buffers are stored planar by default.  <a href="#a0cab9a483032a76377d6fc4af736cbf6">More...</a><br /></td></tr>
<tr class="separator:a0cab9a483032a76377d6fc4af736cbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22944f400ab4cad685d14ea409e7cb7f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; add_const_if_T_is_const&lt; void &gt;, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a22944f400ab4cad685d14ea409e7cb7f">make_interleaved</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, T *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3814e3ef9f982a3aa036e90db2078006">data</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#acf79c935f9c932b199edc597ff101579">width</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#abcba83ef16a1817362b9b734d40d6ca9">height</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a7ecdfcb141d4433d580f962c2cd89e22">channels</a>)</td></tr>
<tr class="memdesc:a22944f400ab4cad685d14ea409e7cb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an existing interleaved image.  <a href="#a22944f400ab4cad685d14ea409e7cb7f">More...</a><br /></td></tr>
<tr class="separator:a22944f400ab4cad685d14ea409e7cb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac79a1e37885495b3d55dafbddda3dd1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aac79a1e37885495b3d55dafbddda3dd1">make_interleaved</a> (T *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3814e3ef9f982a3aa036e90db2078006">data</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#acf79c935f9c932b199edc597ff101579">width</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#abcba83ef16a1817362b9b734d40d6ca9">height</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a7ecdfcb141d4433d580f962c2cd89e22">channels</a>)</td></tr>
<tr class="memdesc:aac79a1e37885495b3d55dafbddda3dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an existing interleaved image.  <a href="#aac79a1e37885495b3d55dafbddda3dd1">More...</a><br /></td></tr>
<tr class="separator:aac79a1e37885495b3d55dafbddda3dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc86335ea3d7af1a0a100d7dd656890e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; add_const_if_T_is_const&lt; void &gt;, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#afc86335ea3d7af1a0a100d7dd656890e">make_scalar</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t)</td></tr>
<tr class="memdesc:afc86335ea3d7af1a0a100d7dd656890e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a zero-dimensional <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#afc86335ea3d7af1a0a100d7dd656890e">More...</a><br /></td></tr>
<tr class="separator:afc86335ea3d7af1a0a100d7dd656890e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5033829573b98879635866922698f26a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a5033829573b98879635866922698f26a">make_scalar</a> ()</td></tr>
<tr class="memdesc:a5033829573b98879635866922698f26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a zero-dimensional <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#a5033829573b98879635866922698f26a">More...</a><br /></td></tr>
<tr class="separator:a5033829573b98879635866922698f26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbfc035a550f75691c1df0f6f0cfa41"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a5bbfc035a550f75691c1df0f6f0cfa41">make_scalar</a> (T *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3814e3ef9f982a3aa036e90db2078006">data</a>)</td></tr>
<tr class="memdesc:a5bbfc035a550f75691c1df0f6f0cfa41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a zero-dimensional <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> that points to non-owned, existing data.  <a href="#a5bbfc035a550f75691c1df0f6f0cfa41">More...</a><br /></td></tr>
<tr class="separator:a5bbfc035a550f75691c1df0f6f0cfa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf19ec15f1195600de758addfd1069a0"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:adf19ec15f1195600de758addfd1069a0"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#adf19ec15f1195600de758addfd1069a0">make_with_shape_of</a> (<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; src, void *(*allocate_fn)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)=nullptr, void(*deallocate_fn)(void *)=nullptr)</td></tr>
<tr class="memdesc:adf19ec15f1195600de758addfd1069a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a buffer with the same shape and memory nesting order as another buffer.  <a href="#adf19ec15f1195600de758addfd1069a0">More...</a><br /></td></tr>
<tr class="separator:adf19ec15f1195600de758addfd1069a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6a0432e50ffc161961ae3af4d5a6c98a"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a6a0432e50ffc161961ae3af4d5a6c98a">has_static_halide_type</a> = !T_is_void</td></tr>
<tr class="memdesc:a6a0432e50ffc161961ae3af4d5a6c98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> type is not void (or const void).  <a href="#a6a0432e50ffc161961ae3af4d5a6c98a">More...</a><br /></td></tr>
<tr class="separator:a6a0432e50ffc161961ae3af4d5a6c98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T = void, int D = 4&gt;<br />
class Halide::Runtime::Buffer&lt; T, D &gt;</h3>

<p>A templated <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> class that wraps <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> and adds functionality. </p>
<p>When using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> from C++, this is the preferred way to create input and output buffers. The overhead of using this class relative to a naked <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> is minimal - it uses another ~16 bytes on the stack, and does no dynamic allocations when using it to represent existing memory of a known maximum dimensionality.</p>
<p>The template parameter T is the element type. For buffers where the element type is unknown, or may vary, use void or const void.</p>
<p>D is the maximum number of dimensions that can be represented using space inside the class itself. Set it to the maximum dimensionality you expect this buffer to be. If the actual dimensionality exceeds this, heap storage is allocated to track the shape of the buffer. D defaults to 4, which should cover nearly all usage.</p>
<p>The class optionally allocates and owns memory for the image using a shared pointer allocated with the provided allocator. If they are null, malloc and free are used. Any device-side allocation is considered as owned if and only if the host-side allocation is owned. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_10_aot_compilation_run_8cpp-example.html#_a0">tutorial/lesson_10_aot_compilation_run.cpp</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00043">43</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a897dbebfae1a242dbac4e509861266dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a897dbebfae1a242dbac4e509861266dd">ElemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00437">437</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acb70f579cf7cab5457f5ce88d771ac93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00586">586</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7a9d31fcdc71f7c00dafe9d076e9dc27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139">BufferDeviceOwnership</a>&#160;</td>
          <td class="paramname"><em>ownership</em> = <code><a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139a6b982c948840b6e4b5fec2711f09627d">BufferDeviceOwnership::Unmanaged</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a>. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00593">593</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a47307ea974c0025db0b9d6bc646de65c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Does not copy underlying data. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00639">639</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1b96681d758ad414ff7751bca77ae863"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of different dimensionality and type. </p>
<p>Asserts that the type matches (at runtime, if one of the types is void). Note that this constructor is implicit. This, for example, lets you pass things like Buffer&lt;T&gt; or Buffer&lt;const void&gt; to functions expected Buffer&lt;const T&gt;. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00654">654</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a19d1e07cb83829f379affad9123726c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00664">664</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2649e245b86b2975807b11a0d91f766e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of different dimensionality and type. </p>
<p>Asserts that the types match (at runtime if one of the types is void). </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00678">678</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="abb2b58ef872e9fd22baac742271901d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of the given size with a runtime type. </p>
<p>Only used when you do know what size you want but you don't know statically what type the elements are. Pass zeroes to make a buffer suitable for bounds query calls. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00815">815</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1b9d3997c7c6d260a3419cda075178d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of the given size. </p>
<p>Pass zeroes to make a buffer suitable for bounds query calls. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00836">836</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a32797f424892a4c602bac1054e8a99cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of the given size. </p>
<p>Pass zeroes to make a buffer suitable for bounds query calls. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00852">852</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0013744b24a2a075b4fd1ef123af495b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of unknown type using a vector of ints as the size. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00868">868</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a52db43880a5c487452f11936cb1166ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of known type using a vector of ints as the size. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00882">882</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a13a16d6c1d993b9c65e68aa204f893ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of unknown type using a vector of ints as the size and a vector of indices indicating the storage order for each dimension. </p>
<p>The length of the sizes vector and the storage-order vector must match. For instance, to allocate an interleaved RGB buffer, you would pass {2, 0, 1} for storage_order. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00902">902</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a72de05f0ec501ab2d7e130faaa5e25e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>storage_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00907">907</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7aac7bbcf212bfd87b017ded998140a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Array , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">Array(&amp;)&#160;</td>
          <td class="paramname"><em>vals</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> that refers to a statically sized array. </p>
<p>Does not take ownership of the data, and does not set the host_dirty flag. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00914">914</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4998f8f4bae8c24ae47b19089de35b8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_const_if_T_is_const&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of runtime type from a pointer and some sizes. </p>
<p>Assumes dense row-major packing and a min coordinate of zero. Does not take ownership of the data and does not set the host_dirty flag. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00928">928</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a42234017b02db28ba6633b628c03868e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer and some sizes. </p>
<p>Assumes dense row-major packing and a min coordinate of zero. Does not take ownership of the data and does not set the host_dirty flag. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00945">945</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a31c020e81707b663ee4761d852222e94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer and a vector of sizes. </p>
<p>Assumes dense row-major packing and a min coordinate of zero. Does not take ownership of the data and does not set the host_dirty flag. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00958">958</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae9301d7908f8580de77b58384eb19582"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_const_if_T_is_const&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of runtime type from a pointer and a vector of sizes. </p>
<p>Assumes dense row-major packing and a min coordinate of zero. Does not take ownership of the data and does not set the host_dirty flag. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00969">969</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a00ce543ccc08cc06bf35050a0fca989e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_const_if_T_is_const&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> *&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and an array describing the shape. </p>
<p>Does not take ownership of the data, and does not set the host_dirty flag. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00982">982</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad536066ac6994e015090a7c7edf59e68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_const_if_T_is_const&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and a vector describing the shape. </p>
<p>Does not take ownership of the data, and does not set the host_dirty flag. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00997">997</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a84a2b9d12d26d24480c0519490ee975e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> *&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and an array describing the shape. </p>
<p>Does not take ownership of the data and does not set the host_dirty flag. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01005">1005</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1d14c533acc38b5737b9b832822ec8cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and a vector describing the shape. </p>
<p>Does not take ownership of the data, and does not set the host_dirty flag. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01017">1017</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab3f46c67f0f5210b97b570a3e7fac95e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::~<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Will release any underlying owned allocation if this is the last reference to it. Will assert fail if there are weak references to this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> outstanding. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01024">1024</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a79d49b7ea3e9045ad11d1ca81c8ab408"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structhalide__type__t.html">halide_type_t</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::static_halide_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> type of T. </p>
<p>Callers should not use the result if has_static_halide_type is false. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00172">172</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_buffer_8h_source.html#l00508">Halide::Buffer&lt; void &gt;::static_halide_type()</a>.</p>

</div>
</div>
<a class="anchor" id="a68535e517e8356e1bf1e22a8d8da5d5f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::owns_host_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> own the host memory it refers to? </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00177">177</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a82f3d58acaccbdcba70de2e854550fc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer_1_1_dimension.html">Dimension</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::dim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the shape of the buffer. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00496">496</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01209">Halide::Runtime::Buffer&lt; double * &gt;::copy_from()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d66fbdc79107f8b6ff11c3cf1add174"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::min </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the mins, strides, extents. </p>
<p>Will be deprecated. Do not use. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00503">503</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a13379161fe8d341bd0fbd4efee874a7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::extent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the mins, strides, extents. </p>
<p>Will be deprecated. Do not use. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00506">506</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a029ad7be5ae8188583b39e8d50bc35e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::stride </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the mins, strides, extents. </p>
<p>Will be deprecated. Do not use. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00509">509</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad16c3ceaa12ee1e1998cd2ab597d86e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::number_of_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of elements this buffer represents. </p>
<p>Equal to the product of the extents </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00516">516</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaefeb8ca81329c0f91a08935418956ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimensionality of the buffer. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00525">525</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01209">Halide::Runtime::Buffer&lt; double * &gt;::copy_from()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01777">Halide::Runtime::Buffer&lt; double * &gt;::make_with_shape_of()</a>.</p>

</div>
</div>
<a class="anchor" id="ad788c908d6b1dcd0c7c1acc5d0a37bc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhalide__type__t.html">halide_type_t</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of the elements. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00530">530</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00619">Halide::Runtime::Buffer&lt; double * &gt;::can_convert_from()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01777">Halide::Runtime::Buffer&lt; double * &gt;::make_with_shape_of()</a>, and <a class="el" href="_buffer_8h_source.html#l00521">Halide::Buffer&lt; void &gt;::type()</a>.</p>

</div>
</div>
<a class="anchor" id="a506c21bfc249b172536a5dfb59b16da4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the element with the lowest address. </p>
<p>If all strides are positive, equal to the host pointer. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00563">563</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="af6d4c313c43fead663bcff07e53f7d3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to one beyond the element with the highest address. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00569">569</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab8b41f324dcf5b0cf2f46ab6e3d5f00e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::size_in_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of bytes spanned by the data in memory. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00575">575</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab8ef51e46c14c186f0c2b18f664b5e31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> to be equivalent to a default-constructed <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of the same static type (if any); <a class="el" href="class_halide_1_1_buffer.html">Buffer&lt;void&gt;</a> will have its runtime type reset to uint8. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00582">582</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a92d2f9350263f7cf70bb2c4ba7b9c99f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::can_convert_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if if an Buffer&lt;T, D&gt; can be constructed from some other <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> type. </p>
<p>If this can be determined at compile time, fail with a static assert; otherwise return a boolean based on runtime typing. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00619">619</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_buffer_8h_source.html#l00513">Halide::Buffer&lt; void &gt;::can_convert_from()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ffd23ee83f803d54a5af2bbf394650f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::assert_can_convert_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fail an assertion at runtime or compile-time if an Buffer&lt;T, D&gt; cannot be constructed from some other <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> type. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00630">630</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01054">Halide::Runtime::Buffer&lt; double * &gt;::as()</a>.</p>

</div>
</div>
<a class="anchor" id="a73b21234b1b51c23d70dde4c7bc0ce68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign from another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality and type. </p>
<p>Asserts that the types match (at runtime if one of the types is void). </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00693">693</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a38b0a9cb0fed41c0445d6927240bb50c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard assignment operator. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00709">709</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2feda3bb0e3bde94f01791b2c3f45449"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move from another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality and type. </p>
<p>Asserts that the types match (at runtime if one of the types is void). </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00727">727</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="af08d24f88faa83c622ab1a17c3c62310"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard move-assignment operator. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00742">742</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab7961b0f7ee27508c36fb019d3d3a67e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::check_overflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the product of the extents fits in memory. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00756">756</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a759f8c2487886eb85bc2607f11beabd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">void *(*)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)&#160;</td>
          <td class="paramname"><em>allocate_fn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>deallocate_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>
<p>Drops the reference to any owned memory. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00771">771</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01156">Halide::Runtime::Buffer&lt; double * &gt;::copy_to_interleaved()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01169">Halide::Runtime::Buffer&lt; double * &gt;::copy_to_planar()</a>.</p>

</div>
</div>
<a class="anchor" id="a65b39bfac1c4ccca5eb45af9cfbeed7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop reference to any owned host or device memory, possibly freeing it, if this buffer held the last reference to it. </p>
<p>Retains the shape of the buffer. Does nothing if this buffer did not allocate its own memory. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00798">798</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="af82da5ef4c1264386e705ef9b7e475c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop reference to any owned device memory, possibly freeing it if this buffer held the last reference to it. </p>
<p>Asserts that device_dirty is false. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00805">805</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01265">Halide::Runtime::Buffer&lt; double * &gt;::cropped()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01459">Halide::Runtime::Buffer&lt; double * &gt;::sliced()</a>.</p>

</div>
</div>
<a class="anchor" id="a2fcb27dc04a87015427ad6aa4bd55e89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a>* <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::raw_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the raw <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> this wraps. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01031">1031</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="afbb951224200a90c4cd127e7d091c5f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a>* <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::raw_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the raw <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> this wraps. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01035">1035</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2a6e8717724ac6b06571a1d0d82c064e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a cast operator to <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> *, so that instances can be passed directly to <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> filters. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01042">1042</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4d8f8c9e94c65bf57359e157cf73a239"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2 = D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T2, D2&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::as </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a typed reference to this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>
<p>Useful for converting a reference to a <a class="el" href="class_halide_1_1_buffer.html">Buffer&lt;void&gt;</a> to a reference to, for example, a Buffer&lt;const uint8_t&gt;, or converting a Buffer&lt;T&gt;&amp; to Buffer&lt;const T&gt;&amp;. Does a runtime assert if the source buffer type is void. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01054">1054</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_buffer_8h_source.html#l00530">Halide::Buffer&lt; void &gt;::copy()</a>.</p>

</div>
</div>
<a class="anchor" id="aa3e5981bd7a2303ee817237b18fef618"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2 = D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T2, D2&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::as </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const typed reference to this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>
<p>Useful for converting a conference reference to one <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> type to a const reference to another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> type. Does a runtime assert if the source buffer type is void. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01065">1065</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7d898fb973e24ded5ead67fbf19bb20c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2 = D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T2, D2&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::as </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this rval <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> with a different type attached. </p>
<p>Does a dynamic type check if the source type is void. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01075">1075</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a702f639c8005677dbe66a50181df17e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;typename std::add_const&lt;T&gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad788c908d6b1dcd0c7c1acc5d0a37bc2">type</a>, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::as_const </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a702f639c8005677dbe66a50181df17e2" title="as_const() is syntactic sugar for .as&lt;const T&gt;(), to avoid the need to recapitulate the type argument...">as_const()</a> is syntactic sugar for .<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4d8f8c9e94c65bf57359e157cf73a239" title="Return a typed reference to this Buffer. ">as&lt;const T&gt;()</a>, to avoid the need to recapitulate the type argument. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01084">1084</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9d75c45addc0b569abe9876cd7f90962"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;typename std::add_const&lt;T&gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad788c908d6b1dcd0c7c1acc5d0a37bc2">type</a>, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::as_const </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a702f639c8005677dbe66a50181df17e2" title="as_const() is syntactic sugar for .as&lt;const T&gt;(), to avoid the need to recapitulate the type argument...">as_const()</a> is syntactic sugar for .<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4d8f8c9e94c65bf57359e157cf73a239" title="Return a typed reference to this Buffer. ">as&lt;const T&gt;()</a>, to avoid the need to recapitulate the type argument. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01091">1091</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="adae97e4679611d7f944cc67ee487d66f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;typename std::add_const&lt;T&gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad788c908d6b1dcd0c7c1acc5d0a37bc2">type</a>, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::as_const </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a702f639c8005677dbe66a50181df17e2" title="as_const() is syntactic sugar for .as&lt;const T&gt;(), to avoid the need to recapitulate the type argument...">as_const()</a> is syntactic sugar for .<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4d8f8c9e94c65bf57359e157cf73a239" title="Return a typed reference to this Buffer. ">as&lt;const T&gt;()</a>, to avoid the need to recapitulate the type argument. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01096">1096</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="acf79c935f9c932b199edc597ff101579"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the first three dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01103">1103</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="abcba83ef16a1817362b9b734d40d6ca9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the first three dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01106">1106</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7ecdfcb141d4433d580f962c2cd89e22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::channels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the first three dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01109">1109</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a78fa4b85ee3f1a486e1fd7e24d78e62e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the min and max value of each dimension. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01116">1116</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a30c0b402a62f374130f0645bd633b507"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the min and max value of each dimension. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01120">1120</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa517071f87ec9c484fb32d0034c03f3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the min and max value of each dimension. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01124">1124</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c1dc53423eb07931ef11918c35927d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::bottom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the min and max value of each dimension. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01128">1128</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3763a8dccaf387d0071f22f0f10135d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;not_const_T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">void *(*)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)&#160;</td>
          <td class="paramname"><em>allocate_fn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>deallocate_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a new image which is a deep copy of this image. </p>
<p>Use crop or slice followed by copy to make a copy of only a portion of the image. The new image uses the same memory layout as the original, with holes compacted away. Note that the returned <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> is always of a non-const type T (ie: </p><pre class="fragment">Buffer&lt;const T&gt;.copy() -&gt; Buffer&lt;T&gt; rather than Buffer&lt;const T&gt;
</pre><p>which is always safe, since we are making a deep copy. (The caller can easily cast it back to Buffer&lt;const T&gt; if desired, which is always safe and free.) </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01145">1145</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac333783142c4d3911129c022a5930eb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;not_const_T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::copy_to_interleaved </td>
          <td>(</td>
          <td class="paramtype">void *(*)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)&#160;</td>
          <td class="paramname"><em>allocate_fn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>deallocate_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3763a8dccaf387d0071f22f0f10135d4" title="Make a new image which is a deep copy of this image. ">copy()</a>, but the copy is created in interleaved memory layout (vs. </p>
<p>keeping the same memory layout as the original). Requires that 'this' has exactly 3 dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01156">1156</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="acf1f20fa69d87c8234e6452837f70d57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;not_const_T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::copy_to_planar </td>
          <td>(</td>
          <td class="paramtype">void *(*)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)&#160;</td>
          <td class="paramname"><em>allocate_fn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>deallocate_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3763a8dccaf387d0071f22f0f10135d4" title="Make a new image which is a deep copy of this image. ">copy()</a>, but the copy is created in planar memory layout (vs. </p>
<p>keeping the same memory layout as the original). </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01169">1169</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="adaa2bfab2ea348fb5c7392d50d3b290f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::alias </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a copy of the <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> which shares the underlying host and/or device allocations as the existing <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>
<p>This is purely syntactic sugar for cases where you have a const reference to a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> but need a temporary non-const copy (e.g. to make a call into AOT-generated <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> code), and want a terse inline way to create a temporary.</p><div class="fragment"><div class="line"><span class="keywordtype">void</span> call_my_func(<span class="keyword">const</span> Buffer&lt;const uint8_t&gt;&amp; input) {</div><div class="line">    my_func(input.alias(), output);</div><div class="line">}</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01195">1195</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac9982b308f61426dd5a33aa31dfc156f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> with the values at the same coordinates in another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>
<p>Restricts itself to coordinates contained within the intersection of the two buffers. If the two Buffers are not in the same coordinate system, you will need to translate the argument <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> first. E.g. if you're blitting a sprite onto a framebuffer, you'll want to translate the sprite to the correct location first like so:</p><div class="fragment"><div class="line">framebuffer.copy_from(sprite.translated({x, y})); </div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01209">1209</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01145">Halide::Runtime::Buffer&lt; double * &gt;::copy()</a>, <a class="el" href="_buffer_8h_source.html#l00535">Halide::Buffer&lt; void &gt;::copy_from()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01156">Halide::Runtime::Buffer&lt; double * &gt;::copy_to_interleaved()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01169">Halide::Runtime::Buffer&lt; double * &gt;::copy_to_planar()</a>.</p>

</div>
</div>
<a class="anchor" id="aafbc2b5dec589194eef2c2856b8ef732"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::cropped </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image that refers to a sub-range of this image along the given dimension. </p>
<p>Asserts that the crop region is within the existing bounds: you cannot "crop outwards", even if you know there is valid <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> storage (e.g. because you already cropped inwards). </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01265">1265</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4a4e4a871377e1eb48980b5fc697c276"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::crop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crop an image in-place along the given dimension. </p>
<p>This does not move any data around in memory - it just changes the min and extent of the given dimension. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01285">1285</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01209">Halide::Runtime::Buffer&lt; double * &gt;::copy_from()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f4e9b37a5d038c889cf0e9f8e6518bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::cropped </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image that refers to a sub-rectangle of this image along the first N dimensions. </p>
<p>Asserts that the crop region is within the existing bounds. The cropped image may drop any device handle if the device_interface cannot accomplish the crop in-place. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01301">1301</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a73e4477fcde56c9f0f448281cd15efad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::crop </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crop an image in-place along the first N dimensions. </p>
<p>This does not move any data around in memory, nor does it free memory. It just rewrites the min/extent of each dimension to refer to a subregion of the same allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01322">1322</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9ceba660b052e7c783d604225cc94c48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::translated </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image which refers to the same data with using translated coordinates in the given dimension. </p>
<p>Positive values move the image data to the right or down relative to the coordinate system. Drops any device handle. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01338">1338</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a08186761f27f13d4097e85b467d2b534"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::translate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate an image in-place along one dimension by changing how it is indexed. </p>
<p>Does not move any data around in memory. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01346">1346</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01338">Halide::Runtime::Buffer&lt; double * &gt;::translated()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e7c882a0d5181db473ab23940ef8022"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::translated </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image which refers to the same data translated along the first N dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01354">1354</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a401c86c132079debb43a85b5957ed9a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::translate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate an image along the first N dimensions by changing how it is indexed. </p>
<p>Does not move any data around in memory. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01362">1362</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aff3f53b0f24123f0d538c8ca24fb96ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::set_min </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the min coordinate of an image in the first N dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01374">1374</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01156">Halide::Runtime::Buffer&lt; double * &gt;::copy_to_interleaved()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01169">Halide::Runtime::Buffer&lt; double * &gt;::copy_to_planar()</a>.</p>

</div>
</div>
<a class="anchor" id="af37b28d6ca3c8d406317362472d8740f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::set_min </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the min coordinate of an image in the first N dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01383">1383</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a32b659bc8241cb45b8a879fb6184a0de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a given coordinate is within the bounds of an image. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01390">1390</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3789329c977c3b2be913d3ab75ddf145"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a given coordinate is within the bounds of an image. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01401">1401</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a12d26b45fc275f98707b449ddffe4722"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::transposed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a buffer which refers to the same data in the same layout using a swapped indexing order for the dimensions given. </p>
<p>So A = B.transposed(0, 1) means that A(i, j) == B(j, i), and more strongly that A.address_of(i, j) == B.address_of(j, i). </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01410">1410</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8ca18450bcc383920ca5f69a9b04b097"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::transpose </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose a buffer in-place by changing how it is indexed. </p>
<p>For example, transpose(0, 1) on a two-dimensional buffer means that the value referred to by coordinates (i, j) is now reached at the coordinates (j, i), and vice versa. This is done by reordering the per-dimension metadata rather than by moving data around in memory, so other views of the same memory will not see the data as having been transposed. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01423">1423</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01720">Halide::Runtime::Buffer&lt; double * &gt;::make_interleaved()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01410">Halide::Runtime::Buffer&lt; double * &gt;::transposed()</a>.</p>

</div>
</div>
<a class="anchor" id="a2cbcff09c23d77a1c008409bdcaab258"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::transpose </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A generalized transpose: instead of swapping two dimensions, pass a vector that lists each dimension index exactly once, in the desired order. </p>
<p>This does not move any data around in memory</p><ul>
<li>it just permutes how it is indexed. </li>
</ul>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01433">1433</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="adff164451de419f2076ebafefaedb8b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::transposed </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a buffer which refers to the same data in the same layout using a different ordering of the dimensions. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01451">1451</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aaab954688f8a932fd039a59bb1f309f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::sliced </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a lower-dimensional buffer that refers to one slice of this buffer. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01459">1459</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="af913de6ba9a380076d4ccc4a9bc8918a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::sliced </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a lower-dimensional buffer that refers to one slice of this buffer at the dimension's minimum. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01476">1476</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2ba2eeed0bf8a096915189de65a5922b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrite the buffer to refer to a single lower-dimensional slice of itself along the given dimension at the given coordinate. </p>
<p>Does not move any data around or free the original memory, so other views of the same data are unaffected. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01484">1484</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01754">Halide::Runtime::Buffer&lt; double * &gt;::make_scalar()</a>.</p>

</div>
</div>
<a class="anchor" id="aa78a00f58dc9628885afb731ffb6fb94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slice a buffer in-place at the dimension's minimum. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01497">1497</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a877b74e2b37ba6c0ca70bbee32681d1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::embedded </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a new buffer that views this buffer as a single slice in a higher-dimensional space. </p>
<p>The new dimension has extent one and the given min. This operation is the opposite of slice. As an example, the following condition is true:</p>
<div class="fragment"><div class="line">im2 = im.embedded(1, 17);</div><div class="line">&amp;im(x, y, c) == &amp;im2(x, 17, y, c);</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01511">1511</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae06c4248b118d756c9678996ace05030"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::embed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Embed a buffer in-place, increasing the dimensionality. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01519">1519</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01511">Halide::Runtime::Buffer&lt; double * &gt;::embedded()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2bcf81706f57476668568dd8ea2c403"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::add_dimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new dimension with a min of zero and an extent of one. </p>
<p>The stride is the extent of the outermost dimension times its stride. The new dimension is the last dimension. This is a special case of embed. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01532">1532</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae7993fdda560897f4d745177470f03d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::add_dimension_with_stride </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new dimension with a min of zero, an extent of one, and the specified stride. </p>
<p>The new dimension is the last dimension. This is a special case of embed. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01563">1563</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a69bb50f8b0e2f295ccea8fc5a6911849"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::set_host_dirty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01573">1573</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa4432ab0ef79b69a1490edce443ccba2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_dirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01582">1582</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01209">Halide::Runtime::Buffer&lt; double * &gt;::copy_from()</a>.</p>

</div>
</div>
<a class="anchor" id="a100ab21fe4346282af0544bea2a86da0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::host_dirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01586">1586</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3219cd20977b4e71add236e9145b7978"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::set_device_dirty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01590">1590</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="af0af202d3ca2202627e8b80578a4b8e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::copy_to_host </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01595">1595</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a78605b601a2e0f548546d58cbee80eef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::copy_to_device </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01602">1602</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_buffer_8h_source.html#l00586">Halide::Buffer&lt; void &gt;::copy_to_device()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_malloc </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01609">1609</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_buffer_8h_source.html#l00596">Halide::Buffer&lt; void &gt;::device_malloc()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f97463086f872f03d846bd13774401b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01613">1613</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5eab3a0f803010e2bbe998c5ba222fbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_wrap_native </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01636">1636</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_buffer_8h_source.html#l00605">Halide::Buffer&lt; void &gt;::device_wrap_native()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f08f71aa63ed354760dc3d82156c913"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_detach_native </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01644">1644</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a785163ac59a479c35a1c40d6c7438196"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_and_host_malloc </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01666">1666</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8e191e00e4e7be10f571f02d256adf2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_and_host_free </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01670">1670</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad9a7fb49d3ef831fcefde4e110d0dbba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_sync </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01693">1693</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0f7e8f92e86a4dd2707bc79b557bfb8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::has_device_allocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01701">1701</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab26820fb3dbdff826c26ff559510317c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139">BufferDeviceOwnership</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_ownership </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the method by which the device field is managed. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01706">1706</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a68a91a4b8591494d648a720373c046f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;void, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_interleaved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If you use the (x, y, c) indexing convention, then <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> Buffers are stored planar by default. </p>
<p>This function constructs an interleaved RGB or RGBA image that can still be indexed using (x, y, c). Passing it to a generator requires that the generator has been compiled with support for interleaved (also known as packed or chunky) memory layouts. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01720">1720</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01156">Halide::Runtime::Buffer&lt; double * &gt;::copy_to_interleaved()</a>, and <a class="el" href="_buffer_8h_source.html#l00313">Halide::Buffer&lt; void &gt;::make_interleaved()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cab9a483032a76377d6fc4af736cbf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_interleaved </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If you use the (x, y, c) indexing convention, then <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> Buffers are stored planar by default. </p>
<p>This function constructs an interleaved RGB or RGBA image that can still be indexed using (x, y, c). Passing it to a generator requires that the generator has been compiled with support for interleaved (also known as packed or chunky) memory layouts. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01735">1735</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a22944f400ab4cad685d14ea409e7cb7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;add_const_if_T_is_const&lt;void&gt;, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_interleaved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an existing interleaved image. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01741">1741</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aac79a1e37885495b3d55dafbddda3dd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_interleaved </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an existing interleaved image. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01749">1749</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="afc86335ea3d7af1a0a100d7dd656890e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;add_const_if_T_is_const&lt;void&gt;, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a zero-dimensional <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01754">1754</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5033829573b98879635866922698f26a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a zero-dimensional <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01761">1761</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_buffer_8h_source.html#l00301">Halide::Buffer&lt; void &gt;::make_scalar()</a>.</p>

</div>
</div>
<a class="anchor" id="a5bbfc035a550f75691c1df0f6f0cfa41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_scalar </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a zero-dimensional <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> that points to non-owned, existing data. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01768">1768</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="adf19ec15f1195600de758addfd1069a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_with_shape_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)&#160;</td>
          <td class="paramname"><em>allocate_fn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>deallocate_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a buffer with the same shape and memory nesting order as another buffer. </p>
<p>It may have a different type. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01777">1777</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01145">Halide::Runtime::Buffer&lt; double * &gt;::copy()</a>, and <a class="el" href="_buffer_8h_source.html#l00336">Halide::Buffer&lt; void &gt;::make_with_shape_of()</a>.</p>

</div>
</div>
<a class="anchor" id="a3814e3ef9f982a3aa036e90db2078006"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the address of the min coordinate. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01871">1871</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac7902663dbfb9dd5bfd912cac43ac22e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const not_void_T&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. The non-const versions set the host_dirty flag to true. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01884">1884</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ada4d201d5dc57ab26ae257096f68c3b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const not_void_T&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. The non-const versions set the host_dirty flag to true. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01893">1893</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a21515ab5c7d44846928345e93230ef46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const not_void_T&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. The non-const versions set the host_dirty flag to true. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01902">1902</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0dc7c0acfeeccc533292ff8aa78bf411"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> not_void_T&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. The non-const versions set the host_dirty flag to true. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01913">1913</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9e57ff7ae9db3df9e1ac0496315483d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> not_void_T&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. The non-const versions set the host_dirty flag to true. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01922">1922</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8f780f85d63212b6aaace8b3713d406a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> not_void_T&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. The non-const versions set the host_dirty flag to true. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01931">1931</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a93f75e4f03ef78e7dbabdce60f34b02a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::all_equal </td>
          <td>(</td>
          <td class="paramtype">not_void_T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests that all values in this buffer are equal to val. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01940">1940</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad6da53ff0035c65d762d91bb618f38f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">not_void_T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01946">1946</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4d0a0cc4790808e46084a6e26b399ed1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename... Args, int N = sizeof...(Args) + 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::for_each_value </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>other_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function on every value in the buffer, and the corresponding values in some number of other buffers of the same size. </p>
<p>The function should take a reference, const reference, or value of the correct type for each buffer. This effectively lifts a function of scalars to an element-wise function of buffers. This produces code that the compiler can autovectorize. This is slightly cheaper than for_each_element, because it does not need to track the coordinates.</p>
<p>Note that constness of Buffers is preserved: a const Buffer&lt;T&gt; (for either 'this' or the other-buffers arguments) will allow mutation of the buffer contents, while a Buffer&lt;const T&gt; will not. Attempting to specify a mutable reference for the lambda argument of a Buffer&lt;const T&gt; will result in a compilation error. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l02107">2107</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p>Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01209">Halide::Runtime::Buffer&lt; double * &gt;::copy_from()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a07082b0fe5d0e06c3f6fb3fa2b7797"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename... Args, int N = sizeof...(Args) + 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::for_each_value </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>other_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function on every value in the buffer, and the corresponding values in some number of other buffers of the same size. </p>
<p>The function should take a reference, const reference, or value of the correct type for each buffer. This effectively lifts a function of scalars to an element-wise function of buffers. This produces code that the compiler can autovectorize. This is slightly cheaper than for_each_element, because it does not need to track the coordinates.</p>
<p>Note that constness of Buffers is preserved: a const Buffer&lt;T&gt; (for either 'this' or the other-buffers arguments) will allow mutation of the buffer contents, while a Buffer&lt;const T&gt; will not. Attempting to specify a mutable reference for the lambda argument of a Buffer&lt;const T&gt; will result in a compilation error. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l02115">2115</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0cf726637c97b9a3aaaa0174151e244c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::for_each_element </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function at each site in a buffer. </p>
<p>This is likely to be much slower than using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> code to populate a buffer, but is convenient for tests. If the function has more arguments than the buffer has dimensions, the remaining arguments will be zero. If it has fewer arguments than the buffer has dimensions then the last few dimensions of the buffer are not iterated over. For example, the following code exploits this to set a floating point RGB image to red:</p>
<div class="fragment"><div class="line">Buffer&lt;float, 3&gt; im(100, 100, 3);</div><div class="line">im.for_each_element([&amp;](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) {</div><div class="line">    im(x, y, 0) = 1.0f;</div><div class="line">    im(x, y, 1) = 0.0f;</div><div class="line">    im(x, y, 2) = 0.0f:</div><div class="line">});</div></div><!-- fragment --><p>The compiled code is equivalent to writing the a nested for loop, and compilers are capable of optimizing it in the same way.</p>
<p>If the callable can be called with an int * as the sole argument, that version is called instead. Each location in the buffer is passed to it in a coordinate array. This version is higher-overhead than the variadic version, but is useful for writing generic code that accepts buffers of arbitrary dimensionality. For example, the following sets the value at all sites in an arbitrary-dimensional buffer to their first coordinate:</p>
<div class="fragment"><div class="line">im.for_each_element([&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span> *pos) {im(pos) = pos[0];});</div></div><!-- fragment --><p>It is also possible to use for_each_element to iterate over entire rows or columns by cropping the buffer to a single column or row respectively and iterating over elements of the result. For example, to set the diagonal of the image to 1 by iterating over the columns:</p>
<div class="fragment"><div class="line">Buffer&lt;float, 3&gt; im(100, 100, 3);</div><div class="line">    im.sliced(1, 0).for_each_element([&amp;](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> c) {</div><div class="line">    im(x, x, c) = 1.0f;</div><div class="line">});</div></div><!-- fragment --><p>Or, assuming the memory layout is known to be dense per row, one can memset each row of an image like so:</p>
<div class="fragment"><div class="line">Buffer&lt;float, 3&gt; im(100, 100, 3);</div><div class="line">im.sliced(0, 0).for_each_element([&amp;](<span class="keywordtype">int</span> y, <span class="keywordtype">int</span> c) {</div><div class="line">    <a class="code" href="runtime__internal_8h.html#a6bed979b3fb2afd7f5aa7102af57bd8b">memset</a>(&amp;im(0, y, c), 0, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * im.width());</div><div class="line">});</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l02306">2306</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="aad393aa0c8c02b91913cc093b0cb959d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::for_each_element </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function at each site in a buffer. </p>
<p>This is likely to be much slower than using <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> code to populate a buffer, but is convenient for tests. If the function has more arguments than the buffer has dimensions, the remaining arguments will be zero. If it has fewer arguments than the buffer has dimensions then the last few dimensions of the buffer are not iterated over. For example, the following code exploits this to set a floating point RGB image to red:</p>
<div class="fragment"><div class="line">Buffer&lt;float, 3&gt; im(100, 100, 3);</div><div class="line">im.for_each_element([&amp;](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) {</div><div class="line">    im(x, y, 0) = 1.0f;</div><div class="line">    im(x, y, 1) = 0.0f;</div><div class="line">    im(x, y, 2) = 0.0f:</div><div class="line">});</div></div><!-- fragment --><p>The compiled code is equivalent to writing the a nested for loop, and compilers are capable of optimizing it in the same way.</p>
<p>If the callable can be called with an int * as the sole argument, that version is called instead. Each location in the buffer is passed to it in a coordinate array. This version is higher-overhead than the variadic version, but is useful for writing generic code that accepts buffers of arbitrary dimensionality. For example, the following sets the value at all sites in an arbitrary-dimensional buffer to their first coordinate:</p>
<div class="fragment"><div class="line">im.for_each_element([&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span> *pos) {im(pos) = pos[0];});</div></div><!-- fragment --><p>It is also possible to use for_each_element to iterate over entire rows or columns by cropping the buffer to a single column or row respectively and iterating over elements of the result. For example, to set the diagonal of the image to 1 by iterating over the columns:</p>
<div class="fragment"><div class="line">Buffer&lt;float, 3&gt; im(100, 100, 3);</div><div class="line">    im.sliced(1, 0).for_each_element([&amp;](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> c) {</div><div class="line">    im(x, x, c) = 1.0f;</div><div class="line">});</div></div><!-- fragment --><p>Or, assuming the memory layout is known to be dense per row, one can memset each row of an image like so:</p>
<div class="fragment"><div class="line">Buffer&lt;float, 3&gt; im(100, 100, 3);</div><div class="line">im.sliced(0, 0).for_each_element([&amp;](<span class="keywordtype">int</span> y, <span class="keywordtype">int</span> c) {</div><div class="line">    <a class="code" href="runtime__internal_8h.html#a6bed979b3fb2afd7f5aa7102af57bd8b">memset</a>(&amp;im(0, y, c), 0, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * im.width());</div><div class="line">});</div></div><!-- fragment --> 
<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l02314">2314</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab6dd431ae848e2b16ba659f3578f0776"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename  = typename std::enable_if&lt;!std::is_arithmetic&lt;typename std::decay&lt;Fn&gt;::type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a buffer by evaluating a callable at every site. </p>
<p>The callable should look much like a callable passed to for_each_element, but it should return the value that should be stored to the coordinate corresponding to the arguments. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l02344">2344</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9b4b9be7258804a1313a89f43a8d40e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::is_bounds_query </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an input buffer passed extern stage is a querying bounds. </p>
<p>Compared to doing the host pointer check directly, this both adds clarity to code and will facilitate moving to another representation for bounds query arguments. </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l02354">2354</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9f27e242b5bce071d42a2ef15550f012"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::msan_check_mem_is_initialized </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>entire</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenient check to verify that all of the interesting bytes in the <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> are initialized under MSAN. </p>
<p>Note that by default, we use <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4d0a0cc4790808e46084a6e26b399ed1" title="Call a function on every value in the buffer, and the corresponding values in some number of other bu...">for_each_value()</a> here so that we skip any unused padding that isn't part of the <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>; this isn't efficient, but in MSAN mode, it doesn't matter. (Pass true for the flag to force check the entire <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> storage.) </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l02363">2363</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a6a0432e50ffc161961ae3af4d5a6c98a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::has_static_halide_type = !T_is_void</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the <a class="el" href="namespace_halide.html" title="This file defines the class FunctionDAG, which is our representation of a Halide pipeline, and contains methods to using Halide&#39;s bounds tools to query properties of it. ">Halide</a> type is not void (or const void). </p>

<p>Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00168">168</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/halidenightly/build_bot/worker/x86-64-linux-1000-cmake/halide/src/runtime/<a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_runtime.html">Runtime</a></li><li class="navelem"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
