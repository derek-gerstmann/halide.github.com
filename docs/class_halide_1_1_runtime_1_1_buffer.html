<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Runtime::Buffer&lt; T, D &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_halide_1_1_runtime_1_1_buffer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_halide_1_1_runtime_1_1_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Halide::Runtime::Buffer&lt; T, D &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A templated <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> class that wraps <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> and adds functionality.  
 <a href="class_halide_1_1_runtime_1_1_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer_1_1_dimension.html">Dimension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-only access to the shape.  <a href="class_halide_1_1_runtime_1_1_buffer_1_1_dimension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a897dbebfae1a242dbac4e509861266dd"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a897dbebfae1a242dbac4e509861266dd">ElemType</a></td></tr>
<tr class="separator:a897dbebfae1a242dbac4e509861266dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0d36d70f9f26e6c74faf08cd3f7061e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0d36d70f9f26e6c74faf08cd3f7061e8">owns_host_memory</a> () const</td></tr>
<tr class="memdesc:a0d36d70f9f26e6c74faf08cd3f7061e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> own the host memory it refers to?  <a href="#a0d36d70f9f26e6c74faf08cd3f7061e8">More...</a><br /></td></tr>
<tr class="separator:a0d36d70f9f26e6c74faf08cd3f7061e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32e3ece8aac2a8f27057b75604dbc11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer_1_1_dimension.html">Dimension</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad32e3ece8aac2a8f27057b75604dbc11">dim</a> (int i) const</td></tr>
<tr class="memdesc:ad32e3ece8aac2a8f27057b75604dbc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the shape of the buffer.  <a href="#ad32e3ece8aac2a8f27057b75604dbc11">More...</a><br /></td></tr>
<tr class="separator:ad32e3ece8aac2a8f27057b75604dbc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859f7c60e0afe9ac395cf1d6f49cdbec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a859f7c60e0afe9ac395cf1d6f49cdbec">number_of_elements</a> () const</td></tr>
<tr class="memdesc:a859f7c60e0afe9ac395cf1d6f49cdbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of elements this buffer represents.  <a href="#a859f7c60e0afe9ac395cf1d6f49cdbec">More...</a><br /></td></tr>
<tr class="separator:a859f7c60e0afe9ac395cf1d6f49cdbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aeeb5d75f820fdf6503531dafbe5e3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0aeeb5d75f820fdf6503531dafbe5e3c">dimensions</a> () const</td></tr>
<tr class="memdesc:a0aeeb5d75f820fdf6503531dafbe5e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimensionality of the buffer.  <a href="#a0aeeb5d75f820fdf6503531dafbe5e3c">More...</a><br /></td></tr>
<tr class="separator:a0aeeb5d75f820fdf6503531dafbe5e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dae808d0762400cc0e2efb65ad5e84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a86dae808d0762400cc0e2efb65ad5e84">type</a> () const</td></tr>
<tr class="memdesc:a86dae808d0762400cc0e2efb65ad5e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the elements.  <a href="#a86dae808d0762400cc0e2efb65ad5e84">More...</a><br /></td></tr>
<tr class="separator:a86dae808d0762400cc0e2efb65ad5e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257ade503e585ecb50232e2e3f9ab15e"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a257ade503e585ecb50232e2e3f9ab15e">begin</a> () const</td></tr>
<tr class="memdesc:a257ade503e585ecb50232e2e3f9ab15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the element with the lowest address.  <a href="#a257ade503e585ecb50232e2e3f9ab15e">More...</a><br /></td></tr>
<tr class="separator:a257ade503e585ecb50232e2e3f9ab15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b96cc7392f2cc9b4a6697d04f9d0283"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8b96cc7392f2cc9b4a6697d04f9d0283">end</a> () const</td></tr>
<tr class="memdesc:a8b96cc7392f2cc9b4a6697d04f9d0283"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to one beyond the element with the highest address.  <a href="#a8b96cc7392f2cc9b4a6697d04f9d0283">More...</a><br /></td></tr>
<tr class="separator:a8b96cc7392f2cc9b4a6697d04f9d0283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89dc1fa1ed026c83e30c18a8f7e0fb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ac89dc1fa1ed026c83e30c18a8f7e0fb4">size_in_bytes</a> () const</td></tr>
<tr class="memdesc:ac89dc1fa1ed026c83e30c18a8f7e0fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of bytes spanned by the data in memory.  <a href="#ac89dc1fa1ed026c83e30c18a8f7e0fb4">More...</a><br /></td></tr>
<tr class="separator:ac89dc1fa1ed026c83e30c18a8f7e0fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb70f579cf7cab5457f5ce88d771ac93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#acb70f579cf7cab5457f5ce88d771ac93">Buffer</a> ()</td></tr>
<tr class="separator:acb70f579cf7cab5457f5ce88d771ac93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9d31fcdc71f7c00dafe9d076e9dc27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a7a9d31fcdc71f7c00dafe9d076e9dc27">Buffer</a> (const <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> &amp;buf, <a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139">BufferDeviceOwnership</a> ownership=<a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139a6b982c948840b6e4b5fec2711f09627d">BufferDeviceOwnership::Unmanaged</a>)</td></tr>
<tr class="memdesc:a7a9d31fcdc71f7c00dafe9d076e9dc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a>.  <a href="#a7a9d31fcdc71f7c00dafe9d076e9dc27">More...</a><br /></td></tr>
<tr class="separator:a7a9d31fcdc71f7c00dafe9d076e9dc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdf833c01068763b282b209eb0a18af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a1cdf833c01068763b282b209eb0a18af">Buffer</a> (const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;old_buf)</td></tr>
<tr class="memdesc:a1cdf833c01068763b282b209eb0a18af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a legacy <a class="el" href="structbuffer__t.html">buffer_t</a>.  <a href="#a1cdf833c01068763b282b209eb0a18af">More...</a><br /></td></tr>
<tr class="separator:a1cdf833c01068763b282b209eb0a18af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a104178f209e6ff6c7b7cd2802250cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbuffer__t.html">buffer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a5a104178f209e6ff6c7b7cd2802250cc">make_legacy_buffer_t</a> () const</td></tr>
<tr class="memdesc:a5a104178f209e6ff6c7b7cd2802250cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the fields of a legacy <a class="el" href="structbuffer__t.html">buffer_t</a> using this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#a5a104178f209e6ff6c7b7cd2802250cc">More...</a><br /></td></tr>
<tr class="separator:a5a104178f209e6ff6c7b7cd2802250cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47307ea974c0025db0b9d6bc646de65c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a47307ea974c0025db0b9d6bc646de65c">Buffer</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;other)</td></tr>
<tr class="memdesc:a47307ea974c0025db0b9d6bc646de65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a47307ea974c0025db0b9d6bc646de65c">More...</a><br /></td></tr>
<tr class="separator:a47307ea974c0025db0b9d6bc646de65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b96681d758ad414ff7751bca77ae863"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a1b96681d758ad414ff7751bca77ae863"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a1b96681d758ad414ff7751bca77ae863">Buffer</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a1b96681d758ad414ff7751bca77ae863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of different dimensionality and type.  <a href="#a1b96681d758ad414ff7751bca77ae863">More...</a><br /></td></tr>
<tr class="separator:a1b96681d758ad414ff7751bca77ae863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7e09bd6c742852fe6507e1e37081b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0b7e09bd6c742852fe6507e1e37081b4">Buffer</a> (<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a0b7e09bd6c742852fe6507e1e37081b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a0b7e09bd6c742852fe6507e1e37081b4">More...</a><br /></td></tr>
<tr class="separator:a0b7e09bd6c742852fe6507e1e37081b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2649e245b86b2975807b11a0d91f766e"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a2649e245b86b2975807b11a0d91f766e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2649e245b86b2975807b11a0d91f766e">Buffer</a> (<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a2649e245b86b2975807b11a0d91f766e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of different dimensionality and type.  <a href="#a2649e245b86b2975807b11a0d91f766e">More...</a><br /></td></tr>
<tr class="separator:a2649e245b86b2975807b11a0d91f766e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b21234b1b51c23d70dde4c7bc0ce68"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a73b21234b1b51c23d70dde4c7bc0ce68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a73b21234b1b51c23d70dde4c7bc0ce68">operator=</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a73b21234b1b51c23d70dde4c7bc0ce68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality and type.  <a href="#a73b21234b1b51c23d70dde4c7bc0ce68">More...</a><br /></td></tr>
<tr class="separator:a73b21234b1b51c23d70dde4c7bc0ce68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b0a9cb0fed41c0445d6927240bb50c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a38b0a9cb0fed41c0445d6927240bb50c">operator=</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;other)</td></tr>
<tr class="memdesc:a38b0a9cb0fed41c0445d6927240bb50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard assignment operator.  <a href="#a38b0a9cb0fed41c0445d6927240bb50c">More...</a><br /></td></tr>
<tr class="separator:a38b0a9cb0fed41c0445d6927240bb50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2feda3bb0e3bde94f01791b2c3f45449"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a2feda3bb0e3bde94f01791b2c3f45449"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2feda3bb0e3bde94f01791b2c3f45449">operator=</a> (<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a2feda3bb0e3bde94f01791b2c3f45449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move from another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality and type.  <a href="#a2feda3bb0e3bde94f01791b2c3f45449">More...</a><br /></td></tr>
<tr class="separator:a2feda3bb0e3bde94f01791b2c3f45449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a180f067e57d8ea9a3b61e4d12769e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad9a180f067e57d8ea9a3b61e4d12769e">operator=</a> (<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:ad9a180f067e57d8ea9a3b61e4d12769e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard move-assignment operator.  <a href="#ad9a180f067e57d8ea9a3b61e4d12769e">More...</a><br /></td></tr>
<tr class="separator:ad9a180f067e57d8ea9a3b61e4d12769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7961b0f7ee27508c36fb019d3d3a67e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ab7961b0f7ee27508c36fb019d3d3a67e">check_overflow</a> ()</td></tr>
<tr class="memdesc:ab7961b0f7ee27508c36fb019d3d3a67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the product of the extents fits in memory.  <a href="#ab7961b0f7ee27508c36fb019d3d3a67e">More...</a><br /></td></tr>
<tr class="separator:ab7961b0f7ee27508c36fb019d3d3a67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759f8c2487886eb85bc2607f11beabd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a759f8c2487886eb85bc2607f11beabd1">allocate</a> (void *(*allocate_fn)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)=nullptr, void(*deallocate_fn)(void *)=nullptr)</td></tr>
<tr class="memdesc:a759f8c2487886eb85bc2607f11beabd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#a759f8c2487886eb85bc2607f11beabd1">More...</a><br /></td></tr>
<tr class="separator:a759f8c2487886eb85bc2607f11beabd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b39bfac1c4ccca5eb45af9cfbeed7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a65b39bfac1c4ccca5eb45af9cfbeed7d">deallocate</a> ()</td></tr>
<tr class="memdesc:a65b39bfac1c4ccca5eb45af9cfbeed7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop reference to any owned host or device memory, possibly freeing it, if this buffer held the last reference to it.  <a href="#a65b39bfac1c4ccca5eb45af9cfbeed7d">More...</a><br /></td></tr>
<tr class="separator:a65b39bfac1c4ccca5eb45af9cfbeed7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82da5ef4c1264386e705ef9b7e475c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af82da5ef4c1264386e705ef9b7e475c7">device_deallocate</a> ()</td></tr>
<tr class="memdesc:af82da5ef4c1264386e705ef9b7e475c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop reference to any owned device memory, possibly freeing it if this buffer held the last reference to it.  <a href="#af82da5ef4c1264386e705ef9b7e475c7">More...</a><br /></td></tr>
<tr class="separator:af82da5ef4c1264386e705ef9b7e475c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad970ef6a40a49021382f1f94905cd800"><td class="memTemplParams" colspan="2">template&lt;typename ... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad970ef6a40a49021382f1f94905cd800"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad970ef6a40a49021382f1f94905cd800">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, int first, Args... rest)</td></tr>
<tr class="memdesc:ad970ef6a40a49021382f1f94905cd800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of the given size with a runtime type.  <a href="#ad970ef6a40a49021382f1f94905cd800">More...</a><br /></td></tr>
<tr class="separator:ad970ef6a40a49021382f1f94905cd800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0013744b24a2a075b4fd1ef123af495b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0013744b24a2a075b4fd1ef123af495b">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, const std::vector&lt; int &gt; &amp;sizes)</td></tr>
<tr class="memdesc:a0013744b24a2a075b4fd1ef123af495b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of unknown type using a vector of ints as the size.  <a href="#a0013744b24a2a075b4fd1ef123af495b">More...</a><br /></td></tr>
<tr class="separator:a0013744b24a2a075b4fd1ef123af495b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52db43880a5c487452f11936cb1166ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a52db43880a5c487452f11936cb1166ab">Buffer</a> (const std::vector&lt; int &gt; &amp;sizes)</td></tr>
<tr class="memdesc:a52db43880a5c487452f11936cb1166ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of known type using a vector of ints as the size.  <a href="#a52db43880a5c487452f11936cb1166ab">More...</a><br /></td></tr>
<tr class="separator:a52db43880a5c487452f11936cb1166ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aac7bbcf212bfd87b017ded998140a9"><td class="memTemplParams" colspan="2">template&lt;typename Array , size_t N&gt; </td></tr>
<tr class="memitem:a7aac7bbcf212bfd87b017ded998140a9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a7aac7bbcf212bfd87b017ded998140a9">Buffer</a> (Array(&amp;vals)[N])</td></tr>
<tr class="memdesc:a7aac7bbcf212bfd87b017ded998140a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> that refers to a statically sized array.  <a href="#a7aac7bbcf212bfd87b017ded998140a9">More...</a><br /></td></tr>
<tr class="separator:a7aac7bbcf212bfd87b017ded998140a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73930eae77ea382b041c2fd281c9322e"><td class="memTemplParams" colspan="2">template&lt;typename ... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a73930eae77ea382b041c2fd281c9322e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a73930eae77ea382b041c2fd281c9322e">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, add_const_if_T_is_const&lt; void &gt; *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4c2876910c7960810940f7f45298dba2">data</a>, int first, Args &amp;&amp;... rest)</td></tr>
<tr class="memdesc:a73930eae77ea382b041c2fd281c9322e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of runtime type from a pointer and some sizes.  <a href="#a73930eae77ea382b041c2fd281c9322e">More...</a><br /></td></tr>
<tr class="separator:a73930eae77ea382b041c2fd281c9322e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669b43683e7ba87a926a36f7f31d1b8b"><td class="memTemplParams" colspan="2">template&lt;typename ... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a669b43683e7ba87a926a36f7f31d1b8b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a669b43683e7ba87a926a36f7f31d1b8b">Buffer</a> (T *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4c2876910c7960810940f7f45298dba2">data</a>, int first, Args &amp;&amp;... rest)</td></tr>
<tr class="memdesc:a669b43683e7ba87a926a36f7f31d1b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer and some sizes.  <a href="#a669b43683e7ba87a926a36f7f31d1b8b">More...</a><br /></td></tr>
<tr class="separator:a669b43683e7ba87a926a36f7f31d1b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c020e81707b663ee4761d852222e94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a31c020e81707b663ee4761d852222e94">Buffer</a> (T *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4c2876910c7960810940f7f45298dba2">data</a>, const std::vector&lt; int &gt; &amp;sizes)</td></tr>
<tr class="memdesc:a31c020e81707b663ee4761d852222e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer and a vector of sizes.  <a href="#a31c020e81707b663ee4761d852222e94">More...</a><br /></td></tr>
<tr class="separator:a31c020e81707b663ee4761d852222e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9301d7908f8580de77b58384eb19582"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ae9301d7908f8580de77b58384eb19582">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, add_const_if_T_is_const&lt; void &gt; *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4c2876910c7960810940f7f45298dba2">data</a>, const std::vector&lt; int &gt; &amp;sizes)</td></tr>
<tr class="memdesc:ae9301d7908f8580de77b58384eb19582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of runtime type from a pointer and a vector of sizes.  <a href="#ae9301d7908f8580de77b58384eb19582">More...</a><br /></td></tr>
<tr class="separator:ae9301d7908f8580de77b58384eb19582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ce543ccc08cc06bf35050a0fca989e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a00ce543ccc08cc06bf35050a0fca989e">Buffer</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, add_const_if_T_is_const&lt; void &gt; *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4c2876910c7960810940f7f45298dba2">data</a>, int d, const <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> *shape)</td></tr>
<tr class="memdesc:a00ce543ccc08cc06bf35050a0fca989e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and an array describing the shape.  <a href="#a00ce543ccc08cc06bf35050a0fca989e">More...</a><br /></td></tr>
<tr class="separator:a00ce543ccc08cc06bf35050a0fca989e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a2b9d12d26d24480c0519490ee975e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a84a2b9d12d26d24480c0519490ee975e">Buffer</a> (T *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4c2876910c7960810940f7f45298dba2">data</a>, int d, const <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> *shape)</td></tr>
<tr class="memdesc:a84a2b9d12d26d24480c0519490ee975e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and an array describing the shape.  <a href="#a84a2b9d12d26d24480c0519490ee975e">More...</a><br /></td></tr>
<tr class="separator:a84a2b9d12d26d24480c0519490ee975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f46c67f0f5210b97b570a3e7fac95e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ab3f46c67f0f5210b97b570a3e7fac95e">~Buffer</a> ()</td></tr>
<tr class="memdesc:ab3f46c67f0f5210b97b570a3e7fac95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab3f46c67f0f5210b97b570a3e7fac95e">More...</a><br /></td></tr>
<tr class="separator:ab3f46c67f0f5210b97b570a3e7fac95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6e8717724ac6b06571a1d0d82c064e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2a6e8717724ac6b06571a1d0d82c064e">operator halide_buffer_t *</a> ()</td></tr>
<tr class="memdesc:a2a6e8717724ac6b06571a1d0d82c064e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a cast operator to <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> *, so that instances can be passed directly to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> filters.  <a href="#a2a6e8717724ac6b06571a1d0d82c064e">More...</a><br /></td></tr>
<tr class="separator:a2a6e8717724ac6b06571a1d0d82c064e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa92236129a979599093e6aecd0b7b90"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2 = D&gt; </td></tr>
<tr class="memitem:afa92236129a979599093e6aecd0b7b90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#afa92236129a979599093e6aecd0b7b90">as</a> () &amp;</td></tr>
<tr class="memdesc:afa92236129a979599093e6aecd0b7b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a typed reference to this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#afa92236129a979599093e6aecd0b7b90">More...</a><br /></td></tr>
<tr class="separator:afa92236129a979599093e6aecd0b7b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495a933b54a287da107d5707d2194078"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2 = D&gt; </td></tr>
<tr class="memitem:a495a933b54a287da107d5707d2194078"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a495a933b54a287da107d5707d2194078">as</a> () const &amp;</td></tr>
<tr class="memdesc:a495a933b54a287da107d5707d2194078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const typed reference to this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#a495a933b54a287da107d5707d2194078">More...</a><br /></td></tr>
<tr class="separator:a495a933b54a287da107d5707d2194078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740f50d25fb68578dfbbebabc7597b8d"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2 = D&gt; </td></tr>
<tr class="memitem:a740f50d25fb68578dfbbebabc7597b8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a740f50d25fb68578dfbbebabc7597b8d">as</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a740f50d25fb68578dfbbebabc7597b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this rval <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> with a different type attached.  <a href="#a740f50d25fb68578dfbbebabc7597b8d">More...</a><br /></td></tr>
<tr class="separator:a740f50d25fb68578dfbbebabc7597b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88259ff293a390125896f095e0e58bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a88259ff293a390125896f095e0e58bc3">copy</a> (void *(*allocate_fn)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)=nullptr, void(*deallocate_fn)(void *)=nullptr) const</td></tr>
<tr class="memdesc:a88259ff293a390125896f095e0e58bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new image which is a deep copy of this image.  <a href="#a88259ff293a390125896f095e0e58bc3">More...</a><br /></td></tr>
<tr class="separator:a88259ff293a390125896f095e0e58bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9982b308f61426dd5a33aa31dfc156f"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:ac9982b308f61426dd5a33aa31dfc156f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ac9982b308f61426dd5a33aa31dfc156f">copy_from</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:ac9982b308f61426dd5a33aa31dfc156f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> with the values at the same coordinates in another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#ac9982b308f61426dd5a33aa31dfc156f">More...</a><br /></td></tr>
<tr class="separator:ac9982b308f61426dd5a33aa31dfc156f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751c5e8cf2bc45cc5492107e72ea5ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a751c5e8cf2bc45cc5492107e72ea5ed8">cropped</a> (int d, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af3880b4f6fdd7fb48003e3218c823b9d">min</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a20485927b517cab777c243cbbf9ee0fa">extent</a>) const</td></tr>
<tr class="memdesc:a751c5e8cf2bc45cc5492107e72ea5ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image that refers to a sub-range of this image along the given dimension.  <a href="#a751c5e8cf2bc45cc5492107e72ea5ed8">More...</a><br /></td></tr>
<tr class="separator:a751c5e8cf2bc45cc5492107e72ea5ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4e4a871377e1eb48980b5fc697c276"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4a4e4a871377e1eb48980b5fc697c276">crop</a> (int d, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af3880b4f6fdd7fb48003e3218c823b9d">min</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a20485927b517cab777c243cbbf9ee0fa">extent</a>)</td></tr>
<tr class="memdesc:a4a4e4a871377e1eb48980b5fc697c276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crop an image in-place along the given dimension.  <a href="#a4a4e4a871377e1eb48980b5fc697c276">More...</a><br /></td></tr>
<tr class="separator:a4a4e4a871377e1eb48980b5fc697c276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f5c12166d98b9aa0e446135f9e7bd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a25f5c12166d98b9aa0e446135f9e7bd1">cropped</a> (const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;rect) const</td></tr>
<tr class="memdesc:a25f5c12166d98b9aa0e446135f9e7bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image that refers to a sub-rectangle of this image along the first N dimensions.  <a href="#a25f5c12166d98b9aa0e446135f9e7bd1">More...</a><br /></td></tr>
<tr class="separator:a25f5c12166d98b9aa0e446135f9e7bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e4477fcde56c9f0f448281cd15efad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a73e4477fcde56c9f0f448281cd15efad">crop</a> (const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;rect)</td></tr>
<tr class="memdesc:a73e4477fcde56c9f0f448281cd15efad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crop an image in-place along the first N dimensions.  <a href="#a73e4477fcde56c9f0f448281cd15efad">More...</a><br /></td></tr>
<tr class="separator:a73e4477fcde56c9f0f448281cd15efad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288f3d55c05380228f2a8b7a9afcbb0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a288f3d55c05380228f2a8b7a9afcbb0f">translated</a> (int d, int dx) const</td></tr>
<tr class="memdesc:a288f3d55c05380228f2a8b7a9afcbb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image which refers to the same data with using translated coordinates in the given dimension.  <a href="#a288f3d55c05380228f2a8b7a9afcbb0f">More...</a><br /></td></tr>
<tr class="separator:a288f3d55c05380228f2a8b7a9afcbb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08186761f27f13d4097e85b467d2b534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a08186761f27f13d4097e85b467d2b534">translate</a> (int d, int delta)</td></tr>
<tr class="memdesc:a08186761f27f13d4097e85b467d2b534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate an image in-place along one dimension.  <a href="#a08186761f27f13d4097e85b467d2b534">More...</a><br /></td></tr>
<tr class="separator:a08186761f27f13d4097e85b467d2b534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb8dd2cde057cfd098d45e9fc2b7a52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a5cb8dd2cde057cfd098d45e9fc2b7a52">translated</a> (const std::vector&lt; int &gt; &amp;delta)</td></tr>
<tr class="memdesc:a5cb8dd2cde057cfd098d45e9fc2b7a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image which refers to the same data translated along the first N dimensions.  <a href="#a5cb8dd2cde057cfd098d45e9fc2b7a52">More...</a><br /></td></tr>
<tr class="separator:a5cb8dd2cde057cfd098d45e9fc2b7a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401c86c132079debb43a85b5957ed9a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a401c86c132079debb43a85b5957ed9a5">translate</a> (const std::vector&lt; int &gt; &amp;delta)</td></tr>
<tr class="memdesc:a401c86c132079debb43a85b5957ed9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate an image along the first N dimensions.  <a href="#a401c86c132079debb43a85b5957ed9a5">More...</a><br /></td></tr>
<tr class="separator:a401c86c132079debb43a85b5957ed9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a284f8c5f2c4cbc343f9f9885eda1a"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:af1a284f8c5f2c4cbc343f9f9885eda1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af1a284f8c5f2c4cbc343f9f9885eda1a">set_min</a> (Args... args)</td></tr>
<tr class="memdesc:af1a284f8c5f2c4cbc343f9f9885eda1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the min coordinate of an image in the first N dimensions.  <a href="#af1a284f8c5f2c4cbc343f9f9885eda1a">More...</a><br /></td></tr>
<tr class="separator:af1a284f8c5f2c4cbc343f9f9885eda1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fef9b582e15c061fbc7177ea459abb4"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a4fef9b582e15c061fbc7177ea459abb4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4fef9b582e15c061fbc7177ea459abb4">contains</a> (Args... args)</td></tr>
<tr class="memdesc:a4fef9b582e15c061fbc7177ea459abb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a given coordinate is within the the bounds of an image.  <a href="#a4fef9b582e15c061fbc7177ea459abb4">More...</a><br /></td></tr>
<tr class="separator:a4fef9b582e15c061fbc7177ea459abb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b28d656d63704c6cc14adc3939d69f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a82b28d656d63704c6cc14adc3939d69f">transposed</a> (int d1, int d2) const</td></tr>
<tr class="memdesc:a82b28d656d63704c6cc14adc3939d69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an image which refers to the same data using a different ordering of the dimensions.  <a href="#a82b28d656d63704c6cc14adc3939d69f">More...</a><br /></td></tr>
<tr class="separator:a82b28d656d63704c6cc14adc3939d69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca18450bcc383920ca5f69a9b04b097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8ca18450bcc383920ca5f69a9b04b097">transpose</a> (int d1, int d2)</td></tr>
<tr class="memdesc:a8ca18450bcc383920ca5f69a9b04b097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose an image in-place.  <a href="#a8ca18450bcc383920ca5f69a9b04b097">More...</a><br /></td></tr>
<tr class="separator:a8ca18450bcc383920ca5f69a9b04b097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eadfc9ad81d2e464915df85ca1afd34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3eadfc9ad81d2e464915df85ca1afd34">sliced</a> (int d, int pos) const</td></tr>
<tr class="memdesc:a3eadfc9ad81d2e464915df85ca1afd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a lower-dimensional image that refers to one slice of this image.  <a href="#a3eadfc9ad81d2e464915df85ca1afd34">More...</a><br /></td></tr>
<tr class="separator:a3eadfc9ad81d2e464915df85ca1afd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba2eeed0bf8a096915189de65a5922b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2ba2eeed0bf8a096915189de65a5922b">slice</a> (int d, int pos)</td></tr>
<tr class="memdesc:a2ba2eeed0bf8a096915189de65a5922b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice an image in-place.  <a href="#a2ba2eeed0bf8a096915189de65a5922b">More...</a><br /></td></tr>
<tr class="separator:a2ba2eeed0bf8a096915189de65a5922b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06187d914dbe5e53a02e0b69b6a092ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a06187d914dbe5e53a02e0b69b6a092ec">embedded</a> (int d, int pos) const</td></tr>
<tr class="memdesc:a06187d914dbe5e53a02e0b69b6a092ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new image that views this image as a single slice in a higher-dimensional space.  <a href="#a06187d914dbe5e53a02e0b69b6a092ec">More...</a><br /></td></tr>
<tr class="separator:a06187d914dbe5e53a02e0b69b6a092ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c4570f918cc6c7b39f7e1fbee55e3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a46c4570f918cc6c7b39f7e1fbee55e3d">embed</a> (int d, int pos)</td></tr>
<tr class="memdesc:a46c4570f918cc6c7b39f7e1fbee55e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Embed an image in-place, increasing the dimensionality.  <a href="#a46c4570f918cc6c7b39f7e1fbee55e3d">More...</a><br /></td></tr>
<tr class="separator:a46c4570f918cc6c7b39f7e1fbee55e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bcf81706f57476668568dd8ea2c403"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aa2bcf81706f57476668568dd8ea2c403">add_dimension</a> ()</td></tr>
<tr class="memdesc:aa2bcf81706f57476668568dd8ea2c403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new dimension with a min of zero and an extent of one.  <a href="#aa2bcf81706f57476668568dd8ea2c403">More...</a><br /></td></tr>
<tr class="separator:aa2bcf81706f57476668568dd8ea2c403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7993fdda560897f4d745177470f03d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ae7993fdda560897f4d745177470f03d8">add_dimension_with_stride</a> (int s)</td></tr>
<tr class="memdesc:ae7993fdda560897f4d745177470f03d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new dimension with a min of zero, an extent of one, and the specified stride.  <a href="#ae7993fdda560897f4d745177470f03d8">More...</a><br /></td></tr>
<tr class="separator:ae7993fdda560897f4d745177470f03d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874b1863aaaa4900ce7809dec5a6ac7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a874b1863aaaa4900ce7809dec5a6ac7e">fill</a> (not_void_T val)</td></tr>
<tr class="separator:a874b1863aaaa4900ce7809dec5a6ac7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b14edde8453d93fcb3806e26e3f48c"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename ... Args, int N = sizeof...(Args) + 1&gt; </td></tr>
<tr class="memitem:ac3b14edde8453d93fcb3806e26e3f48c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ac3b14edde8453d93fcb3806e26e3f48c">for_each_value</a> (Fn &amp;&amp;f, Args... other_buffers)</td></tr>
<tr class="memdesc:ac3b14edde8453d93fcb3806e26e3f48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function on every value in the buffer, and the corresponding values in some number of other buffers of the same size.  <a href="#ac3b14edde8453d93fcb3806e26e3f48c">More...</a><br /></td></tr>
<tr class="separator:ac3b14edde8453d93fcb3806e26e3f48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9243929cb98508a4542093b3b75ff5f"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:ae9243929cb98508a4542093b3b75ff5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ae9243929cb98508a4542093b3b75ff5f">for_each_element</a> (Fn &amp;&amp;f) const</td></tr>
<tr class="memdesc:ae9243929cb98508a4542093b3b75ff5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function at each site in a buffer.  <a href="#ae9243929cb98508a4542093b3b75ff5f">More...</a><br /></td></tr>
<tr class="separator:ae9243929cb98508a4542093b3b75ff5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e64b513f76146d3f7d183774c3c5449"><td class="memTemplParams" colspan="2">template&lt;typename Fn , typename  = typename std::enable_if&lt;!std::is_arithmetic&lt;typename std::decay&lt;Fn&gt;::type&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a2e64b513f76146d3f7d183774c3c5449"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2e64b513f76146d3f7d183774c3c5449">fill</a> (Fn &amp;&amp;f)</td></tr>
<tr class="memdesc:a2e64b513f76146d3f7d183774c3c5449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a buffer by evaluating a callable at every site.  <a href="#a2e64b513f76146d3f7d183774c3c5449">More...</a><br /></td></tr>
<tr class="separator:a2e64b513f76146d3f7d183774c3c5449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003e3a2a7bfb93df233c2b65af0114fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a003e3a2a7bfb93df233c2b65af0114fb">is_bounds_query</a> ()</td></tr>
<tr class="memdesc:a003e3a2a7bfb93df233c2b65af0114fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an input buffer passed extern stage is a querying bounds.  <a href="#a003e3a2a7bfb93df233c2b65af0114fb">More...</a><br /></td></tr>
<tr class="separator:a003e3a2a7bfb93df233c2b65af0114fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af3880b4f6fdd7fb48003e3218c823b9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af3880b4f6fdd7fb48003e3218c823b9d">min</a> (int i) const</td></tr>
<tr class="memdesc:af3880b4f6fdd7fb48003e3218c823b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the mins, strides, extents.  <a href="#af3880b4f6fdd7fb48003e3218c823b9d">More...</a><br /></td></tr>
<tr class="separator:af3880b4f6fdd7fb48003e3218c823b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20485927b517cab777c243cbbf9ee0fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a20485927b517cab777c243cbbf9ee0fa">extent</a> (int i) const</td></tr>
<tr class="memdesc:a20485927b517cab777c243cbbf9ee0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the mins, strides, extents.  <a href="#a20485927b517cab777c243cbbf9ee0fa">More...</a><br /></td></tr>
<tr class="separator:a20485927b517cab777c243cbbf9ee0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5eb0526a5d19a6d51f392c7a66194a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8a5eb0526a5d19a6d51f392c7a66194a">stride</a> (int i) const</td></tr>
<tr class="memdesc:a8a5eb0526a5d19a6d51f392c7a66194a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the mins, strides, extents.  <a href="#a8a5eb0526a5d19a6d51f392c7a66194a">More...</a><br /></td></tr>
<tr class="separator:a8a5eb0526a5d19a6d51f392c7a66194a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1b9d3997c7c6d260a3419cda075178d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a1b9d3997c7c6d260a3419cda075178d1">Buffer</a> (int first)</td></tr>
<tr class="memdesc:a1b9d3997c7c6d260a3419cda075178d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of the given size.  <a href="#a1b9d3997c7c6d260a3419cda075178d1">More...</a><br /></td></tr>
<tr class="separator:a1b9d3997c7c6d260a3419cda075178d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39e3f37f0d706e5817fc00203a4c398"><td class="memTemplParams" colspan="2">template&lt;typename ... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae39e3f37f0d706e5817fc00203a4c398"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ae39e3f37f0d706e5817fc00203a4c398">Buffer</a> (int first, int second, Args... rest)</td></tr>
<tr class="memdesc:ae39e3f37f0d706e5817fc00203a4c398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new image of the given size.  <a href="#ae39e3f37f0d706e5817fc00203a4c398">More...</a><br /></td></tr>
<tr class="separator:ae39e3f37f0d706e5817fc00203a4c398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2fcb27dc04a87015427ad6aa4bd55e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2fcb27dc04a87015427ad6aa4bd55e89">raw_buffer</a> ()</td></tr>
<tr class="memdesc:a2fcb27dc04a87015427ad6aa4bd55e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> this wraps.  <a href="#a2fcb27dc04a87015427ad6aa4bd55e89">More...</a><br /></td></tr>
<tr class="separator:a2fcb27dc04a87015427ad6aa4bd55e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdb7fc902921e8c9347e7bb235be4a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#abfdb7fc902921e8c9347e7bb235be4a2">raw_buffer</a> () const</td></tr>
<tr class="memdesc:abfdb7fc902921e8c9347e7bb235be4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> this wraps.  <a href="#abfdb7fc902921e8c9347e7bb235be4a2">More...</a><br /></td></tr>
<tr class="separator:abfdb7fc902921e8c9347e7bb235be4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0212355929ed6a149b5d0015198c9334"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0212355929ed6a149b5d0015198c9334">width</a> () const</td></tr>
<tr class="memdesc:a0212355929ed6a149b5d0015198c9334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the first three dimensions.  <a href="#a0212355929ed6a149b5d0015198c9334">More...</a><br /></td></tr>
<tr class="separator:a0212355929ed6a149b5d0015198c9334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4af7ecd8ecee22bed639df971acac8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#adf4af7ecd8ecee22bed639df971acac8">height</a> () const</td></tr>
<tr class="memdesc:adf4af7ecd8ecee22bed639df971acac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the first three dimensions.  <a href="#adf4af7ecd8ecee22bed639df971acac8">More...</a><br /></td></tr>
<tr class="separator:adf4af7ecd8ecee22bed639df971acac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977f7595994c8bf673b99d0594ecee91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a977f7595994c8bf673b99d0594ecee91">channels</a> () const</td></tr>
<tr class="memdesc:a977f7595994c8bf673b99d0594ecee91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the first three dimensions.  <a href="#a977f7595994c8bf673b99d0594ecee91">More...</a><br /></td></tr>
<tr class="separator:a977f7595994c8bf673b99d0594ecee91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6941d552162fdd18174379aa572bb951"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a6941d552162fdd18174379aa572bb951">left</a> () const</td></tr>
<tr class="memdesc:a6941d552162fdd18174379aa572bb951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the min and max value of each dimension.  <a href="#a6941d552162fdd18174379aa572bb951">More...</a><br /></td></tr>
<tr class="separator:a6941d552162fdd18174379aa572bb951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dba2e0d8029ac9b9df4196ca9f167e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ae1dba2e0d8029ac9b9df4196ca9f167e">right</a> () const</td></tr>
<tr class="memdesc:ae1dba2e0d8029ac9b9df4196ca9f167e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the min and max value of each dimension.  <a href="#ae1dba2e0d8029ac9b9df4196ca9f167e">More...</a><br /></td></tr>
<tr class="separator:ae1dba2e0d8029ac9b9df4196ca9f167e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c68b83bf2196b4fe31d5a19e866279c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8c68b83bf2196b4fe31d5a19e866279c">top</a> () const</td></tr>
<tr class="memdesc:a8c68b83bf2196b4fe31d5a19e866279c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the min and max value of each dimension.  <a href="#a8c68b83bf2196b4fe31d5a19e866279c">More...</a><br /></td></tr>
<tr class="separator:a8c68b83bf2196b4fe31d5a19e866279c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49616c07a3e9a3e5694f4b1f319174ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a49616c07a3e9a3e5694f4b1f319174ad">bottom</a> () const</td></tr>
<tr class="memdesc:a49616c07a3e9a3e5694f4b1f319174ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conventional names for the min and max value of each dimension.  <a href="#a49616c07a3e9a3e5694f4b1f319174ad">More...</a><br /></td></tr>
<tr class="separator:a49616c07a3e9a3e5694f4b1f319174ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae6174e9d4e337351d6a8716d5dd1c91c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ae6174e9d4e337351d6a8716d5dd1c91c">set_host_dirty</a> (bool v=true)</td></tr>
<tr class="memdesc:ae6174e9d4e337351d6a8716d5dd1c91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#ae6174e9d4e337351d6a8716d5dd1c91c">More...</a><br /></td></tr>
<tr class="separator:ae6174e9d4e337351d6a8716d5dd1c91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44b8b797624c2188886c1ba7f34576c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af44b8b797624c2188886c1ba7f34576c">device_dirty</a> () const</td></tr>
<tr class="memdesc:af44b8b797624c2188886c1ba7f34576c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#af44b8b797624c2188886c1ba7f34576c">More...</a><br /></td></tr>
<tr class="separator:af44b8b797624c2188886c1ba7f34576c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ec04364e9dde0b2eb2f5f01592792e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a07ec04364e9dde0b2eb2f5f01592792e">host_dirty</a> () const</td></tr>
<tr class="memdesc:a07ec04364e9dde0b2eb2f5f01592792e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a07ec04364e9dde0b2eb2f5f01592792e">More...</a><br /></td></tr>
<tr class="separator:a07ec04364e9dde0b2eb2f5f01592792e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3219cd20977b4e71add236e9145b7978"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3219cd20977b4e71add236e9145b7978">set_device_dirty</a> (bool v=true)</td></tr>
<tr class="memdesc:a3219cd20977b4e71add236e9145b7978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a3219cd20977b4e71add236e9145b7978">More...</a><br /></td></tr>
<tr class="separator:a3219cd20977b4e71add236e9145b7978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0af202d3ca2202627e8b80578a4b8e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af0af202d3ca2202627e8b80578a4b8e0">copy_to_host</a> (void *ctx=nullptr)</td></tr>
<tr class="memdesc:af0af202d3ca2202627e8b80578a4b8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#af0af202d3ca2202627e8b80578a4b8e0">More...</a><br /></td></tr>
<tr class="separator:af0af202d3ca2202627e8b80578a4b8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78605b601a2e0f548546d58cbee80eef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a78605b601a2e0f548546d58cbee80eef">copy_to_device</a> (const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface, void *ctx=nullptr)</td></tr>
<tr class="memdesc:a78605b601a2e0f548546d58cbee80eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a78605b601a2e0f548546d58cbee80eef">More...</a><br /></td></tr>
<tr class="separator:a78605b601a2e0f548546d58cbee80eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe">device_malloc</a> (const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface, void *ctx=nullptr)</td></tr>
<tr class="memdesc:ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe">More...</a><br /></td></tr>
<tr class="separator:ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f97463086f872f03d846bd13774401b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2f97463086f872f03d846bd13774401b">device_free</a> (void *ctx=nullptr)</td></tr>
<tr class="memdesc:a2f97463086f872f03d846bd13774401b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a2f97463086f872f03d846bd13774401b">More...</a><br /></td></tr>
<tr class="separator:a2f97463086f872f03d846bd13774401b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eab3a0f803010e2bbe998c5ba222fbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a5eab3a0f803010e2bbe998c5ba222fbe">device_wrap_native</a> (const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface, <a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a> handle, void *ctx=nullptr)</td></tr>
<tr class="memdesc:a5eab3a0f803010e2bbe998c5ba222fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a5eab3a0f803010e2bbe998c5ba222fbe">More...</a><br /></td></tr>
<tr class="separator:a5eab3a0f803010e2bbe998c5ba222fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f08f71aa63ed354760dc3d82156c913"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a2f08f71aa63ed354760dc3d82156c913">device_detach_native</a> (void *ctx=nullptr)</td></tr>
<tr class="memdesc:a2f08f71aa63ed354760dc3d82156c913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a2f08f71aa63ed354760dc3d82156c913">More...</a><br /></td></tr>
<tr class="separator:a2f08f71aa63ed354760dc3d82156c913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785163ac59a479c35a1c40d6c7438196"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a785163ac59a479c35a1c40d6c7438196">device_and_host_malloc</a> (const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface, void *ctx=nullptr)</td></tr>
<tr class="memdesc:a785163ac59a479c35a1c40d6c7438196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a785163ac59a479c35a1c40d6c7438196">More...</a><br /></td></tr>
<tr class="separator:a785163ac59a479c35a1c40d6c7438196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e191e00e4e7be10f571f02d256adf2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8e191e00e4e7be10f571f02d256adf2d">device_and_host_free</a> (const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *device_interface, void *ctx=nullptr)</td></tr>
<tr class="memdesc:a8e191e00e4e7be10f571f02d256adf2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a8e191e00e4e7be10f571f02d256adf2d">More...</a><br /></td></tr>
<tr class="separator:a8e191e00e4e7be10f571f02d256adf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a7fb49d3ef831fcefde4e110d0dbba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ad9a7fb49d3ef831fcefde4e110d0dbba">device_sync</a> (void *ctx=nullptr)</td></tr>
<tr class="memdesc:ad9a7fb49d3ef831fcefde4e110d0dbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#ad9a7fb49d3ef831fcefde4e110d0dbba">More...</a><br /></td></tr>
<tr class="separator:ad9a7fb49d3ef831fcefde4e110d0dbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ceab490f4b6f4eee9b3158347ef2a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a74ceab490f4b6f4eee9b3158347ef2a2">has_device_allocation</a> () const</td></tr>
<tr class="memdesc:a74ceab490f4b6f4eee9b3158347ef2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for managing any GPU allocation.  <a href="#a74ceab490f4b6f4eee9b3158347ef2a2">More...</a><br /></td></tr>
<tr class="separator:a74ceab490f4b6f4eee9b3158347ef2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add02956afe11074378fa40188a6543f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139">BufferDeviceOwnership</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#add02956afe11074378fa40188a6543f7">device_ownership</a> () const</td></tr>
<tr class="memdesc:add02956afe11074378fa40188a6543f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the method by which the device field is managed.  <a href="#add02956afe11074378fa40188a6543f7">More...</a><br /></td></tr>
<tr class="separator:add02956afe11074378fa40188a6543f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4c2876910c7960810940f7f45298dba2"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4c2876910c7960810940f7f45298dba2">data</a> ()</td></tr>
<tr class="memdesc:a4c2876910c7960810940f7f45298dba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the address of the min coordinate.  <a href="#a4c2876910c7960810940f7f45298dba2">More...</a><br /></td></tr>
<tr class="separator:a4c2876910c7960810940f7f45298dba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf54ffc79bfb1e6712507e452a744d7"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aedf54ffc79bfb1e6712507e452a744d7">data</a> () const</td></tr>
<tr class="memdesc:aedf54ffc79bfb1e6712507e452a744d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the address of the min coordinate.  <a href="#aedf54ffc79bfb1e6712507e452a744d7">More...</a><br /></td></tr>
<tr class="separator:aedf54ffc79bfb1e6712507e452a744d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab2119a46845d354a7d9abda6a8f8477d"><td class="memTemplParams" colspan="2">template&lt;typename ... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab2119a46845d354a7d9abda6a8f8477d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const not_void_T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ab2119a46845d354a7d9abda6a8f8477d">operator()</a> (int first, Args... rest) const</td></tr>
<tr class="memdesc:ab2119a46845d354a7d9abda6a8f8477d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#ab2119a46845d354a7d9abda6a8f8477d">More...</a><br /></td></tr>
<tr class="separator:ab2119a46845d354a7d9abda6a8f8477d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d5997b23e03865220d426a0a3d3219"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const not_void_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#ae1d5997b23e03865220d426a0a3d3219">operator()</a> () const</td></tr>
<tr class="memdesc:ae1d5997b23e03865220d426a0a3d3219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#ae1d5997b23e03865220d426a0a3d3219">More...</a><br /></td></tr>
<tr class="separator:ae1d5997b23e03865220d426a0a3d3219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4ec17b55dbcbcccb1cf741e0b6f64c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const not_void_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a9e4ec17b55dbcbcccb1cf741e0b6f64c">operator()</a> (const int *pos) const</td></tr>
<tr class="memdesc:a9e4ec17b55dbcbcccb1cf741e0b6f64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#a9e4ec17b55dbcbcccb1cf741e0b6f64c">More...</a><br /></td></tr>
<tr class="separator:a9e4ec17b55dbcbcccb1cf741e0b6f64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2db29d2b5347b2017c5773f2071059a"><td class="memTemplParams" colspan="2">template&lt;typename ... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:af2db29d2b5347b2017c5773f2071059a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> not_void_T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#af2db29d2b5347b2017c5773f2071059a">operator()</a> (int first, Args... rest)</td></tr>
<tr class="memdesc:af2db29d2b5347b2017c5773f2071059a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#af2db29d2b5347b2017c5773f2071059a">More...</a><br /></td></tr>
<tr class="separator:af2db29d2b5347b2017c5773f2071059a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e57ff7ae9db3df9e1ac0496315483d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> not_void_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a9e57ff7ae9db3df9e1ac0496315483d4">operator()</a> ()</td></tr>
<tr class="memdesc:a9e57ff7ae9db3df9e1ac0496315483d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#a9e57ff7ae9db3df9e1ac0496315483d4">More...</a><br /></td></tr>
<tr class="separator:a9e57ff7ae9db3df9e1ac0496315483d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f780f85d63212b6aaace8b3713d406a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> not_void_T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a8f780f85d63212b6aaace8b3713d406a">operator()</a> (const int *pos)</td></tr>
<tr class="memdesc:a8f780f85d63212b6aaace8b3713d406a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access elements.  <a href="#a8f780f85d63212b6aaace8b3713d406a">More...</a><br /></td></tr>
<tr class="separator:a8f780f85d63212b6aaace8b3713d406a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a79d49b7ea3e9045ad11d1ca81c8ab408"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a79d49b7ea3e9045ad11d1ca81c8ab408">static_halide_type</a> ()</td></tr>
<tr class="memdesc:a79d49b7ea3e9045ad11d1ca81c8ab408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> type of T.  <a href="#a79d49b7ea3e9045ad11d1ca81c8ab408">More...</a><br /></td></tr>
<tr class="separator:a79d49b7ea3e9045ad11d1ca81c8ab408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d2f9350263f7cf70bb2c4ba7b9c99f"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a92d2f9350263f7cf70bb2c4ba7b9c99f"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a92d2f9350263f7cf70bb2c4ba7b9c99f">can_convert_from</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a92d2f9350263f7cf70bb2c4ba7b9c99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if if an Buffer&lt;T, D&gt; can be constructed from some other <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> type.  <a href="#a92d2f9350263f7cf70bb2c4ba7b9c99f">More...</a><br /></td></tr>
<tr class="separator:a92d2f9350263f7cf70bb2c4ba7b9c99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffd23ee83f803d54a5af2bbf394650f"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:a3ffd23ee83f803d54a5af2bbf394650f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a3ffd23ee83f803d54a5af2bbf394650f">assert_can_convert_from</a> (const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a3ffd23ee83f803d54a5af2bbf394650f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fail an assertion at runtime or compile-time if an Buffer&lt;T, D&gt; cannot be constructed from some other <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> type.  <a href="#a3ffd23ee83f803d54a5af2bbf394650f">More...</a><br /></td></tr>
<tr class="separator:a3ffd23ee83f803d54a5af2bbf394650f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a91a4b8591494d648a720373c046f5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; void, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a68a91a4b8591494d648a720373c046f5">make_interleaved</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0212355929ed6a149b5d0015198c9334">width</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#adf4af7ecd8ecee22bed639df971acac8">height</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a977f7595994c8bf673b99d0594ecee91">channels</a>)</td></tr>
<tr class="memdesc:a68a91a4b8591494d648a720373c046f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you use the (x, y, c) indexing convention, then <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Buffers are stored planar by default.  <a href="#a68a91a4b8591494d648a720373c046f5">More...</a><br /></td></tr>
<tr class="separator:a68a91a4b8591494d648a720373c046f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cab9a483032a76377d6fc4af736cbf6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0cab9a483032a76377d6fc4af736cbf6">make_interleaved</a> (int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0212355929ed6a149b5d0015198c9334">width</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#adf4af7ecd8ecee22bed639df971acac8">height</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a977f7595994c8bf673b99d0594ecee91">channels</a>)</td></tr>
<tr class="memdesc:a0cab9a483032a76377d6fc4af736cbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you use the (x, y, c) indexing convention, then <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Buffers are stored planar by default.  <a href="#a0cab9a483032a76377d6fc4af736cbf6">More...</a><br /></td></tr>
<tr class="separator:a0cab9a483032a76377d6fc4af736cbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22944f400ab4cad685d14ea409e7cb7f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; add_const_if_T_is_const&lt; void &gt;, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a22944f400ab4cad685d14ea409e7cb7f">make_interleaved</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t, T *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4c2876910c7960810940f7f45298dba2">data</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0212355929ed6a149b5d0015198c9334">width</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#adf4af7ecd8ecee22bed639df971acac8">height</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a977f7595994c8bf673b99d0594ecee91">channels</a>)</td></tr>
<tr class="memdesc:a22944f400ab4cad685d14ea409e7cb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an existing interleaved image.  <a href="#a22944f400ab4cad685d14ea409e7cb7f">More...</a><br /></td></tr>
<tr class="separator:a22944f400ab4cad685d14ea409e7cb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac79a1e37885495b3d55dafbddda3dd1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#aac79a1e37885495b3d55dafbddda3dd1">make_interleaved</a> (T *<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a4c2876910c7960810940f7f45298dba2">data</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a0212355929ed6a149b5d0015198c9334">width</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#adf4af7ecd8ecee22bed639df971acac8">height</a>, int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a977f7595994c8bf673b99d0594ecee91">channels</a>)</td></tr>
<tr class="memdesc:aac79a1e37885495b3d55dafbddda3dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap an existing interleaved image.  <a href="#aac79a1e37885495b3d55dafbddda3dd1">More...</a><br /></td></tr>
<tr class="separator:aac79a1e37885495b3d55dafbddda3dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc86335ea3d7af1a0a100d7dd656890e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; add_const_if_T_is_const&lt; void &gt;, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#afc86335ea3d7af1a0a100d7dd656890e">make_scalar</a> (<a class="el" href="structhalide__type__t.html">halide_type_t</a> t)</td></tr>
<tr class="memdesc:afc86335ea3d7af1a0a100d7dd656890e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a zero-dimensional <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#afc86335ea3d7af1a0a100d7dd656890e">More...</a><br /></td></tr>
<tr class="separator:afc86335ea3d7af1a0a100d7dd656890e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5033829573b98879635866922698f26a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a5033829573b98879635866922698f26a">make_scalar</a> ()</td></tr>
<tr class="memdesc:a5033829573b98879635866922698f26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a zero-dimensional <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>.  <a href="#a5033829573b98879635866922698f26a">More...</a><br /></td></tr>
<tr class="separator:a5033829573b98879635866922698f26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf19ec15f1195600de758addfd1069a0"><td class="memTemplParams" colspan="2">template&lt;typename T2 , int D2&gt; </td></tr>
<tr class="memitem:adf19ec15f1195600de758addfd1069a0"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#adf19ec15f1195600de758addfd1069a0">make_with_shape_of</a> (<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; src, void *(*allocate_fn)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)=nullptr, void(*deallocate_fn)(void *)=nullptr)</td></tr>
<tr class="memdesc:adf19ec15f1195600de758addfd1069a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a buffer with the same shape and memory nesting order as another buffer.  <a href="#adf19ec15f1195600de758addfd1069a0">More...</a><br /></td></tr>
<tr class="separator:adf19ec15f1195600de758addfd1069a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6a0432e50ffc161961ae3af4d5a6c98a"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a6a0432e50ffc161961ae3af4d5a6c98a">has_static_halide_type</a> = !T_is_void</td></tr>
<tr class="memdesc:a6a0432e50ffc161961ae3af4d5a6c98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> type is not void (or const void).  <a href="#a6a0432e50ffc161961ae3af4d5a6c98a">More...</a><br /></td></tr>
<tr class="separator:a6a0432e50ffc161961ae3af4d5a6c98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T = void, int D = 4&gt;<br />
class Halide::Runtime::Buffer&lt; T, D &gt;</h3>

<p>A templated <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> class that wraps <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> and adds functionality. </p>
<p>When using <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> from C++, this is the preferred way to create input and output buffers. The overhead of using this class relative to a naked <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> is minimal - it uses another ~16 bytes on the stack, and does no dynamic allocations when using it to represent existing memory of a known maximum dimensionality.</p>
<p>The template parameter T is the element type. For buffers where the element type is unknown, or may vary, use void or const void.</p>
<p>D is the maximum number of dimensions that can be represented using space inside the class itself. Set it to the maximum dimensionality you expect this buffer to be. If the actual dimensionality exceeds this, heap storage is allocated to track the shape of the buffer. D defaults to 4, which should cover nearly all usage.</p>
<p>The class optionally allocates and owns memory for the image using a shared pointer allocated with the provided allocator. If they are null, malloc and free are used. Any device-side allocation is considered as owned if and only if the host-side allocation is owned. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="tutorial_2lesson_10_aot_compilation_run_8cpp-example.html#_a0">tutorial/lesson_10_aot_compilation_run.cpp</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00035">35</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a897dbebfae1a242dbac4e509861266dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897dbebfae1a242dbac4e509861266dd">&#9670;&nbsp;</a></span>ElemType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html#a897dbebfae1a242dbac4e509861266dd">ElemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00354">354</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acb70f579cf7cab5457f5ce88d771ac93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb70f579cf7cab5457f5ce88d771ac93">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[1/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00464">464</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a7a9d31fcdc71f7c00dafe9d076e9dc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9d31fcdc71f7c00dafe9d076e9dc27">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[2/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139">BufferDeviceOwnership</a>&#160;</td>
          <td class="paramname"><em>ownership</em> = <code><a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139a6b982c948840b6e4b5fec2711f09627d">BufferDeviceOwnership::Unmanaged</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a>. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00470">470</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l01166">halide_buffer_t::type</a>.</p>

</div>
</div>
<a id="a1cdf833c01068763b282b209eb0a18af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdf833c01068763b282b209eb0a18af">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[3/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuffer__t.html">buffer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>old_buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a legacy <a class="el" href="structbuffer__t.html">buffer_t</a>. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00477">477</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l01300">buffer_t::dev</a>, <a class="el" href="_halide_runtime_8h_source.html#l01305">buffer_t::elem_size</a>, <a class="el" href="_halide_runtime_8h_source.html#l01302">buffer_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l01301">buffer_t::host</a>, <a class="el" href="_halide_runtime_8h_source.html#l01304">buffer_t::min</a>, and <a class="el" href="_halide_runtime_8h_source.html#l01303">buffer_t::stride</a>.</p>

</div>
</div>
<a id="a47307ea974c0025db0b9d6bc646de65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47307ea974c0025db0b9d6bc646de65c">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[4/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Does not copy underlying data. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00538">538</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a1b96681d758ad414ff7751bca77ae863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b96681d758ad414ff7751bca77ae863">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[5/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of different dimensionality and type. </p>
<p>Asserts that the type matches (at runtime, if one of the types is void). Note that this constructor is implicit. This, for example, lets you pass things like Buffer&lt;T&gt; or Buffer&lt;const void&gt; to functions expected Buffer&lt;const T&gt;. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00552">552</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a0b7e09bd6c742852fe6507e1e37081b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7e09bd6c742852fe6507e1e37081b4">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[6/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00561">561</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l01152">halide_buffer_t::device</a>, and <a class="el" href="_halide_runtime_8h_source.html#l01155">halide_buffer_t::device_interface</a>.</p>

</div>
</div>
<a id="a2649e245b86b2975807b11a0d91f766e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2649e245b86b2975807b11a0d91f766e">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[7/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of different dimensionality and type. </p>
<p>Asserts that the types match (at runtime if one of the types is void). </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00575">575</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l01152">halide_buffer_t::device</a>, and <a class="el" href="_halide_runtime_8h_source.html#l01155">halide_buffer_t::device_interface</a>.</p>

</div>
</div>
<a id="ad970ef6a40a49021382f1f94905cd800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad970ef6a40a49021382f1f94905cd800">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[8/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of the given size with a runtime type. </p>
<p>Only used when you do know what size you want but you don't know statically what type the elements are. Pass zeroes to make a buffer suitable for bounds query calls. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00714">714</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a1b9d3997c7c6d260a3419cda075178d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9d3997c7c6d260a3419cda075178d1">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[9/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of the given size. </p>
<p>Pass zeroes to make a buffer suitable for bounds query calls. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00735">735</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="ae39e3f37f0d706e5817fc00203a4c398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39e3f37f0d706e5817fc00203a4c398">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[10/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of the given size. </p>
<p>Pass zeroes to make a buffer suitable for bounds query calls. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00750">750</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a0013744b24a2a075b4fd1ef123af495b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0013744b24a2a075b4fd1ef123af495b">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[11/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of unknown type using a vector of ints as the size. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00765">765</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a52db43880a5c487452f11936cb1166ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52db43880a5c487452f11936cb1166ab">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[12/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new image of known type using a vector of ints as the size. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00780">780</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a7aac7bbcf212bfd87b017ded998140a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aac7bbcf212bfd87b017ded998140a9">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[13/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Array , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">Array(&amp;)&#160;</td>
          <td class="paramname"><em>vals</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> that refers to a statically sized array. </p>
<p>Does not take ownership of the data, and does not set the host_dirty flag. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00794">794</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a73930eae77ea382b041c2fd281c9322e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73930eae77ea382b041c2fd281c9322e">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[14/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_const_if_T_is_const&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of runtime type from a pointer and some sizes. </p>
<p>Assumes dense row-major packing and a min coordinate of zero. Does not take ownership of the data and does not set the host_dirty flag. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00808">808</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a669b43683e7ba87a926a36f7f31d1b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669b43683e7ba87a926a36f7f31d1b8b">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[15/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer and some sizes. </p>
<p>Assumes dense row-major packing and a min coordinate of zero. Does not take ownership of the data and does not set the host_dirty flag. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00824">824</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a31c020e81707b663ee4761d852222e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c020e81707b663ee4761d852222e94">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[16/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer and a vector of sizes. </p>
<p>Assumes dense row-major packing and a min coordinate of zero. Does not take ownership of the data and does not set the host_dirty flag. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00836">836</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="ae9301d7908f8580de77b58384eb19582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9301d7908f8580de77b58384eb19582">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[17/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_const_if_T_is_const&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of runtime type from a pointer and a vector of sizes. </p>
<p>Assumes dense row-major packing and a min coordinate of zero. Does not take ownership of the data and does not set the host_dirty flag. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00848">848</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a00ce543ccc08cc06bf35050a0fca989e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ce543ccc08cc06bf35050a0fca989e">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[18/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">add_const_if_T_is_const&lt; void &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> *&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and an array describing the shape. </p>
<p>Does not take ownership of the data, and does not set the host_dirty flag. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00862">862</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a84a2b9d12d26d24480c0519490ee975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a2b9d12d26d24480c0519490ee975e">&#9670;&nbsp;</a></span>Buffer() <span class="overload">[19/19]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhalide__dimension__t.html">halide_dimension_t</a> *&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> from a pointer to the min coordinate and an array describing the shape. </p>
<p>Does not take ownership of the data and does not set the host_dirty flag. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00878">878</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="ab3f46c67f0f5210b97b570a3e7fac95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f46c67f0f5210b97b570a3e7fac95e">&#9670;&nbsp;</a></span>~Buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::~<a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Will release any underlying owned allocation if this is the last reference to it. Will assert fail if there are weak references to this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> outstanding. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00891">891</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a79d49b7ea3e9045ad11d1ca81c8ab408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d49b7ea3e9045ad11d1ca81c8ab408">&#9670;&nbsp;</a></span>static_halide_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structhalide__type__t.html">halide_type_t</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::static_halide_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> type of T. </p>
<p>Callers should not use the result if has_static_halide_type is false. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00144">144</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00379">Halide::Buffer&lt;&gt;::static_halide_type()</a>.</p>

</div>
</div>
<a id="a0d36d70f9f26e6c74faf08cd3f7061e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d36d70f9f26e6c74faf08cd3f7061e8">&#9670;&nbsp;</a></span>owns_host_memory()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::owns_host_memory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> own the host memory it refers to? </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00149">149</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139a030218254584bb915dbaa23473bf1be7">Halide::Runtime::Allocated</a>, <a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139a4bf6b0068f5403fac944342621d7e21d">Halide::Runtime::AllocatedDeviceAndHost</a>, <a class="el" href="runtime__internal_8h_source.html#l00197">Halide::Runtime::Internal::b</a>, <a class="el" href="_halide_buffer_8h_source.html#l00078">Halide::Runtime::DeviceRefCount::count</a>, <a class="el" href="_halide_buffer_8h_source.html#l00062">Halide::Runtime::AllocationHeader::deallocate_fn</a>, <a class="el" href="_halide_runtime_8h_source.html#l01152">halide_buffer_t::device</a>, <a class="el" href="_halide_runtime_8h_source.html#l01173">halide_buffer_t::dim</a>, <a class="el" href="_func_8h_source.html#l00419">Halide::max()</a>, <a class="el" href="runtime__internal_8h.html#add55236e1a6168d059f1409762081d1a">memcpy()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00079">Halide::Runtime::DeviceRefCount::ownership</a>, <a class="el" href="_halide_buffer_8h_source.html#l00063">Halide::Runtime::AllocationHeader::ref_count</a>, and <a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139a5f6e793d786dfb1f54ab06b29c5a6e2a">Halide::Runtime::WrappedNative</a>.</p>

</div>
</div>
<a id="ad32e3ece8aac2a8f27057b75604dbc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32e3ece8aac2a8f27057b75604dbc11">&#9670;&nbsp;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer_1_1_dimension.html">Dimension</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::dim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the shape of the buffer. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00404">404</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00996">Halide::Runtime::Buffer&lt; T, D &gt;::copy_from()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01613">Halide::Runtime::Buffer&lt; T, D &gt;::fill()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01457">Halide::Runtime::Buffer&lt; T, D &gt;::make_with_shape_of()</a>.</p>

</div>
</div>
<a id="af3880b4f6fdd7fb48003e3218c823b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3880b4f6fdd7fb48003e3218c823b9d">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::min </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the mins, strides, extents. </p>
<p>Will be deprecated. Do not use. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00410">410</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a20485927b517cab777c243cbbf9ee0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20485927b517cab777c243cbbf9ee0fa">&#9670;&nbsp;</a></span>extent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::extent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the mins, strides, extents. </p>
<p>Will be deprecated. Do not use. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00411">411</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a8a5eb0526a5d19a6d51f392c7a66194a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5eb0526a5d19a6d51f392c7a66194a">&#9670;&nbsp;</a></span>stride()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::stride </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the mins, strides, extents. </p>
<p>Will be deprecated. Do not use. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00412">412</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a859f7c60e0afe9ac395cf1d6f49cdbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859f7c60e0afe9ac395cf1d6f49cdbec">&#9670;&nbsp;</a></span>number_of_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::number_of_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of elements this buffer represents. </p>
<p>Equal to the product of the extents </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00417">417</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a0aeeb5d75f820fdf6503531dafbe5e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aeeb5d75f820fdf6503531dafbe5e3c">&#9670;&nbsp;</a></span>dimensions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::dimensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the dimensionality of the buffer. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00426">426</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00996">Halide::Runtime::Buffer&lt; T, D &gt;::copy_from()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01613">Halide::Runtime::Buffer&lt; T, D &gt;::fill()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01457">Halide::Runtime::Buffer&lt; T, D &gt;::make_with_shape_of()</a>.</p>

</div>
</div>
<a id="a86dae808d0762400cc0e2efb65ad5e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86dae808d0762400cc0e2efb65ad5e84">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhalide__type__t.html">halide_type_t</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of the elements. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00431">431</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00517">Halide::Runtime::Buffer&lt; T, D &gt;::can_convert_from()</a>.</p>

</div>
</div>
<a id="a257ade503e585ecb50232e2e3f9ab15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257ade503e585ecb50232e2e3f9ab15e">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the element with the lowest address. </p>
<p>If all strides are positive, equal to the host pointer. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00437">437</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a8b96cc7392f2cc9b4a6697d04f9d0283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b96cc7392f2cc9b4a6697d04f9d0283">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to one beyond the element with the highest address. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00448">448</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="ac89dc1fa1ed026c83e30c18a8f7e0fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89dc1fa1ed026c83e30c18a8f7e0fb4">&#9670;&nbsp;</a></span>size_in_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::size_in_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of bytes spanned by the data in memory. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00460">460</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="printer_8h_source.html#l00030">end</a>.</p>

</div>
</div>
<a id="a5a104178f209e6ff6c7b7cd2802250cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a104178f209e6ff6c7b7cd2802250cc">&#9670;&nbsp;</a></span>make_legacy_buffer_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbuffer__t.html">buffer_t</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_legacy_buffer_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate the fields of a legacy <a class="el" href="structbuffer__t.html">buffer_t</a> using this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>
<p>Does not copy device metadata. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00496">496</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l01305">buffer_t::elem_size</a>, <a class="el" href="_halide_runtime_8h_source.html#l01302">buffer_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l01301">buffer_t::host</a>, <a class="el" href="_halide_runtime_8h_source.html#l01304">buffer_t::min</a>, and <a class="el" href="_halide_runtime_8h_source.html#l01303">buffer_t::stride</a>.</p>

</div>
</div>
<a id="a92d2f9350263f7cf70bb2c4ba7b9c99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d2f9350263f7cf70bb2c4ba7b9c99f">&#9670;&nbsp;</a></span>can_convert_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::can_convert_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if if an Buffer&lt;T, D&gt; can be constructed from some other <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> type. </p>
<p>If this can be determined at compile time, fail with a static assert; otherwise return a boolean based on runtime typing. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00517">517</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l00431">Halide::Runtime::Buffer&lt; T, D &gt;::type()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00384">Halide::Buffer&lt;&gt;::can_convert_from()</a>.</p>

</div>
</div>
<a id="a3ffd23ee83f803d54a5af2bbf394650f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffd23ee83f803d54a5af2bbf394650f">&#9670;&nbsp;</a></span>assert_can_convert_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::assert_can_convert_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fail an assertion at runtime or compile-time if an Buffer&lt;T, D&gt; cannot be constructed from some other <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> type. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00533">533</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00919">Halide::Runtime::Buffer&lt; T, D &gt;::as()</a>.</p>

</div>
</div>
<a id="a73b21234b1b51c23d70dde4c7bc0ce68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b21234b1b51c23d70dde4c7bc0ce68">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign from another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality and type. </p>
<p>Asserts that the types match (at runtime if one of the types is void). </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00589">589</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a38b0a9cb0fed41c0445d6927240bb50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b0a9cb0fed41c0445d6927240bb50c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard assignment operator. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00605">605</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a2feda3bb0e3bde94f01791b2c3f45449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2feda3bb0e3bde94f01791b2c3f45449">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move from another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> of possibly-different dimensionality and type. </p>
<p>Asserts that the types match (at runtime if one of the types is void). </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00623">623</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l01152">halide_buffer_t::device</a>, and <a class="el" href="_halide_runtime_8h_source.html#l01155">halide_buffer_t::device_interface</a>.</p>

</div>
</div>
<a id="ad9a180f067e57d8ea9a3b61e4d12769e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a180f067e57d8ea9a3b61e4d12769e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T, D &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard move-assignment operator. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00639">639</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l01152">halide_buffer_t::device</a>, and <a class="el" href="_halide_runtime_8h_source.html#l01155">halide_buffer_t::device_interface</a>.</p>

</div>
</div>
<a id="ab7961b0f7ee27508c36fb019d3d3a67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7961b0f7ee27508c36fb019d3d3a67e">&#9670;&nbsp;</a></span>check_overflow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::check_overflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the product of the extents fits in memory. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00654">654</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a759f8c2487886eb85bc2607f11beabd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759f8c2487886eb85bc2607f11beabd1">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">void *(*)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)&#160;</td>
          <td class="paramname"><em>allocate_fn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>deallocate_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate memory for this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>
<p>Drops the reference to any owned memory. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00669">669</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l00062">Halide::Runtime::AllocationHeader::deallocate_fn</a>, <a class="el" href="runtime__internal_8h.html#af07d89f5ceaea0c7c8252cc41fd75f37">free()</a>, <a class="el" href="runtime__internal_8h.html#a1c8580582aae58105f16108d4ec89e9a">malloc()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00063">Halide::Runtime::AllocationHeader::ref_count</a>.</p>

</div>
</div>
<a id="a65b39bfac1c4ccca5eb45af9cfbeed7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b39bfac1c4ccca5eb45af9cfbeed7d">&#9670;&nbsp;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop reference to any owned host or device memory, possibly freeing it, if this buffer held the last reference to it. </p>
<p>Retains the shape of the buffer. Does nothing if this buffer did not allocate its own memory. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00697">697</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="af82da5ef4c1264386e705ef9b7e475c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82da5ef4c1264386e705ef9b7e475c7">&#9670;&nbsp;</a></span>device_deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_deallocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop reference to any owned device memory, possibly freeing it if this buffer held the last reference to it. </p>
<p>Asserts that device_dirty is false. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00704">704</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a2fcb27dc04a87015427ad6aa4bd55e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcb27dc04a87015427ad6aa4bd55e89">&#9670;&nbsp;</a></span>raw_buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a>* <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::raw_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the raw <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> this wraps. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00898">898</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="printer_8h_source.html#l00030">buf</a>.</p>

</div>
</div>
<a id="abfdb7fc902921e8c9347e7bb235be4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfdb7fc902921e8c9347e7bb235be4a2">&#9670;&nbsp;</a></span>raw_buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a>* <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::raw_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the raw <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> this wraps. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00902">902</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="printer_8h_source.html#l00030">buf</a>.</p>

</div>
</div>
<a id="a2a6e8717724ac6b06571a1d0d82c064e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6e8717724ac6b06571a1d0d82c064e">&#9670;&nbsp;</a></span>operator halide_buffer_t *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator <a class="el" href="structhalide__buffer__t.html">halide_buffer_t</a> * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a cast operator to <a class="el" href="structhalide__buffer__t.html" title="The raw representation of an image passed around by generated Halide code. ">halide_buffer_t</a> *, so that instances can be passed directly to <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> filters. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00909">909</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="printer_8h_source.html#l00030">buf</a>.</p>

</div>
</div>
<a id="afa92236129a979599093e6aecd0b7b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa92236129a979599093e6aecd0b7b90">&#9670;&nbsp;</a></span>as() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2 = D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T2, D2&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::as </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a typed reference to this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>
<p>Useful for converting a reference to a Buffer&lt;void&gt; to a reference to, for example, a Buffer&lt;const uint8_t&gt;. Does a runtime assert if the source buffer type is void. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00919">919</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l00533">Halide::Runtime::Buffer&lt; T, D &gt;::assert_can_convert_from()</a>.</p>

</div>
</div>
<a id="a495a933b54a287da107d5707d2194078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495a933b54a287da107d5707d2194078">&#9670;&nbsp;</a></span>as() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2 = D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T2, D2&gt;&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::as </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const typed reference to this <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>
<p>Useful for converting a conference reference to one <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> type to a const reference to another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> type. Does a runtime assert if the source buffer type is void. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00930">930</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l00533">Halide::Runtime::Buffer&lt; T, D &gt;::assert_can_convert_from()</a>.</p>

</div>
</div>
<a id="a740f50d25fb68578dfbbebabc7597b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740f50d25fb68578dfbbebabc7597b8d">&#9670;&nbsp;</a></span>as() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2 = D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T2, D2&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::as </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this rval <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> with a different type attached. </p>
<p>Does a dynamic type check if the source type is void. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00938">938</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l00533">Halide::Runtime::Buffer&lt; T, D &gt;::assert_can_convert_from()</a>.</p>

</div>
</div>
<a id="a0212355929ed6a149b5d0015198c9334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0212355929ed6a149b5d0015198c9334">&#9670;&nbsp;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the first three dimensions. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00945">945</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="adf4af7ecd8ecee22bed639df971acac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4af7ecd8ecee22bed639df971acac8">&#9670;&nbsp;</a></span>height()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the first three dimensions. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00948">948</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a977f7595994c8bf673b99d0594ecee91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977f7595994c8bf673b99d0594ecee91">&#9670;&nbsp;</a></span>channels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::channels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the first three dimensions. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00951">951</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a6941d552162fdd18174379aa572bb951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6941d552162fdd18174379aa572bb951">&#9670;&nbsp;</a></span>left()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the min and max value of each dimension. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00958">958</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="ae1dba2e0d8029ac9b9df4196ca9f167e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1dba2e0d8029ac9b9df4196ca9f167e">&#9670;&nbsp;</a></span>right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the min and max value of each dimension. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00962">962</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a8c68b83bf2196b4fe31d5a19e866279c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c68b83bf2196b4fe31d5a19e866279c">&#9670;&nbsp;</a></span>top()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the min and max value of each dimension. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00966">966</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a49616c07a3e9a3e5694f4b1f319174ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49616c07a3e9a3e5694f4b1f319174ad">&#9670;&nbsp;</a></span>bottom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::bottom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conventional names for the min and max value of each dimension. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00970">970</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a88259ff293a390125896f095e0e58bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88259ff293a390125896f095e0e58bc3">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">void *(*)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)&#160;</td>
          <td class="paramname"><em>allocate_fn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>deallocate_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a new image which is a deep copy of this image. </p>
<p>Use crop or slice followed by copy to make a copy of only a portion of the image. The new image uses the same memory layout as the original, with holes compacted away. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00979">979</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l00996">Halide::Runtime::Buffer&lt; T, D &gt;::copy_from()</a>, and <a class="el" href="printer_8h_source.html#l00030">dst</a>.</p>

</div>
</div>
<a id="ac9982b308f61426dd5a33aa31dfc156f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9982b308f61426dd5a33aa31dfc156f">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> with the values at the same coordinates in another <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>
<p>Restricts itself to coordinates contained within the intersection of the two buffers. If the two Buffers are not in the same coordinate system, you will need to translate the argument <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a> first. E.g. if you're blitting a sprite onto a framebuffer, you'll want to translate the sprite to the correct location first like so:</p><div class="fragment"><div class="line">framebuffer.copy_from(sprite.translated({x, y})); </div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00996">996</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l01059">Halide::Runtime::Buffer&lt; T, D &gt;::crop()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01265">Halide::Runtime::Buffer&lt; T, D &gt;::device_dirty()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00404">Halide::Runtime::Buffer&lt; T, D &gt;::dim()</a>, <a class="el" href="_halide_buffer_8h_source.html#l00426">Halide::Runtime::Buffer&lt; T, D &gt;::dimensions()</a>, <a class="el" href="printer_8h_source.html#l00030">dst</a>, <a class="el" href="_halide_buffer_8h_source.html#l01711">Halide::Runtime::Buffer&lt; T, D &gt;::for_each_value()</a>, <a class="el" href="_func_8h_source.html#l00419">Halide::max()</a>, and <a class="el" href="_func_8h_source.html#l00418">Halide::min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00979">Halide::Runtime::Buffer&lt; T, D &gt;::copy()</a>.</p>

</div>
</div>
<a id="a751c5e8cf2bc45cc5492107e72ea5ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751c5e8cf2bc45cc5492107e72ea5ed8">&#9670;&nbsp;</a></span>cropped() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::cropped </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image that refers to a sub-range of this image along the given dimension. </p>
<p>Does not assert the crop region is within the existing bounds. The cropped image drops any device handle. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01050">1050</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l01059">Halide::Runtime::Buffer&lt; T, D &gt;::crop()</a>.</p>

</div>
</div>
<a id="a4a4e4a871377e1eb48980b5fc697c276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4e4a871377e1eb48980b5fc697c276">&#9670;&nbsp;</a></span>crop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::crop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crop an image in-place along the given dimension. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01059">1059</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l00418">Halide::min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00996">Halide::Runtime::Buffer&lt; T, D &gt;::copy_from()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01050">Halide::Runtime::Buffer&lt; T, D &gt;::cropped()</a>.</p>

</div>
</div>
<a id="a25f5c12166d98b9aa0e446135f9e7bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f5c12166d98b9aa0e446135f9e7bd1">&#9670;&nbsp;</a></span>cropped() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::cropped </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image that refers to a sub-rectangle of this image along the first N dimensions. </p>
<p>Does not assert the crop region is within the existing bounds. The cropped image drops any device handle. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01076">1076</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l01059">Halide::Runtime::Buffer&lt; T, D &gt;::crop()</a>.</p>

</div>
</div>
<a id="a73e4477fcde56c9f0f448281cd15efad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e4477fcde56c9f0f448281cd15efad">&#9670;&nbsp;</a></span>crop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::crop </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crop an image in-place along the first N dimensions. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01085">1085</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l00419">Halide::max()</a>.</p>

</div>
</div>
<a id="a288f3d55c05380228f2a8b7a9afcbb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288f3d55c05380228f2a8b7a9afcbb0f">&#9670;&nbsp;</a></span>translated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::translated </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image which refers to the same data with using translated coordinates in the given dimension. </p>
<p>Positive values move the image data to the right or down relative to the coordinate system. Drops any device handle. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01098">1098</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l01105">Halide::Runtime::Buffer&lt; T, D &gt;::translate()</a>.</p>

</div>
</div>
<a id="a08186761f27f13d4097e85b467d2b534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08186761f27f13d4097e85b467d2b534">&#9670;&nbsp;</a></span>translate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::translate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate an image in-place along one dimension. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01105">1105</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01098">Halide::Runtime::Buffer&lt; T, D &gt;::translated()</a>.</p>

</div>
</div>
<a id="a5cb8dd2cde057cfd098d45e9fc2b7a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb8dd2cde057cfd098d45e9fc2b7a52">&#9670;&nbsp;</a></span>translated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::translated </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image which refers to the same data translated along the first N dimensions. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01112">1112</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l01105">Halide::Runtime::Buffer&lt; T, D &gt;::translate()</a>.</p>

</div>
</div>
<a id="a401c86c132079debb43a85b5957ed9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401c86c132079debb43a85b5957ed9a5">&#9670;&nbsp;</a></span>translate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::translate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translate an image along the first N dimensions. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01119">1119</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_func_8h_source.html#l00419">Halide::max()</a>.</p>

</div>
</div>
<a id="af1a284f8c5f2c4cbc343f9f9885eda1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a284f8c5f2c4cbc343f9f9885eda1a">&#9670;&nbsp;</a></span>set_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::set_min </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the min coordinate of an image in the first N dimensions. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01131">1131</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a4fef9b582e15c061fbc7177ea459abb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fef9b582e15c061fbc7177ea459abb4">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a given coordinate is within the the bounds of an image. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01142">1142</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a82b28d656d63704c6cc14adc3939d69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b28d656d63704c6cc14adc3939d69f">&#9670;&nbsp;</a></span>transposed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::transposed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an image which refers to the same data using a different ordering of the dimensions. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01155">1155</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l01162">Halide::Runtime::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
<a id="a8ca18450bcc383920ca5f69a9b04b097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca18450bcc383920ca5f69a9b04b097">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::transpose </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose an image in-place. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01162">1162</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01403">Halide::Runtime::Buffer&lt; T, D &gt;::make_interleaved()</a>, <a class="el" href="_halide_buffer_8h_source.html#l01457">Halide::Runtime::Buffer&lt; T, D &gt;::make_with_shape_of()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01155">Halide::Runtime::Buffer&lt; T, D &gt;::transposed()</a>.</p>

</div>
</div>
<a id="a3eadfc9ad81d2e464915df85ca1afd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eadfc9ad81d2e464915df85ca1afd34">&#9670;&nbsp;</a></span>sliced()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::sliced </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a lower-dimensional image that refers to one slice of this image. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01168">1168</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l01175">Halide::Runtime::Buffer&lt; T, D &gt;::slice()</a>.</p>

</div>
</div>
<a id="a2ba2eeed0bf8a096915189de65a5922b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba2eeed0bf8a096915189de65a5922b">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slice an image in-place. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01175">1175</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01441">Halide::Runtime::Buffer&lt; T, D &gt;::make_scalar()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01168">Halide::Runtime::Buffer&lt; T, D &gt;::sliced()</a>.</p>

</div>
</div>
<a id="a06187d914dbe5e53a02e0b69b6a092ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06187d914dbe5e53a02e0b69b6a092ec">&#9670;&nbsp;</a></span>embedded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::embedded </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a new image that views this image as a single slice in a higher-dimensional space. </p>
<p>The new dimension has extent one and the given min. This operation is the opposite of slice. As an example, the following condition is true:</p>
<div class="fragment"><div class="line">im2 = im.embedded(1, 17);</div><div class="line">&amp;im(x, y, c) == &amp;im2(x, 17, y, c);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01200">1200</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l01209">Halide::Runtime::Buffer&lt; T, D &gt;::embed()</a>.</p>

</div>
</div>
<a id="a46c4570f918cc6c7b39f7e1fbee55e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c4570f918cc6c7b39f7e1fbee55e3d">&#9670;&nbsp;</a></span>embed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::embed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Embed an image in-place, increasing the dimensionality. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01209">1209</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l01200">Halide::Runtime::Buffer&lt; T, D &gt;::embedded()</a>.</p>

</div>
</div>
<a id="aa2bcf81706f57476668568dd8ea2c403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bcf81706f57476668568dd8ea2c403">&#9670;&nbsp;</a></span>add_dimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::add_dimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new dimension with a min of zero and an extent of one. </p>
<p>The stride is the extent of the outermost dimension times its stride. The new dimension is the last dimension. This is a special case of embed. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01222">1222</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l01115">halide_dimension_t::stride</a>.</p>

</div>
</div>
<a id="ae7993fdda560897f4d745177470f03d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7993fdda560897f4d745177470f03d8">&#9670;&nbsp;</a></span>add_dimension_with_stride()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::add_dimension_with_stride </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new dimension with a min of zero, an extent of one, and the specified stride. </p>
<p>The new dimension is the last dimension. This is a special case of embed. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01253">1253</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="ae6174e9d4e337351d6a8716d5dd1c91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6174e9d4e337351d6a8716d5dd1c91c">&#9670;&nbsp;</a></span>set_host_dirty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::set_host_dirty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01260">1260</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="af44b8b797624c2188886c1ba7f34576c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44b8b797624c2188886c1ba7f34576c">&#9670;&nbsp;</a></span>device_dirty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_dirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01265">1265</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00996">Halide::Runtime::Buffer&lt; T, D &gt;::copy_from()</a>.</p>

</div>
</div>
<a id="a07ec04364e9dde0b2eb2f5f01592792e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ec04364e9dde0b2eb2f5f01592792e">&#9670;&nbsp;</a></span>host_dirty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::host_dirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01269">1269</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a3219cd20977b4e71add236e9145b7978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3219cd20977b4e71add236e9145b7978">&#9670;&nbsp;</a></span>set_device_dirty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::set_device_dirty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01273">1273</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="af0af202d3ca2202627e8b80578a4b8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0af202d3ca2202627e8b80578a4b8e0">&#9670;&nbsp;</a></span>copy_to_host()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::copy_to_host </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01278">1278</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a78605b601a2e0f548546d58cbee80eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78605b601a2e0f548546d58cbee80eef">&#9670;&nbsp;</a></span>copy_to_device()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::copy_to_device </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01285">1285</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l00525">halide_device_interface_t::copy_to_device</a>.</p>

</div>
</div>
<a id="ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cb60be4d9d2b8b2b0dcdc7fddc7ebe">&#9670;&nbsp;</a></span>device_malloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_malloc </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01292">1292</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l00518">halide_device_interface_t::device_malloc</a>.</p>

</div>
</div>
<a id="a2f97463086f872f03d846bd13774401b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f97463086f872f03d846bd13774401b">&#9670;&nbsp;</a></span>device_free()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01296">1296</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139a030218254584bb915dbaa23473bf1be7">Halide::Runtime::Allocated</a>, <a class="el" href="_halide_buffer_8h_source.html#l00078">Halide::Runtime::DeviceRefCount::count</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00079">Halide::Runtime::DeviceRefCount::ownership</a>.</p>

</div>
</div>
<a id="a5eab3a0f803010e2bbe998c5ba222fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eab3a0f803010e2bbe998c5ba222fbe">&#9670;&nbsp;</a></span>device_wrap_native()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_wrap_native </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#a015141fcb741f5cbee8e65a30b61e1ce">uint64_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01319">1319</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l00079">Halide::Runtime::DeviceRefCount::ownership</a>, <a class="el" href="_halide_runtime_8h_source.html#l00535">halide_device_interface_t::wrap_native</a>, and <a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139a5f6e793d786dfb1f54ab06b29c5a6e2a">Halide::Runtime::WrappedNative</a>.</p>

</div>
</div>
<a id="a2f08f71aa63ed354760dc3d82156c913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f08f71aa63ed354760dc3d82156c913">&#9670;&nbsp;</a></span>device_detach_native()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_detach_native </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01327">1327</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l00078">Halide::Runtime::DeviceRefCount::count</a>, <a class="el" href="_halide_buffer_8h_source.html#l00079">Halide::Runtime::DeviceRefCount::ownership</a>, and <a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139a5f6e793d786dfb1f54ab06b29c5a6e2a">Halide::Runtime::WrappedNative</a>.</p>

</div>
</div>
<a id="a785163ac59a479c35a1c40d6c7438196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785163ac59a479c35a1c40d6c7438196">&#9670;&nbsp;</a></span>device_and_host_malloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_and_host_malloc </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01349">1349</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l00527">halide_device_interface_t::device_and_host_malloc</a>.</p>

</div>
</div>
<a id="a8e191e00e4e7be10f571f02d256adf2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e191e00e4e7be10f571f02d256adf2d">&#9670;&nbsp;</a></span>device_and_host_free()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_and_host_free </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structhalide__device__interface__t.html">halide_device_interface_t</a> *&#160;</td>
          <td class="paramname"><em>device_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01353">1353</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139a4bf6b0068f5403fac944342621d7e21d">Halide::Runtime::AllocatedDeviceAndHost</a>, <a class="el" href="_halide_buffer_8h_source.html#l00078">Halide::Runtime::DeviceRefCount::count</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00079">Halide::Runtime::DeviceRefCount::ownership</a>.</p>

</div>
</div>
<a id="ad9a7fb49d3ef831fcefde4e110d0dbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a7fb49d3ef831fcefde4e110d0dbba">&#9670;&nbsp;</a></span>device_sync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_sync </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01376">1376</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a74ceab490f4b6f4eee9b3158347ef2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ceab490f4b6f4eee9b3158347ef2a2">&#9670;&nbsp;</a></span>has_device_allocation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::has_device_allocation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for managing any GPU allocation. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01384">1384</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="add02956afe11074378fa40188a6543f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add02956afe11074378fa40188a6543f7">&#9670;&nbsp;</a></span>device_ownership()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139">BufferDeviceOwnership</a> <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::device_ownership </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the method by which the device field is managed. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01389">1389</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="namespace_halide_1_1_runtime.html#a73f7124ef4cb605c30adbf8216681139a030218254584bb915dbaa23473bf1be7">Halide::Runtime::Allocated</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00079">Halide::Runtime::DeviceRefCount::ownership</a>.</p>

</div>
</div>
<a id="a68a91a4b8591494d648a720373c046f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a91a4b8591494d648a720373c046f5">&#9670;&nbsp;</a></span>make_interleaved() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;void, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_interleaved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If you use the (x, y, c) indexing convention, then <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Buffers are stored planar by default. </p>
<p>This function constructs an interleaved RGB or RGBA image that can still be indexed using (x, y, c). Passing it to a generator requires that the generator has been compiled with support for interleaved (also known as packed or chunky) memory layouts. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01403">1403</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l01162">Halide::Runtime::Buffer&lt; T, D &gt;::transpose()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00224">Halide::Buffer&lt;&gt;::make_interleaved()</a>.</p>

</div>
</div>
<a id="a0cab9a483032a76377d6fc4af736cbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cab9a483032a76377d6fc4af736cbf6">&#9670;&nbsp;</a></span>make_interleaved() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_interleaved </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If you use the (x, y, c) indexing convention, then <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> Buffers are stored planar by default. </p>
<p>This function constructs an interleaved RGB or RGBA image that can still be indexed using (x, y, c). Passing it to a generator requires that the generator has been compiled with support for interleaved (also known as packed or chunky) memory layouts. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01416">1416</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l01162">Halide::Runtime::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
<a id="a22944f400ab4cad685d14ea409e7cb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22944f400ab4cad685d14ea409e7cb7f">&#9670;&nbsp;</a></span>make_interleaved() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;add_const_if_T_is_const&lt;void&gt;, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_interleaved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an existing interleaved image. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01425">1425</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l01162">Halide::Runtime::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
<a id="aac79a1e37885495b3d55dafbddda3dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac79a1e37885495b3d55dafbddda3dd1">&#9670;&nbsp;</a></span>make_interleaved() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_interleaved </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap an existing interleaved image. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01433">1433</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l01162">Halide::Runtime::Buffer&lt; T, D &gt;::transpose()</a>.</p>

</div>
</div>
<a id="afc86335ea3d7af1a0a100d7dd656890e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc86335ea3d7af1a0a100d7dd656890e">&#9670;&nbsp;</a></span>make_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;add_const_if_T_is_const&lt;void&gt;, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhalide__type__t.html">halide_type_t</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a zero-dimensional <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01441">1441</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="printer_8h_source.html#l00030">buf</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01175">Halide::Runtime::Buffer&lt; T, D &gt;::slice()</a>.</p>

</div>
</div>
<a id="a5033829573b98879635866922698f26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5033829573b98879635866922698f26a">&#9670;&nbsp;</a></span>make_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_scalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a zero-dimensional <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html" title="A templated Buffer class that wraps halide_buffer_t and adds functionality. ">Buffer</a>. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01448">1448</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="printer_8h_source.html#l00030">buf</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01175">Halide::Runtime::Buffer&lt; T, D &gt;::slice()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00216">Halide::Buffer&lt;&gt;::make_scalar()</a>.</p>

</div>
</div>
<a id="adf19ec15f1195600de758addfd1069a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf19ec15f1195600de758addfd1069a0">&#9670;&nbsp;</a></span>make_with_shape_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename T2 , int D2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt;T, D&gt; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::make_with_shape_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a>&lt; T2, D2 &gt;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(<a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>)&#160;</td>
          <td class="paramname"><em>allocate_fn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>deallocate_fn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a buffer with the same shape and memory nesting order as another buffer. </p>
<p>It may have a different type. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01457">1457</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l00404">Halide::Runtime::Buffer&lt; T, D &gt;::dim()</a>, <a class="el" href="_halide_runtime_8h_source.html#l01173">halide_buffer_t::dim</a>, <a class="el" href="_halide_buffer_8h_source.html#l00426">Halide::Runtime::Buffer&lt; T, D &gt;::dimensions()</a>, <a class="el" href="printer_8h_source.html#l00030">dst</a>, <a class="el" href="_halide_runtime_8h_source.html#l01115">halide_dimension_t::extent</a>, <a class="el" href="_halide_runtime_8h_source.html#l00027">HALIDE_ALWAYS_INLINE</a>, <a class="el" href="_halide_runtime_8h_source.html#l01115">halide_dimension_t::stride</a>, and <a class="el" href="_halide_buffer_8h_source.html#l01162">Halide::Runtime::Buffer&lt; T, D &gt;::transpose()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_buffer_8h_source.html#l00247">Halide::Buffer&lt;&gt;::make_with_shape_of()</a>.</p>

</div>
</div>
<a id="a4c2876910c7960810940f7f45298dba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2876910c7960810940f7f45298dba2">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the address of the min coordinate. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01540">1540</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="aedf54ffc79bfb1e6712507e452a744d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf54ffc79bfb1e6712507e452a744d7">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the address of the min coordinate. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01544">1544</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l00027">HALIDE_ALWAYS_INLINE</a>.</p>

</div>
</div>
<a id="ab2119a46845d354a7d9abda6a8f8477d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2119a46845d354a7d9abda6a8f8477d">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const not_void_T&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. The non-const versions set the host_dirty flag to true. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01559">1559</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l00027">HALIDE_ALWAYS_INLINE</a>.</p>

</div>
</div>
<a id="ae1d5997b23e03865220d426a0a3d3219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d5997b23e03865220d426a0a3d3219">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const not_void_T&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. The non-const versions set the host_dirty flag to true. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01568">1568</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l00027">HALIDE_ALWAYS_INLINE</a>.</p>

</div>
</div>
<a id="a9e4ec17b55dbcbcccb1cf741e0b6f64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4ec17b55dbcbcccb1cf741e0b6f64c">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> const not_void_T&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. The non-const versions set the host_dirty flag to true. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01577">1577</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l00027">HALIDE_ALWAYS_INLINE</a>.</p>

</div>
</div>
<a id="af2db29d2b5347b2017c5773f2071059a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2db29d2b5347b2017c5773f2071059a">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args, typename  = typename std::enable_if&lt;AllInts&lt;Args...&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> not_void_T&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. The non-const versions set the host_dirty flag to true. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01587">1587</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l00027">HALIDE_ALWAYS_INLINE</a>.</p>

</div>
</div>
<a id="a9e57ff7ae9db3df9e1ac0496315483d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e57ff7ae9db3df9e1ac0496315483d4">&#9670;&nbsp;</a></span>operator()() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> not_void_T&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. The non-const versions set the host_dirty flag to true. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01596">1596</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_runtime_8h_source.html#l00027">HALIDE_ALWAYS_INLINE</a>.</p>

</div>
</div>
<a id="a8f780f85d63212b6aaace8b3713d406a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f780f85d63212b6aaace8b3713d406a">&#9670;&nbsp;</a></span>operator()() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_halide_runtime_8h.html#ac0c2048ce1a292798d15d9dc3346de26">HALIDE_ALWAYS_INLINE</a> not_void_T&amp; <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access elements. </p>
<p>Use im(...) to get a reference to an element, and use &amp;im(...) to get the address of an element. If you pass fewer arguments than the buffer has dimensions, the rest are treated as their min coordinate. The non-const versions set the host_dirty flag to true. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01605">1605</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a874b1863aaaa4900ce7809dec5a6ac7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874b1863aaaa4900ce7809dec5a6ac7e">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">not_void_T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01613">1613</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l00404">Halide::Runtime::Buffer&lt; T, D &gt;::dim()</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00426">Halide::Runtime::Buffer&lt; T, D &gt;::dimensions()</a>.</p>

</div>
</div>
<a id="ac3b14edde8453d93fcb3806e26e3f48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b14edde8453d93fcb3806e26e3f48c">&#9670;&nbsp;</a></span>for_each_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename ... Args, int N = sizeof...(Args) + 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::for_each_value </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>other_buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function on every value in the buffer, and the corresponding values in some number of other buffers of the same size. </p>
<p>The function should take a reference, const reference, or value of the correct type for each buffer. This effectively lifts a function of scalars to an element-wise function of buffers. This produces code that the compiler can autovectorize. This is slightly cheaper than for_each_element, because it does not need to track the coordinates. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01711">1711</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="_halide_buffer_8h_source.html#l00023">HALIDE_ALLOCA</a>, <a class="el" href="_halide_runtime_8h_source.html#l00027">HALIDE_ALWAYS_INLINE</a>, <a class="el" href="_func_8h_source.html#l00419">Halide::max()</a>, and <a class="el" href="_func_8h_source.html#l00418">Halide::min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="_halide_buffer_8h_source.html#l00996">Halide::Runtime::Buffer&lt; T, D &gt;::copy_from()</a>.</p>

</div>
</div>
<a id="ae9243929cb98508a4542093b3b75ff5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9243929cb98508a4542093b3b75ff5f">&#9670;&nbsp;</a></span>for_each_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::for_each_element </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a function at each site in a buffer. </p>
<p>This is likely to be much slower than using <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> code to populate a buffer, but is convenient for tests. If the function has more arguments than the buffer has dimensions, the remaining arguments will be zero. If it has fewer arguments than the buffer has dimensions then the last few dimensions of the buffer are not iterated over. For example, the following code exploits this to set a floating point RGB image to red:</p>
<div class="fragment"><div class="line">Buffer&lt;float, 3&gt; im(100, 100, 3);</div><div class="line">im.for_each_element([&amp;](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) {</div><div class="line">    im(x, y, 0) = 1.0f;</div><div class="line">    im(x, y, 1) = 0.0f;</div><div class="line">    im(x, y, 2) = 0.0f:</div><div class="line">});</div></div><!-- fragment --><p>The compiled code is equivalent to writing the a nested for loop, and compilers are capable of optimizing it in the same way.</p>
<p>If the callable can be called with an int * as the sole argument, that version is called instead. Each location in the buffer is passed to it in a coordinate array. This version is higher-overhead than the variadic version, but is useful for writing generic code that accepts buffers of arbitrary dimensionality. For example, the following sets the value at all sites in an arbitrary-dimensional buffer to their first coordinate:</p>
<div class="fragment"><div class="line">im.for_each_element([&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span> *pos) {im(pos) = pos[0];});</div></div><!-- fragment --><p>It is also possible to use for_each_element to iterate over entire rows or columns by cropping the buffer to a single column or row respectively and iterating over elements of the result. For example, to set the diagonal of the image to 1 by iterating over the columns:</p>
<div class="fragment"><div class="line">Buffer&lt;float, 3&gt; im(100, 100, 3);</div><div class="line">    im.sliced(1, 0).for_each_element([&amp;](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> c) {</div><div class="line">    im(x, x, c) = 1.0f;</div><div class="line">});</div></div><!-- fragment --><p>Or, assuming the memory layout is known to be dense per row, one can memset each row of an image like so:</p>
<div class="fragment"><div class="line">Buffer&lt;float, 3&gt; im(100, 100, 3);</div><div class="line">im.sliced(0, 0).for_each_element([&amp;](<span class="keywordtype">int</span> y, <span class="keywordtype">int</span> c) {</div><div class="line">    <a class="code" href="runtime__internal_8h.html#a6bed979b3fb2afd7f5aa7102af57bd8b">memset</a>(&amp;im(0, y, c), 0, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * im.width());</div><div class="line">});</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01944">1944</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

<p class="reference">References <a class="el" href="printer_8h_source.html#l00030">buf</a>, and <a class="el" href="_halide_buffer_8h_source.html#l00023">HALIDE_ALLOCA</a>.</p>

</div>
</div>
<a id="a2e64b513f76146d3f7d183774c3c5449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e64b513f76146d3f7d183774c3c5449">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<div class="memtemplate">
template&lt;typename Fn , typename  = typename std::enable_if&lt;!std::is_arithmetic&lt;typename std::decay&lt;Fn&gt;::type&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a buffer by evaluating a callable at every site. </p>
<p>The callable should look much like a callable passed to for_each_element, but it should return the value that should be stored to the coordinate corresponding to the arguments. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01976">1976</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<a id="a003e3a2a7bfb93df233c2b65af0114fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003e3a2a7bfb93df233c2b65af0114fb">&#9670;&nbsp;</a></span>is_bounds_query()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::is_bounds_query </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an input buffer passed extern stage is a querying bounds. </p>
<p>Compared to doing the host pointer check directly, this both adds clarity to code and will facilitate moving to another representation for bounds query arguments. </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l01986">1986</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6a0432e50ffc161961ae3af4d5a6c98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0432e50ffc161961ae3af4d5a6c98a">&#9670;&nbsp;</a></span>has_static_halide_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T = void, int D = 4&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Halide::Runtime::Buffer</a>&lt; T, D &gt;::has_static_halide_type = !T_is_void</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the <a class="el" href="namespace_halide.html" title="Defines methods for manipulating and analyzing boolean expressions. ">Halide</a> type is not void (or const void). </p>

<p class="definition">Definition at line <a class="el" href="_halide_buffer_8h_source.html#l00140">140</a> of file <a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_halide_buffer_8h_source.html">HalideBuffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="namespace_halide_1_1_runtime.html">Runtime</a></li><li class="navelem"><a class="el" href="class_halide_1_1_runtime_1_1_buffer.html">Buffer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
