<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Halide: Halide::Stage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Halide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_halide_1_1_stage.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_halide_1_1_stage-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Halide::Stage Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A single definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>.  
 <a href="class_halide_1_1_stage.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_func_8h_source.html">Func.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91222724ee6ff9f4d01dcb4f836d7627"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a91222724ee6ff9f4d01dcb4f836d7627">Stage</a> (<a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a> f, <a class="el" href="class_halide_1_1_internal_1_1_definition.html">Internal::Definition</a> d, <a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> stage_index)</td></tr>
<tr class="separator:a91222724ee6ff9f4d01dcb4f836d7627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f2793f8e9e9fead538e2cde9239d96"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">Internal::StageSchedule</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aa2f2793f8e9e9fead538e2cde9239d96">get_schedule</a> () const</td></tr>
<tr class="memdesc:aa2f2793f8e9e9fead538e2cde9239d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current StageSchedule associated with this <a class="el" href="class_halide_1_1_stage.html" title="A single definition of a Func.">Stage</a>.  <br /></td></tr>
<tr class="separator:aa2f2793f8e9e9fead538e2cde9239d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae73b461d876d4d921474d5042dad65"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aeae73b461d876d4d921474d5042dad65">dump_argument_list</a> () const</td></tr>
<tr class="memdesc:aeae73b461d876d4d921474d5042dad65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string describing the current var list taking into account all the splits, reorders, and tiles.  <br /></td></tr>
<tr class="separator:aeae73b461d876d4d921474d5042dad65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075401098fc0eb3fa260bbb93a21e80b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a075401098fc0eb3fa260bbb93a21e80b">name</a> () const</td></tr>
<tr class="memdesc:a075401098fc0eb3fa260bbb93a21e80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of this stage, e.g.  <br /></td></tr>
<tr class="separator:a075401098fc0eb3fa260bbb93a21e80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51279e6a9e09a72445846f28387b0abb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a51279e6a9e09a72445846f28387b0abb">rfactor</a> (std::vector&lt; std::pair&lt; <a class="el" href="class_halide_1_1_r_var.html">RVar</a>, <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &gt; preserved)</td></tr>
<tr class="memdesc:a51279e6a9e09a72445846f28387b0abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling <a class="el" href="class_halide_1_1_stage.html#a51279e6a9e09a72445846f28387b0abb" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> on an associative update definition a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> will split the update into an intermediate which computes the partial results and replaces the current update definition with a new definition which merges the partial results.  <br /></td></tr>
<tr class="separator:a51279e6a9e09a72445846f28387b0abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad5f03630fb3fd72a3ab0b0563502cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_func.html">Func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a2ad5f03630fb3fd72a3ab0b0563502cc">rfactor</a> (const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;r, const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;v)</td></tr>
<tr class="separator:a2ad5f03630fb3fd72a3ab0b0563502cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd245c66c941885f339c824afd4532e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a3fd245c66c941885f339c824afd4532e">compute_with</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> loop_level, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt; &gt; &amp;align)</td></tr>
<tr class="memdesc:a3fd245c66c941885f339c824afd4532e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the iteration over this stage to be fused with another stage 's' from outermost loop to a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>.  <br /></td></tr>
<tr class="separator:a3fd245c66c941885f339c824afd4532e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e81c2dafddd51a486071ad927df0b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a98e81c2dafddd51a486071ad927df0b8">compute_with</a> (<a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a> loop_level, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> align=<a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a>)</td></tr>
<tr class="separator:a98e81c2dafddd51a486071ad927df0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d49917ac2e488a72d03a27afce1ce2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a27d49917ac2e488a72d03a27afce1ce2">compute_with</a> (const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;s, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt; &gt; &amp;align)</td></tr>
<tr class="separator:a27d49917ac2e488a72d03a27afce1ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6511739735cff1a0526c6975bf9cf1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ab6511739735cff1a0526c6975bf9cf1a">compute_with</a> (const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;s, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> align=<a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a>)</td></tr>
<tr class="separator:ab6511739735cff1a0526c6975bf9cf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accee02c7cbd10ed1d9e06d192396d30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#accee02c7cbd10ed1d9e06d192396d30d">split</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;old, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;outer, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;inner, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;factor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="memdesc:accee02c7cbd10ed1d9e06d192396d30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduling calls that control how the domain of this stage is traversed.  <br /></td></tr>
<tr class="separator:accee02c7cbd10ed1d9e06d192396d30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b373ea2beafa6f44cbda818e7a3259"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aa8b373ea2beafa6f44cbda818e7a3259">fuse</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;inner, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;outer, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;fused)</td></tr>
<tr class="separator:aa8b373ea2beafa6f44cbda818e7a3259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34c217376890998bd14d714ae99b828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aa34c217376890998bd14d714ae99b828">serial</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="separator:aa34c217376890998bd14d714ae99b828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4b238ac563c21c4800a43e59c42733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a9b4b238ac563c21c4800a43e59c42733">parallel</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="separator:a9b4b238ac563c21c4800a43e59c42733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cddae992bed87a0ee529d6ec4946356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a2cddae992bed87a0ee529d6ec4946356">vectorize</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="separator:a2cddae992bed87a0ee529d6ec4946356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5c995abf6a28d50340abfb7c62a7a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a3c5c995abf6a28d50340abfb7c62a7a1">unroll</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var)</td></tr>
<tr class="separator:a3c5c995abf6a28d50340abfb7c62a7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d47a2c04c3cddad66c69ec44eb2d806"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a5d47a2c04c3cddad66c69ec44eb2d806">parallel</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;task_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a5d47a2c04c3cddad66c69ec44eb2d806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1a26a58cc5c354ab63992a291aa8ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aad1a26a58cc5c354ab63992a291aa8ea">vectorize</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;factor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:aad1a26a58cc5c354ab63992a291aa8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68271b7ea00a77f2472bf296558c20bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a68271b7ea00a77f2472bf296558c20bb">unroll</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;var, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;factor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a68271b7ea00a77f2472bf296558c20bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac638da06726dd7df2b0969126db5961f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ac638da06726dd7df2b0969126db5961f">tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;xo, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;yo, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;xi, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;yi, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;xfactor, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;yfactor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:ac638da06726dd7df2b0969126db5961f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7e4f046051894423937c1408c18a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a5a7e4f046051894423937c1408c18a49">tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;xi, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;yi, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;xfactor, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;yfactor, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a5a7e4f046051894423937c1408c18a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9370980f98758a209673f784ca5b2a2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a9370980f98758a209673f784ca5b2a2d">tile</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;previous, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;outers, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;inners, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;factors, const std::vector&lt; <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> &gt; &amp;tails)</td></tr>
<tr class="separator:a9370980f98758a209673f784ca5b2a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603a0d98a647e0b1349d4a19a06a03c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a603a0d98a647e0b1349d4a19a06a03c3">tile</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;previous, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;outers, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;inners, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;factors, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a603a0d98a647e0b1349d4a19a06a03c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10af473a0048caa53e3074213ac0c6de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a10af473a0048caa53e3074213ac0c6de">tile</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;previous, const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;inners, const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;factors, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>)</td></tr>
<tr class="separator:a10af473a0048caa53e3074213ac0c6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9046162bdca77e4e721416ed96a72c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a8d9046162bdca77e4e721416ed96a72c">reorder</a> (const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;vars)</td></tr>
<tr class="separator:a8d9046162bdca77e4e721416ed96a72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d83cdc16b5cc0c2c136bfa67c2bd27"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a25d83cdc16b5cc0c2c136bfa67c2bd27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;::value, <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a25d83cdc16b5cc0c2c136bfa67c2bd27">reorder</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a25d83cdc16b5cc0c2c136bfa67c2bd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f536a065c94e358c0f7a76a91be631b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a5f536a065c94e358c0f7a76a91be631b">rename</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;old_name, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;new_name)</td></tr>
<tr class="separator:a5f536a065c94e358c0f7a76a91be631b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8e12da382c2be8cfd512de0b5ddb36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a7d8e12da382c2be8cfd512de0b5ddb36">specialize</a> (const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;condition)</td></tr>
<tr class="separator:a7d8e12da382c2be8cfd512de0b5ddb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99d85e44a0ea26a885216a6d722019c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ab99d85e44a0ea26a885216a6d722019c">specialize_fail</a> (const std::string &amp;message)</td></tr>
<tr class="separator:ab99d85e44a0ea26a885216a6d722019c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91c747a1009aa40ea9324604baf2598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ad91c747a1009aa40ea9324604baf2598">gpu_threads</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ad91c747a1009aa40ea9324604baf2598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a104370352936c5d34d1c712d8cda8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a1a104370352936c5d34d1c712d8cda8c">gpu_threads</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a1a104370352936c5d34d1c712d8cda8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8810dfadbbdf8d1b4f71b2e325e66511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a8810dfadbbdf8d1b4f71b2e325e66511">gpu_threads</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_z, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a8810dfadbbdf8d1b4f71b2e325e66511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b011103b0796641640924e36d7eaae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a3b011103b0796641640924e36d7eaae0">gpu_lanes</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a3b011103b0796641640924e36d7eaae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fc2971080af50ece652a0db663ad7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a64fc2971080af50ece652a0db663ad7b">gpu_single_thread</a> (<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a64fc2971080af50ece652a0db663ad7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60049815a2ac3ca0e7dad45fa8e23bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aa60049815a2ac3ca0e7dad45fa8e23bd">gpu_blocks</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:aa60049815a2ac3ca0e7dad45fa8e23bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac918038fad64179016577205a644265a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ac918038fad64179016577205a644265a">gpu_blocks</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ac918038fad64179016577205a644265a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930b71e0c23d6dd88902326a6559945d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a930b71e0c23d6dd88902326a6559945d">gpu_blocks</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_z, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a930b71e0c23d6dd88902326a6559945d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bef5b5e6d723d96960ac4e07b21f290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a2bef5b5e6d723d96960ac4e07b21f290">gpu</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a2bef5b5e6d723d96960ac4e07b21f290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33939944bd37de9d52cdab4e17a0c5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ab33939944bd37de9d52cdab4e17a0c5c">gpu</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:ab33939944bd37de9d52cdab4e17a0c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0e9e1c3d4520b468d2509592712a93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a8f0e9e1c3d4520b468d2509592712a93">gpu</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;block_z, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;thread_z, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a8f0e9e1c3d4520b468d2509592712a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e326e1af96a1c931c62d616e2c6429"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a46e326e1af96a1c931c62d616e2c6429">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a46e326e1af96a1c931c62d616e2c6429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1950302fd37d43d2d823db1a95815be2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a1950302fd37d43d2d823db1a95815be2">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a1950302fd37d43d2d823db1a95815be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0db59614989f90b3f90aa5cf799b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a0a0db59614989f90b3f90aa5cf799b2f">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;by, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a0a0db59614989f90b3f90aa5cf799b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2b9c4a421828c5f176b402fe600eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aed2b9c4a421828c5f176b402fe600eb7">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:aed2b9c4a421828c5f176b402fe600eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd1fb143091ed35baedde0c12f15e79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aefd1fb143091ed35baedde0c12f15e79">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;z, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;by, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;bz, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tz, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;z_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:aefd1fb143091ed35baedde0c12f15e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c8edfbea40ab234e644e3b298245a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a44c8edfbea40ab234e644e3b298245a9">gpu_tile</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;y, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;z, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tx, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;ty, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;tz, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;x_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;y_size, const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;z_size, <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> tail=<a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a>, <a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a> device_api=<a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a>)</td></tr>
<tr class="separator:a44c8edfbea40ab234e644e3b298245a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bfa2520452780b2e3e818b56284da1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a51bfa2520452780b2e3e818b56284da1">allow_race_conditions</a> ()</td></tr>
<tr class="separator:a51bfa2520452780b2e3e818b56284da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36ae738190f419d49bff57de1a5ee41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ad36ae738190f419d49bff57de1a5ee41">atomic</a> (bool override_associativity_test=false)</td></tr>
<tr class="separator:ad36ae738190f419d49bff57de1a5ee41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8ae551fdf75c6c80a89d796814ec18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#aca8ae551fdf75c6c80a89d796814ec18">hexagon</a> (const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;x=<a class="el" href="class_halide_1_1_var.html#aae5374d79ed234db176e6a59057bdb1b">Var::outermost</a>())</td></tr>
<tr class="separator:aca8ae551fdf75c6c80a89d796814ec18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f39c87435d0cb8f614c43fe0b188d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a04f39c87435d0cb8f614c43fe0b188d5">prefetch</a> (const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;f, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;at, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;from, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> offset=1, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> strategy=<a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a>)</td></tr>
<tr class="separator:a04f39c87435d0cb8f614c43fe0b188d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef9dc33ba697936a6a435957d43e7ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a6ef9dc33ba697936a6a435957d43e7ec">prefetch</a> (const <a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Internal::Parameter</a> &amp;param, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;at, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;from, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> offset=1, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> strategy=<a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a>)</td></tr>
<tr class="separator:a6ef9dc33ba697936a6a435957d43e7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877ee5b5b51d19422b6319f45acc18ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a877ee5b5b51d19422b6319f45acc18ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#a877ee5b5b51d19422b6319f45acc18ae">prefetch</a> (const T &amp;image, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;at, const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;from, <a class="el" href="struct_halide_1_1_expr.html">Expr</a> offset=1, <a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a> strategy=<a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a>)</td></tr>
<tr class="separator:a877ee5b5b51d19422b6319f45acc18ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b47b05cd107a0fbc4f1b2991771fb6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#ad8b47b05cd107a0fbc4f1b2991771fb6">source_location</a> () const</td></tr>
<tr class="memdesc:ad8b47b05cd107a0fbc4f1b2991771fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to get the source file and line where this stage was defined by parsing the process's own debug symbols.  <br /></td></tr>
<tr class="separator:ad8b47b05cd107a0fbc4f1b2991771fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31af040ad702c3fa25208d1615254bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_halide_1_1_stage.html#af31af040ad702c3fa25208d1615254bd">unscheduled</a> ()</td></tr>
<tr class="memdesc:af31af040ad702c3fa25208d1615254bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that this stage has intentionally been given no schedule, and suppress the warning about unscheduled update definitions that would otherwise fire.  <br /></td></tr>
<tr class="separator:af31af040ad702c3fa25208d1615254bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A single definition of a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. </p>
<p>May be a pure or update definition. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00070">70</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a91222724ee6ff9f4d01dcb4f836d7627" name="a91222724ee6ff9f4d01dcb4f836d7627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91222724ee6ff9f4d01dcb4f836d7627">&#9670;&#160;</a></span>Stage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Halide::Stage::Stage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_function.html">Internal::Function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_internal_1_1_definition.html">Internal::Definition</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="runtime__internal_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>stage_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00094">94</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_internal_1_1_definition.html#a79b6581a7346b5f381f495853efed1f6">Halide::Internal::Definition::args()</a>, <a class="el" href="class_halide_1_1_internal_1_1_function.html#a8f0c8fde693029b5b623f724daff5610">Halide::Internal::Function::args()</a>, <a class="el" href="class_halide_1_1_internal_1_1_definition.html#add2ca6ed247cf025facda56bd82da44c">Halide::Internal::Definition::defined()</a>, and <a class="el" href="_errors_8h_source.html#l00019">internal_assert</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa2f2793f8e9e9fead538e2cde9239d96" name="aa2f2793f8e9e9fead538e2cde9239d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f2793f8e9e9fead538e2cde9239d96">&#9670;&#160;</a></span>get_schedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_halide_1_1_internal_1_1_stage_schedule.html">Internal::StageSchedule</a> &amp; Halide::Stage::get_schedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current StageSchedule associated with this <a class="el" href="class_halide_1_1_stage.html" title="A single definition of a Func.">Stage</a>. </p>
<p>For introspection only: to modify schedule, use the <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> interface. </p>

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00107">107</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_internal_1_1_definition.html#ad0cdab27ae97e245c88225078b9e264f">Halide::Internal::Definition::schedule()</a>.</p>

<p class="reference">Referenced by <a class="el" href="cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>, and <a class="el" href="_func_8h_source.html#l02481">Halide::Func::get_schedule()</a>.</p>

</div>
</div>
<a id="aeae73b461d876d4d921474d5042dad65" name="aeae73b461d876d4d921474d5042dad65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae73b461d876d4d921474d5042dad65">&#9670;&#160;</a></span>dump_argument_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Stage::dump_argument_list </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a string describing the current var list taking into account all the splits, reorders, and tiles. </p>

</div>
</div>
<a id="a075401098fc0eb3fa260bbb93a21e80b" name="a075401098fc0eb3fa260bbb93a21e80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075401098fc0eb3fa260bbb93a21e80b">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Stage::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of this stage, e.g. </p>
<p>"f.update(2)" </p>

</div>
</div>
<a id="a51279e6a9e09a72445846f28387b0abb" name="a51279e6a9e09a72445846f28387b0abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51279e6a9e09a72445846f28387b0abb">&#9670;&#160;</a></span>rfactor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Stage::rfactor </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="class_halide_1_1_r_var.html">RVar</a>, <a class="el" href="class_halide_1_1_var.html">Var</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>preserved</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling <a class="el" href="class_halide_1_1_stage.html#a51279e6a9e09a72445846f28387b0abb" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> on an associative update definition a <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> will split the update into an intermediate which computes the partial results and replaces the current update definition with a new definition which merges the partial results. </p>
<p>If called on a init/pure definition, this will throw an error. <a class="el" href="class_halide_1_1_stage.html#a51279e6a9e09a72445846f28387b0abb" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> will automatically infer the associative reduction operator and identity of the operator. If it can't prove the operation is associative or if it cannot find an identity for that operator, this will throw an error. In addition, commutativity of the operator is required if <a class="el" href="class_halide_1_1_stage.html#a51279e6a9e09a72445846f28387b0abb" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> is called on the inner dimension but excluding the outer dimensions.</p>
<p><a class="el" href="class_halide_1_1_stage.html#a51279e6a9e09a72445846f28387b0abb" title="Calling rfactor() on an associative update definition a Func will split the update into an intermedia...">rfactor()</a> takes as input 'preserved', which is a list of &lt;<a class="el" href="class_halide_1_1_r_var.html" title="A reduction variable represents a single dimension of a reduction domain (RDom).">RVar</a>, <a class="el" href="class_halide_1_1_var.html" title="A Halide variable, to be used when defining functions.">Var</a>&gt; pairs. The rvars not listed in 'preserved' are removed from the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> and are lifted to the intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. The remaining rvars (the ones in 'preserved') are made pure in the intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>. The intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s update definition inherits all scheduling directives (e.g. split,fuse, etc.) applied to the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s update definition. The loop order of the intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s update definition is the same as the original, although the RVars in 'preserved' are replaced by the new pure Vars. The loop order of the intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s init definition from innermost to outermost is the args' order of the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>'s init definition followed by the new pure Vars.</p>
<p>The intermediate <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> also inherits storage order from the original <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> with the new pure Vars added to the outermost.</p>
<p>For example, f.update(0).rfactor({{r.y, u}}) would rewrite a pipeline like this: </p><div class="fragment"><div class="line">f(x, y) = 0;</div>
<div class="line">f(x, y) += g(r.x, r.y);</div>
</div><!-- fragment --><p> into a pipeline like this: </p><div class="fragment"><div class="line">f_intm(x, y, u) = 0;</div>
<div class="line">f_intm(x, y, u) += g(r.x, u);</div>
<div class="line"> </div>
<div class="line">f(x, y) = 0;</div>
<div class="line">f(x, y) += f_intm(x, y, r.y);</div>
</div><!-- fragment --><p>This has a variety of uses. You can use it to split computation of an associative reduction: </p><div class="fragment"><div class="line">f(x, y) = 10;</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_r_dom.html">RDom</a> r(0, 96);</div>
<div class="line">f(x, y) = <a class="code hl_function" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f(x, y), g(x, y, r.x));</div>
<div class="line">f.update(0).split(r.x, rxo, rxi, 8).reorder(y, x).parallel(x);</div>
<div class="line">f.update(0).rfactor({{rxo, u}}).compute_root().parallel(u).update(0).parallel(u);</div>
<div class="ttc" id="aclass_halide_1_1_r_dom_html"><div class="ttname"><a href="class_halide_1_1_r_dom.html">Halide::RDom</a></div><div class="ttdoc">A multi-dimensional domain over which to iterate.</div><div class="ttdef"><b>Definition:</b> <a href="_r_dom_8h_source.html#l00193">RDom.h:193</a></div></div>
<div class="ttc" id="anamespace_halide_html_aea2c7f5fe6c79a49dcbb28951cf8405d"><div class="ttname"><a href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">Halide::max</a></div><div class="ttdeci">Expr max(const FuncRef &amp;a, const FuncRef &amp;b)</div><div class="ttdef"><b>Definition:</b> <a href="_func_8h_source.html#l00587">Func.h:587</a></div></div>
</div><!-- fragment --><p>, which is equivalent to: </p><div class="fragment"><div class="line"><a class="code hl_function" href="class_halide_1_1_stage.html#a9b4b238ac563c21c4800a43e59c42733">parallel</a> <span class="keywordflow">for</span> u = 0 to 11:</div>
<div class="line">  <span class="keywordflow">for</span> y:</div>
<div class="line">    <span class="keywordflow">for</span> x:</div>
<div class="line">      f_intm(x, y, u) = -inf</div>
<div class="line"><a class="code hl_function" href="class_halide_1_1_stage.html#a9b4b238ac563c21c4800a43e59c42733">parallel</a> <span class="keywordflow">for</span> x:</div>
<div class="line">  <span class="keywordflow">for</span> y:</div>
<div class="line">    <a class="code hl_function" href="class_halide_1_1_stage.html#a9b4b238ac563c21c4800a43e59c42733">parallel</a> <span class="keywordflow">for</span> u = 0 to 11:</div>
<div class="line">      <span class="keywordflow">for</span> rxi = 0 to 7:</div>
<div class="line">        f_intm(x, y, u) = <a class="code hl_function" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f_intm(x, y, u), g(8*u + rxi))</div>
<div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> x:</div>
<div class="line">    f(x, y) = 10</div>
<div class="line"><a class="code hl_function" href="class_halide_1_1_stage.html#a9b4b238ac563c21c4800a43e59c42733">parallel</a> <span class="keywordflow">for</span> x:</div>
<div class="line">  <span class="keywordflow">for</span> y:</div>
<div class="line">    <span class="keywordflow">for</span> rxo = 0 to 11:</div>
<div class="line">      f(x, y) = <a class="code hl_function" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f(x, y), f_intm(x, y, rxo))</div>
<div class="ttc" id="aclass_halide_1_1_stage_html_a9b4b238ac563c21c4800a43e59c42733"><div class="ttname"><a href="class_halide_1_1_stage.html#a9b4b238ac563c21c4800a43e59c42733">Halide::Stage::parallel</a></div><div class="ttdeci">Stage &amp; parallel(const VarOrRVar &amp;var)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2ad5f03630fb3fd72a3ab0b0563502cc" name="a2ad5f03630fb3fd72a3ab0b0563502cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad5f03630fb3fd72a3ab0b0563502cc">&#9670;&#160;</a></span>rfactor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_func.html">Func</a> Halide::Stage::rfactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_r_var.html">RVar</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fd245c66c941885f339c824afd4532e" name="a3fd245c66c941885f339c824afd4532e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd245c66c941885f339c824afd4532e">&#9670;&#160;</a></span>compute_with() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::compute_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a>&#160;</td>
          <td class="paramname"><em>loop_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule the iteration over this stage to be fused with another stage 's' from outermost loop to a given <a class="el" href="class_halide_1_1_loop_level.html" title="A reference to a site in a Halide statement at the top of the body of a particular for loop.">LoopLevel</a>. </p>
<p>'this' stage will be computed AFTER 's' in the innermost fused dimension. There should not be any dependencies between those two fused stages. If either of the stages being fused is a stage of an extern <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a>, this will throw an error.</p>
<p>Note that the two stages that are fused together should have the same exact schedule from the outermost to the innermost fused dimension, and the stage we are calling compute_with on should not have specializations, e.g. f2.compute_with(f1, x) is allowed only if f2 has no specializations.</p>
<p>Also, if a producer is desired to be computed at the fused loop level, the function passed to the compute_at() needs to be the "parent". Consider the following code: </p><div class="fragment"><div class="line">input(x, y) = x + y;</div>
<div class="line">f(x, y) = input(x, y);</div>
<div class="line">f(x, y) += 5;</div>
<div class="line">g(x, y) = x - y;</div>
<div class="line">g(x, y) += 10;</div>
<div class="line">f.compute_with(g, y);</div>
<div class="line">f.update().compute_with(g.update(), y);</div>
</div><!-- fragment --><p>To compute 'input' at the fused loop level at dimension y, we specify input.compute_at(g, y) instead of input.compute_at(f, y) since 'g' is the "parent" for this fused loop (i.e. 'g' is computed first before 'f' is computed). On the other hand, to compute 'input' at the innermost dimension of 'f', we specify input.compute_at(f, x) instead of input.compute_at(g, x) since the x dimension of 'f' is not fused (only the y dimension is).</p>
<p>Given the constraints, this has a variety of uses. Consider the following code: </p><div class="fragment"><div class="line">f(x, y) = x + y;</div>
<div class="line">g(x, y) = x - y;</div>
<div class="line">h(x, y) = f(x, y) + g(x, y);</div>
<div class="line">f.compute_root();</div>
<div class="line">g.compute_root();</div>
<div class="line">f.split(x, xo, xi, 8);</div>
<div class="line">g.split(x, xo, xi, 8);</div>
<div class="line">g.compute_with(f, xo);</div>
</div><!-- fragment --><p>This is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> xo:</div>
<div class="line">    <span class="keywordflow">for</span> xi:</div>
<div class="line">      f(8*xo + xi) = (8*xo + xi) + y</div>
<div class="line">    <span class="keywordflow">for</span> xi:</div>
<div class="line">      g(8*xo + xi) = (8*xo + xi) - y</div>
<div class="line"><span class="keywordflow">for</span> y:</div>
<div class="line">  <span class="keywordflow">for</span> x:</div>
<div class="line">    h(x, y) = f(x, y) + g(x, y)</div>
</div><!-- fragment --><p>The size of the dimensions of the stages computed_with do not have to match. Consider the following code where 'g' is half the size of 'f': </p><div class="fragment"><div class="line">Image&lt;int&gt; f_im(size, size), g_im(size/2, size/2);</div>
<div class="line">input(x, y) = x + y;</div>
<div class="line">f(x, y) = input(x, y);</div>
<div class="line">g(x, y) = input(2*x, 2*y);</div>
<div class="line">g.compute_with(f, y);</div>
<div class="line">input.compute_at(f, y);</div>
<div class="line"><a class="code hl_class" href="class_halide_1_1_pipeline.html">Pipeline</a>({f, g}).realize({f_im, g_im});</div>
<div class="ttc" id="aclass_halide_1_1_pipeline_html"><div class="ttname"><a href="class_halide_1_1_pipeline.html">Halide::Pipeline</a></div><div class="ttdoc">A class representing a Halide pipeline.</div><div class="ttdef"><b>Definition:</b> <a href="_pipeline_8h_source.html#l00148">Pipeline.h:148</a></div></div>
</div><!-- fragment --><p>This is equivalent to: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> y = 0 to size-1:</div>
<div class="line">  <span class="keywordflow">for</span> x = 0 to size-1:</div>
<div class="line">    input(x, y) = x + y;</div>
<div class="line">  <span class="keywordflow">for</span> x = 0 to size-1:</div>
<div class="line">    f(x, y) = input(x, y)</div>
<div class="line">  <span class="keywordflow">for</span> x = 0 to size/2-1:</div>
<div class="line">    <span class="keywordflow">if</span> (y &lt; size/2-1):</div>
<div class="line">      g(x, y) = input(2*x, 2*y)</div>
</div><!-- fragment --><p>'align' specifies how the loop iteration of each dimension of the two stages being fused should be aligned in the fused loop nests (see LoopAlignStrategy for options). Consider the following loop nests: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> z = f_min_z to f_max_z:</div>
<div class="line">  <span class="keywordflow">for</span> y = f_min_y to f_max_y:</div>
<div class="line">    <span class="keywordflow">for</span> x = f_min_x to f_max_x:</div>
<div class="line">      f(x, y, z) = x + y + z</div>
<div class="line"><span class="keywordflow">for</span> z = g_min_z to g_max_z:</div>
<div class="line">  <span class="keywordflow">for</span> y = g_min_y to g_max_y:</div>
<div class="line">    <span class="keywordflow">for</span> x = g_min_x to g_max_x:</div>
<div class="line">      g(x, y, z) = x - y - z</div>
</div><!-- fragment --><p>If no alignment strategy is specified, the following loop nest will be generated: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> z = <a class="code hl_function" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>(f_min_z, g_min_z) to <a class="code hl_function" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f_max_z, g_max_z):</div>
<div class="line">  for y = <a class="code hl_function" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>(f_min_y, g_min_y) to <a class="code hl_function" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f_max_y, g_max_y):</div>
<div class="line">    for x = f_min_x to f_max_x:</div>
<div class="line">      if (f_min_z &lt;= z &lt;= f_max_z):</div>
<div class="line">        if (f_min_y &lt;= y &lt;= f_max_y):</div>
<div class="line">          f(x, y, z) = x + y + z</div>
<div class="line">    for x = g_min_x to g_max_x:</div>
<div class="line">      if (g_min_z &lt;= z &lt;= g_max_z):</div>
<div class="line">        if (g_min_y &lt;= y &lt;= g_max_y):</div>
<div class="line">          g(x, y, z) = x - y - z</div>
<div class="ttc" id="anamespace_halide_html_a842daf6fbd0f87ec9ea8336cb0cdd23e"><div class="ttname"><a href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">Halide::min</a></div><div class="ttdeci">Expr min(const FuncRef &amp;a, const FuncRef &amp;b)</div><div class="ttdoc">Explicit overloads of min and max for FuncRef.</div><div class="ttdef"><b>Definition:</b> <a href="_func_8h_source.html#l00584">Func.h:584</a></div></div>
</div><!-- fragment --><p>Instead, these alignment strategies: </p><div class="fragment"><div class="line">g.compute_with(f, y, {{z, <a class="code hl_enumvalue" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b">LoopAlignStrategy::AlignStart</a>}, {y, <a class="code hl_enumvalue" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af">LoopAlignStrategy::AlignEnd</a>}});</div>
<div class="ttc" id="anamespace_halide_html_a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af"><div class="ttname"><a href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af">Halide::LoopAlignStrategy::AlignEnd</a></div><div class="ttdeci">@ AlignEnd</div><div class="ttdoc">Shift the end of the fused loops to align.</div></div>
<div class="ttc" id="anamespace_halide_html_a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b"><div class="ttname"><a href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b">Halide::LoopAlignStrategy::AlignStart</a></div><div class="ttdeci">@ AlignStart</div><div class="ttdoc">Shift the start of the fused loops to align.</div></div>
</div><!-- fragment --><p> will produce the following loop nest: </p><div class="fragment"><div class="line">f_loop_min_z = f_min_z</div>
<div class="line">f_loop_max_z = <a class="code hl_function" href="namespace_halide.html#aea2c7f5fe6c79a49dcbb28951cf8405d">max</a>(f_max_z, (f_min_z - g_min_z) + g_max_z)</div>
<div class="line"><span class="keywordflow">for</span> z = f_min_z to f_loop_max_z:</div>
<div class="line">  f_loop_min_y = <a class="code hl_function" href="namespace_halide.html#a842daf6fbd0f87ec9ea8336cb0cdd23e">min</a>(f_min_y, (f_max_y - g_max_y) + g_min_y)</div>
<div class="line">  f_loop_max_y = f_max_y</div>
<div class="line">  <span class="keywordflow">for</span> y = f_loop_min_y to f_loop_max_y:</div>
<div class="line">    <span class="keywordflow">for</span> x = f_min_x to f_max_x:</div>
<div class="line">      <span class="keywordflow">if</span> (f_loop_min_z &lt;= z &lt;= f_loop_max_z):</div>
<div class="line">        <span class="keywordflow">if</span> (f_loop_min_y &lt;= y &lt;= f_loop_max_y):</div>
<div class="line">          f(x, y, z) = x + y + z</div>
<div class="line">    <span class="keywordflow">for</span> x = g_min_x to g_max_x:</div>
<div class="line">      g_shift_z = g_min_z - f_loop_min_z</div>
<div class="line">      g_shift_y = g_max_y - f_loop_max_y</div>
<div class="line">      <span class="keywordflow">if</span> (g_min_z &lt;= (z + g_shift_z) &lt;= g_max_z):</div>
<div class="line">        <span class="keywordflow">if</span> (g_min_y &lt;= (y + g_shift_y) &lt;= g_max_y):</div>
<div class="line">          g(x, y + g_shift_y, z + g_shift_z) = x - (y + g_shift_y) - (z + g_shift_z)</div>
</div><!-- fragment --><p><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a7bdacdfaf12e9cd3af92850a628baf4b" title="Shift the start of the fused loops to align.">LoopAlignStrategy::AlignStart</a> on dimension z will shift the loop iteration of 'g' at dimension z so that its starting value matches that of 'f'. Likewise, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a58a4774b4ffb202dc1be23bfff77a3af" title="Shift the end of the fused loops to align.">LoopAlignStrategy::AlignEnd</a> on dimension y will shift the loop iteration of 'g' at dimension y so that its end value matches that of 'f'. </p>

</div>
</div>
<a id="a98e81c2dafddd51a486071ad927df0b8" name="a98e81c2dafddd51a486071ad927df0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e81c2dafddd51a486071ad927df0b8">&#9670;&#160;</a></span>compute_with() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::compute_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_halide_1_1_loop_level.html">LoopLevel</a>&#160;</td>
          <td class="paramname"><em>loop_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a>&#160;</td>
          <td class="paramname"><em>align</em> = <code><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27d49917ac2e488a72d03a27afce1ce2" name="a27d49917ac2e488a72d03a27afce1ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d49917ac2e488a72d03a27afce1ce2">&#9670;&#160;</a></span>compute_with() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::compute_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, <a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6511739735cff1a0526c6975bf9cf1a" name="ab6511739735cff1a0526c6975bf9cf1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6511739735cff1a0526c6975bf9cf1a">&#9670;&#160;</a></span>compute_with() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::compute_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354">LoopAlignStrategy</a>&#160;</td>
          <td class="paramname"><em>align</em> = <code><a class="el" href="namespace_halide.html#a751041c9a6cffe776b613f4dd04c3354a06b9281e396db002010bde1de57262eb">LoopAlignStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accee02c7cbd10ed1d9e06d192396d30d" name="accee02c7cbd10ed1d9e06d192396d30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accee02c7cbd10ed1d9e06d192396d30d">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scheduling calls that control how the domain of this stage is traversed. </p>
<p>See the documentation for <a class="el" href="class_halide_1_1_func.html" title="A halide function.">Func</a> for the meanings. </p>

</div>
</div>
<a id="aa8b373ea2beafa6f44cbda818e7a3259" name="aa8b373ea2beafa6f44cbda818e7a3259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b373ea2beafa6f44cbda818e7a3259">&#9670;&#160;</a></span>fuse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::fuse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>fused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa34c217376890998bd14d714ae99b828" name="aa34c217376890998bd14d714ae99b828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34c217376890998bd14d714ae99b828">&#9670;&#160;</a></span>serial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::serial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b4b238ac563c21c4800a43e59c42733" name="a9b4b238ac563c21c4800a43e59c42733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4b238ac563c21c4800a43e59c42733">&#9670;&#160;</a></span>parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>.</p>

</div>
</div>
<a id="a2cddae992bed87a0ee529d6ec4946356" name="a2cddae992bed87a0ee529d6ec4946356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cddae992bed87a0ee529d6ec4946356">&#9670;&#160;</a></span>vectorize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::vectorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="tutorial_2lesson_09_update_definitions_8cpp-example.html#a13">tutorial/lesson_09_update_definitions.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3c5c995abf6a28d50340abfb7c62a7a1" name="a3c5c995abf6a28d50340abfb7c62a7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5c995abf6a28d50340abfb7c62a7a1">&#9670;&#160;</a></span>unroll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d47a2c04c3cddad66c69ec44eb2d806" name="a5d47a2c04c3cddad66c69ec44eb2d806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d47a2c04c3cddad66c69ec44eb2d806">&#9670;&#160;</a></span>parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>task_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad1a26a58cc5c354ab63992a291aa8ea" name="aad1a26a58cc5c354ab63992a291aa8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1a26a58cc5c354ab63992a291aa8ea">&#9670;&#160;</a></span>vectorize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::vectorize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68271b7ea00a77f2472bf296558c20bb" name="a68271b7ea00a77f2472bf296558c20bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68271b7ea00a77f2472bf296558c20bb">&#9670;&#160;</a></span>unroll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::unroll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac638da06726dd7df2b0969126db5961f" name="ac638da06726dd7df2b0969126db5961f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac638da06726dd7df2b0969126db5961f">&#9670;&#160;</a></span>tile() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>xo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>yo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>xfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>yfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a7e4f046051894423937c1408c18a49" name="a5a7e4f046051894423937c1408c18a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7e4f046051894423937c1408c18a49">&#9670;&#160;</a></span>tile() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>xfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>yfactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9370980f98758a209673f784ca5b2a2d" name="a9370980f98758a209673f784ca5b2a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9370980f98758a209673f784ca5b2a2d">&#9670;&#160;</a></span>tile() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>previous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tails</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a603a0d98a647e0b1349d4a19a06a03c3" name="a603a0d98a647e0b1349d4a19a06a03c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603a0d98a647e0b1349d4a19a06a03c3">&#9670;&#160;</a></span>tile() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>previous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>outers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10af473a0048caa53e3074213ac0c6de" name="a10af473a0048caa53e3074213ac0c6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10af473a0048caa53e3074213ac0c6de">&#9670;&#160;</a></span>tile() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::tile </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>previous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d9046162bdca77e4e721416ed96a72c" name="a8d9046162bdca77e4e721416ed96a72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9046162bdca77e4e721416ed96a72c">&#9670;&#160;</a></span>reorder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::reorder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="cost__model__schedule_8h_source.html#l00005">do_cost_model_schedule()</a>, and <a class="el" href="_func_8h_source.html#l00378">reorder()</a>.</p>

</div>
</div>
<a id="a25d83cdc16b5cc0c2c136bfa67c2bd27" name="a25d83cdc16b5cc0c2c136bfa67c2bd27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d83cdc16b5cc0c2c136bfa67c2bd27">&#9670;&#160;</a></span>reorder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_util_8h.html#a53da0047a6b6ce91b46f76c018d63931">HALIDE_NO_USER_CODE_INLINE</a> std::enable_if&lt; <a class="el" href="struct_halide_1_1_internal_1_1all__are__convertible.html">Internal::all_are_convertible</a>&lt; <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a>, Args... &gt;::value, <a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; &gt;::type Halide::Stage::reorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00378">378</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_stage.html#a8d9046162bdca77e4e721416ed96a72c">reorder()</a>.</p>

</div>
</div>
<a id="a5f536a065c94e358c0f7a76a91be631b" name="a5f536a065c94e358c0f7a76a91be631b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f536a065c94e358c0f7a76a91be631b">&#9670;&#160;</a></span>rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::rename </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>new_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d8e12da382c2be8cfd512de0b5ddb36" name="a7d8e12da382c2be8cfd512de0b5ddb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8e12da382c2be8cfd512de0b5ddb36">&#9670;&#160;</a></span>specialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> Halide::Stage::specialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab99d85e44a0ea26a885216a6d722019c" name="ab99d85e44a0ea26a885216a6d722019c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99d85e44a0ea26a885216a6d722019c">&#9670;&#160;</a></span>specialize_fail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Stage::specialize_fail </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad91c747a1009aa40ea9324604baf2598" name="ad91c747a1009aa40ea9324604baf2598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91c747a1009aa40ea9324604baf2598">&#9670;&#160;</a></span>gpu_threads() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a104370352936c5d34d1c712d8cda8c" name="a1a104370352936c5d34d1c712d8cda8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a104370352936c5d34d1c712d8cda8c">&#9670;&#160;</a></span>gpu_threads() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8810dfadbbdf8d1b4f71b2e325e66511" name="a8810dfadbbdf8d1b4f71b2e325e66511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8810dfadbbdf8d1b4f71b2e325e66511">&#9670;&#160;</a></span>gpu_threads() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_threads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b011103b0796641640924e36d7eaae0" name="a3b011103b0796641640924e36d7eaae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b011103b0796641640924e36d7eaae0">&#9670;&#160;</a></span>gpu_lanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_lanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64fc2971080af50ece652a0db663ad7b" name="a64fc2971080af50ece652a0db663ad7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fc2971080af50ece652a0db663ad7b">&#9670;&#160;</a></span>gpu_single_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_single_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa60049815a2ac3ca0e7dad45fa8e23bd" name="aa60049815a2ac3ca0e7dad45fa8e23bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60049815a2ac3ca0e7dad45fa8e23bd">&#9670;&#160;</a></span>gpu_blocks() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac918038fad64179016577205a644265a" name="ac918038fad64179016577205a644265a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac918038fad64179016577205a644265a">&#9670;&#160;</a></span>gpu_blocks() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a930b71e0c23d6dd88902326a6559945d" name="a930b71e0c23d6dd88902326a6559945d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930b71e0c23d6dd88902326a6559945d">&#9670;&#160;</a></span>gpu_blocks() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_blocks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bef5b5e6d723d96960ac4e07b21f290" name="a2bef5b5e6d723d96960ac4e07b21f290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bef5b5e6d723d96960ac4e07b21f290">&#9670;&#160;</a></span>gpu() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab33939944bd37de9d52cdab4e17a0c5c" name="ab33939944bd37de9d52cdab4e17a0c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33939944bd37de9d52cdab4e17a0c5c">&#9670;&#160;</a></span>gpu() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f0e9e1c3d4520b468d2509592712a93" name="a8f0e9e1c3d4520b468d2509592712a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0e9e1c3d4520b468d2509592712a93">&#9670;&#160;</a></span>gpu() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>block_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>thread_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46e326e1af96a1c931c62d616e2c6429" name="a46e326e1af96a1c931c62d616e2c6429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e326e1af96a1c931c62d616e2c6429">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1950302fd37d43d2d823db1a95815be2" name="a1950302fd37d43d2d823db1a95815be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1950302fd37d43d2d823db1a95815be2">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a0db59614989f90b3f90aa5cf799b2f" name="a0a0db59614989f90b3f90aa5cf799b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0db59614989f90b3f90aa5cf799b2f">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed2b9c4a421828c5f176b402fe600eb7" name="aed2b9c4a421828c5f176b402fe600eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2b9c4a421828c5f176b402fe600eb7">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aefd1fb143091ed35baedde0c12f15e79" name="aefd1fb143091ed35baedde0c12f15e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd1fb143091ed35baedde0c12f15e79">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>bz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44c8edfbea40ab234e644e3b298245a9" name="a44c8edfbea40ab234e644e3b298245a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c8edfbea40ab234e644e3b298245a9">&#9670;&#160;</a></span>gpu_tile() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::gpu_tile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>tz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>x_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>y_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_expr.html">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>z_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0f">TailStrategy</a>&#160;</td>
          <td class="paramname"><em>tail</em> = <code><a class="el" href="namespace_halide.html#a6c6557df562bd7850664e70fdb8fea0fa06b9281e396db002010bde1de57262eb">TailStrategy::Auto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6e">DeviceAPI</a>&#160;</td>
          <td class="paramname"><em>device_api</em> = <code><a class="el" href="namespace_halide.html#aa26c7f430d2b1c44ba3e1d3f6df2ba6eaee977b69833eed1db30528c41d839ef8">DeviceAPI::Default_GPU</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51bfa2520452780b2e3e818b56284da1" name="a51bfa2520452780b2e3e818b56284da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bfa2520452780b2e3e818b56284da1">&#9670;&#160;</a></span>allow_race_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::allow_race_conditions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad36ae738190f419d49bff57de1a5ee41" name="ad36ae738190f419d49bff57de1a5ee41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36ae738190f419d49bff57de1a5ee41">&#9670;&#160;</a></span>atomic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::atomic </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>override_associativity_test</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca8ae551fdf75c6c80a89d796814ec18" name="aca8ae551fdf75c6c80a89d796814ec18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8ae551fdf75c6c80a89d796814ec18">&#9670;&#160;</a></span>hexagon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::hexagon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em> = <code><a class="el" href="class_halide_1_1_var.html#aae5374d79ed234db176e6a59057bdb1b">Var::outermost</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04f39c87435d0cb8f614c43fe0b188d5" name="a04f39c87435d0cb8f614c43fe0b188d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f39c87435d0cb8f614c43fe0b188d5">&#9670;&#160;</a></span>prefetch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::prefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_func.html">Func</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="_func_8h_source.html#l00449">prefetch()</a>.</p>

</div>
</div>
<a id="a6ef9dc33ba697936a6a435957d43e7ec" name="a6ef9dc33ba697936a6a435957d43e7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef9dc33ba697936a6a435957d43e7ec">&#9670;&#160;</a></span>prefetch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::prefetch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_halide_1_1_internal_1_1_parameter.html">Internal::Parameter</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a877ee5b5b51d19422b6319f45acc18ae" name="a877ee5b5b51d19422b6319f45acc18ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877ee5b5b51d19422b6319f45acc18ae">&#9670;&#160;</a></span>prefetch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_halide_1_1_stage.html">Stage</a> &amp; Halide::Stage::prefetch </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_halide_1_1_var_or_r_var.html">VarOrRVar</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_halide_1_1_expr.html">Expr</a>&#160;</td>
          <td class="paramname"><em>offset</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4d">PrefetchBoundStrategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="namespace_halide.html#a36b78b48c1fe9126344a218d07348f4da5b80e0001d7f4873a60bbded160c687d">PrefetchBoundStrategy::GuardWithIf</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_func_8h_source.html#l00449">449</a> of file <a class="el" href="_func_8h_source.html">Func.h</a>.</p>

<p class="reference">References <a class="el" href="class_halide_1_1_stage.html#a04f39c87435d0cb8f614c43fe0b188d5">prefetch()</a>.</p>

</div>
</div>
<a id="ad8b47b05cd107a0fbc4f1b2991771fb6" name="ad8b47b05cd107a0fbc4f1b2991771fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b47b05cd107a0fbc4f1b2991771fb6">&#9670;&#160;</a></span>source_location()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Halide::Stage::source_location </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to get the source file and line where this stage was defined by parsing the process's own debug symbols. </p>
<p>Returns an empty string if no debug symbols were found or the debug symbols were not understood. Works on OS X and Linux only. </p>

</div>
</div>
<a id="af31af040ad702c3fa25208d1615254bd" name="af31af040ad702c3fa25208d1615254bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31af040ad702c3fa25208d1615254bd">&#9670;&#160;</a></span>unscheduled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Halide::Stage::unscheduled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assert that this stage has intentionally been given no schedule, and suppress the warning about unscheduled update definitions that would otherwise fire. </p>
<p>This counts as a schedule, so calling this twice on the same <a class="el" href="class_halide_1_1_stage.html" title="A single definition of a Func.">Stage</a> will fail the assertion. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_func_8h_source.html">Func.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_halide.html">Halide</a></li><li class="navelem"><a class="el" href="class_halide_1_1_stage.html">Stage</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
