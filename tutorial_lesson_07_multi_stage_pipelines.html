<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>
lesson 07 multi stage pipelines
</title>
<link rel="stylesheet" type="text/css" href="highlight.css">
<style>

a:visited {
color: #000000;
}

a:link {
color: #000000;
}

a:hover {
color: #aa0000;
}

</style>
</head>
<body class="hl" style="background-color: #444444; font-family: Helvetica, Arial, sans-serif;">

<div>
<style scoped>
@import "../assets/css/bootstrap.css";
</style>
<div class="navbar navbar-fixed-top">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="index.html">Halide</a>
      <div class="nav-collapse">
        <ul class="nav">
          <li class="active"><a href="index.html#overview">Overview</a></li>
          <li><a href="index.html#gettingstarted">Getting Started</a></li>
          <li><a href="index.html#publications">Publications</a></li>
          <li><a href="index.html#resources">Resources</a></li>
          <li class="divider-vertical"></li>
          <li><a href="/docs">Docs</a></li>
          <li><a href="http://github.com/halide/Halide/issues">Bugs</a></li>
          <li><a href="http://github.com/halide/Halide/wiki">Wiki</a></li>
          <li class="divider-vertical"></li>
          <li><a href="http://stackoverflow.com/questions/tagged/halide"><i class="fa fa-stack-overflow"></i>/#halide</a></li>
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </div>
</div>

<div style="position:relative; width: 100%; top:60px;">
<div style="width:200px; float:left; ">
<a href="tutorial_introduction.html" style="text-decoration:none;" ><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px;
background-color: #dddddd; 
text-align: left; ">
<b>
00
&nbsp</b>
Introduction
</div>
</span>
</a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_01_basics.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
01
&nbsp</b>
 Getting started with Funcs, Vars, and Exprs
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_02_input_image.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
02
&nbsp</b>
 Processing images
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_03_debugging_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
03
&nbsp</b>
 Inspecting the generated code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_04_debugging_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
04
&nbsp</b>
 Debugging with tracing, print, and print_when
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_05_scheduling_1.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
05
&nbsp</b>
 Vectorize, parallelize, unroll and tile your code
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_06_realizing_over_shifted_domains.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
06
&nbsp</b>
 Realizing Funcs over arbitrary domains
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_07_multi_stage_pipelines.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; padding-right:40px; background-color: #ffffff; color: #000000; text-align: left; ">
<b>
07
&nbsp</b>
 Multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_08_scheduling_2.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
08
&nbsp</b>
 Scheduling multi-stage pipelines
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_09_update_definitions.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
09
&nbsp</b>
 Multi-pass Funcs, update definitions, and reductions
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_generate.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 1
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_10_aot_compilation_run.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
10
&nbsp</b>
 AOT compilation part 2
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_11_cross_compilation.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
11
&nbsp</b>
 Cross-compilation
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_12_using_the_gpu.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
12
&nbsp</b>
 Using the GPU
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_13_tuples.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
13
&nbsp</b>
 Tuples
</div></span></a>
<div style="width:200px; height:20px;"></div>
<a href=
tutorial_lesson_14_types.html
 style="text-decoration:none;"><span style="width:100%; height:100%; top:0; left:0;">
<div style="width:200px; padding:20px; background-color: #dddddd; text-align: left; ">
<b>
14
&nbsp</b>
 The Halide type system
</div></span></a>
</div>
<div style="position:relative; margin-left:260px; padding:20px; background-color: #ffffff;">
<pre class="hl">
<span class="hl slc">// Halide tutorial lesson 7: Multi-stage pipelines</span>

<span class="hl slc">// On linux, you can compile and run it like so:</span>
<span class="hl slc">// g++ lesson_07*.cpp -g -std=c++11 -I ../include -L ../bin -lHalide `libpng-config --cflags --ldflags` -lpthread -ldl -o lesson_07</span>
<span class="hl slc">// LD_LIBRARY_PATH=../bin ./lesson_07</span>

<span class="hl slc">// On os x:</span>
<span class="hl slc">// g++ lesson_07*.cpp -g -std=c++11 -I ../include -L ../bin -lHalide `libpng-config --cflags --ldflags` -o lesson_07</span>
<span class="hl slc">// DYLD_LIBRARY_PATH=../bin ./lesson_07</span>

<span class="hl slc">// If you have the entire Halide source tree, you can also build it by</span>
<span class="hl slc">// running:</span>
<span class="hl slc">//    make tutorial_lesson_07_multi_stage_pipelines</span>
<span class="hl slc">// in a shell with the current directory at the top of the halide</span>
<span class="hl slc">// source tree.</span>

<span class="hl ppc">#include</span> <span class="hl pps">&quot;Halide.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include &lt;stdio.h&gt;</span>

<span class="hl kwa">using namespace</span> Halide<span class="hl opt">;</span>

<span class="hl slc">// Support code for loading pngs.</span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;image_io.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">(</span><span class="hl kwb">int</span> argc<span class="hl opt">,</span> <span class="hl kwb">char</span> <span class="hl opt">**</span>argv<span class="hl opt">) {</span>
    <span class="hl slc">// First we'll declare some Vars to use below.</span>
    Var <span class="hl kwd">x</span><span class="hl opt">(</span><span class="hl str">&quot;x&quot;</span><span class="hl opt">),</span> <span class="hl kwd">y</span><span class="hl opt">(</span><span class="hl str">&quot;y&quot;</span><span class="hl opt">),</span> <span class="hl kwd">c</span><span class="hl opt">(</span><span class="hl str">&quot;c&quot;</span><span class="hl opt">);</span>

    <span class="hl slc">// Now we'll express a multi-stage pipeline that blurs an image</span>
    <span class="hl slc">// first horizontally, and then vertically.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// Take a color 8-bit input</span>
        Image<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;</span> input <span class="hl opt">=</span> load<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;(</span><span class="hl str">&quot;images/rgb.png&quot;</span><span class="hl opt">);</span>

        <span class="hl slc">// Upgrade it to 16-bit, so we can do math without it overflowing.</span>
        Func <span class="hl kwd">input_16</span><span class="hl opt">(</span><span class="hl str">&quot;input_16&quot;</span><span class="hl opt">);</span>
        <span class="hl kwd">input_16</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) =</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">uint16_t</span><span class="hl opt">&gt;(</span><span class="hl kwd">input</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">));</span>

        <span class="hl slc">// Blur it horizontally:</span>
        Func <span class="hl kwd">blur_x</span><span class="hl opt">(</span><span class="hl str">&quot;blur_x&quot;</span><span class="hl opt">);</span>
        <span class="hl kwd">blur_x</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) = (</span><span class="hl kwd">input_16</span><span class="hl opt">(</span>x<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) +</span> <span class="hl num">2</span><span class="hl opt">*</span><span class="hl kwd">input_16</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) +</span> <span class="hl kwd">input_16</span><span class="hl opt">(</span>x<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">))/</span><span class="hl num">4</span><span class="hl opt">;</span>

        <span class="hl slc">// Blur it vertically:</span>
        Func <span class="hl kwd">blur_y</span><span class="hl opt">(</span><span class="hl str">&quot;blur_y&quot;</span><span class="hl opt">);</span>
        <span class="hl kwd">blur_y</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) = (</span><span class="hl kwd">blur_x</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">,</span> c<span class="hl opt">) +</span> <span class="hl num">2</span><span class="hl opt">*</span><span class="hl kwd">blur_x</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) +</span> <span class="hl kwd">blur_x</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">,</span> c<span class="hl opt">))/</span><span class="hl num">4</span><span class="hl opt">;</span>

        <span class="hl slc">// Convert back to 8-bit.</span>
        Func <span class="hl kwd">output</span><span class="hl opt">(</span><span class="hl str">&quot;output&quot;</span><span class="hl opt">);</span>
        <span class="hl kwd">output</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) =</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;(</span><span class="hl kwd">blur_y</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">));</span>

        <span class="hl slc">// Each Func in this pipeline calls a previous one using</span>
        <span class="hl slc">// familiar function call syntax (we've overloaded operator()</span>
        <span class="hl slc">// on Func objects). A Func may call any other Func that has</span>
        <span class="hl slc">// been given a definition. This restriction prevents</span>
        <span class="hl slc">// pipelines with loops in them. Halide pipelines are always</span>
        <span class="hl slc">// feed-forward graphs of Funcs.</span>

        <span class="hl slc">// Now let's realize it...</span>

        <span class="hl slc">// Image&lt;uint8_t&gt; result = output.realize(input.width(), input.height(), 3);</span>

        <span class="hl slc">// Except that the line above is not going to work. Uncomment</span>
        <span class="hl slc">// it to see what happens.</span>

        <span class="hl slc">// Realizing this pipeline over the same domain as the input</span>
        <span class="hl slc">// image requires reading pixels out of bounds in the input,</span>
        <span class="hl slc">// because the blur_x stage reaches outwards horizontally, and</span>
        <span class="hl slc">// the blur_y stage reaches outwards vertically. Halide</span>
        <span class="hl slc">// detects this by injecting a piece of code at the top of the</span>
        <span class="hl slc">// pipeline that computes the region over which the input will</span>
        <span class="hl slc">// be read. When it starts to run the pipeline it first runs</span>
        <span class="hl slc">// this code, determines that the input will be read out of</span>
        <span class="hl slc">// bounds, and refuses to continue. No actual bounds checks</span>
        <span class="hl slc">// occur in the inner loop; that would be slow.</span>
        <span class="hl slc">//</span>
        <span class="hl slc">// So what do we do? There are a few options. If we realize</span>
        <span class="hl slc">// over a domain shifted inwards by one pixel, we won't be</span>
        <span class="hl slc">// asking the Halide routine to read out of bounds. We saw how</span>
        <span class="hl slc">// to do this in the previous lesson:</span>
        Image<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;</span> <span class="hl kwd">result</span><span class="hl opt">(</span>input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">()-</span><span class="hl num">2</span><span class="hl opt">,</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">()-</span><span class="hl num">2</span><span class="hl opt">,</span> <span class="hl num">3</span><span class="hl opt">);</span>
        result<span class="hl opt">.</span><span class="hl kwd">set_min</span><span class="hl opt">(</span><span class="hl num">1</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span>
        output<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span>result<span class="hl opt">);</span>

        <span class="hl slc">// Save the result. It should look like a slightly blurry</span>
        <span class="hl slc">// parrot, and it should be two pixels narrower and two pixels</span>
        <span class="hl slc">// shorter than the input image.</span>
        <span class="hl kwd">save</span><span class="hl opt">(</span>result<span class="hl opt">,</span> <span class="hl str">&quot;blurry_parrot_1.png&quot;</span><span class="hl opt">);</span>

        <span class="hl slc">// This is usually the fastest way to deal with boundaries:</span>
        <span class="hl slc">// don't write code that reads out of bounds :) The more</span>
        <span class="hl slc">// general solution is our next example.</span>
    <span class="hl opt">}</span>

    <span class="hl slc">// The same pipeline, with a boundary condition on the input.</span>
    <span class="hl opt">{</span>
        <span class="hl slc">// Take a color 8-bit input</span>
        Image<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;</span> input <span class="hl opt">=</span> load<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;(</span><span class="hl str">&quot;images/rgb.png&quot;</span><span class="hl opt">);</span>

        <span class="hl slc">// This time, we'll wrap the input in a Func that prevents</span>
        <span class="hl slc">// reading out of bounds:</span>
        Func <span class="hl kwd">clamped</span><span class="hl opt">(</span><span class="hl str">&quot;clamped&quot;</span><span class="hl opt">);</span>

        <span class="hl slc">// Define an expression that clamps x to lie within the</span>
        <span class="hl slc">// range [0, input.width()-1].</span>
        Expr clamped_x <span class="hl opt">=</span> <span class="hl kwd">clamp</span><span class="hl opt">(</span>x<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">()-</span><span class="hl num">1</span><span class="hl opt">);</span>
        <span class="hl slc">// Similarly clamp y.</span>
        Expr clamped_y <span class="hl opt">=</span> <span class="hl kwd">clamp</span><span class="hl opt">(</span>y<span class="hl opt">,</span> <span class="hl num">0</span><span class="hl opt">,</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">()-</span><span class="hl num">1</span><span class="hl opt">);</span>
        <span class="hl slc">// Load from input at the clamped coordinates. This means that</span>
        <span class="hl slc">// no matter how we evaluated the Func 'clamped', we'll never</span>
        <span class="hl slc">// read out of bounds on the input. This is a clamp-to-edge</span>
        <span class="hl slc">// style boundary condition, and is the simplest boundary</span>
        <span class="hl slc">// condition to express in Halide.</span>
        <span class="hl kwd">clamped</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) =</span> <span class="hl kwd">input</span><span class="hl opt">(</span>clamped_x<span class="hl opt">,</span> clamped_y<span class="hl opt">,</span> c<span class="hl opt">);</span>

        <span class="hl slc">// Defining 'clamped' in that way can be done more concisely</span>
        <span class="hl slc">// using a helper function from the BoundaryConditions</span>
        <span class="hl slc">// namespace like so:</span>
        <span class="hl slc">//</span>
        <span class="hl slc">// clamped = BoundaryConditions::repeat_edge(input);</span>
        <span class="hl slc">//</span>
        <span class="hl slc">// These are important to use for other boundary conditions,</span>
        <span class="hl slc">// because they are expressed in the way that Halide can best</span>
        <span class="hl slc">// understand and optimize.</span>

        <span class="hl slc">// Upgrade it to 16-bit, so we can do math without it</span>
        <span class="hl slc">// overflowing. This time we'll refer to our new Func</span>
        <span class="hl slc">// 'clamped', instead of referring to the input image</span>
        <span class="hl slc">// directly.</span>
        Func <span class="hl kwd">input_16</span><span class="hl opt">(</span><span class="hl str">&quot;input_16&quot;</span><span class="hl opt">);</span>
        <span class="hl kwd">input_16</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) =</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">uint16_t</span><span class="hl opt">&gt;(</span><span class="hl kwd">clamped</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">));</span>

        <span class="hl slc">// The rest of the pipeline will be the same...</span>

        <span class="hl slc">// Blur it horizontally:</span>
        Func <span class="hl kwd">blur_x</span><span class="hl opt">(</span><span class="hl str">&quot;blur_x&quot;</span><span class="hl opt">);</span>
        <span class="hl kwd">blur_x</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) = (</span><span class="hl kwd">input_16</span><span class="hl opt">(</span>x<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) +</span> <span class="hl num">2</span><span class="hl opt">*</span><span class="hl kwd">input_16</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) +</span> <span class="hl kwd">input_16</span><span class="hl opt">(</span>x<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">))/</span><span class="hl num">4</span><span class="hl opt">;</span>

        <span class="hl slc">// Blur it vertically:</span>
        Func <span class="hl kwd">blur_y</span><span class="hl opt">(</span><span class="hl str">&quot;blur_y&quot;</span><span class="hl opt">);</span>
        <span class="hl kwd">blur_y</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) = (</span><span class="hl kwd">blur_x</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">-</span><span class="hl num">1</span><span class="hl opt">,</span> c<span class="hl opt">) +</span> <span class="hl num">2</span><span class="hl opt">*</span><span class="hl kwd">blur_x</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) +</span> <span class="hl kwd">blur_x</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">,</span> c<span class="hl opt">))/</span><span class="hl num">4</span><span class="hl opt">;</span>

        <span class="hl slc">// Convert back to 8-bit.</span>
        Func <span class="hl kwd">output</span><span class="hl opt">(</span><span class="hl str">&quot;output&quot;</span><span class="hl opt">);</span>
        <span class="hl kwd">output</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">) =</span> cast<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;(</span><span class="hl kwd">blur_y</span><span class="hl opt">(</span>x<span class="hl opt">,</span> y<span class="hl opt">,</span> c<span class="hl opt">));</span>

        <span class="hl slc">// This time it's safe to evaluate the output over the some</span>
        <span class="hl slc">// domain as the input, because we have a boundary condition.</span>
        Image<span class="hl opt">&lt;</span><span class="hl kwb">uint8_t</span><span class="hl opt">&gt;</span> result <span class="hl opt">=</span> output<span class="hl opt">.</span><span class="hl kwd">realize</span><span class="hl opt">(</span>input<span class="hl opt">.</span><span class="hl kwd">width</span><span class="hl opt">(),</span> input<span class="hl opt">.</span><span class="hl kwd">height</span><span class="hl opt">(),</span> <span class="hl num">3</span><span class="hl opt">);</span>

        <span class="hl slc">// Save the result. It should look like a slightly blurry</span>
        <span class="hl slc">// parrot, but this time it will be the same size as the</span>
        <span class="hl slc">// input.</span>
        <span class="hl kwd">save</span><span class="hl opt">(</span>result<span class="hl opt">,</span> <span class="hl str">&quot;blurry_parrot_2.png&quot;</span><span class="hl opt">);</span>
    <span class="hl opt">}</span>

    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;Success!</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre>
</div></body></html>
